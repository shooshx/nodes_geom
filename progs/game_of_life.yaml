nodes:
  '1':
    params:
      File Upload:
        rurl: img/test_img1.png
      size:
        e_x: 1.141
        e_y: 0.8710000000000001
        se_cv: 'return vec2(2, 2)'
      Smooth Scaling:
        v: false
      Transform:
        e_tx: 0
        e_ty: 0
        e_r: 0
        e_pvx: 0
        e_pvy: 0
        e_sx: 1
        e_sy: 1
      Texture Edge:
        sel_str: Pad
    name: init_image
    cls_name: Load Image
    x: -2609
    y: 858
    disp_param: {}
  '3':
    params:
      Type:
        sel_str: GLSL Program
      Use first texture as gradient:
        v: true
      "Float\nExpression":
        se_v: coord.x
        show_code: true
        se_cv: return coord.x
      "Color\nExpression":
        hex: '#CCCCCC'
        show_code: true
        se_cv: 'return rgb(coord.x, coord.y, 1.0)'
      "GLSL\nCode":
        text: "\n\nivec2 toTexelCoord(vec2 coord) {\n    vec2 fc = (_u_tex_tmat_0 * vec3(coord, 1.0)).xy;\n    ivec2 tsz = textureSize(_u_in_tex_0, 0);\n    ivec2 c = ivec2(fc * vec2(tsz));\n    return c;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// avoid grayish colors\nvec3 hsv_stretch(vec3 c) \n{\n    vec3 hc = rgb2hsv(c);\n    hc.g = 1.0;  // saturation\n    //hc.b = 1.0;  // value\n    return hsv2rgb(hc);\n}\n\nivec2 around[] = ivec2[]( ivec2(-1,-1), ivec2(0,-1), ivec2(1,-1),\n\t\t\t     ivec2(-1,0), ivec2(1,0),\n\t\t\t     ivec2(-1,1), ivec2(0,1), ivec2(1,1) );\n\nuniform float fade_c;\nuniform bool run_life;\n\nvoid main() {\n    \n    int nei = 0;\n    vec3 new_col = vec3(0.0);\n    ivec2 texel_coord = toTexelCoord(v_coord);\n\tfor(int i = 0; i < 8; ++i)\n\t{\n\t    ivec2 cr = texel_coord + around[i];\n\t\tvec4 c = texelFetch(_u_in_tex_0, cr, 0);\n\t\tif (c.a == 1.0)\n\t\t{\n\t\t\t++nei;\n\t\t\tnew_col += c.rgb;\n\t\t}\n\t}\n\tnew_col /= float(nei);\n\tnew_col = hsv_stretch(new_col);\n\t\n    vec4 myv = texelFetch(_u_in_tex_0, texel_coord, 0);\n    if (!run_life) {\n        outColor = vec4(myv.rgb, myv.a*fade_c); // die\n        return;\n    }\n    \n    if (myv.a != 1.0)\n    {\n        if (nei == 3)\n            outColor = vec4(new_col, 1.0);\n        else\n            outColor = vec4(myv.rgb, myv.a*fade_c); // stay dead\n    }\n    else\n    {\n    \tif (nei == 2 || nei == 3)\n\t\t\toutColor = vec4(new_col, 1.0);\n\t\telse\n\t\t\toutColor = vec4(myv.rgb, myv.a*fade_c); // die\n    }\n}\n"
        dlg_rect:
          left: 716
          top: 0
          width: 808
          height: 886
          visible: false
          track_top: 0
          track_left: 716
        panel_rect:
          height: 284
      order:
        sorted_order: [0]
      fade_c:
        e_v: 0.8190000000000001
        sldcfg_v:
          min: 0.1
          max: 0.99
          visible: true
          allowed: true
        se_cv: return 0
      run_life:
        v: false
    name: life_integrate
    cls_name: Function Fill
    x: -2254
    y: 1272
    disp_param: {}
  '5':
    params:
      Pick Index:
        e_v: 0
        show_code: true
        se_cv: |-
          if (frame_num == 0)
              return 0
          else
              return 1
      OrderInputs:
        sorted_order: [1, 0]
    name: pick_one_1
    cls_name: Pick One
    x: -2469
    y: 1111
    disp_param: {}
  '8':
    params:
      Filter Enabled:
        v: true
      Change Expr:
        se_v: frame_num
        show_code: true
        se_cv: return frame_num
    name: change_filter_1
    cls_name: Change Filter
    x: -2251
    y: 1149
    disp_param: {}
  '12':
    params:
      Type:
        sel_str: Direct Color
      Use first texture as gradient:
        v: true
      "Float\nExpression":
        se_v: coord.x
        show_code: true
        se_cv: return in_tex(coord)
      "Color\nExpression":
        hex: '#CCCCCC'
        show_code: true
        dlg_rect:
          left: null
          top: null
          width: null
          height: null
          visible: false
        se_cv: |-
          c = in_tex(coord)
          if (c == rgba(1,1,1,1))
              return rgba(0,0,0,0) 
          return c
      "GLSL\nCode":
        text: |
          void main() {
              outColor = vec4(1.0, v_coord.x, 0.0, 1.0);    
          }
      order:
        sorted_order: [0]
    name: white to transparent
    cls_name: Function Fill
    x: -2560
    y: 946
    disp_param: {}
  '14':
    params:
      Resolution:
        x: 550
        y: 420
      Size:
        e_x: 1.141
        e_y: 0.8710000000000001
        se_cv: 'return vec2(2, 2)'
      Smooth Scaling:
        v: false
      Texture Edge:
        sel_str: Pad
      Transform:
        e_tx: 0
        e_ty: 0
        e_r: 0
        e_pvx: 0
        e_pvy: 0
        e_sx: 1
        e_sy: 1
    name: create_pixel_buffer_2
    cls_name: Create Pixel-Buffer
    x: -2334
    y: 820
    disp_param: {}
  '23':
    params:
      Type:
        sel_str: GLSL Program
      Use first texture as gradient:
        v: true
      "Float\nExpression":
        se_v: coord.x
        show_code: true
        se_cv: return coord.x
      "Color\nExpression":
        hex: '#CCCCCC'
        show_code: true
        se_cv: |-
          r = rand(coord.x)
          return rgb(coord.x, coord.y, 1.0)
      "GLSL\nCode":
        text: |

          // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
          uint hash(uint x) {
              x += ( x << 10u );
              x ^= ( x >>  6u );
              x += ( x <<  3u );
              x ^= ( x >> 11u );
              x += ( x << 15u );
              return x;
          }

          uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)   ); }

          // Construct a float with half-open range [0:1] using low 23 bits.
          // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
          float floatConstruct( uint m ) {
              const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
              const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

              m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
              m |= ieeeOne;                          // Add fractional part to 1.0

              float  f = uintBitsToFloat( m );       // Range [1:2]
              return f - 1.0;                        // Range [0:1]
          }

          // Pseudo-random value in half-open range [0:1].
          float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

          vec3 hsv2rgb(vec3 c)
          {
              vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
              vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
              return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }


          void main() {
              vec3 c = hsv2rgb(vec3(random(v_coord), 1.0, 1.0) );
            
              float alpha = 1.0;
              if (random(v_coord*0.5) < 0.5)
                  alpha = 0.0;
              outColor = vec4(c, alpha);    
          }
        dlg_rect:
          left: 475
          top: 174
          width: 622
          height: 688
          visible: false
          track_top: 174
        panel_rect:
          height: 296
      order:
        sorted_order: []
    name: random pixels
    cls_name: Function Fill
    x: -2225
    y: 975
    disp_param: {}
  '28':
    params:
      Resolution:
        x: 900
        y: 900
      Size:
        e_x: 2
        e_y: 2
        se_cv: 'return vec2(2, 2)'
      Smooth Scaling:
        v: false
      Texture Edge:
        sel_str: Pad
      Transform:
        se_tx: '-0.131'
        se_ty: '-0.235'
        e_r: 0
        e_pvx: 0
        e_pvy: 0
        e_sx: 1
        e_sy: 1
    name: create_pixel_buffer_4
    cls_name: Create Pixel-Buffer
    x: -2002
    y: 877
    disp_param: {}
  '37':
    params:
      Type:
        sel_str: GLSL Program
      Use first texture as gradient:
        v: false
      "Float\nExpression":
        se_v: coord.x
        show_code: true
        se_cv: return in_tex(coord)
      "Color\nExpression":
        hex: '#CCCCCC'
        show_code: true
        se_cv: |-
          c = in_tex(coord)
          if (c.alpha < 0.2)
              c *= 4
          if (c.alpha == 1)
              c = vec4(0,0,0,0)
          return c
      "GLSL\nCode":
        text: "\nivec2 toTexelCoord(vec2 coord) {\n    vec2 fc = (_u_tex_tmat_0 * vec3(coord, 1.0)).xy;\n    ivec2 tsz = textureSize(_u_in_tex_0, 0);\n    ivec2 c = ivec2(fc * vec2(tsz));\n    return c;\n}\n\n\nivec2 around[] = ivec2[]( ivec2(-1,-1), ivec2(0,-1), ivec2(1,-1),\n\t\t\t     ivec2(-1,0), ivec2(1,0),\n\t\t\t     ivec2(-1,1), ivec2(0,1), ivec2(1,1) );\n\nvoid main() {\n    ivec2 cr = toTexelCoord(v_coord);\n    vec4 c = texelFetch(_u_in_tex_0, cr, 0);\t\n    \n    if (c.a < 0.2)\n        c *= 4.0;\n    if (c.a == 1.0) {\n        vec4 sum = vec4(0.0);\n        int count = 0;\n        for(int i = 0; i < 8; ++i) {\n            vec4 ac = texelFetch(_u_in_tex_0, cr+around[i], 0);\n            if (ac.a != 1.0) {\n                sum += ac;\n                ++count;\n            }\n        }\n        sum = sum * (1.0 / float(count) * 4.0);\n        //sum /= 4.0;\n        c = sum;\n    }\n    \n    outColor = c;\n}\n"
        panel_rect:
          height: 322
      order:
        sorted_order: [0]
    name: saturate_colors
    cls_name: Image Process
    x: -2268
    y: 1404
    disp_param: {}
lines:
  - from_name: out
    from_id: 5
    to_name: in
    to_id: 8
    uid: 9
  - from_name: out
    from_id: 8
    to_name: in_texs
    to_id: 3
    uid: 10
  - from_name: out_texture
    from_id: 3
    to_name: in_multi
    to_id: 5
    uid: 11
  - from_name: out_tex
    from_id: 14
    to_name: in_fb
    to_id: 12
    uid: 20
  - from_name: out_img
    from_id: 1
    to_name: in_texs
    to_id: 12
    uid: 21
  - from_name: out_tex
    from_id: 28
    to_name: in_fb
    to_id: 23
    uid: 29
  - from_name: out_texture
    from_id: 23
    to_name: in_multi
    to_id: 5
    uid: 31
  - from_name: out_tex
    from_id: 28
    to_name: in_fb
    to_id: 3
    uid: 32
  - from_name: out_texture
    from_id: 3
    to_name: in_texs
    to_id: 37
    uid: 38
next_node_id: 40
names_idx_s:
  Load Image: 1
  Create Pixel-Buffer: 4
  Function Fill: 5
  Pick One: 1
  Change Filter: 1
  Geom Primitive: 1
  Manual Geometry: 1
  Image Process: 3
display_node_id: 3
tdisp_node_ids:
  - 3
input_node_ids: []
nodes_view:
  pan_x: 2553
  pan_y: -1075
decor: []

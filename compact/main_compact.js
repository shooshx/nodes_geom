
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.1.0

Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.glMatrix = {}));
}(this, function (exports) { 'use strict';

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  var RANDOM = Math.random;
  /**
   * Sets the type of array used when creating new vectors and matrices
   *
   * @param {Type} type Array type, such as Float32Array or Array
   */

  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  var degree = Math.PI / 180;
  /**
   * Convert Degree To Radian
   *
   * @param {Number} a Angle in Degrees
   */

  function toRadian(a) {
    return a * degree;
  }
  /**
   * Tests whether or not the arguments have approximately the same value, within an absolute
   * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
   * than or equal to 1.0, and a relative tolerance is used for larger values)
   *
   * @param {Number} a The first number to test.
   * @param {Number} b The second number to test.
   * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
   */

  function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
  }
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  var common = /*#__PURE__*/Object.freeze({
    EPSILON: EPSILON,
    get ARRAY_TYPE () { return ARRAY_TYPE; },
    RANDOM: RANDOM,
    setMatrixArrayType: setMatrixArrayType,
    toRadian: toRadian,
    equals: equals
  });

  /**
   * 2x2 Matrix
   * @module mat2
   */

  /**
   * Creates a new identity mat2
   *
   * @returns {mat2} a new 2x2 matrix
   */

  function create() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2 initialized with values from an existing matrix
   *
   * @param {mat2} a matrix to clone
   * @returns {mat2} a new 2x2 matrix
   */

  function clone(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Copy the values from one mat2 to another
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set a mat2 to the identity matrix
   *
   * @param {mat2} out the receiving matrix
   * @returns {mat2} out
   */

  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Create a new mat2 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out A new 2x2 matrix
   */

  function fromValues(m00, m01, m10, m11) {
    var out = new ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Set the components of a mat2 to the given values
   *
   * @param {mat2} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out
   */

  function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Transpose the values of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
      var a1 = a[1];
      out[1] = a[2];
      out[2] = a1;
    } else {
      out[0] = a[0];
      out[1] = a[2];
      out[2] = a[1];
      out[3] = a[3];
    }

    return out;
  }
  /**
   * Inverts a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function invert(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3]; // Calculate the determinant

    var det = a0 * a3 - a2 * a1;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
  }
  /**
   * Calculates the determinant of a mat2
   *
   * @param {mat2} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
  }
  /**
   * Multiplies two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function multiply(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
  }
  /**
   * Rotates a mat2 by the given angle
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function rotate(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
  }
  /**
   * Scales the mat2 by the dimensions in the given vec2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2} out
   **/

  function scale(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2
   *
   * @param {mat2} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2
   *
   * @param {mat2} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3]);
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @param {mat2} L the lower triangular matrix
   * @param {mat2} D the diagonal matrix
   * @param {mat2} U the upper triangular matrix
   * @param {mat2} a the input matrix to factorize
   */

  function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [L, D, U];
  }
  /**
   * Adds two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two mat2's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2} out the receiving vector
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Alias for {@link mat2.multiply}
   * @function
   */

  var mul = multiply;
  /**
   * Alias for {@link mat2.subtract}
   * @function
   */

  var sub = subtract;

  var mat2 = /*#__PURE__*/Object.freeze({
    create: create,
    clone: clone,
    copy: copy,
    identity: identity,
    fromValues: fromValues,
    set: set,
    transpose: transpose,
    invert: invert,
    adjoint: adjoint,
    determinant: determinant,
    multiply: multiply,
    rotate: rotate,
    scale: scale,
    fromRotation: fromRotation,
    fromScaling: fromScaling,
    str: str,
    frob: frob,
    LDU: LDU,
    add: add,
    subtract: subtract,
    exactEquals: exactEquals,
    equals: equals$1,
    multiplyScalar: multiplyScalar,
    multiplyScalarAndAdd: multiplyScalarAndAdd,
    mul: mul,
    sub: sub
  });

  /**
   * 2x3 Matrix
   * @module mat2d
   *
   * @description
   * A mat2d contains six elements defined as:
   * <pre>
   * [a, b, c,
   *  d, tx, ty]
   * </pre>
   * This is a short form for the 3x3 matrix:
   * <pre>
   * [a, b, 0,
   *  c, d, 0,
   *  tx, ty, 1]
   * </pre>
   * The last column is ignored so the array is shorter and operations are faster.
   */

  /**
   * Creates a new identity mat2d
   *
   * @returns {mat2d} a new 2x3 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(6);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[4] = 0;
      out[5] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2d initialized with values from an existing matrix
   *
   * @param {mat2d} a matrix to clone
   * @returns {mat2d} a new 2x3 matrix
   */

  function clone$1(a) {
    var out = new ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Copy the values from one mat2d to another
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Set a mat2d to the identity matrix
   *
   * @param {mat2d} out the receiving matrix
   * @returns {mat2d} out
   */

  function identity$1(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Create a new mat2d with the given values
   *
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} A new mat2d
   */

  function fromValues$1(a, b, c, d, tx, ty) {
    var out = new ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Set the components of a mat2d to the given values
   *
   * @param {mat2d} out the receiving matrix
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} out
   */

  function set$1(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Inverts a mat2d
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function invert$1(out, a) {
    var aa = a[0],
        ab = a[1],
        ac = a[2],
        ad = a[3];
    var atx = a[4],
        aty = a[5];
    var det = aa * ad - ab * ac;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
  }
  /**
   * Calculates the determinant of a mat2d
   *
   * @param {mat2d} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    return a[0] * a[3] - a[1] * a[2];
  }
  /**
   * Multiplies two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function multiply$1(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
  }
  /**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function rotate$1(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Scales the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2d} out
   **/

  function scale$1(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Translates the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to translate the matrix by
   * @returns {mat2d} out
   **/

  function translate(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.rotate(dest, dest, rad);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function fromRotation$1(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.scale(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2d} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.translate(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat2d} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2d
   *
   * @param {mat2d} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$1(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2d
   *
   * @param {mat2d} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$1(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
  }
  /**
   * Adds two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2d} out
   */

  function multiplyScalar$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
  }
  /**
   * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2d} out the receiving vector
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2d} out
   */

  function multiplyScalarAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$2(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
  }
  /**
   * Alias for {@link mat2d.multiply}
   * @function
   */

  var mul$1 = multiply$1;
  /**
   * Alias for {@link mat2d.subtract}
   * @function
   */

  var sub$1 = subtract$1;

  var mat2d = /*#__PURE__*/Object.freeze({
    create: create$1,
    clone: clone$1,
    copy: copy$1,
    identity: identity$1,
    fromValues: fromValues$1,
    set: set$1,
    invert: invert$1,
    determinant: determinant$1,
    multiply: multiply$1,
    rotate: rotate$1,
    scale: scale$1,
    translate: translate,
    fromRotation: fromRotation$1,
    fromScaling: fromScaling$1,
    fromTranslation: fromTranslation,
    str: str$1,
    frob: frob$1,
    add: add$1,
    subtract: subtract$1,
    multiplyScalar: multiplyScalar$1,
    multiplyScalarAndAdd: multiplyScalarAndAdd$1,
    exactEquals: exactEquals$1,
    equals: equals$2,
    mul: mul$1,
    sub: sub$1
  });

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$2() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {mat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {mat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */

  function clone$2(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues$2(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {mat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$2(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$2(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to translate
   * @param {vec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$1(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$2(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$2(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$2(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat2d} a the matrix to copy
   * @returns {mat3} out
   **/

  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  /**
  * Calculates a 3x3 matrix from the given quaternion
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {quat} q Quaternion to create matrix from
  *
  * @returns {mat3} out
  */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
  * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {mat4} a Mat4 to derive the normal matrix from
  *
  * @returns {mat3} out
  */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */

  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat3
   *
   * @param {mat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$2(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {mat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$2(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function add$2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */

  function multiplyScalar$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  /**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */

  function multiplyScalarAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$3(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }
  /**
   * Alias for {@link mat3.multiply}
   * @function
   */

  var mul$2 = multiply$2;
  /**
   * Alias for {@link mat3.subtract}
   * @function
   */

  var sub$2 = subtract$2;

  var mat3 = /*#__PURE__*/Object.freeze({
    create: create$2,
    fromMat4: fromMat4,
    clone: clone$2,
    copy: copy$2,
    fromValues: fromValues$2,
    set: set$2,
    identity: identity$2,
    transpose: transpose$1,
    invert: invert$2,
    adjoint: adjoint$1,
    determinant: determinant$2,
    multiply: multiply$2,
    translate: translate$1,
    rotate: rotate$2,
    scale: scale$2,
    fromTranslation: fromTranslation$1,
    fromRotation: fromRotation$2,
    fromScaling: fromScaling$2,
    fromMat2d: fromMat2d,
    fromQuat: fromQuat,
    normalFromMat4: normalFromMat4,
    projection: projection,
    str: str$2,
    frob: frob$2,
    add: add$2,
    subtract: subtract$2,
    multiplyScalar: multiplyScalar$2,
    multiplyScalarAndAdd: multiplyScalarAndAdd$2,
    exactEquals: exactEquals$2,
    equals: equals$3,
    mul: mul$2,
    sub: sub$2
  });

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$3() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {mat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone$3(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose$2(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function invert$3(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {mat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$3(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$3(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to translate
   * @param {vec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate$2(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {vec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$3(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate$3(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation$2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling$3(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation$3(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {quat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {mat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @param {vec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity$3(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {mat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$3(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {mat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$3(a) {
    return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd$3(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$4(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul$3 = multiply$3;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub$3 = subtract$3;

  var mat4 = /*#__PURE__*/Object.freeze({
    create: create$3,
    clone: clone$3,
    copy: copy$3,
    fromValues: fromValues$3,
    set: set$3,
    identity: identity$3,
    transpose: transpose$2,
    invert: invert$3,
    adjoint: adjoint$2,
    determinant: determinant$3,
    multiply: multiply$3,
    translate: translate$2,
    scale: scale$3,
    rotate: rotate$3,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    fromTranslation: fromTranslation$2,
    fromScaling: fromScaling$3,
    fromRotation: fromRotation$3,
    fromXRotation: fromXRotation,
    fromYRotation: fromYRotation,
    fromZRotation: fromZRotation,
    fromRotationTranslation: fromRotationTranslation,
    fromQuat2: fromQuat2,
    getTranslation: getTranslation,
    getScaling: getScaling,
    getRotation: getRotation,
    fromRotationTranslationScale: fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
    fromQuat: fromQuat$1,
    frustum: frustum,
    perspective: perspective,
    perspectiveFromFieldOfView: perspectiveFromFieldOfView,
    ortho: ortho,
    lookAt: lookAt,
    targetTo: targetTo,
    str: str$3,
    frob: frob$3,
    add: add$3,
    subtract: subtract$3,
    multiplyScalar: multiplyScalar$3,
    multiplyScalarAndAdd: multiplyScalarAndAdd$3,
    exactEquals: exactEquals$3,
    equals: equals$4,
    mul: mul$3,
    sub: sub$3
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$4() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {vec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */

  function clone$4(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$4(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the source vector
   * @returns {vec3} out
   */

  function copy$4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$4(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function add$4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Math.ceil the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to ceil
   * @returns {vec3} out
   */

  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to floor
   * @returns {vec3} out
   */

  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * Math.round the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to round
   * @returns {vec3} out
   */

  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Calculates the squared length of a vec3
   *
   * @param {vec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to negate
   * @returns {vec3} out
   */

  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec3} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec3} out
   */

  function random(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    var z = RANDOM() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateX$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateY$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateZ$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2]; //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param {vec3} a The first operand
   * @param {vec3} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var tempA = fromValues$4(a[0], a[1], a[2]);
    var tempB = fromValues$4(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1.0) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec3 to zero
   *
   * @param {vec3} out the receiving vector
   * @returns {vec3} out
   */

  function zero(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec3} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$4(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$5(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.subtract}
   * @function
   */

  var sub$4 = subtract$4;
  /**
   * Alias for {@link vec3.multiply}
   * @function
   */

  var mul$4 = multiply$4;
  /**
   * Alias for {@link vec3.divide}
   * @function
   */

  var div = divide;
  /**
   * Alias for {@link vec3.distance}
   * @function
   */

  var dist = distance;
  /**
   * Alias for {@link vec3.squaredDistance}
   * @function
   */

  var sqrDist = squaredDistance;
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Alias for {@link vec3.squaredLength}
   * @function
   */

  var sqrLen = squaredLength;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create$4();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  var vec3 = /*#__PURE__*/Object.freeze({
    create: create$4,
    clone: clone$4,
    length: length,
    fromValues: fromValues$4,
    copy: copy$4,
    set: set$4,
    add: add$4,
    subtract: subtract$4,
    multiply: multiply$4,
    divide: divide,
    ceil: ceil,
    floor: floor,
    min: min,
    max: max,
    round: round,
    scale: scale$4,
    scaleAndAdd: scaleAndAdd,
    distance: distance,
    squaredDistance: squaredDistance,
    squaredLength: squaredLength,
    negate: negate,
    inverse: inverse,
    normalize: normalize,
    dot: dot,
    cross: cross,
    lerp: lerp,
    hermite: hermite,
    bezier: bezier,
    random: random,
    transformMat4: transformMat4,
    transformMat3: transformMat3,
    transformQuat: transformQuat,
    rotateX: rotateX$1,
    rotateY: rotateY$1,
    rotateZ: rotateZ$1,
    angle: angle,
    zero: zero,
    str: str$4,
    exactEquals: exactEquals$4,
    equals: equals$5,
    sub: sub$4,
    mul: mul$4,
    div: div,
    dist: dist,
    sqrDist: sqrDist,
    len: len,
    sqrLen: sqrLen,
    forEach: forEach
  });

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$5() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with values from an existing vector
   *
   * @param {vec4} a vector to clone
   * @returns {vec4} a new 4D vector
   */

  function clone$5(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$5(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the source vector
   * @returns {vec4} out
   */

  function copy$5(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */

  function set$5(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function add$5(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function subtract$5(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function multiply$5(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  /**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function divide$1(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  /**
   * Math.ceil the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to ceil
   * @returns {vec4} out
   */

  function ceil$1(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  /**
   * Math.floor the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to floor
   * @returns {vec4} out
   */

  function floor$1(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  /**
   * Returns the minimum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function min$1(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  /**
   * Returns the maximum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function max$1(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  /**
   * Math.round the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to round
   * @returns {vec4} out
   */

  function round$1(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  /**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */

  function scale$5(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */

  function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Calculates the length of a vec4
   *
   * @param {vec4} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$1(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
  }
  /**
   * Calculates the squared length of a vec4
   *
   * @param {vec4} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$1(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to negate
   * @returns {vec4} out
   */

  function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to invert
   * @returns {vec4} out
   */

  function inverse$1(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$1(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {vec4} result the receiving vector
   * @param {vec4} U the first vector
   * @param {vec4} V the second vector
   * @param {vec4} W the third vector
   * @returns {vec4} result
   */

  function cross$1(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0],
        B = v[0] * w[2] - v[2] * w[0],
        C = v[0] * w[3] - v[3] * w[0],
        D = v[1] * w[2] - v[2] * w[1],
        E = v[1] * w[3] - v[3] * w[1],
        F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */

  function lerp$1(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec4} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec4} out
   */

  function random$1(out, scale) {
    scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;

    var v1, v2, v3, v4;
    var s1, s2;

    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);

    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);

    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale * v1;
    out[1] = scale * v2;
    out[2] = scale * v3 * d;
    out[3] = scale * v4 * d;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec4} out
   */

  function transformQuat$1(out, a, q) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3]; // calculate quat * vec

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to zero
   *
   * @param {vec4} out the receiving vector
   * @returns {vec4} out
   */

  function zero$1(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec4} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$5(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$5(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$6(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Alias for {@link vec4.subtract}
   * @function
   */

  var sub$5 = subtract$5;
  /**
   * Alias for {@link vec4.multiply}
   * @function
   */

  var mul$5 = multiply$5;
  /**
   * Alias for {@link vec4.divide}
   * @function
   */

  var div$1 = divide$1;
  /**
   * Alias for {@link vec4.distance}
   * @function
   */

  var dist$1 = distance$1;
  /**
   * Alias for {@link vec4.squaredDistance}
   * @function
   */

  var sqrDist$1 = squaredDistance$1;
  /**
   * Alias for {@link vec4.length}
   * @function
   */

  var len$1 = length$1;
  /**
   * Alias for {@link vec4.squaredLength}
   * @function
   */

  var sqrLen$1 = squaredLength$1;
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$5();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  var vec4 = /*#__PURE__*/Object.freeze({
    create: create$5,
    clone: clone$5,
    fromValues: fromValues$5,
    copy: copy$5,
    set: set$5,
    add: add$5,
    subtract: subtract$5,
    multiply: multiply$5,
    divide: divide$1,
    ceil: ceil$1,
    floor: floor$1,
    min: min$1,
    max: max$1,
    round: round$1,
    scale: scale$5,
    scaleAndAdd: scaleAndAdd$1,
    distance: distance$1,
    squaredDistance: squaredDistance$1,
    length: length$1,
    squaredLength: squaredLength$1,
    negate: negate$1,
    inverse: inverse$1,
    normalize: normalize$1,
    dot: dot$1,
    cross: cross$1,
    lerp: lerp$1,
    random: random$1,
    transformMat4: transformMat4$1,
    transformQuat: transformQuat$1,
    zero: zero$1,
    str: str$5,
    exactEquals: exactEquals$5,
    equals: equals$6,
    sub: sub$5,
    mul: mul$5,
    div: div$1,
    dist: dist$1,
    sqrDist: sqrDist$1,
    len: len$1,
    sqrLen: sqrLen$1,
    forEach: forEach$1
  });

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$6() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Set a quat to the identity quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function identity$4(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {vec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {quat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Gets the angular distance between two unit quaternions
   *
   * @param  {quat} a     Origin unit quaternion 
   * @param  {quat} b     Destination unit quaternion
   * @return {Number}     Angle, in radians, between the two quaternions
   */

  function getAngle(a, b) {
    var dotproduct = dot$2(a, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   */

  function multiply$6(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateX$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateY$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var by = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateZ$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bz = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate W component of
   * @returns {quat} out
   */

  function calculateW(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
  }
  /**
   * Calculate the exponential of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate the exponential of
   * @returns {quat} out
   */

  function exp(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var et = Math.exp(w);
    var s = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x * s;
    out[1] = y * s;
    out[2] = z * s;
    out[3] = et * Math.cos(r);
    return out;
  }
  /**
   * Calculate the natural logarithm of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate the exponential of
   * @returns {quat} out
   */

  function ln(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var r = Math.sqrt(x * x + y * y + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x * t;
    out[1] = y * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
    return out;
  }
  /**
   * Calculate the scalar power of a unit quaternion.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate the exponential of
   * @param {Number} b amount to scale the quaternion by
   * @returns {quat} out
   */

  function pow(out, a, b) {
    ln(out, a);
    scale$6(out, out, b);
    exp(out, out);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Generates a random unit quaternion
   * 
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function random$2(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert$4(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {mat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Returns a string representation of a quatenion
   *
   * @param {quat} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$6(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat} a quaternion to clone
   * @returns {quat} a new quaternion
   * @function
   */

  var clone$6 = clone$5;
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues$6 = fromValues$5;
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy$6 = copy$5;
  /**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */

  var set$6 = set$5;
  /**
   * Adds two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   * @function
   */

  var add$6 = add$5;
  /**
   * Alias for {@link quat.multiply}
   * @function
   */

  var mul$6 = multiply$6;
  /**
   * Scales a quat by a scalar number
   *
   * @param {quat} out the receiving vector
   * @param {quat} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {quat} out
   * @function
   */

  var scale$6 = scale$5;
  /**
   * Calculates the dot product of two quat's
   *
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$2 = dot$1;
  /**
   * Performs a linear interpolation between two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   * @function
   */

  var lerp$2 = lerp$1;
  /**
   * Calculates the length of a quat
   *
   * @param {quat} a vector to calculate length of
   * @returns {Number} length of a
   */

  var length$2 = length$1;
  /**
   * Alias for {@link quat.length}
   * @function
   */

  var len$2 = length$2;
  /**
   * Calculates the squared length of a quat
   *
   * @param {quat} a vector to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$2 = squaredLength$1;
  /**
   * Alias for {@link quat.squaredLength}
   * @function
   */

  var sqrLen$2 = squaredLength$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$1;
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat} a The first quaternion.
   * @param {quat} b The second quaternion.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var exactEquals$6 = exactEquals$5;
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   *
   * @param {quat} a The first vector.
   * @param {quat} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var equals$7 = equals$6;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {vec3} a the initial vector
   * @param {vec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$4();
    var xUnitVec3 = fromValues$4(1, 0, 0);
    var yUnitVec3 = fromValues$4(0, 1, 0);
    return function (out, a, b) {
      var dot$1 = dot(a, b);

      if (dot$1 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot$1 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot$1;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {quat} c the third operand
   * @param {quat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$6();
    var temp2 = create$6();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {vec3} view  the vector representing the viewing direction
   * @param {vec3} right the vector representing the local "right" direction
   * @param {vec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create$2();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  var quat = /*#__PURE__*/Object.freeze({
    create: create$6,
    identity: identity$4,
    setAxisAngle: setAxisAngle,
    getAxisAngle: getAxisAngle,
    getAngle: getAngle,
    multiply: multiply$6,
    rotateX: rotateX$2,
    rotateY: rotateY$2,
    rotateZ: rotateZ$2,
    calculateW: calculateW,
    exp: exp,
    ln: ln,
    pow: pow,
    slerp: slerp,
    random: random$2,
    invert: invert$4,
    conjugate: conjugate,
    fromMat3: fromMat3,
    fromEuler: fromEuler,
    str: str$6,
    clone: clone$6,
    fromValues: fromValues$6,
    copy: copy$6,
    set: set$6,
    add: add$6,
    mul: mul$6,
    scale: scale$6,
    dot: dot$2,
    lerp: lerp$2,
    length: length$2,
    len: len$2,
    squaredLength: squaredLength$2,
    sqrLen: sqrLen$2,
    normalize: normalize$2,
    exactEquals: exactEquals$6,
    equals: equals$7,
    rotationTo: rotationTo,
    sqlerp: sqlerp,
    setAxes: setAxes
  });

  /**
   * Dual Quaternion<br>
   * Format: [real, dual]<br>
   * Quaternion format: XYZW<br>
   * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
   * @module quat2
   */

  /**
   * Creates a new identity dual quat
   *
   * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
   */

  function create$7() {
    var dq = new ARRAY_TYPE(8);

    if (ARRAY_TYPE != Float32Array) {
      dq[0] = 0;
      dq[1] = 0;
      dq[2] = 0;
      dq[4] = 0;
      dq[5] = 0;
      dq[6] = 0;
      dq[7] = 0;
    }

    dq[3] = 1;
    return dq;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat2} a dual quaternion to clone
   * @returns {quat2} new dual quaternion
   * @function
   */

  function clone$7(a) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
  }
  /**
   * Creates a new dual quat initialized with the given values
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromValues$7(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
  }
  /**
   * Creates a new dual quat from the given values (quat and translation)
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component (translation)
   * @param {Number} y2 Y component (translation)
   * @param {Number} z2 Z component (translation)
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5,
        ay = y2 * 0.5,
        az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
  }
  /**
   * Creates a dual quat from a quaternion and a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q a normalized quaternion
   * @param {vec3} t tranlation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotationTranslation$1(out, q, t) {
    var ax = t[0] * 0.5,
        ay = t[1] * 0.5,
        az = t[2] * 0.5,
        bx = q[0],
        by = q[1],
        bz = q[2],
        bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Creates a dual quat from a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {vec3} t translation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromTranslation$3(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a dual quat from a quaternion
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q the quaternion
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotation$4(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a new dual quat from a matrix (4x4)
   *
   * @param {quat2} out the dual quaternion
   * @param {mat4} a the matrix
   * @returns {quat2} dual quat receiving operation result
   * @function
   */

  function fromMat4$1(out, a) {
    //TODO Optimize this
    var outer = create$6();
    getRotation(outer, a);
    var t = new ARRAY_TYPE(3);
    getTranslation(t, a);
    fromRotationTranslation$1(out, outer, t);
    return out;
  }
  /**
   * Copy the values from one dual quat to another
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the source dual quaternion
   * @returns {quat2} out
   * @function
   */

  function copy$7(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Set a dual quat to the identity dual quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @returns {quat2} out
   */

  function identity$5(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Set the components of a dual quat to the given values
   *
   * @param {quat2} out the receiving quaternion
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} out
   * @function
   */

  function set$7(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
  }
  /**
   * Gets the real part of a dual quat
   * @param  {quat} out real part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} real part
   */

  var getReal = copy$6;
  /**
   * Gets the dual part of a dual quat
   * @param  {quat} out dual part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} dual part
   */

  function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
  }
  /**
   * Set the real component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the real part
   * @returns {quat2} out
   * @function
   */

  var setReal = copy$6;
  /**
   * Set the dual component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the dual part
   * @returns {quat2} out
   * @function
   */

  function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
  }
  /**
   * Gets the translation of a normalized dual quat
   * @param  {vec3} out translation
   * @param  {quat2} a Dual Quaternion to be decomposed
   * @return {vec3} translation
   */

  function getTranslation$1(out, a) {
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
  }
  /**
   * Translates a dual quat by the given vector
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to translate
   * @param {vec3} v vector to translate by
   * @returns {quat2} out
   */

  function translate$3(out, a, v) {
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3],
        bx1 = v[0] * 0.5,
        by1 = v[1] * 0.5,
        bz1 = v[2] * 0.5,
        ax2 = a[4],
        ay2 = a[5],
        az2 = a[6],
        aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
  }
  /**
   * Rotates a dual quat around the X axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateX$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateX$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Y axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateY$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateY$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Z axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateZ$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateZ$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (a * q)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {quat} q quaternion to rotate by
   * @returns {quat2} out
   */

  function rotateByQuatAppend(out, a, q) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (q * a)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat} q quaternion to rotate by
   * @param {quat2} a the dual quaternion to rotate
   * @returns {quat2} out
   */

  function rotateByQuatPrepend(out, q, a) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        bx = a[0],
        by = a[1],
        bz = a[2],
        bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
  }
  /**
   * Rotates a dual quat around a given axis. Does the normalisation automatically
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {vec3} axis the axis to rotate around
   * @param {Number} rad how far the rotation should be
   * @returns {quat2} out
   */

  function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < EPSILON) {
      return copy$7(out, a);
    }

    var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Adds two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   * @function
   */

  function add$7(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
  }
  /**
   * Multiplies two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   */

  function multiply$7(out, a, b) {
    var ax0 = a[0],
        ay0 = a[1],
        az0 = a[2],
        aw0 = a[3],
        bx1 = b[4],
        by1 = b[5],
        bz1 = b[6],
        bw1 = b[7],
        ax1 = a[4],
        ay1 = a[5],
        az1 = a[6],
        aw1 = a[7],
        bx0 = b[0],
        by0 = b[1],
        bz0 = b[2],
        bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
  }
  /**
   * Alias for {@link quat2.multiply}
   * @function
   */

  var mul$7 = multiply$7;
  /**
   * Scales a dual quat by a scalar number
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the dual quat to scale
   * @param {Number} b amount to scale the dual quat by
   * @returns {quat2} out
   * @function
   */

  function scale$7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
  }
  /**
   * Calculates the dot product of two dual quat's (The dot product of the real parts)
   *
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$3 = dot$2;
  /**
   * Performs a linear interpolation between two dual quats's
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat2} out
   */

  function lerp$3(out, a, b, t) {
    var mt = 1 - t;
    if (dot$3(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
  }
  /**
   * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quat to calculate inverse of
   * @returns {quat2} out
   */

  function invert$5(out, a) {
    var sqlen = squaredLength$3(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
  }
  /**
   * Calculates the conjugate of a dual quat
   * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat2} a quat to calculate conjugate of
   * @returns {quat2} out
   */

  function conjugate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Calculates the length of a dual quat
   *
   * @param {quat2} a dual quat to calculate length of
   * @returns {Number} length of a
   * @function
   */

  var length$3 = length$2;
  /**
   * Alias for {@link quat2.length}
   * @function
   */

  var len$3 = length$3;
  /**
   * Calculates the squared length of a dual quat
   *
   * @param {quat2} a dual quat to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$3 = squaredLength$2;
  /**
   * Alias for {@link quat2.squaredLength}
   * @function
   */

  var sqrLen$3 = squaredLength$3;
  /**
   * Normalize a dual quat
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quaternion to normalize
   * @returns {quat2} out
   * @function
   */

  function normalize$3(out, a) {
    var magnitude = squaredLength$3(a);

    if (magnitude > 0) {
      magnitude = Math.sqrt(magnitude);
      var a0 = a[0] / magnitude;
      var a1 = a[1] / magnitude;
      var a2 = a[2] / magnitude;
      var a3 = a[3] / magnitude;
      var b0 = a[4];
      var b1 = a[5];
      var b2 = a[6];
      var b3 = a[7];
      var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
      out[0] = a0;
      out[1] = a1;
      out[2] = a2;
      out[3] = a3;
      out[4] = (b0 - a0 * a_dot_b) / magnitude;
      out[5] = (b1 - a1 * a_dot_b) / magnitude;
      out[6] = (b2 - a2 * a_dot_b) / magnitude;
      out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }

    return out;
  }
  /**
   * Returns a string representation of a dual quatenion
   *
   * @param {quat2} a dual quaternion to represent as a string
   * @returns {String} string representation of the dual quat
   */

  function str$7(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
  }
  /**
   * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat2} a the first dual quaternion.
   * @param {quat2} b the second dual quaternion.
   * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
   */

  function exactEquals$7(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
  }
  /**
   * Returns whether or not the dual quaternions have approximately the same elements in the same position.
   *
   * @param {quat2} a the first dual quat.
   * @param {quat2} b the second dual quat.
   * @returns {Boolean} true if the dual quats are equal, false otherwise.
   */

  function equals$8(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
  }

  var quat2 = /*#__PURE__*/Object.freeze({
    create: create$7,
    clone: clone$7,
    fromValues: fromValues$7,
    fromRotationTranslationValues: fromRotationTranslationValues,
    fromRotationTranslation: fromRotationTranslation$1,
    fromTranslation: fromTranslation$3,
    fromRotation: fromRotation$4,
    fromMat4: fromMat4$1,
    copy: copy$7,
    identity: identity$5,
    set: set$7,
    getReal: getReal,
    getDual: getDual,
    setReal: setReal,
    setDual: setDual,
    getTranslation: getTranslation$1,
    translate: translate$3,
    rotateX: rotateX$3,
    rotateY: rotateY$3,
    rotateZ: rotateZ$3,
    rotateByQuatAppend: rotateByQuatAppend,
    rotateByQuatPrepend: rotateByQuatPrepend,
    rotateAroundAxis: rotateAroundAxis,
    add: add$7,
    multiply: multiply$7,
    mul: mul$7,
    scale: scale$7,
    dot: dot$3,
    lerp: lerp$3,
    invert: invert$5,
    conjugate: conjugate$1,
    length: length$3,
    len: len$3,
    squaredLength: squaredLength$3,
    sqrLen: sqrLen$3,
    normalize: normalize$3,
    str: str$7,
    exactEquals: exactEquals$7,
    equals: equals$8
  });

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create$8() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec2 initialized with values from an existing vector
   *
   * @param {vec2} a vector to clone
   * @returns {vec2} a new 2D vector
   */

  function clone$8(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */

  function fromValues$8(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the source vector
   * @returns {vec2} out
   */

  function copy$8(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Set the components of a vec2 to the given values
   *
   * @param {vec2} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} out
   */

  function set$8(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function add$8(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function subtract$6(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function multiply$8(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  /**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function divide$2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  /**
   * Math.ceil the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to ceil
   * @returns {vec2} out
   */

  function ceil$2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  /**
   * Math.floor the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to floor
   * @returns {vec2} out
   */

  function floor$2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  /**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function min$2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  /**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function max$2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  /**
   * Math.round the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to round
   * @returns {vec2} out
   */

  function round$2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale$8(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Adds two vec2's after scaling the second operand by a scalar value
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec2} out
   */

  function scaleAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$2(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$2(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x * x + y * y;
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {vec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$4(a) {
    var x = a[0],
        y = a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the squared length of a vec2
   *
   * @param {vec2} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$4(a) {
    var x = a[0],
        y = a[1];
    return x * x + y * y;
  }
  /**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to negate
   * @returns {vec2} out
   */

  function negate$2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to invert
   * @returns {vec2} out
   */

  function inverse$2(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize$4(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$4(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec3} out
   */

  function cross$2(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */

  function lerp$4(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec2} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec2} out
   */

  function random$3(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2d} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3$1(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat4$2(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  /**
   * Rotate a 2D vector
   * @param {vec2} out The receiving vec2
   * @param {vec2} a The vec2 point to rotate
   * @param {vec2} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec2} out
   */

  function rotate$4(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0],
        p1 = a[1] - b[1],
        sinC = Math.sin(c),
        cosC = Math.cos(c); //perform rotation and translate to correct position

    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {vec2} a The first operand
   * @param {vec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$1(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;

    if (len1 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len1 = 1 / Math.sqrt(len1);
    }

    var len2 = x2 * x2 + y2 * y2;

    if (len2 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len2 = 1 / Math.sqrt(len2);
    }

    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1.0) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec2 to zero
   *
   * @param {vec2} out the receiving vector
   * @returns {vec2} out
   */

  function zero$2(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec2} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$8(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
  }
  /**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$8(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$9(a, b) {
    var a0 = a[0],
        a1 = a[1];
    var b0 = b[0],
        b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
  }
  /**
   * Alias for {@link vec2.length}
   * @function
   */

  var len$4 = length$4;
  /**
   * Alias for {@link vec2.subtract}
   * @function
   */

  var sub$6 = subtract$6;
  /**
   * Alias for {@link vec2.multiply}
   * @function
   */

  var mul$8 = multiply$8;
  /**
   * Alias for {@link vec2.divide}
   * @function
   */

  var div$2 = divide$2;
  /**
   * Alias for {@link vec2.distance}
   * @function
   */

  var dist$2 = distance$2;
  /**
   * Alias for {@link vec2.squaredDistance}
   * @function
   */

  var sqrDist$2 = squaredDistance$2;
  /**
   * Alias for {@link vec2.squaredLength}
   * @function
   */

  var sqrLen$4 = squaredLength$4;
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$8();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  var vec2 = /*#__PURE__*/Object.freeze({
    create: create$8,
    clone: clone$8,
    fromValues: fromValues$8,
    copy: copy$8,
    set: set$8,
    add: add$8,
    subtract: subtract$6,
    multiply: multiply$8,
    divide: divide$2,
    ceil: ceil$2,
    floor: floor$2,
    min: min$2,
    max: max$2,
    round: round$2,
    scale: scale$8,
    scaleAndAdd: scaleAndAdd$2,
    distance: distance$2,
    squaredDistance: squaredDistance$2,
    length: length$4,
    squaredLength: squaredLength$4,
    negate: negate$2,
    inverse: inverse$2,
    normalize: normalize$4,
    dot: dot$4,
    cross: cross$2,
    lerp: lerp$4,
    random: random$3,
    transformMat2: transformMat2,
    transformMat2d: transformMat2d,
    transformMat3: transformMat3$1,
    transformMat4: transformMat4$2,
    rotate: rotate$4,
    angle: angle$1,
    zero: zero$2,
    str: str$8,
    exactEquals: exactEquals$8,
    equals: equals$9,
    len: len$4,
    sub: sub$6,
    mul: mul$8,
    div: div$2,
    dist: dist$2,
    sqrDist: sqrDist$2,
    sqrLen: sqrLen$4,
    forEach: forEach$2
  });

  exports.glMatrix = common;
  exports.mat2 = mat2;
  exports.mat2d = mat2d;
  exports.mat3 = mat3;
  exports.mat4 = mat4;
  exports.quat = quat;
  exports.quat2 = quat2;
  exports.vec2 = vec2;
  exports.vec3 = vec3;
  exports.vec4 = vec4;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

"use strict"
/*!	Curve calc function for canvas 2.3.1
 *	Epistemex (c) 2013-2014
 *	License: MIT
 https://github.com/gdenisov/cardinal-spline-js
 */

/**
 * Calculates an array containing points representing a cardinal spline through given point array.
 * Points must be arranged as: [x1, y1, x2, y2, ..., xn, yn].
 *
 * The points for the cardinal spline are returned as a new array.
 *
 * @param {Array} points - point array
 * @param {Number} [tension=0.5] - tension. Typically between [0.0, 1.0] but can be exceeded
 * @param {Number} [numOfSeg=20] - number of segments between two points (line resolution)
 * @param {Boolean} [close=false] - Close the ends making the line continuous
 * @returns {Float32Array} New array with the calculated points that was added to the path
 */
function getCurvePoints(points, tension, numOfSeg, close) {

	'use strict';

	// options or defaults
	tension = (typeof tension === 'number') ? tension : 0.5;
	numOfSeg = numOfSeg ? numOfSeg : 25;

	var pts,									// for cloning point array
		i = 1,
		l = points.length,
		rPos = 0,
		rLen = (l-2) * numOfSeg + 2 + (close ? 2 * numOfSeg: 0),
		res = new Float32Array(rLen),
		cache = new Float32Array((numOfSeg + 2) * 4),
		cachePtr = 4;

	pts = points.slice(0);

	if (close) {
		pts.unshift(points[l - 1]);				// insert end point as first point
		pts.unshift(points[l - 2]);
		pts.push(points[0], points[1]); 		// first point as last point
	}
	else {
		pts.unshift(points[1]);					// copy 1. point and insert at beginning
		pts.unshift(points[0]);
		pts.push(points[l - 2], points[l - 1]);	// duplicate end-points
	}

	// cache inner-loop calculations as they are based on t alone
	cache[0] = 1;								// 1,0,0,0

	for (; i < numOfSeg; i++) {

		var st = i / numOfSeg,
			st2 = st * st,
			st3 = st2 * st,
			st23 = st3 * 2,
			st32 = st2 * 3;

		cache[cachePtr++] =	st23 - st32 + 1;	// c1
		cache[cachePtr++] =	st32 - st23;		// c2
		cache[cachePtr++] =	st3 - 2 * st2 + st;	// c3
		cache[cachePtr++] =	st3 - st2;			// c4
	}

	cache[++cachePtr] = 1;						// 0,1,0,0

	// calc. points
	parse(pts, cache, l);

	if (close) {
		//l = points.length;
		pts = [];
		pts.push(points[l - 4], points[l - 3], points[l - 2], points[l - 1]); // second last and last
		pts.push(points[0], points[1], points[2], points[3]); // first and second
		parse(pts, cache, 4);
	}

	function parse(pts, cache, l) {

		for (var i = 2, t; i < l; i += 2) {

			var pt1 = pts[i],
				pt2 = pts[i+1],
				pt3 = pts[i+2],
				pt4 = pts[i+3],

				t1x = (pt3 - pts[i-2]) * tension,
				t1y = (pt4 - pts[i-1]) * tension,
				t2x = (pts[i+4] - pt1) * tension,
				t2y = (pts[i+5] - pt2) * tension;

			for (t = 0; t < numOfSeg; t++) {

				var c = t << 2, //t * 4;

					c1 = cache[c],
					c2 = cache[c+1],
					c3 = cache[c+2],
					c4 = cache[c+3];

				res[rPos++] = c1 * pt1 + c2 * pt3 + c3 * t1x + c4 * t2x;
				res[rPos++] = c1 * pt2 + c2 * pt4 + c3 * t1y + c4 * t2y;
			}
		}
	}

	// add last point
	l = close ? 0 : points.length - 2;
	res[rPos++] = points[l];
	res[rPos] = points[l+1];

	return res;
}


const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);

class Delaunator {

    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);

        for (let i = 0; i < n; i++) {
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }

        return new Delaunator(coords);
    }

    constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

        this.coords = coords;

        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);

        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);

        this.update();
    }

    update() {
        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
        const n = coords.length >> 1;

        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = 0; i < n; i++) {
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        let minDist = Infinity;
        let i0, i1, i2;

        // pick a seed point close to the center
        for (let i = 0; i < n; i++) {
            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist) {
                i0 = i;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];

        minDist = Infinity;

        // find the point closest to the seed
        for (let i = 0; i < n; i++) {
            if (i === i0) continue;
            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist && d > 0) {
                i1 = i;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];

        let minRadius = Infinity;

        // find the third point which forms the smallest circumcircle with the first two
        for (let i = 0; i < n; i++) {
            if (i === i0 || i === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
            if (r < minRadius) {
                i2 = i;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];

        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for (let i = 0; i < n; i++) {
                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
            }
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for (let i = 0, d0 = -Infinity; i < n; i++) {
                const id = this._ids[i];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }

        // swap the order of the seed points for counter-clockwise orientation
        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }

        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;

        for (let i = 0; i < n; i++) {
            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
        }

        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);

        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;

        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;

        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;

        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;

        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);

        for (let k = 0, xp, yp; k < this._ids.length; k++) {
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];

            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;

            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }

            start = hullPrev[start];
            let e = start, q;
            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;

            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e === start) {
                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                    this._legalize(t + 2);
                    hullTri[q] = t;
                    hullNext[e] = e; // mark as removed
                    hullSize--;
                    e = q;
                }
            }

            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;

            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }

        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
            this.hull[i] = e;
            e = hullNext[e];
        }

        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }

    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }

    _legalize(a) {
        const {_triangles: triangles, _halfedges: halfedges, coords} = this;

        let i = 0;
        let ar = 0;

        // recursion eliminated with a fixed-size stack
        while (true) {
            const b = halfedges[a];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */
            const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;

            if (b === -1) { // convex hull edge
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }

            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;

            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];

            const illegal = inCircle(
                coords[2 * p0], coords[2 * p0 + 1],
                coords[2 * pr], coords[2 * pr + 1],
                coords[2 * pl], coords[2 * pl + 1],
                coords[2 * p1], coords[2 * p1 + 1]);

            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;

                const hbl = halfedges[bl];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    } while (e !== this._hullStart);
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);

                const br = b0 + (b + 1) % 3;

                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) {
                    EDGE_STACK[i++] = br;
                }
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }

        return ar;
    }

    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }

    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;

        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;

        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);

        this.trianglesLen += 3;

        return t;
    }
}

// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}

// return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
function orientIfSure(px, py, rx, ry, qx, qy) {
    const l = (ry - py) * (qx - px);
    const r = (rx - px) * (qy - py);
    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
}

// a more robust orientation test that's stable in a given triangle (to fix robustness issues)
function orient(rx, ry, qx, qy, px, py) {
    return (orientIfSure(px, py, rx, ry, qx, qy) ||
        orientIfSure(rx, ry, qx, qy, px, py) ||
        orientIfSure(qx, qy, px, py, rx, ry)) < 0;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;

    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;

    return dx * (ey * cp - bp * fy) -
           dy * (ex * cp - bp * fx) +
           ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;

    return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;

    return {x, y};
}

function quicksort(ids, dists, left, right) {
    if (right - left <= 20) {
        for (let i = left + 1; i <= right; i++) {
            const temp = ids[i];
            const tempDist = dists[temp];
            let j = i - 1;
            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
            ids[j + 1] = temp;
        }
    } else {
        const median = (left + right) >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

        const temp = ids[i];
        const tempDist = dists[temp];
        while (true) {
            do i++; while (dists[ids[i]] < tempDist);
            do j--; while (dists[ids[j]] > tempDist);
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;

        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}

function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}

"use strict"
// from https://github.com/d3/d3-delaunay/blob/master/src/voronoi.js

class Voronoi {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
    this._init_from_dela();
  }
  /*update() {
    this.delaunay.update();
    this._init();
    return this;
  }*/
  _init_from_dela() { // see https://github.com/d3/d3-delaunay/blob/master/src/delaunay.js
    const {delaunay: {points, hull, triangles, halfedges}} = this;

    this.delaunay.inedges = this.inedges = new Int32Array(points.length / 2);
    this.delaunay._hullIndex = this._hullIndex = new Int32Array(points.length / 2);

    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);

    // Compute an index from each point to an (arbitrary) incoming halfedge
    // Used to give the first neighbor of each point; for this reason,
    // on the hull we give priority to exterior halfedges
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }    
  }
  _step_from_dela(i, x, y) {
    const { delaunay: {inedges, hull, _hullIndex, halfedges, triangles, points}} = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = (x - points[i * 2]) ** 2 + (y - points[i * 2 + 1]) ** 2;
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = (x - points[t * 2]) ** 2 + (y - points[t * 2 + 1]) ** 2;
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if ((x - points[e * 2]) ** 2 + (y - points[e * 2 + 1]) ** 2 < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c;
  }  

  _init() {
    const {delaunay: {points, hull, triangles}, vectors} = this;

    // Compute circumcenters.
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t1 = triangles[i] * 2;
      const t2 = triangles[i + 1] * 2;
      const t3 = triangles[i + 2] * 2;
      const x1 = points[t1];
      const y1 = points[t1 + 1];
      const x2 = points[t2];
      const y2 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];

      const dx = x2 - x1;
      const dy = y2 - y1;
      const ex = x3 - x1;
      const ey = y3 - y1;
      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;

      if (!ab) {
        // degenerate case (collinear diagram)
        x = (x1 + x3) / 2 - 1e8 * ey;
        y = (y1 + y3) / 2 + 1e8 * ex;
      }
      else if (Math.abs(ab) < 1e-8) {
        // almost equal points (degenerate triangle)
        x = (x1 + x3) / 2;
        y = (y1 + y3) / 2;
      } else {
        const d = 1 / ab;
        x = x1 + (ey * bl - dy * cl) * d;
        y = y1 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    }

    // Compute exterior cell rays.
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  /*render(context) {
    const buffer = context == null ? context = new Path : undefined;
    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
      if (p) this._renderSegment(x, y, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path : undefined;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }*/
  renderCell(i, context) {
    const buffer = context == null ? context = new Path : undefined;
    const points = this._clip(i);
    if (points === null) return;
    context.moveTo(points[0], points[1], i);
    let n = points.length;
    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
    for (let i = 2; i < n; i += 2) {
      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
        context.lineTo(points[i], points[i + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
/*  *cellPolygons() {
    const {delaunay: {points}} = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) yield cell;
    }
  }*/
  renderCells(context) {
    const {delaunay: {points}} = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      this.renderCell(i, context);
    }
  }
/*  cellPolygon(i) {
    const polygon = new Polygon;
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }*/
  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this._step_from_dela(i, x, y) === i;
  }
  _cell(i) {
    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
    const e0 = inedges[i];
    if (e0 === -1) return null; // coincident point
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    // degenerate case (1 valid point: return the box)
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const {vectors: V} = this;
    const v = i * 4;
    return V[v] || V[v + 1]
        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
        : this._clipFinite(i, points);
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);
        else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x, y, c = c0 || c1;
      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;
      switch (e0) {
        case 0b0101: e0 = 0b0100; continue; // top-left
        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
        case 0b0110: e0 = 0b0010; continue; // top-right
        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
        case 0b1010: e0 = 0b1000; continue; // bottom-right
        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
        case 0b1001: e0 = 0b0001; continue; // bottom-left
        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
      }
      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i = 0; i < P.length; i+= 2) {
        const j = (i + 2) % P.length, k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k]
        || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
          P.splice(j, 2), i -= 2;
      }
    }
    return j;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c, x, y;
    if (vy < 0) { // top
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) { // bottom
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }
    if (vx > 0) { // right
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) { // left
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }
    return [x, y];
  }
  _edgecode(x, y) {
    return (x === this.xmin ? 0b0001
        : x === this.xmax ? 0b0010 : 0b0000)
        | (y === this.ymin ? 0b0100
        : y === this.ymax ? 0b1000 : 0b0000);
  }
  _regioncode(x, y) {
    return (x < this.xmin ? 0b0001
        : x > this.xmax ? 0b0010 : 0b0000)
        | (y < this.ymin ? 0b0100
        : y > this.ymax ? 0b1000 : 0b0000);
  }
}
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.poly2tri = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={"version": "1.5.0"}
},{}],2:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;



},{}],4:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = require('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      // → "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      // → '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":11}],5:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = require('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":11}],6:[function(require,module,exports){
(function (global){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/**
 * Public API for poly2tri.js
 * @module poly2tri
 */


/**
 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
 * @name poly2tri
 * @global
 * @public
 * @type {module:poly2tri}
 */
var previousPoly2tri = global.poly2tri;
/**
 * For Browser + &lt;script&gt; :
 * reverts the {@linkcode poly2tri} global object to its previous value,
 * and returns a reference to the instance called.
 *
 * @example
 *              var p = poly2tri.noConflict();
 * @public
 * @return {module:poly2tri} instance called
 */
// (this feature is not automatically provided by browserify).
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

/**
 * poly2tri library version
 * @public
 * @const {string}
 */
exports.VERSION = require('../dist/version.json').version;

/**
 * Exports the {@linkcode PointError} class.
 * @public
 * @typedef {PointError} module:poly2tri.PointError
 * @function
 */
exports.PointError = require('./pointerror');
/**
 * Exports the {@linkcode Point} class.
 * @public
 * @typedef {Point} module:poly2tri.Point
 * @function
 */
exports.Point = require('./point');
/**
 * Exports the {@linkcode Triangle} class.
 * @public
 * @typedef {Triangle} module:poly2tri.Triangle
 * @function
 */
exports.Triangle = require('./triangle');
/**
 * Exports the {@linkcode SweepContext} class.
 * @public
 * @typedef {SweepContext} module:poly2tri.SweepContext
 * @function
 */
exports.SweepContext = require('./sweepcontext');


// Backward compatibility
var sweep = require('./sweep');
/**
 * @function
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 */
exports.triangulate = sweep.triangulate;
/**
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
 */
exports.sweep = {Triangulate: sweep.triangulate};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";

/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = require('./assert');
var PointError = require('./pointerror');
var Triangle = require('./triangle');
var Node = require('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = require('./utils');

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*π/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = require('./pointerror');
var Point = require('./point');
var Triangle = require('./triangle');
var sweep = require('./sweep');
var AdvancingFront = require('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = require("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":11}],10:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;


},{}],11:[function(require,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      // → "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      // → "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      // → "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[6])(6)
});
/*!
 * Paper.js v0.12.4 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2019, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Sun Dec 15 21:25:00 2019 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2019 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = function(self, undefined) {

self = self || require('./node/self.js');
var window = self.window,
	document = self.document;

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,
		array = [],
		slice = array.slice,
		create = Object.create,
		describe = Object.getOwnPropertyDescriptor,
		define = Object.defineProperty,

		forEach = array.forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++) {
				iter.call(bind, this[i], i, this);
			}
		},

		forIn = function(iter, bind) {
			for (var i in this) {
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
			}
		},

		set = Object.assign || function(dst) {
			for (var i = 1, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				for (var key in src) {
					if (src.hasOwnProperty(key))
						dst[key] = src[key];
				}
			}
			return dst;
		},

		each = function(obj, iter, bind) {
			if (obj) {
				var desc = describe(obj, 'length');
				(desc && typeof desc.value === 'number' ? forEach : forIn)
					.call(obj, iter, bind = bind || obj);
			}
			return bind;
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res)) {
					res = { value: res, writable: true };
				}
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable != null ? enumerable : !bean;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function Base() {
		for (var i = 0, l = arguments.length; i < l; i++) {
			var src = arguments[i];
			if (src)
				set(this, src);
		}
		return this;
	}

	return inject(Base, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, null, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, obj, l = arguments.length;
					i < l && !(ctor && proto); i++) {
				obj = arguments[i];
				ctor = ctor || obj.initialize;
				proto = proto || obj.prototype;
			}
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = proto || create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}).inject({
		enumerable: false,

		initialize: Base,

		set: Base,

		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src) {
					inject(this, src, src.enumerable, src.beans, src.preserve);
				}
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			set: set,
			each: each,
			create: create,
			define: define,
			describe: describe,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			},

			slice: function(list, begin, end) {
				return slice.call(list, begin, end);
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	enumerable: false,

	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	importJSON: function(json) {
		return Base.importJSON(json, this);
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	set: function(props, exclude) {
		if (props)
			Base.filter(this, props, exclude, this._prioritize);
		return this;
	}
}, {

beans: false,
statics: {
	exports: {},

	extend: function extend() {
		var res = extend.base.apply(this, arguments),
			name = res.prototype._class;
		if (name && !Base.exports[name])
			Base.exports[name] = res;
		return res;
	},

	equals: function(obj1, obj2) {
		if (obj1 === obj2)
			return true;
		if (obj1 && obj1.equals)
			return obj1.equals(obj2);
		if (obj2 && obj2.equals)
			return obj2.equals(obj1);
		if (obj1 && obj2
				&& typeof obj1 === 'object' && typeof obj2 === 'object') {
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				var length = obj1.length;
				if (length !== obj2.length)
					return false;
				while (length--) {
					if (!Base.equals(obj1[length], obj2[length]))
						return false;
				}
			} else {
				var keys = Object.keys(obj1),
					length = keys.length;
				if (length !== Object.keys(obj2).length)
					return false;
				while (length--) {
					var key = keys[length];
					if (!(obj2.hasOwnProperty(key)
							&& Base.equals(obj1[key], obj2[key])))
						return false;
				}
			}
			return true;
		}
		return false;
	},

	read: function(list, start, options, amount) {
		if (this === Base) {
			var value = this.peek(list, start);
			list.__index++;
			return value;
		}
		var proto = this.prototype,
			readIndex = proto._readIndex,
			begin = start || readIndex && list.__index || 0,
			length = list.length,
			obj = list[begin];
		amount = amount || length - begin;
		if (obj instanceof this
			|| options && options.readNull && obj == null && amount <= 1) {
			if (readIndex)
				list.__index = begin + 1;
			return obj && options && options.clone ? obj.clone() : obj;
		}
		obj = Base.create(proto);
		if (readIndex)
			obj.__read = true;
		obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length
				? Base.slice(list, begin, begin + amount)
				: list) || obj;
		if (readIndex) {
			list.__index = begin + obj.__read;
			var filtered = obj.__filtered;
			if (filtered) {
				list.__filtered = filtered;
				obj.__filtered = undefined;
			}
			obj.__read = undefined;
		}
		return obj;
	},

	peek: function(list, start) {
		return list[list.__index = start || list.__index || 0];
	},

	remain: function(list) {
		return list.length - (list.__index || 0);
	},

	readList: function(list, start, options, amount) {
		var res = [],
			entry,
			begin = start || 0,
			end = amount ? begin + amount : list.length;
		for (var i = begin; i < end; i++) {
			res.push(Array.isArray(entry = list[i])
					? this.read(entry, 0, options)
					: this.read(list, i, options, 1));
		}
		return res;
	},

	readNamed: function(list, name, start, options, amount) {
		var value = this.getNamed(list, name),
			hasValue = value !== undefined;
		if (hasValue) {
			var filtered = list.__filtered;
			if (!filtered) {
				var source = this.getSource(list);
				filtered = list.__filtered = Base.create(source);
				filtered.__unfiltered = source;
			}
			filtered[name] = undefined;
		}
		return this.read(hasValue ? [value] : list, start, options, amount);
	},

	readSupported: function(list, dest) {
		var source = this.getSource(list),
			that = this,
			read = false;
		if (source) {
			Object.keys(source).forEach(function(key) {
				if (key in dest) {
					var value = that.readNamed(list, key);
					if (value !== undefined) {
						dest[key] = value;
					}
					read = true;
				}
			});
		}
		return read;
	},

	getSource: function(list) {
		var source = list.__source;
		if (source === undefined) {
			var arg = list.length === 1 && list[0];
			source = list.__source = arg && Base.isPlainObject(arg)
				? arg : null;
		}
		return source;
	},

	getNamed: function(list, name) {
		var source = this.getSource(list);
		if (source) {
			return name ? source[name] : list.__filtered || source;
		}
	},

	hasNamed: function(list, name) {
		return !!this.getNamed(list, name);
	},

	filter: function(dest, source, exclude, prioritize) {
		var processed;

		function handleKey(key) {
			if (!(exclude && key in exclude) &&
				!(processed && key in processed)) {
				var value = source[key];
				if (value !== undefined)
					dest[key] = value;
			}
		}

		if (prioritize) {
			var keys = {};
			for (var i = 0, key, l = prioritize.length; i < l; i++) {
				if ((key = prioritize[i]) in source) {
					handleKey(key);
					keys[key] = true;
				}
			}
			processed = keys;
		}

		Object.keys(source.__unfiltered || source).forEach(handleKey);
		return dest;
	},

	isPlainValue: function(obj, asString) {
		return Base.isPlainObject(obj) || Array.isArray(obj)
				|| asString && typeof obj === 'string';
	},

	serialize: function(obj, options, compact, dictionary) {
		options = options || {};

		var isRoot = !dictionary,
			res;
		if (isRoot) {
			options.formatter = new Formatter(options.precision);
			dictionary = {
				length: 0,
				definitions: {},
				references: {},
				add: function(item, create) {
					var id = '#' + item._id,
						ref = this.references[id];
					if (!ref) {
						this.length++;
						var res = create.call(item),
							name = item._class;
						if (name && res[0] !== name)
							res.unshift(name);
						this.definitions[id] = res;
						ref = this.references[id] = [id];
					}
					return ref;
				}
			};
		}
		if (obj && obj._serialize) {
			res = obj._serialize(options, dictionary);
			var name = obj._class;
			if (name && !obj._compactSerialize && (isRoot || !compact)
					&& res[0] !== name) {
				res.unshift(name);
			}
		} else if (Array.isArray(obj)) {
			res = [];
			for (var i = 0, l = obj.length; i < l; i++)
				res[i] = Base.serialize(obj[i], options, compact, dictionary);
		} else if (Base.isPlainObject(obj)) {
			res = {};
			var keys = Object.keys(obj);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				res[key] = Base.serialize(obj[key], options, compact,
						dictionary);
			}
		} else if (typeof obj === 'number') {
			res = options.formatter.number(obj, options.precision);
		} else {
			res = obj;
		}
		return isRoot && dictionary.length > 0
				? [['dictionary', dictionary.definitions], res]
				: res;
	},

	deserialize: function(json, create, _data, _setDictionary, _isRoot) {
		var res = json,
			isFirst = !_data,
			hasDictionary = isFirst && json && json.length
				&& json[0][0] === 'dictionary';
		_data = _data || {};
		if (Array.isArray(json)) {
			var type = json[0],
				isDictionary = type === 'dictionary';
			if (json.length == 1 && /^#/.test(type)) {
				return _data.dictionary[type];
			}
			type = Base.exports[type];
			res = [];
			for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
				res.push(Base.deserialize(json[i], create, _data,
						isDictionary, hasDictionary));
			}
			if (type) {
				var args = res;
				if (create) {
					res = create(type, args, isFirst || _isRoot);
				} else {
					res = new type(args);
				}
			}
		} else if (Base.isPlainObject(json)) {
			res = {};
			if (_setDictionary)
				_data.dictionary = res;
			for (var key in json)
				res[key] = Base.deserialize(json[key], create, _data);
		}
		return hasDictionary ? res[1] : res;
	},

	exportJSON: function(obj, options) {
		var json = Base.serialize(obj, options);
		return options && options.asString == false
				? json
				: JSON.stringify(json);
	},

	importJSON: function(json, target) {
		return Base.deserialize(
				typeof json === 'string' ? JSON.parse(json) : json,
				function(ctor, args, isRoot) {
					var useTarget = isRoot && target
							&& target.constructor === ctor,
						obj = useTarget ? target
							: Base.create(ctor.prototype);
					if (args.length === 1 && obj instanceof Item
							&& (useTarget || !(obj instanceof Layer))) {
						var arg = args[0];
						if (Base.isPlainObject(arg)) {
							arg.insert = false;
							if (useTarget) {
								args = args.concat([{ insert: true }]);
							}
						}
					}
					(useTarget ? obj.set : ctor).apply(obj, args);
					if (useTarget)
						target = null;
					return obj;
				});
	},

	push: function(list, items) {
		var itemsLength = items.length;
		if (itemsLength < 4096) {
			list.push.apply(list, items);
		} else {
			var startLength = list.length;
			list.length += itemsLength;
			for (var i = 0; i < itemsLength; i++) {
				list[startLength + i] = items[i];
			}
		}
		return list;
	},

	splice: function(list, items, index, remove) {
		var amount = items && items.length,
			append = index === undefined;
		index = append ? list.length : index;
		if (index > list.length)
			index = list.length;
		for (var i = 0; i < amount; i++)
			items[i]._index = index + i;
		if (append) {
			Base.push(list, items);
			return [];
		} else {
			var args = [index, remove];
			if (items)
				Base.push(args, items);
			var removed = list.splice.apply(list, args);
			for (var i = 0, l = removed.length; i < l; i++)
				removed[i]._index = undefined;
			for (var i = index + amount, l = list.length; i < l; i++)
				list[i]._index = i;
			return removed;
		}
	},

	capitalize: function(str) {
		return str.replace(/\b[a-z]/g, function(match) {
			return match.toUpperCase();
		});
	},

	camelize: function(str) {
		return str.replace(/-(.)/g, function(match, chr) {
			return chr.toUpperCase();
		});
	},

	hyphenate: function(str) {
		return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	}
}});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function handler() {
			func.apply(this, arguments);
			this.off(type, handler);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = Base.slice(arguments, 1),
			setTarget = event && event.target && !event.currentTarget;
		handlers = handlers.slice();
		if (setTarget)
			event.currentTarget = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) == false) {
				if (event && event.stop)
					event.stop();
				break;
		   }
		}
		if (setTarget)
			delete event.currentTarget;
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var types = this._eventTypes,
			handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		if (types) {
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var entry = types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			insertItems: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1) || {};
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
		if (!this.agent) {
			var user = self.navigator.userAgent.toLowerCase(),
				os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],
				platform = os === 'darwin' ? 'mac' : os,
				agent = proto.agent = proto.browser = { platform: platform };
			if (platform)
				agent[platform] = true;
			user.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
				function(match, n, v1, v2, rv) {
					if (!agent.chrome) {
						var v = n === 'opera' ? v2 :
								/^(node|trident)$/.test(n) ? rv : v1;
						agent.version = v;
						agent.versionNumber = parseFloat(v);
						n = { trident: 'msie', jsdom: 'node' }[n] || n;
						agent.name = n;
						agent[n] = true;
					}
				}
			);
			if (agent.chrome)
				delete agent.webkit;
			if (agent.atom)
				delete agent.chrome;
		}
	},

	version: "0.12.4",

	getView: function() {
		var project = this.project;
		return project && project._view;
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, options) {
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	createCanvas: function(width, height) {
		return CanvasProvider.getCanvas(width, height);
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		var projects = this.projects,
			tools = this.tools;
		for (var i = projects.length - 1; i >= 0; i--)
			projects[i].remove();
		for (var i = tools.length - 1; i >= 0; i--)
			tools[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	},

	getView: function() {
		return this._scope.getView();
	}
});

var CollisionDetection = {
	findItemBoundsCollisions: function(items1, items2, tolerance) {
		function getBounds(items) {
			var bounds = new Array(items.length);
			for (var i = 0; i < items.length; i++) {
				var rect = items[i].getBounds();
				bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
			}
			return bounds;
		}

		var bounds1 = getBounds(items1),
			bounds2 = !items2 || items2 === items1
				? bounds1
				: getBounds(items2);
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {
		function getBounds(curves) {
			var min = Math.min,
				max = Math.max,
				bounds = new Array(curves.length);
			for (var i = 0; i < curves.length; i++) {
				var v = curves[i];
				bounds[i] = [
					min(v[0], v[2], v[4], v[6]),
					min(v[1], v[3], v[5], v[7]),
					max(v[0], v[2], v[4], v[6]),
					max(v[1], v[3], v[5], v[7])
				];
			}
			return bounds;
		}

		var bounds1 = getBounds(curves1),
			bounds2 = !curves2 || curves2 === curves1
				? bounds1
				: getBounds(curves2);
		if (bothAxis) {
			var hor = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, false, true),
				ver = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, true, true),
				list = [];
			for (var i = 0, l = hor.length; i < l; i++) {
				list[i] = { hor: hor[i], ver: ver[i] };
			}
			return list;
		}
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findBoundsCollisions: function(boundsA, boundsB, tolerance,
		sweepVertical, onlySweepAxisCollisions) {
		var self = !boundsB || boundsA === boundsB,
			allBounds = self ? boundsA : boundsA.concat(boundsB),
			lengthA = boundsA.length,
			lengthAll = allBounds.length;

		function binarySearch(indices, coord, value) {
			var lo = 0,
				hi = indices.length;
			while (lo < hi) {
				var mid = (hi + lo) >>> 1;
				if (allBounds[indices[mid]][coord] < value) {
					lo = mid + 1;
				} else {
					hi = mid;
				}
			}
			return lo - 1;
		}

		var pri0 = sweepVertical ? 1 : 0,
			pri1 = pri0 + 2,
			sec0 = sweepVertical ? 0 : 1,
			sec1 = sec0 + 2;
		var allIndicesByPri0 = new Array(lengthAll);
		for (var i = 0; i < lengthAll; i++) {
			allIndicesByPri0[i] = i;
		}
		allIndicesByPri0.sort(function(i1, i2) {
			return allBounds[i1][pri0] - allBounds[i2][pri0];
		});
		var activeIndicesByPri1 = [],
			allCollisions = new Array(lengthA);
		for (var i = 0; i < lengthAll; i++) {
			var curIndex = allIndicesByPri0[i],
				curBounds = allBounds[curIndex],
				origIndex = self ? curIndex : curIndex - lengthA,
				isCurrentA = curIndex < lengthA,
				isCurrentB = self || !isCurrentA,
				curCollisions = isCurrentA ? [] : null;
			if (activeIndicesByPri1.length) {
				var pruneCount = binarySearch(activeIndicesByPri1, pri1,
						curBounds[pri0] - tolerance) + 1;
				activeIndicesByPri1.splice(0, pruneCount);
				if (self && onlySweepAxisCollisions) {
					curCollisions = curCollisions.concat(activeIndicesByPri1);
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j];
						allCollisions[activeIndex].push(origIndex);
					}
				} else {
					var curSec1 = curBounds[sec1],
						curSec0 = curBounds[sec0];
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j],
							activeBounds = allBounds[activeIndex],
							isActiveA = activeIndex < lengthA,
							isActiveB = self || activeIndex >= lengthA;

						if (
							onlySweepAxisCollisions ||
							(
								isCurrentA && isActiveB ||
								isCurrentB && isActiveA
							) && (
								curSec1 >= activeBounds[sec0] - tolerance &&
								curSec0 <= activeBounds[sec1] + tolerance
							)
						) {
							if (isCurrentA && isActiveB) {
								curCollisions.push(
									self ? activeIndex : activeIndex - lengthA);
							}
							if (isCurrentB && isActiveA) {
								allCollisions[activeIndex].push(origIndex);
							}
						}
					}
				}
			}
			if (isCurrentA) {
				if (boundsA === boundsB) {
					curCollisions.push(curIndex);
				}
				allCollisions[curIndex] = curCollisions;
			}
			if (activeIndicesByPri1.length) {
				var curPri1 = curBounds[pri1],
					index = binarySearch(activeIndicesByPri1, pri1, curPri1);
				activeIndicesByPri1.splice(index + 1, 0, curIndex);
			} else {
				activeIndicesByPri1.push(curIndex);
			}
		}
		for (var i = 0; i < allCollisions.length; i++) {
			var collisions = allCollisions[i];
			if (collisions) {
				collisions.sort(function(i1, i2) { return i1 - i2; });
			}
		}
		return allCollisions;
	}
};

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = Base.pick(precision, 5);
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return this.precision < 16
				? Math.round(val * this.multiplier) / this.multiplier : val;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		log2 = Math.log2 || function(x) {
			return Math.log(x) * Math.LOG2E;
		},
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clamp(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	function getDiscriminant(a, b, c) {
		function split(v) {
			var x = v * 134217729,
				y = v - x,
				hi = y + x,
				lo = v - hi;
			return [hi, lo];
		}

		var D = b * b - a * c,
			E = b * b + a * c;
		if (abs(D) * 3 < E) {
			var ad = split(a),
				bd = split(b),
				cd = split(c),
				p = b * b,
				dp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],
				q = a * c,
				dq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])
						+ ad[1] * cd[1];
			D = (p - q) + (dp - dq);
		}
		return D;
	}

	function getNormalizationFactor() {
		var norm = Math.max.apply(Math, arguments);
		return norm && (norm < 1e-8 || norm > 1e8)
				? pow(2, -Math.round(log2(norm)))
				: 0;
	}

	return {
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 1e-8,
		GEOMETRIC_EPSILON: 1e-7,
		TRIGONOMETRIC_EPSILON: 1e-8,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		isMachineZero: function(val) {
			return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
		},

		clamp: clamp,

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance) {
					x = nx;
					break;
				}
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return clamp(x, a, b);
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var x1, x2 = Infinity;
			if (abs(a) < EPSILON) {
				if (abs(b) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / b;
			} else {
				b *= -0.5;
				var D = getDiscriminant(a, b, c);
				if (D && abs(D) < MACHINE_EPSILON) {
					var f = getNormalizationFactor(abs(a), abs(b), abs(c));
					if (f) {
						a *= f;
						b *= f;
						c *= f;
						D = getDiscriminant(a, b, c);
					}
				}
				if (D >= -MACHINE_EPSILON) {
					var Q = D < 0 ? 0 : sqrt(D),
						R = b + (b < 0 ? -Q : Q);
					if (R === 0) {
						x1 = c / a;
						x2 = -x1;
					} else {
						x1 = R / a;
						x2 = c / R;
					}
				}
			}
			var count = 0,
				boundless = min == null,
				minB = min - EPSILON,
				maxB = max + EPSILON;
			if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
				roots[count++] = boundless ? x1 : clamp(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
				roots[count++] = boundless ? x2 : clamp(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
				x, b1, c2, qd, q;
			if (f) {
				a *= f;
				b *= f;
				c *= f;
				d *= f;
			}

			function evaluate(x0) {
				x = x0;
				var tmp = a * x;
				b1 = tmp + b;
				c2 = b1 * x + c;
				qd = (tmp + b1) * x + c2;
				q = c2 * x + d;
			}

			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				evaluate(-(b / a) / 3);
				var t = q / a,
					r = pow(abs(t), 1/3),
					s = t < 0 ? -1 : 1,
					td = -qd / a,
					rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
					x0 = x - s * rd;
				if (x0 !== x) {
					do {
						evaluate(x0);
						x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
				boundless = min == null;
			if (isFinite(x) && (count === 0
					|| count > 0 && x !== roots[0] && x !== roots[1])
					&& (boundless || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = boundless ? x : clamp(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(name) {
		if (name) {
			var pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this._set(arg0, hasY ? arg1 : arg0);
			if (reading)
				read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('angle' in obj) {
				this._set(obj.length || 0, 0);
				this.setAngle(obj.angle || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this._set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var args = arguments,
			point = Point.read(args),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(args);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var args = arguments,
			point = Point.read(args),
			tolerance = Base.read(args);
		return this.getDistance(point) <= tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.x) && isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	isInQuadrant: function(q) {
		return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0
			&& this.y * (q > 2 ? -1 : 1) >= 0;
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		return this._setter === 'setPosition' ? 4 : 0;
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this._set(arg0, hasHeight ? arg1 : arg0);
			if (reading)
				read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.width) && isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var args = arguments,
			type = typeof arg0,
			read;
		if (type === 'number') {
			this._set(arg0, arg1, arg2, arg3);
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0, 0, 0);
			read = arg0 === null ? 1 : 0;
		} else if (args.length === 1) {
			if (Array.isArray(arg0)) {
				this._set.apply(this, arg0);
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this._set(arg0.x || 0, arg0.y || 0,
						arg0.width || 0, arg0.height || 0);
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this._set(0, 0, 0, 0);
				if (Base.readSupported(args, this)) {
					read = 1;
				}
			}
		}
		if (read === undefined) {
			var frm = Point.readNamed(args, 'from'),
				next = Base.peek(args),
				x = frm.x,
				y = frm.y,
				width,
				height;
			if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
				var to = Point.readNamed(args, 'to');
				width = to.x - x;
				height = to.y - y;
				if (width < 0) {
					x = to.x;
					width = -width;
				}
				if (height < 0) {
					y = to.y;
					height = -height;
				}
			} else {
				var size = Size.read(args);
				width = size.width;
				height = size.height;
			}
			this._set(x, y, width, height);
			read = args.__index;
		}
		var filtered = args.__filtered;
		if (filtered)
			this.__filtered = filtered;
		if (this.__read)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	_fw: 1,
	_fh: 1,

	setSize: function() {
		var size = Size.read(arguments),
			sx = this._sx,
			sy = this._sy,
			w = size.width,
			h = size.height;
		if (sx) {
			this.x += (this.width - w) * sx;
		}
		if (sy) {
			this.y += (this.height - h) * sy;
		}
		this.width = w;
		this.height = h;
		this._fw = this._fh = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fw) {
			var amount = left - this.x;
			this.width -= this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = left;
		this._sx = this._fw = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fh) {
			var amount = top - this.y;
			this.height -= this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = top;
		this._sy = this._fh = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (!this._fw) {
			var amount = right - this.x;
			this.width = this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = right - this.width;
		this._sx = 1;
		this._fw = 0;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (!this._fh) {
			var amount = bottom - this.y;
			this.height = this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = bottom - this.height;
		this._sy = 1;
		this._fh = 0;
	},

	getCenterX: function() {
		return this.x + this.width / 2;
	},

	setCenterX: function(x) {
		if (this._fw || this._sx === 0.5) {
			this.x = x - this.width / 2;
		} else {
			if (this._sx) {
				this.x += (x - this.x) * 2 * this._sx;
			}
			this.width = (x - this.x) * 2;
		}
		this._sx = 0.5;
		this._fw = 0;
	},

	getCenterY: function() {
		return this.y + this.height / 2;
	},

	setCenterY: function(y) {
		if (this._fh || this._sy === 0.5) {
			this.y = y - this.height / 2;
		} else {
			if (this._sy) {
				this.y += (y - this.y) * 2 * this._sy;
			}
			this.height = (y - this.y) * 2;
		}
		this._sy = 0.5;
		this._fh = 0;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length === 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments),
			epsilon = Base.read(arguments) || 0;
		return rect.x + rect.width > this.x - epsilon
				&& rect.y + rect.height > this.y - epsilon
				&& rect.x < this.x + this.width + epsilon
				&& rect.y < this.y + this.height + epsilon;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join(''),
			xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this._set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key),
			internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return !!(this._owner._selection & 2);
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner._changeSelection) {
					owner._changeSelection(2, selected);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg, _dontNotify) {
		var args = arguments,
			count = args.length,
			ok = true;
		if (count >= 6) {
			this._set.apply(this, args);
		} else if (count === 1 || count === 2) {
			if (arg instanceof Matrix) {
				this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,
						_dontNotify);
			} else if (Array.isArray(arg)) {
				this._set.apply(this,
						_dontNotify ? arg.concat([_dontNotify]) : arg);
			} else {
				ok = false;
			}
		} else if (!count) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok) {
			throw new Error('Unsupported matrix parameters');
		}
		return this;
	},

	set: '#initialize',

	_set: function(a, b, c, d, tx, ty, _dontNotify) {
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.getValues(), options, true, dictionary);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(25);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._b, this._c, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._c),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._b), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._b = this._c = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._c;
		this._ty += x * this._b + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var args = arguments,
			scale = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._b *= scale.x;
		this._c *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * c;
		this._b = cos * b + sin * d;
		this._c = -sin * a + cos * c;
		this._d = -sin * b + cos * d;
		this._tx += tx * a + ty * c;
		this._ty += tx * b + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var args = arguments,
			shear = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			b = this._b;
		this._a += shear.y * this._c;
		this._b += shear.y * this._d;
		this._c += shear.x * a;
		this._d += shear.x * b;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var args = arguments,
			skew = Point.read(args),
			center = Point.read(args, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	append: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * c1;
			this._c = b2 * a1 + d2 * c1;
			this._b = a2 * b1 + c2 * d1;
			this._d = b2 * b1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * c1;
			this._ty += tx2 * b1 + ty2 * d1;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	prepend: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * b1;
			this._c = a2 * c1 + b2 * d1;
			this._b = c2 * a1 + d2 * b1;
			this._d = c2 * c1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	appended: function(mx) {
		return this.clone().append(mx);
	},

	prepended: function(mx) {
		return this.clone().prepend(mx);
	},

	invert: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			this._a = d / det;
			this._b = -b / det;
			this._c = -c / det;
			this._d = a / det;
			this._tx = (c * ty - d * tx) / det;
			this._ty = (b * tx - a * ty) / det;
			res = this;
		}
		return res;
	},

	inverted: function() {
		return this.clone().invert();
	},

	concatenate: '#append',
	preConcatenate: '#prepend',
	chain: '#appended',

	_shiftless: function() {
		return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
	},

	_orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isIdentity: function() {
		return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	isInvertible: function() {
		var det = this._a * this._d - this._c * this._b;
		return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
	},

	isSingular: function() {
		return !this.isInvertible();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest._set(
				x * this._a + y * this._c + this._tx,
				x * this._b + y * this._d + this._ty,
				_dontNotify);
	},

	_transformCoordinates: function(src, dst, count) {
		for (var i = 0, max = 2 * count; i < max; i += 2) {
			var x = src[i],
				y = src[i + 1];
			dst[i] = x * this._a + y * this._c + this._tx;
			dst[i + 1] = x * this._b + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j]) {
				min[j] = val;
			} else if (val > max[j]) {
				max[j] = val;
			}
		}
		if (!dest)
			dest = new Rectangle();
		return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			res = dest._set(
					(x * d - y * c) / det,
					(y * a - x * b) / det,
					_dontNotify);
		}
		return res;
	},

	decompose: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			det = a * d - b * c,
			sqrt = Math.sqrt,
			atan2 = Math.atan2,
			degrees = 180 / Math.PI,
			rotate,
			scale,
			skew;
		if (a !== 0 || b !== 0) {
			var r = sqrt(a * a + b * b);
			rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
			scale = [r, det / r];
			skew = [atan2(a * c + b * d, r * r), 0];
		} else if (c !== 0 || d !== 0) {
			var s = sqrt(c * c + d * d);
			rotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);
			scale = [det / s, s];
			skew = [0, atan2(a * c + b * d, s * s)];
		} else {
			rotate = 0;
			skew = scale = [0, 0];
		}
		return {
			translation: this.getTranslation(),
			rotation: rotate * degrees,
			scaling: new Point(scale),
			skewing: new Point(skew[0] * degrees, skew[1] * degrees)
		};
	},

	getValues: function() {
		return [ this._a, this._b, this._c, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return this.decompose().scaling;
	},

	getRotation: function() {
		return this.decompose().rotation;
	},

	applyToContext: function(ctx) {
		if (!this.isIdentity()) {
			ctx.transform(this._a, this._b, this._c, this._d,
					this._tx, this._ty);
		}
	}
}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {
	var part = Base.capitalize(key),
		prop = '_' + key;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(this.getSignedDistance(point));
	},

	getSignedDistance: function(point) {
		return Line.getSignedDistance(this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isMachineZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (!isInfinite && Numerical.isMachineZero(ccw)) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			  return  vx === 0 ? (vy > 0 ? x - px : px - x)
					: vy === 0 ? (vx < 0 ? y - py : py - y)
					: ((x - px) * vy - (y - py) * vx) / (
						vy > vx
							? vy * Math.sqrt(1 + (vx * vx) / (vy * vy))
							: vx * Math.sqrt(1 + (vy * vy) / (vx * vx))
					);
		},

		getDistance: function(px, py, vx, vy, x, y, asVector) {
			return Math.abs(
					Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',
	_compactSerialize: true,

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this._children = [];
		this._namedChildren = {};
		this._activeLayer = null;
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectionItems = {};
		this._selectionCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this._children, options, true, dictionary);
	},

	_changed: function(flags, item) {
		if (flags & 1) {
			var view = this._view;
			if (view) {
				view._needsUpdate = true;
				if (!view._requested && view._autoUpdate)
					view.requestUpdate();
			}
		}
		var changes = this._changes;
		if (changes && item) {
			var changesById = this._changesById,
				id = item._id,
				entry = changesById[id];
			if (entry) {
				entry.flags |= flags;
			} else {
				changes.push(changesById[id] = { item: item, flags: flags });
			}
		}
	},

	clear: function() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--)
			children[i].remove();
	},

	isEmpty: function() {
		return !this._children.length;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.set(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getLayers: function() {
		return this._children;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this, insert: true });
	},

	getSymbolDefinitions: function() {
		var definitions = [],
			ids = {};
		this.getItems({
			class: SymbolItem,
			match: function(item) {
				var definition = item._definition,
					id = definition._id;
				if (!ids[id]) {
					ids[id] = true;
					definitions.push(definition);
				}
				return false;
			}
		});
		return definitions;
	},

	getSymbols: 'getSymbolDefinitions',

	getSelectedItems: function() {
		var selectionItems = this._selectionItems,
			items = [];
		for (var id in selectionItems) {
			var item = selectionItems[id],
				selection = item._selection;
			if ((selection & 1) && item.isInserted()) {
				items.push(item);
			} else if (!selection) {
				this._updateSelection(item);
			}
		}
		return items;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectionItems = this._selectionItems;
		if (item._selection) {
			if (selectionItems[id] !== item) {
				this._selectionCount++;
				selectionItems[id] = item;
			}
		} else if (selectionItems[id] === item) {
			this._selectionCount--;
			delete selectionItems[id];
		}
	},

	selectAll: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectionItems = this._selectionItems;
		for (var i in selectionItems)
			selectionItems[i].setFullySelected(false);
	},

	addLayer: function(layer) {
		return this.insertLayer(undefined, layer);
	},

	insertLayer: function(index, layer) {
		if (layer instanceof Layer) {
			layer._remove(false, true);
			Base.splice(this._children, [layer], index, 0);
			layer._setProject(this, true);
			var name = layer._name;
			if (name)
				layer.setName(name);
			if (this._changes)
				layer._changed(5);
			if (!this._activeLayer)
				this._activeLayer = layer;
		} else {
			layer = null;
		}
		return layer;
	},

	_insertItem: function(index, item, _created) {
		item = this.insertLayer(index, item)
				|| (this._activeLayer || this._insertItem(undefined,
						new Layer(Item.NO_INSERT), true))
						.insertChild(index, item);
		if (_created && item.activate)
			item.activate();
		return item;
	},

	getItems: function(options) {
		return Item._getItems(this, options);
	},

	getItem: function(options) {
		return Item._getItems(this, options, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	removeOn: function(type) {
		var sets = this._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var children = this._children,
			param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].draw(ctx, param);
		}
		ctx.restore();

		if (this._selectionCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectionItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items) {
				items[id]._drawSelection(ctx, matrix, size, items, version);
			}
			ctx.restore();
		}
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = Base.set({},
					this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_name: null,
	_applyMatrix: true,
	_canApplyMatrix: true,
	_canScaleStroke: false,
	_pivot: null,
	_visible: true,
	_blendMode: 'normal',
	_opacity: 1,
	_locked: false,
	_guide: false,
	_clipMask: false,
	_selection: 0,
	_selectBounds: true,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		locked: false,
		guide: false,
		clipMask: false,
		selected: false,
		data: {}
	},
	_prioritize: ['applyMatrix']
},
new function() {
	var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
	return Base.each(handlers,
		function(name) {
			this._events[name] = {
				install: function(type) {
					this.getView()._countItemEvent(type, 1);
				},

				uninstall: function(type) {
					this.getView()._countItemEvent(type, -1);
				}
			};
		}, {
			_events: {
				onFrame: {
					install: function() {
						this.getView()._animateItem(this, true);
					},

					uninstall: function() {
						this.getView()._animateItem(this, false);
					}
				},

				onLoad: {},
				onError: {}
			},
			statics: {
				_itemHandlers: handlers
			}
		}
	);
}, {
	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project,
			settings = paper.settings;
		this._id = internal ? null : UID.get();
		this._parent = this._index = null;
		this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (internal || hasProps && props.insert == false
			|| !settings.insertItems && !(hasProps && props.insert === true)) {
			this._setProject(project);
		} else {
			(hasProps && props.parent || project)
					._insertItem(undefined, this, true);
		}
		if (hasProps && props !== Item.NO_INSERT) {
			this.set(props, {
				internal: true, insert: true, project: true, parent: true
			});
		}
		return hasProps;
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._symbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed = undefined;
		}
		if (flags & 16) {
			this._globalMatrix = undefined;
		}
		if (cacheParent
				&& (flags & 72)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project)
			project._changed(flags, this);
		if (symbol)
			symbol._changed(flags);
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var owner = this._getOwner();
		if (name && owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren;
			(namedChildren[name] = namedChildren[name] || []).push(this);
			if (!(name in children))
				children[name] = this;
		}
		this._name = name || undefined;
		this._changed(256);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			key = '_' + name,
			flags = {
				locked: 256,
				visible: 265
			};
		this['get' + part] = function() {
			return this[key];
		};
		this['set' + part] = function(value) {
			if (value != this[key]) {
				this[key] = value;
				this._changed(flags[name] || 257);
			}
		};
	},
{}), {
	beans: true,

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		if (selection !== this._selection) {
			this._selection = selection;
			var project = this._project;
			if (project) {
				project._updateSelection(this);
				this._changed(257);
			}
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return !!(this._selection & 1);
	},

	setSelected: function(selected) {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isFullySelected: function() {
		var children = this._children,
			selected = !!(this._selection & 1);
		if (children && selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(257);
			if (this._parent)
				this._parent._changed(2048);
		}
	},

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		var position = this._position ||
			(this._position = this._getPositionFromBounds());
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	_getPositionFromBounds: function(bounds) {
		return this._pivot
				? this._matrix._transformPoint(this._pivot)
				: (bounds || this.getBounds()).getCenter(true);
	},

	getPivot: function() {
		var pivot = this._pivot;
		return pivot
				? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')
				: null;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	}
}, Base.each({
		getStrokeBounds: { stroke: true },
		getHandleBounds: { handle: true },
		getInternalBounds: { internal: true }
	},
	function(options, key) {
		this[key] = function(matrix) {
			return this.getBounds(matrix, options);
		};
	},
{
	beans: true,

	getBounds: function(matrix, options) {
		var hasMatrix = options || matrix instanceof Matrix,
			opts = Base.set({}, hasMatrix ? options : matrix,
					this._boundsOptions);
		if (!opts.stroke || this.getStrokeScaling())
			opts.cacheItem = this;
		var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
		return !arguments.length
				? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,
					this, 'setBounds')
				: rect;
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			_matrix = this._matrix,
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			if (!_matrix.isInvertible()) {
				_matrix.set(_matrix._backup
						|| new Matrix().translate(_matrix.getTranslation()));
				bounds = this.getBounds();
			}
			matrix.scale(
					bounds.width !== 0 ? rect.width / bounds.width : 0,
					bounds.height !== 0 ? rect.height / bounds.height : 0);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getBounds: function(matrix, options) {
		var children = this._children;
		if (!children || !children.length)
			return new Rectangle();
		Item._updateBoundsCache(this, options.cacheItem);
		return Item._getBounds(children, matrix, options);
	},

	_getBoundsCacheKey: function(options, internal) {
		return [
			options.stroke ? 1 : 0,
			options.handle ? 1 : 0,
			internal ? 1 : 0
		].join('');
	},

	_getCachedBounds: function(matrix, options, noInternal) {
		matrix = matrix && matrix._orNullIfIdentity();
		var internal = options.internal && !noInternal,
			cacheItem = options.cacheItem,
			_matrix = internal ? null : this._matrix._orNullIfIdentity(),
			cacheKey = cacheItem && (!matrix || matrix.equals(_matrix))
				&& this._getBoundsCacheKey(options, internal),
			bounds = this._bounds;
		Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
		if (cacheKey && bounds && cacheKey in bounds) {
			var cached = bounds[cacheKey];
			return {
				rect: cached.rect.clone(),
				nonscaling: cached.nonscaling
			};
		}
		var res = this._getBounds(matrix || _matrix, options),
			rect = res.rect || res,
			style = this._style,
			nonscaling = res.nonscaling || style.hasStroke()
				&& !style.getStrokeScaling();
		if (cacheKey) {
			if (!bounds) {
				this._bounds = bounds = {};
			}
			var cached = bounds[cacheKey] = {
				rect: rect.clone(),
				nonscaling: nonscaling,
				internal: internal
			};
		}
		return {
			rect: rect,
			nonscaling: nonscaling
		};
	},

	_getStrokeMatrix: function(matrix, options) {
		var parent = this.getStrokeScaling() ? null
				: options && options.internal ? this
					: this._parent || this._symbol && this._symbol._item,
			mx = parent ? parent.getViewMatrix().invert() : matrix;
		return mx && mx._shiftless();
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent && item) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		},

		_getBounds: function(items, matrix, options) {
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2,
				nonscaling = false;
			options = options || {};
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				if (item._visible && !item.isEmpty(true)) {
					var bounds = item._getCachedBounds(
						matrix && matrix.appended(item._matrix), options, true),
						rect = bounds.rect;
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
					if (bounds.nonscaling)
						nonscaling = true;
				}
			}
			return {
				rect: isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle(),
				nonscaling: nonscaling
			};
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._applyMatrix
			? null
			: this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	getRotation: function() {
		var decomposed = this._decompose();
		return decomposed ? decomposed.rotation : 0;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			if (decomposed) {
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		}
	},

	getScaling: function() {
		var decomposed = this._decompose(),
			s = decomposed && decomposed.scaling;
		return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling && !current.equals(scaling)) {
			var rotation = this.getRotation(),
				decomposed = this._decomposed,
				matrix = new Matrix(),
				center = this.getPosition(true);
			matrix.translate(center);
			if (rotation)
				matrix.rotate(rotation);
			matrix.scale(scaling.x / current.x, scaling.y / current.y);
			if (rotation)
				matrix.rotate(-rotation);
			matrix.translate(center.negate());
			this.transform(matrix);
			if (decomposed) {
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix;
		if (matrix) {
			var parent = this._parent;
			var parents = [];
			while (parent) {
				if (!parent._globalMatrix) {
					matrix = null;
					for (var i = 0, l = parents.length; i < l; i++) {
						parents[i]._globalMatrix = null;
					}
					break;
				}
				parents.push(parent);
				parent = parent._parent;
			}
		}
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.prepend(parent.getGlobalMatrix(true));
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getViewMatrix: function() {
		return this.getGlobalMatrix().prepend(this.getView()._matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project._view;
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	_getOwner: '#getParent',

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(options) {
		var copy = new this.constructor(Item.NO_INSERT),
			children = this._children,
			insert = Base.pick(options ? options.insert : undefined,
					options === undefined || options === true),
			deep = Base.pick(options ? options.deep : undefined, true);
		if (children)
			copy.copyAttributes(this);
		if (!children || deep)
			copy.copyContent(this);
		if (!children)
			copy.copyAttributes(this);
		if (insert)
			copy.insertAbove(this);
		var name = this._name,
			parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				orig = name,
				i = 1;
			while (children[name])
				name = orig + ' ' + (i++);
			if (name !== orig)
				copy.setName(name);
		}
		return copy;
	},

	copyContent: function(source) {
		var children = source._children;
		for (var i = 0, l = children && children.length; i < l; i++) {
			this.addChild(children[i].clone(false), true);
		}
	},

	copyAttributes: function(source, excludeMatrix) {
		this.setStyle(source._style);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (source.hasOwnProperty(key))
				this[key] = source[key];
		}
		if (!excludeMatrix)
			this._matrix.set(source._matrix, true);
		this.setApplyMatrix(source._applyMatrix);
		this.setPivot(source._pivot);
		this.setSelection(source._selection);
		var data = source._data,
			name = source._name;
		this._data = data ? Base.clone(data) : null;
		if (name)
			this.setName(name);
	},

	rasterize: function(resolution, insert) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			raster = new Raster(Item.NO_INSERT);
		if (!size.isZero()) {
			var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
				ctx = canvas.getContext('2d'),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
			raster.setCanvas(canvas);
		}
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		if (insert === undefined || insert)
			raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		var matrix = this._matrix;
		return (
			matrix.isInvertible() &&
			!!this._contains(matrix._inverseTransform(Point.read(arguments)))
		);
	},

	_contains: function(point) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				if (children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix, true).length > 0;
	}
},
new function() {
	function hitTest() {
		var args = arguments;
		return this._hitTest(
				Point.read(args),
				HitResult.getOptions(args));
	}

	function hitTestAll() {
		var args = arguments,
			point = Point.read(args),
			options = HitResult.getOptions(args),
			all = [];
		this._hitTest(point, new Base({ all: all }, options));
		return all;
	}

	function hitTestChildren(point, options, viewMatrix, _exclude) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				var child = children[i];
				var res = child !== _exclude && child._hitTest(point, options,
						viewMatrix);
				if (res && !options.all)
					return res;
			}
		}
		return null;
	}

	Project.inject({
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTest: hitTestChildren
	});

	return {
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTestChildren: hitTestChildren,
	};
}, {

	_hitTest: function(point, options, parentViewMatrix) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty()) {
			return null;
		}

		var matrix = this._matrix,
			viewMatrix = parentViewMatrix
					? parentViewMatrix.appended(matrix)
					: this.getGlobalMatrix().prepend(this.getView()._matrix),
			tolerance = Math.max(options.tolerance, 1e-12),
			tolerancePadding = options._tolerancePadding = new Size(
					Path._getStrokePadding(tolerance,
						matrix._shiftless().invert()));
		point = matrix._inverseTransform(point);
		if (!point || !this._children &&
			!this.getBounds({ internal: true, stroke: true, handle: true })
				.expand(tolerancePadding.multiply(2))._containsPoint(point)) {
			return null;
		}

		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this.isSelected()
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			match = options.match,
			that = this,
			bounds,
			res;

		function filter(hit) {
			if (hit && match && !match(hit))
				hit = null;
			if (hit && options.all)
				options.all.push(hit);
			return hit;
		}

		function checkPoint(type, part) {
			var pt = part ? bounds['get' + part]() : that.getPosition();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
				return new HitResult(type, that, {
					name: part ? Base.hyphenate(part) : type,
					point: pt
				});
			}
		}

		var checkPosition = options.position,
			checkCenter = options.center,
			checkBounds = options.bounds;
		if (checkSelf && this._parent
				&& (checkPosition || checkCenter || checkBounds)) {
			if (checkCenter || checkBounds) {
				bounds = this.getInternalBounds();
			}
			res = checkPosition && checkPoint('position') ||
					checkCenter && checkPoint('center', 'Center');
			if (!res && checkBounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++) {
					res = checkPoint('bounds', points[i]);
				}
			}
			res = filter(res);
		}

		if (!res) {
			res = this._hitTestChildren(point, options, viewMatrix)
				|| checkSelf
					&& filter(this._hitTestSelf(point, options, viewMatrix,
						this.getStrokeScaling() ? null
							: viewMatrix._shiftless().invert()))
				|| null;
		}
		if (res && res.point) {
			res.point = matrix.transform(res.point);
		}
		return res;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
			return true;
		} else if (type === 'function') {
			return name(this);
		} else if (name === 'match') {
			return compare(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (name === 'class') {
				if (typeof compare === 'function')
					return this instanceof compare;
				value = this._class;
			}
			if (typeof compare === 'function') {
				return !!compare(value);
			} else if (compare) {
				if (compare.test) {
					return compare.test(value);
				} else if (Base.isPlainObject(compare)) {
					return matchObject(compare, value);
				}
			}
			return Base.equals(value, compare);
		}
	},

	getItems: function(options) {
		return Item._getItems(this, options, this._matrix);
	},

	getItem: function(options) {
		return Item._getItems(this, options, this._matrix, null, true)[0]
				|| null;
	},

	statics: {
		_getItems: function _getItems(item, options, matrix, param, firstOnly) {
			if (!param) {
				var obj = typeof options === 'object' && options,
					overlapping = obj && obj.overlapping,
					inside = obj && obj.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					recursive: obj && obj.recursive !== false,
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (obj) {
					options = Base.filter({}, options, {
						recursive: true, inside: true, overlapping: true
					});
				}
			}
			var children = item._children,
				items = param.items,
				rect = param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.appended(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(rect.contains(bounds)
							|| param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(options)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				if (param.recursive !== false) {
					_getItems(child, options, childMatrix, param, firstOnly);
				}
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this ? this.addChild(res) : res;
	},

	addChild: function(item) {
		return this.insertChild(undefined, item);
	},

	insertChild: function(index, item) {
		var res = item ? this.insertChildren(index, [item]) : null;
		return res && res[0];
	},

	addChildren: function(items) {
		return this.insertChildren(this._children.length, items);
	},

	insertChildren: function(index, items) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Base.slice(items);
			var inserted = {};
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i],
					id = item && item._id;
				if (!item || inserted[id]) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
					inserted[id] = true;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i],
					name = item._name;
				item._parent = this;
				item._setProject(project, true);
				if (name)
					item.setName(name);
				if (notifySelf)
					item._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertItem: '#insertChild',

	_insertAt: function(item, offset) {
		var owner = item && item._getOwner(),
			res = item !== this && owner ? this : null;
		if (res) {
			res._remove(false, true);
			owner._insertItem(item._index + offset, res);
		}
		return res;
	},

	insertAbove: function(item) {
		return this._insertAt(item, 1);
	},

	insertBelow: function(item) {
		return this._insertAt(item, 0);
	},

	sendToBack: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(0, this) : null;
	},

	bringToFront: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(undefined, this) : null;
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	addTo: function(owner) {
		return owner._insertItem(undefined, this);
	},

	copyTo: function(owner) {
		return this.clone(false).addTo(owner);
	},

	reduce: function(options) {
		var children = this._children;
		if (children && children.length === 1) {
			var child = children[0].reduce(options);
			if (this._parent) {
				child.insertAbove(this);
				this.remove();
			} else {
				child.remove();
			}
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var owner = this._getOwner();
		if (owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[0];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var owner = this._getOwner(),
			project = this._project,
			index = this._index;
		if (this._style)
			this._style._dispose();
		if (owner) {
			if (this._name)
				this._removeNamed();
			if (index != null) {
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(owner._children, null, index, 1);
			}
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent)
				owner._changed(11, this);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(start, end) {
		if (!this._children)
			return null;
		start = start || 0;
		end = Base.pick(end, this._children.length);
		var removed = Base.splice(this._children, null, start, end - start);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function(recursively) {
		var children = this._children;
		var numChildren = children ? children.length : 0;
		if (recursively) {
			for (var i = 0; i < numChildren; i++) {
				if (!children[i].isEmpty(recursively)) {
					return false;
				}
			}
			return true;
		}
		return !numChildren;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent === item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getPosition(true)));
	};
}, {
	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	transform: function(matrix, _applyRecursively, _setApplyMatrix) {
		var _matrix = this._matrix,
			transformMatrix = matrix && !matrix.isIdentity(),
			applyMatrix = (
				_setApplyMatrix && this._canApplyMatrix ||
				this._applyMatrix && (
					transformMatrix || !_matrix.isIdentity() ||
					_applyRecursively && this._children
				)
			);
		if (!transformMatrix && !applyMatrix)
			return this;
		if (transformMatrix) {
			if (!matrix.isInvertible() && _matrix.isInvertible())
				_matrix._backup = _matrix.getValues();
			_matrix.prepend(matrix, true);
			var style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (fillColor)
				fillColor.transform(matrix);
			if (strokeColor)
				strokeColor.transform(matrix);
		}

		if (applyMatrix && (applyMatrix = this._transformContent(
				_matrix, _applyRecursively, _setApplyMatrix))) {
			var pivot = this._pivot;
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		if (transformMatrix || applyMatrix) {
			this._changed(25);
		}
		var decomp = transformMatrix && bounds && matrix.decompose();
		if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var cache = bounds[key];
				if (cache.nonscaling) {
					delete bounds[key];
				} else if (applyMatrix || !cache.internal) {
					var rect = cache.rect;
					matrix._transformBounds(rect, rect);
				}
			}
			this._bounds = bounds;
			var cached = bounds[this._getBoundsCacheKey(
				this._boundsOptions || {})];
			if (cached) {
				this._position = this._getPositionFromBounds(cached.rect);
			}
		} else if (transformMatrix && position && this._pivot) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++) {
				children[i].transform(matrix, applyRecursively, setApplyMatrix);
			}
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	}
}), {

	_setStyles: function(ctx, param, viewMatrix) {
		var style = this._style,
			matrix = this._matrix;
		if (style.hasFill()) {
			ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
		}
		if (style.hasStroke()) {
			ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
			ctx.lineWidth = style.getStrokeWidth();
			var strokeJoin = style.getStrokeJoin(),
				strokeCap = style.getStrokeCap(),
				miterLimit = style.getMiterLimit();
			if (strokeJoin)
				ctx.lineJoin = strokeJoin;
			if (strokeCap)
				ctx.lineCap = strokeCap;
			if (miterLimit)
				ctx.miterLimit = miterLimit;
			if (paper.support.nativeDash) {
				var dashArray = style.getDashArray(),
					dashOffset = style.getDashOffset();
				if (dashArray && dashArray.length) {
					if ('setLineDash' in ctx) {
						ctx.setLineDash(dashArray);
						ctx.lineDashOffset = dashOffset;
					} else {
						ctx.mozDash = dashArray;
						ctx.mozDashOffset = dashOffset;
					}
				}
			}
		}
		if (style.hasShadow()) {
			var pixelRatio = param.pixelRatio || 1,
				mx = viewMatrix._shiftless().prepend(
					new Matrix().scale(pixelRatio, pixelRatio)),
				blur = mx.transform(new Point(style.getShadowBlur(), 0)),
				offset = mx.transform(this.getShadowOffset());
			ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
			ctx.shadowBlur = blur.getLength();
			ctx.shadowOffsetX = offset.x;
			ctx.shadowOffsetY = offset.y;
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].appended(matrix);
		if (!globalMatrix.isInvertible())
			return;

		viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)
				: globalMatrix;

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(viewMatrix);
			if (!bounds.width || !bounds.height) {
				matrices.pop();
				return;
			}
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.appended(matrix)
				: this._canScaleStroke && !this.getStrokeScaling(true)
					&& viewMatrix,
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform) {
			(direct ? matrix : viewMatrix).applyToContext(ctx);
		}
		if (clip) {
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, viewMatrix, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish) {
			ctx.clip(this.getFillRule());
		}
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
		var selection = this._selection,
			itemSelected = selection & 1,
			boundsSelected = selection & 2
					|| itemSelected && this._selectBounds,
			positionSelected = selection & 4;
		if (!this._drawSelected)
			itemSelected = false;
		if ((itemSelected || boundsSelected || positionSelected)
				&& this._isUpdated(updateVersion)) {
			var layer,
				color = this.getSelectedColor(true) || (layer = this.getLayer())
					&& layer.getSelectedColor(true),
				mx = matrix.appended(this.getGlobalMatrix(true)),
				half = size / 2;
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (itemSelected)
				this._drawSelected(ctx, mx, selectionItems);
			if (positionSelected) {
				var pos = this.getPosition(true),
					parent = this._parent,
					point = parent ? parent.localToGlobal(pos) : pos,
					x = point.x,
					y = point.y;
				ctx.beginPath();
				ctx.arc(x, y, half, 0, Math.PI * 2, true);
				ctx.stroke();
				var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
					start = half,
					end = size + 1;
				for (var i = 0; i < 4; i++) {
					var delta = deltas[i],
						dx = delta[0],
						dy = delta[1];
					ctx.moveTo(x + dx * start, y + dy * start);
					ctx.lineTo(x + dx * end, y + dy * end);
					ctx.stroke();
				}
			}
			if (boundsSelected) {
				var coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++) {
					ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				}
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++) {
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
				}
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(key) {
	this['removeOn' + Base.capitalize(key)] = function() {
		var hash = {};
		hash[key] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}), {
	tween: function(from, to, options) {
		if (!options) {
			options = to;
			to = from;
			from = null;
			if (!options) {
				options = to;
				to = null;
			}
		}
		var easing = options && options.easing,
			start = options && options.start,
			duration = options != null && (
				typeof options === 'number' ? options : options.duration
			),
			tween = new Tween(this, from, to, duration, easing, start);
		function onFrame(event) {
			tween._handleFrame(event.time * 1000);
			if (!tween.running) {
				this.off('frame', onFrame);
			}
		}
		if (duration) {
			this.on('frame', onFrame);
		}
		return tween;
	},

	tweenTo: function(to, options) {
		return this.tween(null, to, options);
	},

	tweenFrom: function(from, options) {
		return this.tween(from, null, options);
	}
});

var Group = Item.extend({
	_class: 'Group',
	_selectBounds: false,
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 2050) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i]._clipMask) {
					clipItem = children[i];
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_getBounds: function _getBounds(matrix, options) {
		var clipItem = this._getClipItem();
		return clipItem
			? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix),
				Base.set({}, options, { stroke: false }))
			: _getBounds.base.call(this, matrix, options);
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		var clipItem = this._getClipItem();
		return (!clipItem || clipItem.contains(point))
				&& _hitTestChildren.base.call(this, point, options, viewMatrix,
					clipItem);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem();
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			ctx.beginPath();
			param.dontStart = param.dontFinish = true;
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var item = children[i];
			if (item !== clipItem)
				item.draw(ctx, param);
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer() {
		Group.apply(this, arguments);
	},

	_getOwner: function() {
		return this._parent || this._index != null && this._project;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_hitTestSelf: function() {
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_canScaleStroke: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props, point) {
		this._initialize(props, point);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	copyContent: function(source) {
		this.setType(source._type);
		this.setSize(source._size);
		this.setRadius(source._radius);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				this._radius.set(Size.min(this._radius, size.divide(2).abs()));
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius._set(width / 2, height / 2);
			}
			this._size._set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size._set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size);
				} else if (type === 'ellipse') {
					this._size._set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.copyAttributes(this);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		if (insert === undefined || insert)
			path.insertAbove(this);
		return path;
	},

	toShape: '#clone',

	_asPathItem: function() {
		return this.toPath(false);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx, param, viewMatrix);
			if (hasFill) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0),
			style = this._style,
			strokeWidth = options.stroke && style.hasStroke()
					&& style.getStrokeWidth();
		if (matrix)
			rect = matrix._transformBounds(rect);
		return strokeWidth
				? rect.expand(Path._getStrokePadding(strokeWidth,
					this._getStrokeMatrix(matrix, options)))
				: rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var q = 1; q <= 4; q++) {
				var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(
							expand ? corner.add(dir.multiply(expand)) : corner,
							center);
				if (rect.contains(point))
					return { point: center, quadrant: q };
			}
		}
	}

	function isOnEllipseStroke(point, radius, padding, quadrant) {
		var vector = point.divide(radius);
		return (!quadrant || vector.isInQuadrant(quadrant)) &&
				vector.subtract(vector.normalize()).multiply(radius)
					.divide(padding).length <= 1;
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center.point).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,
				strokeMatrix) {
			var hit = false,
				style = this._style,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill();
			if (hitStroke || hitFill) {
				var type = this._type,
					radius = this._radius,
					strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
					strokePadding = options._tolerancePadding.add(
						Path._getStrokePadding(strokeRadius,
							!style.getStrokeScaling() && strokeMatrix));
				if (type === 'rectangle') {
					var padding = strokePadding.multiply(2),
						center = getCornerCenter(this, point, padding);
					if (center) {
						hit = isOnEllipseStroke(point.subtract(center.point),
								radius, strokePadding, center.quadrant);
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(padding),
							inner = rect.expand(padding.negate());
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					hit = isOnEllipseStroke(point, radius, strokePadding);
				}
			}
			return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = Base.create(Shape.prototype);
		item._type = type;
		item._size = size;
		item._radius = radius;
		item._initialize(Base.getNamed(args), point);
		return item;
	}

	return {
		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.min(Size.readNamed(args, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, args);
		},

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, args);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: false, handle: false },
	_serializeFields: {
		crossOrigin: null,
		source: null
	},
	_prioritize: ['crossOrigin'],
	_smoothing: true,
	beans: true,

	initialize: function Raster(source, position) {
		if (!this._initialize(source,
				position !== undefined && Point.read(arguments))) {
			var image,
				type = typeof source,
				object = type === 'string'
					? document.getElementById(source)
					: type  === 'object'
						? source
						: null;
			if (object && object !== Item.NO_INSERT) {
				if (object.getContent || object.naturalHeight != null) {
					image = object;
				} else if (object) {
					var size = Size.read(arguments);
					if (!size.isZero()) {
						image = CanvasProvider.getCanvas(size);
					}
				}
			}
			if (image) {
				this.setImage(image);
			} else {
				this.setSource(source);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	copyContent: function(source) {
		var image = source._image,
			canvas = source._canvas;
		if (image) {
			this._setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(source._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			this._setImage(copyCanvas);
		}
		this._crossOrigin = source._crossOrigin;
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this._setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	getLoaded: function() {
		return this._loaded;
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		var that = this;

		function emit(event) {
			var view = that.getView(),
				type = event && event.type || 'load';
			if (view && that.responds(type)) {
				paper = view._scope;
				that.emit(type, new Event(event));
			}
		}

		this._setImage(image);
		if (this._loaded) {
			setTimeout(emit, 0);
		} else if (image) {
			DomEvent.add(image, {
				load: function(event) {
					that._setImage(image);
					emit(event);
				},
				error: emit
			});
		}
	},

	_setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = !!(image && image.src && image.complete);
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(1033);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(_change) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (_change) {
			this._image = null;
			this._changed(1025);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		var image = this._image;
		return image && image.src || this.toDataURL();
	},

	setSource: function(src) {
		var image = new self.Image(),
			crossOrigin = this._crossOrigin;
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (src)
			image.src = src;
		this.setImage(image);
	},

	getCrossOrigin: function() {
		var image = this._image;
		return image && image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		var image = this._image;
		if (image)
			image.crossOrigin = crossOrigin;
	},

	getSmoothing: function() {
		return this._smoothing;
	},

	setSmoothing: function(smoothing) {
		this._smoothing = smoothing;
		this._changed(257);
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster._setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.prepend(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var image = this._image,
			src = image && image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (typeof object === 'object') {
			if ('width' in object) {
				bounds = new Rectangle(object);
			} else if ('x' in object) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
		}
		if (!bounds)
			return null;
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var args = arguments,
			point = Point.read(args),
			color = Color.read(args),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	clear: function() {
		var size = this._size;
		this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx, param, viewMatrix) {
		var element = this.getElement();
		if (element && element.width > 0 && element.height > 0) {
			ctx.globalAlpha = this._opacity;

			this._setStyles(ctx, param, viewMatrix);

			DomElement.setPrefixed(
				ctx, 'imageSmoothingEnabled', this._smoothing
			);

			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var SymbolItem = Item.extend({
	_class: 'SymbolItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: true },
	_serializeFields: {
		symbol: null
	},

	initialize: function SymbolItem(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setDefinition(arg0 instanceof SymbolDefinition ?
					arg0 : new SymbolDefinition(arg0));
	},

	_equals: function(item) {
		return this._definition === item._definition;
	},

	copyContent: function(source) {
		this.setDefinition(source._definition);
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(definition) {
		this._definition = definition;
		this._changed(9);
	},

	getSymbol: '#getDefinition',
	setSymbol: '#setDefinition',

	isEmpty: function() {
		return this._definition._item.isEmpty();
	},

	_getBounds: function(matrix, options) {
		var item = this._definition._item;
		return item._getCachedBounds(item._matrix.prepended(matrix), options);
	},

	_hitTestSelf: function(point, options, viewMatrix) {
		var opts = options.extend({ all: false });
		var res = this._definition._item._hitTest(point, opts, viewMatrix);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this._definition._item.draw(ctx, param);
	}

});

var SymbolDefinition = Base.extend({
	_class: 'SymbolDefinition',

	initialize: function SymbolDefinition(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		if (item)
			this.setItem(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._item],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8)
			Item._clearBoundsCache(this);
		if (flags & 1)
			this.project._changed(flags);
	},

	getItem: function() {
		return this._item;
	},

	setItem: function(item, _dontCenter) {
		if (item._symbol)
			item = item.clone();
		if (this._item)
			this._item._symbol = null;
		this._item = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._symbol = this;
		this._changed(9);
	},

	getDefinition: '#getItem',
	setDefinition: '#setItem',

	place: function(position) {
		return new SymbolItem(this, position);
	},

	clone: function() {
		return new SymbolDefinition(this._item.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this._item.equals(symbol._item)
				|| false;
	}
});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values)
			this.inject(values);
	},

	statics: {
		getOptions: function(args) {
			var options = args && Base.read(args);
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				position: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,
	_selection: 0,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut, selection;
		if (count > 0) {
			if (arg0 == null || typeof arg0 === 'object') {
				if (count === 1 && arg0 && 'point' in arg0) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
					selection = arg0.selection;
				} else {
					point = arg0;
					handleIn = arg1;
					handleOut = arg2;
					selection = arg3;
				}
			} else {
				point = [ arg0, arg1 ];
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
		if (selection)
			this.setSelection(selection);
	},

	_serialize: function(options, dictionary) {
		var point = this._point,
			selection = this._selection,
			obj = selection || this.hasHandles()
					? [point, this._handleIn, this._handleOut]
					: point;
		if (selection)
			obj.push(selection);
		return Base.serialize(obj, options, true, dictionary);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(41);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		this._point.set(Point.read(arguments));
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		this._handleIn.set(Point.read(arguments));
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		this._handleOut.set(Point.read(arguments));
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	isSmooth: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut;
		return !handleIn.isZero() && !handleOut.isZero()
				&& handleIn.isCollinear(handleOut);
	},

	clearHandles: function() {
		this._handleIn._set(0, 0);
		this._handleOut._set(0, 0);
	},

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		var oldSelection = this._selection,
			path = this._path;
		this._selection = selection = selection || 0;
		if (path && selection !== oldSelection) {
			path._updateSelection(this, oldSelection, selection);
			path._changed(257);
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		return !!(this._selection & 7);
	},

	setSelected: function(selected) {
		this._changeSelection(7, selected);
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	smooth: function(options, _first, _last) {
		var opts = options || {},
			type = opts.type,
			factor = opts.factor,
			prev = this.getPrevious(),
			next = this.getNext(),
			p0 = (prev || this)._point,
			p1 = this._point,
			p2 = (next || this)._point,
			d1 = p0.getDistance(p1),
			d2 = p1.getDistance(p2);
		if (!type || type === 'catmull-rom') {
			var a = factor === undefined ? 0.5 : factor,
				d1_a = Math.pow(d1, a),
				d1_2a = d1_a * d1_a,
				d2_a = Math.pow(d2, a),
				d2_2a = d2_a * d2_a;
			if (!_first && prev) {
				var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
					N = 3 * d2_a * (d2_a + d1_a);
				this.setHandleIn(N !== 0
					? new Point(
						(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,
						(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)
					: new Point());
			}
			if (!_last && next) {
				var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
					N = 3 * d1_a * (d1_a + d2_a);
				this.setHandleOut(N !== 0
					? new Point(
						(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,
						(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)
					: new Point());
			}
		} else if (type === 'geometric') {
			if (prev && next) {
				var vector = p0.subtract(p2),
					t = factor === undefined ? 0.4 : factor,
					k = t * d1 / (d1 + d2);
				if (!_first)
					this.setHandleIn(vector.multiply(k));
				if (!_last)
					this.setHandleOut(vector.multiply(k - t));
			}
		} else {
			throw new Error('Smoothing method \'' + type + '\' not supported.');
		}
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return !this._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			tmp = handleIn.clone();
		handleIn.set(handleOut);
		handleOut.set(tmp);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	interpolate: function(from, to, factor) {
		var u = 1 - factor,
			v = factor,
			point1 = from._point,
			point2 = to._point,
			handleIn1 = from._handleIn,
			handleIn2 = to._handleIn,
			handleOut2 = to._handleOut,
			handleOut1 = from._handleOut;
		this._point._set(
				u * point1._x + v * point2._x,
				u * point1._y + v * point2._y, true);
		this._handleIn._set(
				u * handleIn1._x + v * handleIn2._x,
				u * handleIn1._y + v * handleIn2._y, true);
		this._handleOut._set(
				u * handleOut1._x + v * handleOut2._x,
				u * handleOut1._y + v * handleOut2._y, true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y,
			selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	_set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this._x) && isZero(this._y);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		var owner = this._owner;
		return this === owner._point ? 1
			: this === owner._handleIn ? 2
			: this === owner._handleOut ? 4
			: 0;
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	beans: true,

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (!count) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true, dictionary);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	classify: function() {
		return Curve.classify(this.getValues());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		this._segment1._point.set(Point.read(arguments));
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		this._segment2._point.set(Point.read(arguments));
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		this._segment1._handleOut.set(Point.read(arguments));
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		this._segment2._handleIn.set(Point.read(arguments));
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return !this._segment1._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	}
}, {
	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	divideAt: function(location) {
		return this.divideAtTime(location && location.curve === this
				? location.time : this.getTimeAt(location));
	},

	divideAtTime: function(time, _setHandles) {
		var tMin = 1e-8,
			tMax = 1 - tMin,
			res = null;
		if (time >= tMin && time <= tMax) {
			var parts = Curve.subdivide(this.getValues(), time),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				seg1 = this._segment1,
				seg2 = this._segment2,
				path = this._path;
			if (setHandles) {
				seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
				seg2._handleIn._set(right[4] - right[6],right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(seg1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				this._changed();
				res = new Curve(segment, seg2);
			}
		}
		return res;
	},

	splitAt: function(location) {
		var path = this._path;
		return path ? path.splitAt(location) : null;
	},

	splitAtTime: function(time) {
		return this.splitAt(this.getLocationAtTime(time));
	},

	divide: function(offset, isTime) {
		return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	split: function(offset, isTime) {
		return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut._set(0, 0);
		this._segment2._handleIn._set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix, straight) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			x1 = p1.x, y1 = p1.y,
			x2 = p2.x, y2 = p2.y,
			values = straight
				? [ x1, y1, x1, y1, x2, y2, x2, y2 ]
				: [
					x1, y1,
					x1 + h1._x, y1 + h1._y,
					x2 + h2._x, y2 + h2._y,
					x2, y2
				];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
			x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
			x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
			x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
			x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
			x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
		return [
			[x0, y0, x4, y4, x7, y7, x9, y9],
			[x9, y9, x8, y8, x6, y6, x3, y3]
		];
	},

	getMonoCurves: function(v, dir) {
		var curves = [],
			io = dir ? 0 : 1,
			o0 = v[io + 0],
			o1 = v[io + 2],
			o2 = v[io + 4],
			o3 = v[io + 6];
		if ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)
				|| Curve.isStraight(v)) {
			curves.push(v);
		} else {
			var a = 3 * (o1 - o2) - o0 + o3,
				b = 2 * (o0 + o2) - 4 * o1,
				c = o1 - o0,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [],
				n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
			if (!n) {
				curves.push(v);
			} else {
				roots.sort();
				var t = roots[0],
					parts = Curve.subdivide(v, t);
				curves.push(parts[0]);
				if (n > 1) {
					t = (roots[1] - t) / (1 - t);
					parts = Curve.subdivide(parts[1], t);
					curves.push(parts[0]);
				}
				curves.push(parts[1]);
			}
		}
		return curves;
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var v0 = v[coord],
			v1 = v[coord + 2],
			v2 = v[coord + 4],
			v3 = v[coord + 6],
			res = 0;
		if (  !(v0 < val && v3 < val && v1 < val && v2 < val ||
				v0 > val && v3 > val && v1 > val && v2 > val)) {
			var c = 3 * (v1 - v0),
				b = 3 * (v2 - v1) - c,
				a = v3 - v0 - c - b;
			res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
		}
		return res;
	},

	getTimeOf: function(v, point) {
		var p0 = new Point(v[0], v[1]),
			p3 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			geomEpsilon = 1e-7,
			t = point.isClose(p0, epsilon) ? 0
			  : point.isClose(p3, epsilon) ? 1
			  : null;
		if (t === null) {
			var coords = [point.x, point.y],
				roots = [];
			for (var c = 0; c < 2; c++) {
				var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
				for (var i = 0; i < count; i++) {
					var u = roots[i];
					if (point.isClose(Curve.getPoint(v, u), geomEpsilon))
						return u;
				}
			}
		}
		return point.isClose(p0, geomEpsilon) ? 0
			 : point.isClose(p3, geomEpsilon) ? 1
			 : null;
	},

	getNearestTime: function(v, point) {
		if (Curve.isStraight(v)) {
			var x0 = v[0], y0 = v[1],
				x3 = v[6], y3 = v[7],
				vx = x3 - x0, vy = y3 - y0,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getTimeOf(v,
					new Point(x0 + u * vx, y0 + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 1e-8) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	isFlatEnough: function(v, flatness) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			ux = 3 * x1 - 2 * x0 - x3,
			uy = 3 * y1 - 2 * y0 - y3,
			vx = 3 * x2 - 2 * x3 - x0,
			vy = 3 * y2 - 2 * y3 - y0;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				<= 16 * flatness * flatness;
	},

	getArea: function(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)
				+ y1 * (x0 - x2) - x1 * (y0 - y2)
				+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}

		padding /= 2;
		var minPad = min[coord] - padding,
			maxPad = max[coord] + padding;
		if (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||
				v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
			if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
				add(v0, padding);
				add(v3, padding);
			} else {
				var a = 3 * (v1 - v2) - v0 + v3,
					b = 2 * (v0 + v2) - 4 * v1,
					c = v1 - v0,
					count = Numerical.solveQuadratic(a, b, c, roots),
					tMin = 1e-8,
					tMax = 1 - tMin;
				add(v3, 0);
				for (var i = 0; i < count; i++) {
					var t = roots[i],
						u = 1 - t;
					if (tMin <= t && t <= tMax)
						add(u * u * u * v0
							+ 3 * u * u * t * v1
							+ 3 * u * t * t * v2
							+ t * t * t * v3,
							padding);
				}
			}
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false, this._path);
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(p1, h1, h2, p2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else {
			var v = p2.subtract(p1);
			if (v.isZero()) {
				return false;
			} else if (v.isCollinear(h1) && v.isCollinear(h2)) {
				var l = new Line(p1, p2),
					epsilon = 1e-7;
				if (l.getDistance(p1.add(h1)) < epsilon &&
					l.getDistance(p2.add(h2)) < epsilon) {
					var div = v.dot(v),
						s1 = v.dot(h1) / div,
						s2 = v.dot(h2) / div;
					return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
				}
			}
		}
		return false;
	},

	isLinear: function(p1, h1, h2, p2) {
		var third = p2.subtract(p1).divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function(epsilon) {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,
				epsilon);
	};

	this.statics[name] = function(v, epsilon) {
		var x0 = v[0], y0 = v[1],
			x3 = v[6], y3 = v[7];
		return test(
				new Point(x0, y0),
				new Point(v[2] - x0, v[3] - y0),
				new Point(v[4] - x3, v[5] - y3),
				new Point(x3, y3), epsilon);
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	hasLength: function(epsilon) {
		return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())
				&& this.getLength() > (epsilon || 0);
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)
				< 1e-8;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)
				< 1e-8;
	}
}), {
	beans: false,

	getLocationAt: function(offset, _isTime) {
		return this.getLocationAtTime(
				_isTime ? offset : this.getTimeAt(offset));
	},

	getLocationAtTime: function(t) {
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getTimeAt: function(offset, start) {
		return Curve.getTimeAt(this.getValues(), offset, start);
	},

	getParameterAt: '#getTimeAt',

	getTimesWithTangent: function () {
		var tangent = Point.read(arguments);
		return tangent.isZero()
				? []
				: Curve.getTimesWithTangent(this.getValues(), tangent);
	},

	getOffsetAtTime: function(t) {
		return this.getPartLength(0, t);
	},

	getLocationOf: function() {
		return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getTimeOf: function() {
		return Curve.getTimeOf(this.getValues(), Point.read(arguments));
	},

	getParameterOf: '#getTimeOf',

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestTime(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(location, _isTime) {
				var values = this.getValues();
				return Curve[name](values, _isTime ? location
						: Curve.getTimeAt(values, location));
			};

			this[name + 'AtTime'] = function(time) {
				return Curve[name](this.getValues(), time);
			};
		}, {
			statics: {
				_evaluateMethods: methods
			}
		}
	);
},
new function() {

	function getLengthIntegrand(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],

			ax = 9 * (x1 - x2) + 3 * (x3 - x0),
			bx = 6 * (x0 + x2) - 12 * x1,
			cx = 3 * (x1 - x0),

			ay = 9 * (y1 - y2) + 3 * (y3 - y0),
			by = 6 * (y0 + y2) - 12 * y1,
			cy = 3 * (y1 - y0);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			isZero = Numerical.isZero;
		if (isZero(x1 - x0) && isZero(y1 - y0)) {
			x1 = x0;
			y1 = y0;
		}
		if (isZero(x2 - x3) && isZero(y2 - y3)) {
			x2 = x3;
			y2 = y3;
		}
		var cx = 3 * (x1 - x0),
			bx = 3 * (x2 - x1) - cx,
			ax = x3 - x0 - cx - bx,
			cy = 3 * (y1 - y0),
			by = 3 * (y2 - y1) - cy,
			ay = y3 - y0 - cy - by,
			x, y;
		if (type === 0) {
			x = t === 0 ? x0 : t === 1 ? x3
					: ((ax * t + bx) * t + cx) * t + x0;
			y = t === 0 ? y0 : t === 1 ? y3
					: ((ay * t + by) * t + cy) * t + y0;
		} else {
			var tMin = 1e-8,
				tMax = 1 - tMin;
			if (t < tMin) {
				x = cx;
				y = cy;
			} else if (t > tMax) {
				x = 3 * (x3 - x2);
				y = 3 * (y3 - y2);
			} else {
				x = (3 * ax * t + 2 * bx) * t + cx;
				y = (3 * ay * t + 2 * by) * t + cy;
			}
			if (normalized) {
				if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
					x = x2 - x1;
					y = y2 - y1;
				}
				var len = Math.sqrt(x * x + y * y);
				if (len) {
					x /= len;
					y /= len;
				}
			}
			if (type === 3) {
				var x2 = 6 * ax * t + 2 * bx,
					y2 = 6 * ay * t + 2 * by,
					d = Math.pow(x * x + y * y, 3 / 2);
				x = d !== 0 ? (x * y2 - y * x2) / d : 0;
				y = 0;
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		classify: function(v) {

			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
				a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
				a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
				d3 = 3 * a3,
				d2 = d3 - a2,
				d1 = d2 - a2 + a1,
				l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
				s = l !== 0 ? 1 / l : 0,
				isZero = Numerical.isZero,
				serpentine = 'serpentine';
			d1 *= s;
			d2 *= s;
			d3 *= s;

			function type(type, t1, t2) {
				var hasRoots = t1 !== undefined,
					t1Ok = hasRoots && t1 > 0 && t1 < 1,
					t2Ok = hasRoots && t2 > 0 && t2 < 1;
				if (hasRoots && (!(t1Ok || t2Ok)
						|| type === 'loop' && !(t1Ok && t2Ok))) {
					type = 'arch';
					t1Ok = t2Ok = false;
				}
				return {
					type: type,
					roots: t1Ok || t2Ok
							? t1Ok && t2Ok
								? t1 < t2 ? [t1, t2] : [t2, t1]
								: [t1Ok ? t1 : t2]
							: null
				};
			}

			if (isZero(d1)) {
				return isZero(d2)
						? type(isZero(d3) ? 'line' : 'quadratic')
						: type(serpentine, d3 / (3 * d2));
			}
			var d = 3 * d2 * d2 - 4 * d1 * d3;
			if (isZero(d)) {
				return type('cusp', d2 / (2 * d1));
			}
			var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
				f2 = 2 * d1;
			return type(d > 0 ? serpentine : 'loop',
					(d2 + f1) / f2,
					(d2 - f1) / f2);
		},

		getLength: function(v, a, b, ds) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (Curve.isStraight(v)) {
				var c = v;
				if (b < 1) {
					c = Curve.subdivide(c, b)[0];
					a /= b;
				}
				if (a > 0) {
					c = Curve.subdivide(c, a)[1];
				}
				var dx = c[6] - c[0],
					dy = c[7] - c[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			return Numerical.integrate(ds || getLengthIntegrand(v), a, b,
					getIterations(a, b));
		},

		getTimeAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0;
			if (offset === 0)
				return start;
			var abs = Math.abs,
				epsilon = 1e-12,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Curve.getLength(v, a, b, ds),
				diff = abs(offset) - rangeLength;
			if (abs(diff) < epsilon) {
				return forward ? b : a;
			} else if (diff > epsilon) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		},

		getPeaks: function(v) {
			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				ax =     -x0 + 3 * x1 - 3 * x2 + x3,
				bx =  3 * x0 - 6 * x1 + 3 * x2,
				cx = -3 * x0 + 3 * x1,
				ay =     -y0 + 3 * y1 - 3 * y2 + y3,
				by =  3 * y0 - 6 * y1 + 3 * y2,
				cy = -3 * y0 + 3 * y1,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [];
			Numerical.solveCubic(
					9 * (ax * ax + ay * ay),
					9 * (ax * bx + by * ay),
					2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),
					(cx * bx + by * cy),
					roots, tMin, tMax);
			return roots.sort();
		}
	}};
},
new function() {

	function addLocation(locations, include, c1, t1, c2, t2, overlap) {
		var excludeStart = !overlap && c1.getPrevious() === c2,
			excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&
			t1 <= (excludeEnd ? tMax : 1)) {
			if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&
				t2 <= (excludeStart ? tMax : 1)) {
				var loc1 = new CurveLocation(c1, t1, null, overlap),
					loc2 = new CurveLocation(c2, t2, null, overlap);
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc1)) {
					CurveLocation.insert(locations, loc1, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, include, flip,
			recursion, calls, tMin, tMax, uMin, uMax) {
		if (++calls >= 4096 || ++recursion >= 40)
			return calls;
		var fatLineEpsilon = 1e-9,
			q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if (d1 === 0 && d2 === 0
				&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0
			|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null
			|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return calls;
		var tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
			var t = (tMinNew + tMaxNew) / 2,
				u = (uMin + uMax) / 2;
			addLocation(locations, include,
					flip ? c2 : c1, flip ? u : t,
					flip ? c1 : c2, flip ? t : u);
		} else {
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			var uDiff = uMax - uMin;
			if (tMaxClip - tMinClip > 0.8) {
				if (tMaxNew - tMinNew > uDiff) {
					var parts = Curve.subdivide(v1, 0.5),
						t = (tMinNew + tMaxNew) / 2;
					calls = addCurveIntersections(
							v2, parts[0], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, t);
					calls = addCurveIntersections(
							v2, parts[1], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, t, tMaxNew);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						u = (uMin + uMax) / 2;
					calls = addCurveIntersections(
							parts[0], v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, u, tMinNew, tMaxNew);
					calls = addCurveIntersections(
							parts[1], v1, c2, c1, locations, include, !flip,
							recursion, calls, u, uMax, tMinNew, tMaxNew);
				}
			} else {
				if (uDiff === 0 || uDiff >= fatLineEpsilon) {
					calls = addCurveIntersections(
							v2, v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, tMaxNew);
				} else {
					calls = addCurveIntersections(
							v1, v2, c1, c2, locations, include, flip,
							recursion, calls, tMinNew, tMaxNew, uMin, uMax);
				}
			}
		}
		return calls;
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= 0.5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function getCurveLineIntersections(v, px, py, vx, vy) {
		var isZero = Numerical.isZero;
		if (isZero(vx) && isZero(vy)) {
			var t = Curve.getTimeOf(v, new Point(px, py));
			return t === null ? [] : [t];
		}
		var angle = Math.atan2(-vy, vx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rv = [],
			roots = [];
		for (var i = 0; i < 8; i += 2) {
			var x = v[i] - px,
				y = v[i + 1] - py;
			rv.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		Curve.solveCubic(rv, 1, 0, roots, 0, 1);
		return roots;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, include,
			flip) {
		var x1 = v2[0], y1 = v2[1],
			x2 = v2[6], y2 = v2[7],
			roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
		for (var i = 0, l = roots.length; i < l; i++) {
			var t1 = roots[i],
				p1 = Curve.getPoint(v1, t1),
				t2 = Curve.getTimeOf(v2, p1);
			if (t2 !== null) {
				addLocation(locations, include,
						flip ? c2 : c1, flip ? t2 : t1,
						flip ? c1 : c2, flip ? t1 : t2);
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, include) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, include,
					c1, Curve.getTimeOf(v1, pt),
					c2, Curve.getTimeOf(v2, pt));
		}
	}

	function getCurveIntersections(v1, v2, c1, c2, locations, include) {
		var epsilon = 1e-12,
			min = Math.min,
			max = Math.max;

		if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >
			min(v2[0], v2[2], v2[4], v2[6]) &&
			min(v1[0], v1[2], v1[4], v1[6]) - epsilon <
			max(v2[0], v2[2], v2[4], v2[6]) &&
			max(v1[1], v1[3], v1[5], v1[7]) + epsilon >
			min(v2[1], v2[3], v2[5], v2[7]) &&
			min(v1[1], v1[3], v1[5], v1[7]) - epsilon <
			max(v2[1], v2[3], v2[5], v2[7])) {
			var overlaps = getOverlaps(v1, v2);
			if (overlaps) {
				for (var i = 0; i < 2; i++) {
					var overlap = overlaps[i];
					addLocation(locations, include,
							c1, overlap[0],
							c2, overlap[1], true);
				}
			} else {
				var straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight = straight1 && straight2,
					flip = straight1 && !straight2,
					before = locations.length;
				(straight
					? addLineIntersection
					: straight1 || straight2
						? addCurveLineIntersections
						: addCurveIntersections)(
							flip ? v2 : v1, flip ? v1 : v2,
							flip ? c2 : c1, flip ? c1 : c2,
							locations, include, flip,
							0, 0, 0, 1, 0, 1);
				if (!straight || locations.length === before) {
					for (var i = 0; i < 4; i++) {
						var t1 = i >> 1,
							t2 = i & 1,
							i1 = t1 * 6,
							i2 = t2 * 6,
							p1 = new Point(v1[i1], v1[i1 + 1]),
							p2 = new Point(v2[i2], v2[i2 + 1]);
						if (p1.isClose(p2, epsilon)) {
							addLocation(locations, include,
									c1, t1,
									c2, t2);
						}
					}
				}
			}
		}
		return locations;
	}

	function getSelfIntersection(v1, c1, locations, include) {
		var info = Curve.classify(v1);
		if (info.type === 'loop') {
			var roots = info.roots;
			addLocation(locations, include,
					c1, roots[0],
					c1, roots[1]);
		}
	  return locations;
	}

	function getIntersections(curves1, curves2, include, matrix1, matrix2,
			_returnFirst) {
		var epsilon = 1e-7,
			self = !curves2;
		if (self)
			curves2 = curves1;
		var length1 = curves1.length,
			length2 = curves2.length,
			values1 = new Array(length1),
			values2 = self ? values1 : new Array(length2),
			locations = [];

		for (var i = 0; i < length1; i++) {
			values1[i] = curves1[i].getValues(matrix1);
		}
		if (!self) {
			for (var i = 0; i < length2; i++) {
				values2[i] = curves2[i].getValues(matrix2);
			}
		}
		var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(
				values1, values2, epsilon);
		for (var index1 = 0; index1 < length1; index1++) {
			var curve1 = curves1[index1],
				v1 = values1[index1];
			if (self) {
				getSelfIntersection(v1, curve1, locations, include);
			}
			var collisions1 = boundsCollisions[index1];
			if (collisions1) {
				for (var j = 0; j < collisions1.length; j++) {
					if (_returnFirst && locations.length)
						return locations;
					var index2 = collisions1[j];
					if (!self || index2 > index1) {
						var curve2 = curves2[index2],
							v2 = values2[index2];
						getCurveIntersections(
								v1, v2, curve1, curve2, locations, include);
					}
				}
			}
		}
		return locations;
	}

	function getOverlaps(v1, v2) {

		function getSquaredLineLength(v) {
			var x = v[6] - v[0],
				y = v[7] - v[1];
			return x * x + y * y;
		}

		var abs = Math.abs,
			getDistance = Line.getDistance,
			timeEpsilon = 1e-8,
			geomEpsilon = 1e-7,
			straight1 = Curve.isStraight(v1),
			straight2 = Curve.isStraight(v2),
			straightBoth = straight1 && straight2,
			flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
			l1 = flip ? v2 : v1,
			l2 = flip ? v1 : v2,
			px = l1[0], py = l1[1],
			vx = l1[6] - px, vy = l1[7] - py;
		if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&
			getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
			if (!straightBoth &&
				getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
				straight1 = straight2 = straightBoth = true;
			}
		} else if (straightBoth) {
			return null;
		}
		if (straight1 ^ straight2) {
			return null;
		}

		var v = [v1, v2],
			pairs = [];
		for (var i = 0; i < 4 && pairs.length < 2; i++) {
			var i1 = i & 1,
				i2 = i1 ^ 1,
				t1 = i >> 1,
				t2 = Curve.getTimeOf(v[i1], new Point(
					v[i2][t1 ? 6 : 0],
					v[i2][t1 ? 7 : 1]));
			if (t2 != null) {
				var pair = i1 ? [t1, t2] : [t2, t1];
				if (!pairs.length ||
					abs(pair[0] - pairs[0][0]) > timeEpsilon &&
					abs(pair[1] - pairs[0][1]) > timeEpsilon) {
					pairs.push(pair);
				}
			}
			if (i > 2 && !pairs.length)
				break;
		}
		if (pairs.length !== 2) {
			pairs = null;
		} else if (!straightBoth) {
			var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
				o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
			if (abs(o2[2] - o1[2]) > geomEpsilon ||
				abs(o2[3] - o1[3]) > geomEpsilon ||
				abs(o2[4] - o1[4]) > geomEpsilon ||
				abs(o2[5] - o1[5]) > geomEpsilon)
				pairs = null;
		}
		return pairs;
	}

	function getTimesWithTangent(v, tangent) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			normalized = tangent.normalize(),
			tx = normalized.x,
			ty = normalized.y,
			ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
			ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
			bx = 6 * x2 - 12 * x1 + 6 * x0,
			by = 6 * y2 - 12 * y1 + 6 * y0,
			cx = 3 * x1 - 3 * x0,
			cy = 3 * y1 - 3 * y0,
			den = 2 * ax * ty - 2 * ay * tx,
			times = [];
		if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
			var num = ax * cy - ay * cx,
				den = ax * by - ay * bx;
			if (den != 0) {
				var t = -num / den;
				if (t >= 0 && t <= 1) times.push(t);
			}
		} else {
			var delta = (bx * bx - 4 * ax * cx) * ty * ty +
				(-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty +
				(by * by - 4 * ay * cy) * tx * tx,
				k = bx * ty - by * tx;
			if (delta >= 0 && den != 0) {
				var d = Math.sqrt(delta),
					t0 = -(k + d) / den,
					t1 = (-k + d) / den;
				if (t0 >= 0 && t0 <= 1) times.push(t0);
				if (t1 >= 0 && t1 <= 1) times.push(t1);
			}
		}
		return times;
	}

	return {
		getIntersections: function(curve) {
			var v1 = this.getValues(),
				v2 = curve && curve !== this && curve.getValues();
			return v2 ? getCurveIntersections(v1, v2, this, curve, [])
					  : getSelfIntersection(v1, this, []);
		},

		statics: {
			getOverlaps: getOverlaps,
			getIntersections: getIntersections,
			getCurveLineIntersections: getCurveLineIntersections,
			getTimesWithTangent: getTimesWithTangent
		}
	};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',

	initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
		if (time >= 0.99999999) {
			var next = curve.getNext();
			if (next) {
				time = 0;
				curve = next;
			}
		}
		this._setCurve(curve);
		this._time = time;
		this._point = point || curve.getPointAtTime(time);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._previous = null;
	},

	_setCurve: function(curve) {
		var path = curve._path;
		this._path = path;
		this._version = path ? path._version : 0;
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		this._setCurve(segment.getCurve());
		this._segment = segment;
		this._time = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var segment = this._segment;
		if (!segment) {
			var curve = this.getCurve(),
				time = this.getTime();
			if (time === 0) {
				segment = curve._segment1;
			} else if (time === 1) {
				segment = curve._segment2;
			} else if (time != null) {
				segment = curve.getPartLength(0, time)
					< curve.getPartLength(time, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var path = this._path,
			that = this;
		if (path && path._version !== this._version) {
			this._time = this._offset = this._curveOffset = this._curve = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
				that._setCurve(curve);
				return curve;
			}
		}

		return this._curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getTime: function() {
		var curve = this.getCurve(),
			time = this._time;
		return curve && time == null
			? this._time = curve.getTimeOf(this._point)
			: time;
	},

	getParameter: '#getTime',

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var offset = this._curveOffset;
		if (offset == null) {
			var curve = this.getCurve(),
				time = this.getTime();
			this._curveOffset = offset = time != null && curve
					&& curve.getPartLength(0, time);
		}
		return offset;
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = curve && curve.divideAtTime(this.getTime());
		if (res) {
			this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve(),
			path = curve._path,
			res = curve && curve.splitAtTime(this.getTime());
		if (res) {
			this._setSegment(path.getLastSegment());
		}
		return  res;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc;
		if (!res && loc instanceof CurveLocation) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				p1 = c1._path,
				p2 = c2._path;
			if (p1 === p2) {
				var abs = Math.abs,
					epsilon = 1e-7,
					diff = abs(this.getOffset() - loc.getOffset()),
					i1 = !_ignoreOther && this._intersection,
					i2 = !_ignoreOther && loc._intersection;
				res = (diff < epsilon
						|| p1 && abs(p1.getLength() - diff) < epsilon)
					&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
			}
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var time = this.getTime();
		if (time != null)
			parts.push('time: ' + f.number(time));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getTime(),
			t2 = inter.getTime(),
			tMin = 1e-8,
			tMax = 1 - tMin,
			t1Inside = t1 >= tMin && t1 <= tMax,
			t2Inside = t2 >= tMin && t2 <= tMax;
		if (t1Inside && t2Inside)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
			c4 = inter.getCurve(),
			c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
		if (t1 > tMax)
			c2 = c2.getNext();
		if (t2 > tMax)
			c4 = c4.getNext();
		if (!c1 || !c2 || !c3 || !c4)
			return false;

		var offsets = [];

		function addOffsets(curve, end) {
			var v = curve.getValues(),
				roots = Curve.classify(v).roots || Curve.getPeaks(v),
				count = roots.length,
				offset = Curve.getLength(v,
					end && count ? roots[count - 1] : 0,
					!end && count ? roots[0] : 1);
			offsets.push(count ? offset : offset / 64);
		}

		function isInRange(angle, min, max) {
			return min < max
					? angle > min && angle < max
					: angle > min || angle < max;
		}

		if (!t1Inside) {
			addOffsets(c1, true);
			addOffsets(c2, false);
		}
		if (!t2Inside) {
			addOffsets(c3, true);
			addOffsets(c4, false);
		}
		var pt = this.getPoint(),
			offset = Math.min.apply(Math, offsets),
			v2 = t1Inside ? c2.getTangentAtTime(t1)
					: c2.getPointAt(offset).subtract(pt),
			v1 = t1Inside ? v2.negate()
					: c1.getPointAt(-offset).subtract(pt),
			v4 = t2Inside ? c4.getTangentAtTime(t2)
					: c4.getPointAt(offset).subtract(pt),
			v3 = t2Inside ? v4.negate()
					: c3.getPointAt(-offset).subtract(pt),
			a1 = v1.getAngle(),
			a2 = v2.getAngle(),
			a3 = v3.getAngle(),
			a4 = v4.getAngle();
		return !!(t1Inside
				? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&
				  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))
				: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&
				  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));
	},

	hasOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve._evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var curve = this.getCurve(),
			time = this.getTime();
		return time != null && curve && curve[get](time, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						1e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 !== path2
				? path1._id - path2._id
				: (loc.getIndex() + loc.getTime())
				- (loc2.getIndex() + loc2.getTime());
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = locations.length - 1; i >= 0; i--) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',
	_selectBounds: false,
	_canScaleStroke: true,
	beans: true,

	initialize: function PathItem() {
	},

	statics: {
		create: function(arg) {
			var data,
				segments,
				compound;
			if (Base.isPlainObject(arg)) {
				segments = arg.segments;
				data = arg.pathData;
			} else if (Array.isArray(arg)) {
				segments = arg;
			} else if (typeof arg === 'string') {
				data = arg;
			}
			if (segments) {
				var first = segments[0];
				compound = first && Array.isArray(first[0]);
			} else if (data) {
				compound = (data.match(/m/gi) || []).length > 1
						|| /z\s*\S+/i.test(data);
			}
			var ctor = compound ? CompoundPath : Path;
			return new ctor(arg);
		}
	},

	_asPathItem: function() {
		return this;
	},

	isClockwise: function() {
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
	},

	setPathData: function(data) {

		var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2) {
					this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));
					if (move) {
						start = current;
						move = false;
					}
				}
				control = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				current = current.clone();
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(1e-12);
				current = start;
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = point.isInside(
				this.getBounds({ internal: true, handle: true }))
					? this._getWinding(point)
					: {};
		return winding.onPath || !!(this.getFillRule() === 'evenodd'
				? winding.windingL & 1 || winding.windingR & 1
				: winding.winding);
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix._orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix)._orNullIfIdentity();
		return self || this.getBounds(matrix1).intersects(
				path.getBounds(matrix2), 1e-12)
				? Curve.getIntersections(
						this.getCurves(), !self && path.getCurves(), include,
						matrix1, matrix2, _returnFirst)
				: [];
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.isCrossing();
		});
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	},

	interpolate: function(from, to, factor) {
		var isPath = !this._children,
			name = isPath ? '_segments' : '_children',
			itemsFrom = from[name],
			itemsTo = to[name],
			items = this[name];
		if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
			throw new Error('Invalid operands in interpolate() call: ' +
					from + ', ' + to);
		}
		var current = items.length,
			length = itemsTo.length;
		if (current < length) {
			var ctor = isPath ? Segment : Path;
			for (var i = current; i < length; i++) {
				this.add(new ctor());
			}
		} else if (current > length) {
			this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
		}
		for (var i = 0; i < length; i++) {
			items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
		}
		if (isPath) {
			this.setClosed(from._closed);
			this._changed(9);
		}
	},

	compare: function(path) {
		var ok = false;
		if (path) {
			var paths1 = this._children || [this],
				paths2 = path._children ? path._children.slice() : [path],
				length1 = paths1.length,
				length2 = paths2.length,
				matched = [],
				count = 0;
			ok = true;
			var boundsOverlaps = CollisionDetection.findBoundsOverlaps(paths1, paths2, Numerical.GEOMETRIC_EPSILON);
			for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
				var path1 = paths1[i1];
				ok = false;
				var pathBoundsOverlaps = boundsOverlaps[i1];
				if (pathBoundsOverlaps) {
					for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
						if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
							if (!matched[pathBoundsOverlaps[i2]]) {
								matched[pathBoundsOverlaps[i2]] = true;
								count++;
							}
							ok = true;
						}
					}
				}
			}
			ok = ok && count === length2;
		}
		return ok;
	},

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var args = arguments,
			segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: args
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? args
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._segmentSelection = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	copyContent: function(source) {
		this.setSegments(source._segments);
		this._closed = source._closed;
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			this._length = this._area = undefined;
			if (flags & 32) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 64) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected(),
			length = segments && segments.length;
		this._segments.length = 0;
		this._segmentSelection = 0;
		this._curves = undefined;
		if (length) {
			var last = segments[length - 1];
			if (typeof last === 'boolean') {
				this.setClosed(last);
				length--;
			}
			this._add(Segment.readList(segments, 0, {}, length));
		}
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(41);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine) {
						var dx = curX - prevX,
							dy = curY - prevY;
						parts.push(
							  dx === 0 ? 'v' + f.number(dy)
							: dy === 0 ? 'h' + f.number(dx)
							: 'l' + f.pair(dx, dy));
					}
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							 + ' ' + f.pair( inX - prevX,  inY - prevY)
							 + ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (!length)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	},

	isEmpty: function() {
		return !this._segments.length;
	},

	_transformContent: function(matrix) {
		var segments = this._segments,
			coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selection)
				this._updateSelection(segment, 0, segment._selection);
		}
		if (append) {
			Base.push(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				start = index > 0 && index + amount - 1 === total ? index - 1
					: index,
				insert = start,
				end = Math.min(start + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [start, 0].concat(segs._curves));
				insert += segs._curves.length;
			}
			for (var i = insert; i < end; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(start, end);
		}
		this._changed(41);
		return segs;
	},

	_adjustCurves: function(start, end) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = start; i < end; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && !start ? segments.length - 1
				: start - 1]) {
			curve._segment2 = segments[start] || segments[0];
			curve._changed();
		}
		if (curve = curves[end]) {
			curve._segment1 = segments[end];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		var args = arguments;
		return args.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args))
			: this._add([ Segment.read(args) ])[0];
	},

	insert: function(index, segment1 ) {
		var args = arguments;
		return args.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args, 1), index)
			: this._add([ Segment.read(args, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readList(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readList(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(start, end, _includeCurves) {
		start = start || 0;
		end = Base.pick(end, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(start, end - start),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selection)
				this._updateSelection(segment, segment._selection, 0);
			segment._index = segment._path = null;
		}
		for (var i = start, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = start > 0 && end === count + (this._closed ? 1 : 0)
					? start - 1
					: start,
				curves = curves.splice(index, amount);
			for (var i = curves.length - 1; i >= 0; i--)
				curves[i]._path = null;
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(41);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		var area = this._area;
		if (area == null) {
			var segments = this._segments,
				closed = this._closed;
			area = 0;
			for (var i = 0, l = segments.length; i < l; i++) {
				var last = i + 1 === l;
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[last ? 0 : i + 1],
						null, last && !closed));
			}
			this._area = area;
		}
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this.isSelected() && length > 0 && this._segmentSelection
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelection: function setSelection(selection) {
		if (!(selection & 1))
			this._selectSegments(false);
		setSelection.base.call(this, selection);
	},

	_selectSegments: function(selected) {
		var segments = this._segments,
			length = segments.length,
			selection = selected ? 7 : 0;
		this._segmentSelection = selection * length;
		for (var i = 0; i < length; i++)
			segments[i]._selection = selection;
	},

	_updateSelection: function(segment, oldSelection, newSelection) {
		segment._selection = newSelection;
		var selection = this._segmentSelection += newSelection - oldSelection;
		if (selection > 0)
			this.setSelected(true);
	},

	divideAt: function(location) {
		var loc = this.getLocationAt(location),
			curve;
		return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))
				? curve._segment1
				: null;
	},

	splitAt: function(location) {
		var loc = this.getLocationAt(location),
			index = loc && loc.index,
			time = loc && loc.time,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (time > tMax) {
			index++;
			time = 0;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (time >= tMin) {
				curves[index++].divideAtTime(time);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.copyAttributes(this);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	split: function(index, time) {
		var curve,
			location = time === undefined ? index
				: (curve = this.getCurves()[index])
					&& curve.getLocationAtTime(time);
		return location != null ? this.splitAt(location) : null;
	},

	join: function(path, tolerance) {
		var epsilon = tolerance || 0;
		if (path && path !== this) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.isClose(last2._point, epsilon))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.isClose(first2._point, epsilon)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.isClose(first2._point, epsilon))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.isClose(last2._point, epsilon)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.isClose(last._point, epsilon)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	reduce: function(options) {
		var curves = this.getCurves(),
			simplify = options && options.simplify,
			tolerance = simplify ? 1e-7 : 0;
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (!curve.hasLength(tolerance)
					|| simplify && curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		this._changed(9);
	},

	flatten: function(flatness) {
		var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
			parts = flattener.parts,
			length = parts.length,
			segments = [];
		for (var i = 0; i < length; i++) {
			segments.push(new Segment(parts[i].curve.slice(0, 2)));
		}
		if (!this._closed && length > 0) {
			segments.push(new Segment(parts[length - 1].curve.slice(6)));
		}
		this.setSegments(segments);
	},

	simplify: function(tolerance) {
		var segments = new PathFitter(this).fit(tolerance || 2.5);
		if (segments)
			this.setSegments(segments);
		return !!segments;
	},

	smooth: function(options) {
		var that = this,
			opts = options || {},
			type = opts.type || 'asymmetric',
			segments = this._segments,
			length = segments.length,
			closed = this._closed;

		function getIndex(value, _default) {
			var index = value && value.index;
			if (index != null) {
				var path = value.path;
				if (path && path !== that)
					throw new Error(value._class + ' ' + index + ' of ' + path
							+ ' is not part of ' + that);
				if (_default && value instanceof Curve)
					index++;
			} else {
				index = typeof value === 'number' ? value : _default;
			}
			return Math.min(index < 0 && closed
					? index % length
					: index < 0 ? index + length : index, length - 1);
		}

		var loop = closed && opts.from === undefined && opts.to === undefined,
			from = getIndex(opts.from, 0),
			to = getIndex(opts.to, length - 1);

		if (from > to) {
			if (closed) {
				from -= length;
			} else {
				var tmp = from;
				from = to;
				to = tmp;
			}
		}
		if (/^(?:asymmetric|continuous)$/.test(type)) {
			var asymmetric = type === 'asymmetric',
				min = Math.min,
				amount = to - from + 1,
				n = amount - 1,
				padding = loop ? min(amount, 4) : 1,
				paddingLeft = padding,
				paddingRight = padding,
				knots = [];
			if (!closed) {
				paddingLeft = min(1, from);
				paddingRight = min(1, length - to - 1);
			}
			n += paddingLeft + paddingRight;
			if (n <= 1)
				return;
			for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
				knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
			}

			var x = knots[0]._x + 2 * knots[1]._x,
				y = knots[0]._y + 2 * knots[1]._y,
				f = 2,
				n_1 = n - 1,
				rx = [x],
				ry = [y],
				rf = [f],
				px = [],
				py = [];
			for (var i = 1; i < n; i++) {
				var internal = i < n_1,
					a = internal ? 1 : asymmetric ? 1 : 2,
					b = internal ? 4 : asymmetric ? 2 : 7,
					u = internal ? 4 : asymmetric ? 3 : 8,
					v = internal ? 2 : asymmetric ? 0 : 1,
					m = a / f;
				f = rf[i] = b - m;
				x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
				y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
			}

			px[n_1] = rx[n_1] / rf[n_1];
			py[n_1] = ry[n_1] / rf[n_1];
			for (var i = n - 2; i >= 0; i--) {
				px[i] = (rx[i] - px[i + 1]) / rf[i];
				py[i] = (ry[i] - py[i + 1]) / rf[i];
			}
			px[n] = (3 * knots[n]._x - px[n_1]) / 2;
			py[n] = (3 * knots[n]._y - py[n_1]) / 2;

			for (var i = paddingLeft, max = n - paddingRight, j = from;
					i <= max; i++, j++) {
				var segment = segments[j < 0 ? j + length : j],
					pt = segment._point,
					hx = px[i] - pt._x,
					hy = py[i] - pt._y;
				if (loop || i < max)
					segment.setHandleOut(hx, hy);
				if (loop || i > paddingLeft)
					segment.setHandleIn(-hx, -hy);
			}
		} else {
			for (var i = from; i <= to; i++) {
				segments[i < 0 ? i + length : i].smooth(opts,
						!loop && i === from, !loop && i === to);
			}
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.copyAttributes(this, true);
			shape._matrix.prepend(this._matrix);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			if (insert === undefined || insert)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	toPath: '#clone',

	compare: function compare(path) {
		if (!path || path instanceof CompoundPath)
			return compare.base.call(this, path);
		var curves1 = this.getCurves(),
			curves2 = path.getCurves(),
			length1 = curves1.length,
			length2 = curves2.length;
		if (!length1 || !length2) {
			return length1 == length2;
		}
		var v1 = curves1[0].getValues(),
			values2 = [],
			pos1 = 0, pos2,
			end1 = 0, end2;
		for (var i = 0; i < length2; i++) {
			var v2 = curves2[i].getValues();
			values2.push(v2);
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
				end2 = overlaps[0][1];
				break;
			}
		}
		var abs = Math.abs,
			epsilon = 1e-8,
			v2 = values2[pos2],
			start2;
		while (v1 && v2) {
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				var t1 = overlaps[0][0];
				if (abs(t1 - end1) < epsilon) {
					end1 = overlaps[1][0];
					if (end1 === 1) {
						v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
						end1 = 0;
					}
					var t2 = overlaps[0][1];
					if (abs(t2 - end2) < epsilon) {
						if (!start2)
							start2 = [pos2, t2];
						end2 = overlaps[1][1];
						if (end2 === 1) {
							if (++pos2 >= length2)
								pos2 = 0;
							v2 = values2[pos2] || curves2[pos2].getValues();
							end2 = 0;
						}
						if (!v1) {
							return start2[0] === pos2 && start2[1] === end2;
						}
						continue;
					}
				}
			}
			break;
		}
		return false;
	},

	_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			strokeRadius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (strokeRadius !== null) {
			if (strokeRadius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = style.getMiterLimit();
				strokePadding = strokePadding.add(
					Path._getStrokePadding(strokeRadius, strokeMatrix));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			var isJoin = closed || segment._index > 0
					&& segment._index < numSegments - 1;
			if ((isJoin ? join : cap) === 'round') {
				return isCloseEnough(segment._point, strokePadding);
			} else {
				area = new Path({ internal: true, closed: true });
				if (isJoin) {
					if (!segment.isSmooth()) {
						Path._addBevelJoin(segment, join, strokeRadius,
							   miterLimit, null, strokeMatrix, addToArea, true);
					}
				} else if (cap === 'square') {
					Path._addSquareCap(segment, cap, strokeRadius, null,
							strokeMatrix, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (strokeRadius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var time = loc.getTime();
				if (time === 0 || time === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point)
							<= miterLimit * strokeRadius
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var loc = this.getLocationAt(offset);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset) {
		if (typeof offset === 'number') {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (curves.length > 0 && offset <= this.getLength()) {
				return new CurveLocation(curves[curves.length - 1], 1);
			}
		} else if (offset && offset.getPath && offset.getPath() === this) {
			return offset;
		}
		return null;
	},

	getOffsetsWithTangent: function() {
		var tangent = Point.read(arguments);
		if (tangent.isZero()) {
			return [];
		}

		var offsets = [];
		var curveStart = 0;
		var curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var curve = curves[i];
			var curveTimes = curve.getTimesWithTangent(tangent);
			for (var j = 0, m = curveTimes.length; j < m; j++) {
				var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);
				if (offsets.indexOf(offset) < 0) {
					offsets.push(offset);
				}
			}
			curveStart += curve.length;
		}
		return offsets;
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size) {
		if (size <= 0) return;

		var half = size / 2,
			miniSize = size - 2,
			miniHalf = half - 1,
			coords = new Array(6),
			pX, pY;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i],
				selection = segment._selection;
			segment._transformCoordinates(matrix, coords);
			pX = coords[0];
			pY = coords[1];
			if (selection & 2)
				drawHandle(2);
			if (selection & 4)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (miniSize > 0 && !(selection & 1)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, viewMatrix, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx, param, viewMatrix);
				if (hasFill) {
					ctx.fill(style.getFillRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this, 0.25, 32, false,
								strokeMatrix),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (!segments.length)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				t = Base.pick(Base.read(args), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var args = arguments,
				abs = Math.abs,
				sqrt = Math.sqrt,
				current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(args),
				through,
				peek = Base.peek(args),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(args) <= 2) {
				through = to;
				to = Point.read(args);
			} else if (!from.equals(to)) {
				var radius = Size.read(args),
					isZero = Numerical.isZero;
				if (isZero(radius.width) || isZero(radius.height))
					return this.lineTo(to);
				var rotation = Base.read(args),
					clockwise = !!Base.read(args),
					large = !!Base.read(args),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq = x * x,
					ySq = y * y;
				var factor = sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1) * sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center, true);
				if (centerSide === 0) {
					extent = throughSide * abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			if (extent) {
				var epsilon = 1e-7,
					ext = abs(extent),
					count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (!i) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			}
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				parameter = Base.read(args),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var args = arguments,
				current = getCurrentSegment(this)._point,
				point = current.add(Point.read(args)),
				clockwise = Base.pick(Base.peek(args), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(args)));
			}
		},

		closePath: function(tolerance) {
			this.setClosed(true);
			this.join(this, tolerance);
		}
	};
}, {

	_getBounds: function(matrix, options) {
		var method = options.handle
				? 'getHandleBounds'
				: options.stroke
				? 'getStrokeBounds'
				: 'getBounds';
		return Path[method](this._segments, this._closed, this, matrix, options);
	},

statics: {
	getBounds: function(segments, closed, path, matrix, options, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6)),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = style.hasStroke(),
			strokeWidth = style.getStrokeWidth(),
			strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
			strokePadding = stroke && Path._getStrokePadding(strokeWidth,
				strokeMatrix),
			bounds = Path.getBounds(segments, closed, path, matrix, options,
				strokePadding);
		if (!stroke)
			return bounds;
		var strokeRadius = strokeWidth / 2,
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = style.getMiterLimit(),
			joinBounds = new Rectangle(new Size(strokePadding));

		function addPoint(point) {
			bounds = bounds.include(point);
		}

		function addRound(segment) {
			bounds = bounds.unite(
					joinBounds.setCenter(segment._point.transform(matrix)));
		}

		function addJoin(segment, join) {
			if (join === 'round' || segment.isSmooth()) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, strokeRadius, miterLimit,
						matrix, strokeMatrix, addPoint);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, strokeRadius, matrix,
						strokeMatrix, addPoint);
			}
		}

		var length = segments.length - (closed ? 0 : 1);
		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getStrokePadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var hor = new Point(radius, 0).transform(matrix),
			ver = new Point(0, radius).transform(matrix),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = Math.atan2(b * tan, a),
			ty = Math.atan2(b, tan * a);
		return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, matrix,
			strokeMatrix, addPoint, isArea) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPoint1().transform(matrix),
			normal1 = curve1.getNormalAtTime(1).multiply(radius)
				.transform(strokeMatrix),
			normal2 = curve2.getNormalAtTime(0).multiply(radius)
				.transform(strokeMatrix),
				angle = normal1.getDirectedAngle(normal2);
		if (angle < 0 || angle >= 180) {
			normal1 = normal1.negate();
			normal2 = normal2.negate();
		}
		if (isArea)
			addPoint(point);
		addPoint(point.add(normal1));
		if (join === 'miter') {
			var corner = new Line(point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit * radius) {
				addPoint(corner);
			}
		}
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,
			addPoint, isArea) {
		var point = segment._point.transform(matrix),
			loc = segment.getLocation(),
			normal = loc.getNormal()
					.multiply(loc.getTime() === 0 ? radius : -radius)
					.transform(strokeMatrix);
		if (cap === 'square') {
			if (isArea) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			point = point.add(normal.rotate(-90));
		}
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = options.stroke && style.hasStroke(),
			strokePadding,
			joinPadding;
		if (stroke) {
			var strokeMatrix = path._getStrokeMatrix(matrix, options),
				strokeRadius = style.getStrokeWidth() / 2,
				joinRadius = strokeRadius;
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
			strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
			joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
		}
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords);
			for (var j = 0; j < 6; j += 2) {
				var padding = !j ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert == false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props, { insert: true });
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			var args = arguments;
			return createPath([
				new Segment(Point.readNamed(args, 'from')),
				new Segment(Point.readNamed(args, 'to'))
			], false, args);
		},

		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createEllipse(center, new Size(radius), args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.readNamed(args, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, args);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args);
			return createEllipse(ellipse.center, ellipse.radius, args);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var args = arguments,
				from = Point.readNamed(args, 'from'),
				through = Point.readNamed(args, 'through'),
				to = Point.readNamed(args, 'to'),
				props = Base.getNamed(args),
				path = new Path(props && props.insert == false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				sides = Base.readNamed(args, 'sides'),
				radius = Base.readNamed(args, 'radius'),
				step = 360 / sides,
				three = sides % 3 === 0,
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, args);
		},

		Star: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				points = Base.readNamed(args, 'points') * 2,
				radius1 = Base.readNamed(args, 'radius1'),
				radius2 = Base.readNamed(args, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, args);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},
	beans: true,

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items) {
		var list = items,
			first = list[0];
		if (first && typeof first[0] === 'number')
			list = [list];
		for (var i = items.length - 1; i >= 0; i--) {
			var item = list[i];
			if (list === items && !(item instanceof Path))
				list = Base.slice(list);
			if (Array.isArray(item)) {
				list[i] = new Path({ segments: item, insert: false });
			} else if (item instanceof CompoundPath) {
				list.splice.apply(list, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		return insertChildren.base.call(this, index, list);
	},

	reduce: function reduce(options) {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce(options);
			if (path.isEmpty())
				path.remove();
		}
		if (!children.length) {
			var path = new Path(Item.NO_INSERT);
			path.copyAttributes(this);
			path.insertAbove(this);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClosed: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			if (!children[i]._closed)
				return false;
		}
		return true;
	},

	setClosed: function(closed) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].setClosed(closed);
		}
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++) {
			Base.push(curves, children[i].getCurves());
		}
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getLastCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	},

	getLength: function() {
		var children = this._children,
			length = 0;
		for (var i = 0, l = children.length; i < l; i++)
			length += children[i].getLength();
		return length;
	},

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.appended(mx) : _matrix, _precision));
		}
		return paths.join('');
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		return _hitTestChildren.base.call(this, point,
				options.class === Path || options.type === 'path' ? options
					: Base.set({}, options, { fill: false }),
				viewMatrix);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var children = this._children;
		if (!children.length)
			return;

		param = param.extend({ dontStart: true, dontFinish: true });
		ctx.beginPath();
		for (var i = 0, l = children.length; i < l; i++)
			children[i].draw(ctx, param, strokeMatrix);

		if (!param.clip) {
			this._setStyles(ctx, param, viewMatrix);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectionItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectionItems[child._id]) {
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.appended(mx));
			}
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && !children.length)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',
			'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',
			'arcBy'],
		function(key) {
			this[key] = function() {
				var path = getCurrentPath(this, true);
				path[key].apply(path, arguments);
			};
		}, {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current
							: new Path(Item.NO_INSERT);
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},

			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},

			closePath: function(tolerance) {
				getCurrentPath(this, true).closePath(tolerance);
			}
		}
	);
}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {
	this[key] = function(param) {
		var children = this._children,
			res;
		for (var i = 0, l = children.length; i < l; i++) {
			res = children[i][key](param) || res;
		}
		return res;
	};
}, {}));

PathItem.inject(new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		operators = {
			unite:     { '1': true, '2': true },
			intersect: { '2': true },
			subtract:  { '1': true },
			exclude:   { '1': true, '-1': true }
		};

	function getPaths(path) {
		return path._children || [path];
	}

	function preparePath(path, resolve) {
		var res = path
			.clone(false)
			.reduce({ simplify: true })
			.transform(null, true, true);
		if (resolve) {
			var paths = getPaths(res);
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				if (!path._closed && !path.isEmpty()) {
					path.closePath(1e-12);
					path.getFirstSegment().setHandleIn(0, 0);
					path.getLastSegment().setHandleOut(0, 0);
				}
			}
			res = res
				.resolveCrossings()
				.reorient(res.getFillRule() === 'nonzero', true);
		}
		return res;
	}

	function createResult(paths, simplify, path1, path2, options) {
		var result = new CompoundPath(Item.NO_INSERT);
		result.addChildren(paths, true);
		result = result.reduce({ simplify: simplify });
		if (!(options && options.insert == false)) {
			result.insertAbove(path2 && path1.isSibling(path2)
					&& path1.getIndex() < path2.getIndex() ? path2 : path1);
		}
		result.copyAttributes(path1, true);
		return result;
	}

	function filterIntersection(inter) {
		return inter.hasOverlap() || inter.isCrossing();
	}

	function traceBoolean(path1, path2, operation, options) {
		if (options && (options.trace == false || options.stroke) &&
				/^(subtract|intersect)$/.test(operation))
			return splitBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true),
			operator = operators[operation];
		operator[operation] = true;
		if (_path2 && (operator.subtract || operator.exclude)
				^ (_path2.isClockwise() ^ _path1.isClockwise()))
			_path2.reverse();
		var crossings = divideLocations(CurveLocation.expand(
				_path1.getIntersections(_path2, filterIntersection))),
			paths1 = getPaths(_path1),
			paths2 = _path2 && getPaths(_path2),
			segments = [],
			curves = [],
			paths;

		function collectPaths(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				Base.push(segments, path._segments);
				Base.push(curves, path.getCurves());
				path._overlapsOnly = true;
			}
		}

		function getCurves(indices) {
			var list = [];
			for (var i = 0, l = indices && indices.length; i < l; i++) {
				list.push(curves[indices[i]]);
			}
			return list;
		}

		if (crossings.length) {
			collectPaths(paths1);
			if (paths2)
				collectPaths(paths2);

			var curvesValues = new Array(curves.length);
			for (var i = 0, l = curves.length; i < l; i++) {
				curvesValues[i] = curves[i].getValues();
			}
			var curveCollisions = CollisionDetection.findCurveBoundsCollisions(
					curvesValues, curvesValues, 0, true);
			var curveCollisionsMap = {};
			for (var i = 0; i < curves.length; i++) {
				var curve = curves[i],
					id = curve._path._id,
					map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
				map[curve.getIndex()] = {
					hor: getCurves(curveCollisions[i].hor),
					ver: getCurves(curveCollisions[i].ver)
				};
			}

			for (var i = 0, l = crossings.length; i < l; i++) {
				propagateWinding(crossings[i]._segment, _path1, _path2,
						curveCollisionsMap, operator);
			}
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i],
					inter = segment._intersection;
				if (!segment._winding) {
					propagateWinding(segment, _path1, _path2,
							curveCollisionsMap, operator);
				}
				if (!(inter && inter._overlap))
					segment._path._overlapsOnly = false;
			}
			paths = tracePaths(segments, operator);
		} else {
			paths = reorientPaths(
					paths2 ? paths1.concat(paths2) : paths1.slice(),
					function(w) {
						return !!operator[w];
					});
		}
		return createResult(paths, true, path1, path2, options);
	}

	function splitBoolean(path1, path2, operation) {
		var _path1 = preparePath(path1),
			_path2 = preparePath(path2),
			crossings = _path1.getIntersections(_path2, filterIntersection),
			subtract = operation === 'subtract',
			divide = operation === 'divide',
			added = {},
			paths = [];

		function addPath(path) {
			if (!added[path._id] && (divide ||
					_path2.contains(path.getPointAt(path.getLength() / 2))
						^ subtract)) {
				paths.unshift(path);
				return added[path._id] = true;
			}
		}

		for (var i = crossings.length - 1; i >= 0; i--) {
			var path = crossings[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return createResult(paths, false, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._previous;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._previous)
				to = to._previous;
			from._next = to;
			to._previous = from;
		}
	}

	function clearCurveHandles(curves) {
		for (var i = curves.length - 1; i >= 0; i--)
			curves[i].clearHandles();
	}

	function reorientPaths(paths, isInside, clockwise) {
		var length = paths && paths.length;
		if (length) {
			var lookup = Base.each(paths, function (path, i) {
					this[path._id] = {
						container: null,
						winding: path.isClockwise() ? 1 : -1,
						index: i
					};
				}, {}),
				sorted = paths.slice().sort(function (a, b) {
					return abs(b.getArea()) - abs(a.getArea());
				}),
				first = sorted[0];
			var collisions = CollisionDetection.findItemBoundsCollisions(sorted,
					null, Numerical.GEOMETRIC_EPSILON);
			if (clockwise == null)
				clockwise = first.isClockwise();
			for (var i = 0; i < length; i++) {
				var path1 = sorted[i],
					entry1 = lookup[path1._id],
					containerWinding = 0,
					indices = collisions[i];
				if (indices) {
					var point = null;
					for (var j = indices.length - 1; j >= 0; j--) {
						if (indices[j] < i) {
							point = point || path1.getInteriorPoint();
							var path2 = sorted[indices[j]];
							if (path2.contains(point)) {
								var entry2 = lookup[path2._id];
								containerWinding = entry2.winding;
								entry1.winding += containerWinding;
								entry1.container = entry2.exclude
									? entry2.container : path2;
								break;
							}
						}
					}
				}
				if (isInside(entry1.winding) === isInside(containerWinding)) {
					entry1.exclude = true;
					paths[entry1.index] = null;
				} else {
					var container = entry1.container;
					path1.setClockwise(
							container ? !container.isClockwise() : clockwise);
				}
			}
		}
		return paths;
	}

	function divideLocations(locations, include, clearLater) {
		var results = include && [],
			tMin = 1e-8,
			tMax = 1 - tMin,
			clearHandles = false,
			clearCurves = clearLater || [],
			clearLookup = clearLater && {},
			renormalizeLocs,
			prevCurve,
			prevTime;

		function getId(curve) {
			return curve._path._id + '.' + curve._segment1._index;
		}

		for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
			var curve = clearLater[i];
			if (curve._path)
				clearLookup[getId(curve)] = true;
		}

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				time = loc._time,
				origTime = time,
				exclude = include && !include(loc),
				curve = loc._curve,
				segment;
			if (curve) {
				if (curve !== prevCurve) {
					clearHandles = !curve.hasHandles()
							|| clearLookup && clearLookup[getId(curve)];
					renormalizeLocs = [];
					prevTime = null;
					prevCurve = curve;
				} else if (prevTime >= tMin) {
					time /= prevTime;
				}
			}
			if (exclude) {
				if (renormalizeLocs)
					renormalizeLocs.push(loc);
				continue;
			} else if (include) {
				results.unshift(loc);
			}
			prevTime = origTime;
			if (time < tMin) {
				segment = curve._segment1;
			} else if (time > tMax) {
				segment = curve._segment2;
			} else {
				var newCurve = curve.divideAtTime(time, true);
				if (clearHandles)
					clearCurves.push(curve, newCurve);
				segment = newCurve._segment1;
				for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
					var l = renormalizeLocs[j];
					l._time = (l._time - time) / (1 - time);
				}
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
		}
		if (!clearLater)
			clearCurveHandles(clearCurves);
		return results || locations;
	}

	function getWinding(point, curves, dir, closed, dontFlip) {
		var curvesList = Array.isArray(curves)
			? curves
			: curves[dir ? 'hor' : 'ver'];
		var ia = dir ? 1 : 0,
			io = ia ^ 1,
			pv = [point.x, point.y],
			pa = pv[ia],
			po = pv[io],
			windingEpsilon = 1e-9,
			qualityEpsilon = 1e-6,
			paL = pa - windingEpsilon,
			paR = pa + windingEpsilon,
			windingL = 0,
			windingR = 0,
			pathWindingL = 0,
			pathWindingR = 0,
			onPath = false,
			onAnyPath = false,
			quality = 1,
			roots = [],
			vPrev,
			vClose;

		function addWinding(v) {
			var o0 = v[io + 0],
				o3 = v[io + 6];
			if (po < min(o0, o3) || po > max(o0, o3)) {
				return;
			}
			var a0 = v[ia + 0],
				a1 = v[ia + 2],
				a2 = v[ia + 4],
				a3 = v[ia + 6];
			if (o0 === o3) {
				if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
					onPath = true;
				}
				return;
			}
			var t =   po === o0 ? 0
					: po === o3 ? 1
					: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)
					? 1
					: Curve.solveCubic(v, io, po, roots, 0, 1) > 0
						? roots[0]
						: 1,
				a =   t === 0 ? a0
					: t === 1 ? a3
					: Curve.getPoint(v, t)[dir ? 'y' : 'x'],
				winding = o0 > o3 ? 1 : -1,
				windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
				a3Prev = vPrev[ia + 6];
			if (po !== o0) {
				if (a < paL) {
					pathWindingL += winding;
				} else if (a > paR) {
					pathWindingR += winding;
				} else {
					onPath = true;
				}
				if (a > pa - qualityEpsilon && a < pa + qualityEpsilon)
					quality /= 2;
			} else {
				if (winding !== windingPrev) {
					if (a0 < paL) {
						pathWindingL += winding;
					} else if (a0 > paR) {
						pathWindingR += winding;
					}
				} else if (a0 != a3Prev) {
					if (a3Prev < paR && a > paR) {
						pathWindingR += winding;
						onPath = true;
					} else if (a3Prev > paL && a < paL) {
						pathWindingL += winding;
						onPath = true;
					}
				}
				quality /= 4;
			}
			vPrev = v;
			return !dontFlip && a > paL && a < paR
					&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0
					&& getWinding(point, curves, !dir, closed, true);
		}

		function handleCurve(v) {
			var o0 = v[io + 0],
				o1 = v[io + 2],
				o2 = v[io + 4],
				o3 = v[io + 6];
			if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
				var a0 = v[ia + 0],
					a1 = v[ia + 2],
					a2 = v[ia + 4],
					a3 = v[ia + 6],
					monoCurves = paL > max(a0, a1, a2, a3) ||
								 paR < min(a0, a1, a2, a3)
							? [v] : Curve.getMonoCurves(v, dir),
					res;
				for (var i = 0, l = monoCurves.length; i < l; i++) {
					if (res = addWinding(monoCurves[i]))
						return res;
				}
			}
		}

		for (var i = 0, l = curvesList.length; i < l; i++) {
			var curve = curvesList[i],
				path = curve._path,
				v = curve.getValues(),
				res;
			if (!i || curvesList[i - 1]._path !== path) {
				vPrev = null;
				if (!path._closed) {
					vClose = Curve.getValues(
							path.getLastCurve().getSegment2(),
							curve.getSegment1(),
							null, !closed);
					if (vClose[io] !== vClose[io + 6]) {
						vPrev = vClose;
					}
				}

				if (!vPrev) {
					vPrev = v;
					var prev = path.getLastCurve();
					while (prev && prev !== curve) {
						var v2 = prev.getValues();
						if (v2[io] !== v2[io + 6]) {
							vPrev = v2;
							break;
						}
						prev = prev.getPrevious();
					}
				}
			}

			if (res = handleCurve(v))
				return res;

			if (i + 1 === l || curvesList[i + 1]._path !== path) {
				if (vClose && (res = handleCurve(vClose)))
					return res;
				if (onPath && !pathWindingL && !pathWindingR) {
					pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir
							? 1 : -1;
				}
				windingL += pathWindingL;
				windingR += pathWindingR;
				pathWindingL = pathWindingR = 0;
				if (onPath) {
					onAnyPath = true;
					onPath = false;
				}
				vClose = null;
			}
		}
		windingL = abs(windingL);
		windingR = abs(windingR);
		return {
			winding: max(windingL, windingR),
			windingL: windingL,
			windingR: windingR,
			quality: quality,
			onPath: onAnyPath
		};
	}

	function propagateWinding(segment, path1, path2, curveCollisionsMap,
			operator) {
		var chain = [],
			start = segment,
			totalLength = 0,
			winding;
		do {
			var curve = segment.getCurve();
			if (curve) {
				var length = curve.getLength();
				chain.push({ segment: segment, curve: curve, length: length });
				totalLength += length;
			}
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		var offsets = [0.5, 0.25, 0.75],
			winding = { winding: 0, quality: -1 },
			tMin = 1e-3,
			tMax = 1 - tMin;
		for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
			var length = totalLength * offsets[i];
			for (var j = 0, l = chain.length; j < l; j++) {
				var entry = chain[j],
					curveLength = entry.length;
				if (length <= curveLength) {
					var curve = entry.curve,
						path = curve._path,
						parent = path._parent,
						operand = parent instanceof CompoundPath ? parent : path,
						t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
						pt = curve.getPointAtTime(t),
						dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
					var wind = null;
					if (operator.subtract && path2) {
						var otherPath = operand === path1 ? path2 : path1,
							pathWinding = otherPath._getWinding(pt, dir, true);
						if (operand === path1 && pathWinding.winding ||
							operand === path2 && !pathWinding.winding) {
							if (pathWinding.quality < 1) {
								continue;
							} else {
								wind = { winding: 0, quality: 1 };
							}
						}
					}
					wind =  wind || getWinding(
							pt, curveCollisionsMap[path._id][curve.getIndex()],
							dir, true);
					if (wind.quality > winding.quality)
						winding = wind;
					break;
				}
				length -= curveLength;
			}
		}
		for (var j = chain.length - 1; j >= 0; j--) {
			chain[j].segment._winding = winding;
		}
	}

	function tracePaths(segments, operator) {
		var paths = [],
			starts;

		function isValid(seg) {
			var winding;
			return !!(seg && !seg._visited && (!operator
					|| operator[(winding = seg._winding || {}).winding]
						&& !(operator.unite && winding.winding === 2
							&& winding.windingL && winding.windingR)));
		}

		function isStart(seg) {
			if (seg) {
				for (var i = 0, l = starts.length; i < l; i++) {
					if (seg === starts[i])
						return true;
				}
			}
			return false;
		}

		function visitPath(path) {
			var segments = path._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				segments[i]._visited = true;
			}
		}

		function getCrossingSegments(segment, collectStarts) {
			var inter = segment._intersection,
				start = inter,
				crossings = [];
			if (collectStarts)
				starts = [segment];

			function collect(inter, end) {
				while (inter && inter !== end) {
					var other = inter._segment,
						path = other && other._path;
					if (path) {
						var next = other.getNext() || path.getFirstSegment(),
							nextInter = next._intersection;
						if (other !== segment && (isStart(other)
							|| isStart(next)
							|| next && (isValid(other) && (isValid(next)
								|| nextInter && isValid(nextInter._segment))))
						) {
							crossings.push(other);
						}
						if (collectStarts)
							starts.push(other);
					}
					inter = inter._next;
				}
			}

			if (inter) {
				collect(inter);
				while (inter && inter._prev)
					inter = inter._prev;
				collect(inter, start);
			}
			return crossings;
		}

		segments.sort(function(seg1, seg2) {
			var inter1 = seg1._intersection,
				inter2 = seg2._intersection,
				over1 = !!(inter1 && inter1._overlap),
				over2 = !!(inter2 && inter2._overlap),
				path1 = seg1._path,
				path2 = seg2._path;
			return over1 ^ over2
					? over1 ? 1 : -1
					: !inter1 ^ !inter2
						? inter1 ? 1 : -1
						: path1 !== path2
							? path1._id - path2._id
							: seg1._index - seg2._index;
		});

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				valid = isValid(seg),
				path = null,
				finished = false,
				closed = true,
				branches = [],
				branch,
				visited,
				handleIn;
			if (valid && seg._path._overlapsOnly) {
				var path1 = seg._path,
					path2 = seg._intersection._segment._path;
				if (path1.compare(path2)) {
					if (path1.getArea())
						paths.push(path1.clone(false));
					visitPath(path1);
					visitPath(path2);
					valid = false;
				}
			}
			while (valid) {
				var first = !path,
					crossings = getCrossingSegments(seg, first),
					other = crossings.shift(),
					finished = !first && (isStart(seg) || isStart(other)),
					cross = !finished && other;
				if (first) {
					path = new Path(Item.NO_INSERT);
					branch = null;
				}
				if (finished) {
					if (seg.isFirst() || seg.isLast())
						closed = seg._path._closed;
					seg._visited = true;
					break;
				}
				if (cross && branch) {
					branches.push(branch);
					branch = null;
				}
				if (!branch) {
					if (cross)
						crossings.push(seg);
					branch = {
						start: path._segments.length,
						crossings: crossings,
						visited: visited = [],
						handleIn: handleIn
					};
				}
				if (cross)
					seg = other;
				if (!isValid(seg)) {
					path.removeSegments(branch.start);
					for (var j = 0, k = visited.length; j < k; j++) {
						visited[j]._visited = false;
					}
					visited.length = 0;
					do {
						seg = branch && branch.crossings.shift();
						if (!seg || !seg._path) {
							seg = null;
							branch = branches.pop();
							if (branch) {
								visited = branch.visited;
								handleIn = branch.handleIn;
							}
						}
					} while (branch && !isValid(seg));
					if (!seg)
						break;
				}
				var next = seg.getNext();
				path.add(new Segment(seg._point, handleIn,
						next && seg._handleOut));
				seg._visited = true;
				visited.push(seg);
				seg = next || seg._path.getFirstSegment();
				handleIn = next && next._handleIn;
			}
			if (finished) {
				if (closed) {
					path.getFirstSegment().setHandleIn(handleIn);
					path.setClosed(closed);
				}
				if (path.getArea() !== 0) {
					paths.push(path);
				}
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, dir, closed) {
			return getWinding(point, this.getCurves(), dir, closed);
		},

		unite: function(path, options) {
			return traceBoolean(this, path, 'unite', options);
		},

		intersect: function(path, options) {
			return traceBoolean(this, path, 'intersect', options);
		},

		subtract: function(path, options) {
			return traceBoolean(this, path, 'subtract', options);
		},

		exclude: function(path, options) {
			return traceBoolean(this, path, 'exclude', options);
		},

		divide: function(path, options) {
			return options && (options.trace == false || options.stroke)
					? splitBoolean(this, path, 'divide')
					: createResult([
						this.subtract(path, options),
						this.intersect(path, options)
					], true, this, path, options);
		},

		resolveCrossings: function() {
			var children = this._children,
				paths = children || [this];

			function hasOverlap(seg, path) {
				var inter = seg && seg._intersection;
				return inter && inter._overlap && inter._path === path;
			}

			var hasOverlaps = false,
				hasCrossings = false,
				intersections = this.getIntersections(null, function(inter) {
					return inter.hasOverlap() && (hasOverlaps = true) ||
							inter.isCrossing() && (hasCrossings = true);
				}),
				clearCurves = hasOverlaps && hasCrossings && [];
			intersections = CurveLocation.expand(intersections);
			if (hasOverlaps) {
				var overlaps = divideLocations(intersections, function(inter) {
					return inter.hasOverlap();
				}, clearCurves);
				for (var i = overlaps.length - 1; i >= 0; i--) {
					var overlap = overlaps[i],
						path = overlap._path,
						seg = overlap._segment,
						prev = seg.getPrevious(),
						next = seg.getNext();
					if (hasOverlap(prev, path) && hasOverlap(next, path)) {
						seg.remove();
						prev._handleOut._set(0, 0);
						next._handleIn._set(0, 0);
						if (prev !== seg && !prev.getCurve().hasLength()) {
							next._handleIn.set(prev._handleIn);
							prev.remove();
						}
					}
				}
			}
			if (hasCrossings) {
				divideLocations(intersections, hasOverlaps && function(inter) {
					var curve1 = inter.getCurve(),
						seg1 = inter.getSegment(),
						other = inter._intersection,
						curve2 = other._curve,
						seg2 = other._segment;
					if (curve1 && curve2 && curve1._path && curve2._path)
						return true;
					if (seg1)
						seg1._intersection = null;
					if (seg2)
						seg2._intersection = null;
				}, clearCurves);
				if (clearCurves)
					clearCurveHandles(clearCurves);
				paths = tracePaths(Base.each(paths, function(path) {
					Base.push(this, path._segments);
				}, []));
			}
			var length = paths.length,
				item;
			if (length > 1 && children) {
				if (paths !== children)
					this.setChildren(paths);
				item = this;
			} else if (length === 1 && !children) {
				if (paths[0] !== this)
					this.setSegments(paths[0].removeSegments());
				item = this;
			}
			if (!item) {
				item = new CompoundPath(Item.NO_INSERT);
				item.addChildren(paths);
				item = item.reduce();
				item.copyAttributes(this);
				this.replaceWith(item);
			}
			return item;
		},

		reorient: function(nonZero, clockwise) {
			var children = this._children;
			if (children && children.length) {
				this.setChildren(reorientPaths(this.removeChildren(),
						function(w) {
							return !!(nonZero ? w : w & 1);
						},
						clockwise));
			} else if (clockwise !== undefined) {
				this.setClockwise(clockwise);
			}
			return this;
		},

		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this.getCurves(),
					y = point.y,
					intercepts = [],
					roots = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var v = curves[i].getValues(),
						o0 = v[1],
						o1 = v[3],
						o2 = v[5],
						o3 = v[7];
					if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
						var monoCurves = Curve.getMonoCurves(v);
						for (var j = 0, m = monoCurves.length; j < m; j++) {
							var mv = monoCurves[j],
								mo0 = mv[1],
								mo3 = mv[7];
							if ((mo0 !== mo3) &&
								(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){
								var x = y === mo0 ? mv[0]
									: y === mo3 ? mv[6]
									: Curve.solveCubic(mv, 1, y, roots, 0, 1)
										=== 1
										? Curve.getPoint(mv, roots[0]).x
										: (mv[0] + mv[6]) / 2;
								intercepts.push(x);
							}
						}
					}
				}
				if (intercepts.length > 1) {
					intercepts.sort(function(a, b) { return a - b; });
					point.x = (intercepts[0] + intercepts[1]) / 2;
				}
			}
			return point;
		}
	};
});

var PathFlattener = Base.extend({
	_class: 'PathFlattener',

	initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minSpan = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, t1, t2) {
			if ((t2 - t1) > minSpan
					&& !(ignoreStraight && Curve.isStraight(curve))
					&& !Curve.isFlatEnough(curve, flatness || 0.25)) {
				var halves = Curve.subdivide(curve, 0.5),
					tMid = (t1 + t2) / 2;
				computeParts(halves[0], index, t1, tMid);
				computeParts(halves[1], index, tMid, t2);
			} else {
				var dx = curve[6] - curve[0],
					dy = curve[7] - curve[1],
					dist = Math.sqrt(dx * dx + dy * dy);
				if (dist > 0) {
					length += dist;
					parts.push({
						offset: length,
						curve: curve,
						index: index,
						time: t2,
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2 || segment1, segments[0]);
		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	_get: function(offset) {
		var parts = this.parts,
			length = parts.length,
			start,
			i, j = this.index;
		for (;;) {
			i = j;
			if (!j || parts[--j].offset < offset)
				break;
		}
		for (; i < length; i++) {
			var part = parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = parts[i - 1],
					prevTime = prev && prev.index === part.index ? prev.time : 0,
					prevOffset = prev ? prev.offset : 0;
				return {
					index: part.index,
					time: prevTime + (part.time - prevTime)
						* (offset - prevOffset) / (part.offset - prevOffset)
				};
			}
		}
		return {
			index: parts[length - 1].index,
			time: 1
		};
	},

	drawPart: function(ctx, from, to) {
		var start = this._get(from),
			end = this._get(to);
		for (var i = start.index, l = end.index; i <= l; i++) {
			var curve = Curve.getPart(this.curves[i],
					i === start.index ? start.time : 0,
					i === end.index ? end.time : 1);
			if (i === start.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var param = this._get(offset);
			return Curve[name](this.curves[param.index], param.time);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path) {
		var points = this.points = [],
			segments = path._segments,
			closed = path._closed;
		for (var i = 0, prev, l = segments.length; i < l; i++) {
			var point = segments[i].point;
			if (!prev || !prev.equals(point)) {
				points.push(prev = point.clone());
			}
		}
		if (closed) {
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}
		this.closed = closed;
	},

	fit: function(error) {
		var points = this.points,
			length = points.length,
			segments = null;
		if (length > 0) {
			segments = [new Segment(points[0])];
			if (length > 1) {
				this.fitCubic(segments, error, 0, length - 1,
						points[1].subtract(points[0]),
						points[length - 2].subtract(points[length - 1]));
				if (this.closed) {
					segments.shift();
					segments.pop();
				}
			}
		}
		return segments;
	},

	fitCubic: function(segments, error, first, last, tan1, tan2) {
		var points = this.points;
		if (last - first === 1) {
			var pt1 = points[first],
				pt2 = points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(error, error * error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < error && parametersInOrder) {
				this.addCurve(segments, curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var tanCenter = points[split - 1].subtract(points[split + 1]);
		this.fitCubic(segments, error, first, split, tan1, tanCenter);
		this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(segments, curve) {
		var prev = segments[segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			abs = Math.abs,
			points = this.points,
			pt1 = points[first],
			pt2 = points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1,
			alpha2;
		if (abs(detC0C1) > epsilon) {
			var detC0X = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0
							: abs(c1) > epsilon ? X[1] / c1
							: 0;
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1,
				pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)),
				pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsOptions: { stroke: false, handle: false },

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	copyContent: function(source) {
		this.setContent(source._content);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(521);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx, param, viewMatrix) {
		if (!this._content)
			return;
		this._setStyles(ctx, param, viewMatrix);
		var lines = this._lines,
			style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (hasFill) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(matrix, options) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var rect = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(rect, rect) : rect;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		namedColors = {
			transparent: [0, 0, 0, 0]
		},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(
				/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
			) || string.match(
				/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
			),
			type = 'rgb',
			components;
		if (match) {
			var amount = match[4] ? 4 : 3;
			components = new Array(amount);
			for (var i = 0; i < amount; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
			type = match[1];
			components = match[2].trim().split(/[,\s]+/g);
			var isHSL = type === 'hsl';
			for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
				var component = components[i];
				var value = parseFloat(component);
				if (isHSL) {
					if (i === 0) {
						var unit = component.match(/([a-z]*)$/)[1];
						value *= ({
							turn: 360,
							rad: 180 / Math.PI,
							grad: 0.9
						}[unit] || 1);
					} else if (i < 3) {
						value /= 100;
					}
				} else if (i < 3) {
					value /= /%$/.test(component) ? 100 : 255;
				}
				components[i] = value;
			}
		} else {
			var color = namedColors[string];
			if (!color) {
				if (window) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					color = namedColors[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				} else {
					color = [0, 0, 0];
				}
			}
			components = color.slice();
		}
		return [type, components];
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = type === 'gradient'
					? name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(
								Array.isArray(value)
									? value
									: arguments, 0, { readNull: true }
							);
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
					: function(value) {
						return value == null || isNaN(value) ? 0 : +value;
					};
			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var args = arguments,
				reading = this.__read,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (reading)
						read = 1;
					args = Base.slice(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (reading) {
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					}
					if (values.length > length)
						values = Base.slice(values, 0, length);
				} else if (argType === 'string') {
					var converted = fromCSS(arg);
					type = converted[0];
					components = converted[1];
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && !i && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (reading && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (reading)
				this.__read = read;
			return this;
		},

		set: '#initialize',

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner) {
				if (this._setter) {
					this._owner[this._setter](this);
				} else {
					this._owner._changed(129);
				}
			}
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this.getAlpha() === col.getAlpha()
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx, matrix) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				highlight = components[3],
				inverse = matrix && matrix.inverted(),
				canvasGradient;
			if (inverse) {
				origin = inverse._transformPoint(origin);
				destination = inverse._transformPoint(destination);
				if (highlight)
					highlight = inverse._transformPoint(highlight);
			}
			if (gradient._radial) {
				var radius = destination.getDistance(origin);
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					offset = stop._offset;
				canvasGradient.addColorStop(
						offset == null ? i / (l - 1) : offset,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			},

			_setOwner: function(color, owner, setter) {
				if (color) {
					if (color._owner && owner && color._owner !== owner) {
						color = color.clone();
					}
					if (!color._owner ^ !owner) {
						color._owner = owner || null;
						color._setter = setter || null;
					}
				}
				return color;
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && Base.isPlainObject(stops)) {
			this.set(stops);
			stops = radial = null;
		}
		if (this._stops == null) {
			this.setStops(stops || ['white', 'black']);
		}
		if (this._radial == null) {
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
		}
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
			this._owners[i]._changed();
		}
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (!this._owners.length)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++) {
			stops[i] = this._stops[i].clone();
		}
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (stops.length < 2) {
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		}
		var _stops = this._stops;
		if (_stops) {
			for (var i = 0, l = _stops.length; i < l; i++)
				_stops[i]._owner = undefined;
		}
		_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
		for (var i = 0, l = _stops.length; i < l; i++)
			_stops[i]._owner = this;
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class) {
			var stops1 = this._stops,
				stops2 = gradient._stops,
				length = stops1.length;
			if (length === stops2.length) {
				for (var i = 0; i < length; i++) {
					if (!stops1[i].equals(stops2[i]))
						return false;
				}
				return true;
			}
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		var color = arg0,
			offset = arg1;
		if (typeof arg0 === 'object' && arg1 === undefined) {
			if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
				color = arg0[0];
				offset = arg0[1];
			} else if ('color' in arg0 || 'offset' in arg0
					|| 'rampPoint' in arg0) {
				color = arg0.color;
				offset = arg0.offset || arg0.rampPoint || 0;
			}
		}
		this.setColor(color);
		this.setOffset(offset);
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._offset);
	},

	_serialize: function(options, dictionary) {
		var color = this._color,
			offset = this._offset;
		return Base.serialize(offset == null ? [color] : [color, offset],
				options, true, dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(129);
	},

	getOffset: function() {
		return this._offset;
	},

	setOffset: function(offset) {
		this._offset = offset;
		this._changed();
	},

	getRampPoint: '#getOffset',
	setRampPoint: '#setOffset',

	getColor: function() {
		return this._color;
	},

	setColor: function() {
		Color._setOwner(this._color, null);
		this._color = Color._setOwner(Color.read(arguments, 0), this,
				'setColor');
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._offset == stop._offset
				|| false;
	}
});

var Style = Base.extend(new function() {
	var itemDefaults = {
		fillColor: null,
		fillRule: 'nonzero',
		strokeColor: null,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		shadowColor: null,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: null
	},
	groupDefaults = Base.set({}, itemDefaults, {
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		leading: null,
		justification: 'left'
	}),
	textDefaults = Base.set({}, groupDefaults, {
		fillColor: new Color()
	}),
	flags = {
		strokeWidth: 193,
		strokeCap: 193,
		strokeJoin: 193,
		strokeScaling: 201,
		miterLimit: 193,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	},
	item = {
		beans: true
	},
	fields = {
		_class: 'Style',
		beans: true,

		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project
					|| paper.project;
			this._defaults = !_owner || _owner instanceof Group ? groupDefaults
					: _owner instanceof TextItem ? textDefaults
					: itemDefaults;
			if (style)
				this.set(style);
		}
	};

	Base.each(groupDefaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath);
			if (applyToChildren) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			}
			if ((key === 'selectedColor' || !applyToChildren)
					&& key in this._defaults) {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old) {
							Color._setOwner(old, null);
							old._canvasStyle = null;
						}
						if (value && value.constructor === Color) {
							value = Color._setOwner(value, owner,
									applyToChildren && set);
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 129);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath),
				value;
			if (applyToChildren && !_dontMerge) {
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (!i) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
			} else if (key in this._defaults) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone) {
						value = value.clone();
					}
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
					}
				}
			}
			if (value && isColor) {
				value = Color._setOwner(value, owner, applyToChildren && set);
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Base.each({
		Font: 'FontFamily',
		WindingRule: 'FillRule'
	}, function(value, key) {
		var get = 'get' + key,
			set = 'set' + key;
		fields[get] = item[get] = '#get' + value;
		fields[set] = item[set] = '#set' + value;
	});

	Item.inject(item);
	return fields;
}, {
	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		function compare(style1, style2, secondary) {
			var values1 = style1._values,
				values2 = style2._values,
				defaults2 = style2._defaults;
			for (var key in values1) {
				var value1 = values1[key],
					value2 = values2[key];
				if (!(secondary && key in values2) && !Base.equals(value1,
						value2 === undefined ? defaults2[key] : value2))
					return false;
			}
			return true;
		}

		return style === this || style && this._class === style._class
				&& compare(this, style)
				&& compare(style, this, true)
				|| false;
	},

	_dispose: function() {
		var color;
		color = this.getFillColor();
		if (color) color._canvasStyle = null;
		color = this.getStrokeColor();
		if (color) color._canvasStyle = null;
		color = this.getShadowColor();
		if (color) color._canvasStyle = null;
	},

	hasFill: function() {
		var color = this.getFillColor();
		return !!color && color.alpha > 0;
	},

	hasStroke: function() {
		var color = this.getStrokeColor();
		return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		var color = this.getShadowColor();
		return !!color && color.alpha > 0 && (this.getShadowBlur() > 0
				|| !this.getShadowOffset().isZero());
	},

	getView: function() {
		return this._project._view;
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		isInserted: function(el) {
			return document.body.contains(el);
		},

		getPrefixed: function(el, name) {
			return el && handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++) {
					var name = parts[i];
					var options = (
						el === document
						&& (name === 'touchstart' || name === 'touchmove')
					) ? { passive: false } : false;
					el.addEventListener(name, func, options);
				}
			}
		}
	},

	remove: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		timer;

	function handleCallbacks() {
		var functions = callbacks;
		callbacks = [];
		for (var i = 0, l = functions.length; i < l; i++)
			functions[i]();
		requested = nativeRequest && callbacks.length;
		if (requested)
			nativeRequest(handleCallbacks);
	}

	return function(callback) {
		callbacks.push(callback);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		}

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		}

		var size;
		if (window && element) {
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userDrag: none,
				userSelect: none,
				touchCallout: none,
				contentZooming: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});

			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}

			size = getCanvasSize();

			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
		} else {
			size = new Size(element);
			element = null;
		}
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		if (!this._pixelRatio)
			this._pixelRatio = window && window.devicePixelRatio || 1;
		this._setElementSize(size.width, size.height);
		this._viewSize = size;
		View._views.push(this);
		View._viewsById[this._id] = this;
		(this._matrix = new Matrix())._owner = this;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
		this._itemEvents = { native: {}, virtual: {} };
		this._autoUpdate = !paper.agent.node;
		this._needsUpdate = false;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		var project = this._project;
		if (project._view === this)
			project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(
		Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),
		function(name) {
			this[name] = {};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	getAutoUpdate: function() {
		return this._autoUpdate;
	},

	setAutoUpdate: function(autoUpdate) {
		this._autoUpdate = autoUpdate;
		if (autoUpdate)
			this.requestUpdate();
	},

	update: function() {
	},

	draw: function() {
		this.update();
	},

	requestUpdate: function() {
		if (!this._requested) {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (that._animate) {
					that.requestUpdate();
					var element = that._element;
					if ((!DomElement.getPrefixed(document, 'hidden')
							|| PaperScope.getAttribute(element, 'keepalive')
								=== 'true') && DomElement.isInView(element)) {
						that._handleFrame();
					}
				}
				if (that._autoUpdate)
					that.update();
			});
			this._requested = true;
		}
	},

	play: function() {
		this._animate = true;
		this.requestUpdate();
	},

	pause: function() {
		this._animate = false;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._last ? now - this._last : 0;
		this._last = now;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_changed: function() {
		this._project._changed(4097);
		this._bounds = this._decomposed = undefined;
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._setElementSize(size.width, size.height);
		this._viewSize.set(size);
		this._changed();
		this.emit('resize', { size: size, delta: delta });
		if (this._autoUpdate) {
			this.update();
		}
	},

	_setElementSize: function(width, height) {
		var element = this._element;
		if (element) {
			if (element.width !== width)
				element.width = width;
			if (element.height !== height)
				element.height = height;
		}
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	isInserted: function() {
		return DomElement.isInserted(this._element);
	},

	getPixelSize: function(size) {
		var element = this._element,
			pixels;
		if (element) {
			var parent = element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			pixels = parseFloat(pixels);
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		return 0;
	}
}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getCenter(true)));
	};
}, {
	_decompose: function() {
		return this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.translate(this.getCenter().subtract(center));
	},

	getZoom: function() {
		var scaling = this._decompose().scaling;
		return (scaling.x + scaling.y) / 2;
	},

	setZoom: function(zoom) {
		this.transform(new Matrix().scale(zoom / this.getZoom(),
			this.getCenter()));
	},

	getRotation: function() {
		return this._decompose().rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			this.rotate(rotation - current);
		}
	},

	getScaling: function() {
		var scaling = this._decompose().scaling;
		return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling) {
			this.scale(scaling.x / current.x, scaling.y / current.y);
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
	},

	transform: function(matrix) {
		this._matrix.append(matrix);
	},

	scrollBy: function() {
		this.translate(Point.read(arguments).negate());
	}
}), {

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	getEventPoint: function(event) {
		return this.viewToProject(DomEvent.getOffset(event, this._element));
	},

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (document && typeof element === 'string')
				element = document.getElementById(element);
			var ctor = window ? CanvasView : View;
			return new ctor(project, element);
		}
	}
},
new function() {
	if (!window)
		return;
	var prevFocus,
		tempFocus,
		dragging = false,
		mouseDown = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[
				target.getAttribute('id')];
	}

	function updateFocus() {
		var view = View._focused;
		if (!view || !view.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				if ((view = View._views[i]).isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, event, point) {
		view._handleMouseEvent('mousemove', event, point);
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {},
		docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML')) {
					var offset = DomEvent.getOffset(event, view._element),
						x = offset.x,
						abs = Math.abs,
						ax = abs(x),
						max = 1 << 25,
						diff = ax - max;
					offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
					handleMouseMove(view, event, view.viewToProject(offset));
				}
			},

			scroll: updateFocus
		};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event);
		if (!dragging) {
			dragging = true;
			view._handleMouseEvent('mousedown', event);
		}
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!mouseDown) {
			var target = getView(event);
			if (target) {
				if (view !== target) {
					if (view)
						handleMouseMove(view, event);
					if (!prevFocus)
						prevFocus = view;
					view = View._focused = tempFocus = target;
				}
			} else if (tempFocus && tempFocus === view) {
				if (prevFocus && !prevFocus.isInserted())
					prevFocus = null;
				view = View._focused = prevFocus;
				prevFocus = null;
				updateFocus();
			}
		}
		if (view)
			handleMouseMove(view, event);
	};

	docEvents[mousedown] = function() {
		mouseDown = true;
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (view && dragging)
			view._handleMouseEvent('mouseup', event);
		mouseDown = dragging = false;
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var called = false,
		prevented = false,
		fallbacks = {
			doubleclick: 'click',
			mousedrag: 'mousemove'
		},
		wasInView = false,
		overView,
		downPoint,
		lastPoint,
		downItem,
		overItem,
		dragItem,
		clickItem,
		clickTime,
		dblClick;

	function emitMouseEvent(obj, target, type, event, point, prevPoint,
			stopItem) {
		var stopped = false,
			mouseEvent;

		function emit(obj, type) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point,
							target || obj,
							prevPoint ? point.subtract(prevPoint) : null);
				}
				if (obj.emit(type, mouseEvent)) {
					called = true;
					if (mouseEvent.prevented)
						prevented = true;
					if (mouseEvent.stopped)
						return stopped = true;
				}
			} else {
				var fallback = fallbacks[type];
				if (fallback)
					return emit(obj, fallback);
			}
		}

		while (obj && obj !== stopItem) {
			if (emit(obj, type))
				break;
			obj = obj._parent;
		}
		return stopped;
	}

	function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
		view._project.removeOn(type);
		prevented = called = false;
		return (dragItem && emitMouseEvent(dragItem, null, type, event,
					point, prevPoint)
			|| hitItem && hitItem !== dragItem
				&& !hitItem.isDescendant(dragItem)
				&& emitMouseEvent(hitItem, null, type === 'mousedrag' ?
					'mousemove' : type, event, point, prevPoint, dragItem)
			|| emitMouseEvent(view, dragItem || hitItem || view, type, event,
					point, prevPoint));
	}

	var itemEventsMap = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleMouseEvent: function(type, event, point) {
			var itemEvents = this._itemEvents,
				hitItems = itemEvents.native[type],
				nativeMove = type === 'mousemove',
				tool = this._scope.tool,
				view = this;

			function responds(type) {
				return itemEvents.virtual[type] || view.responds(type)
						|| tool && tool.responds(type);
			}

			if (nativeMove && dragging && responds('mousedrag'))
				type = 'mousedrag';
			if (!point)
				point = this.getEventPoint(event);

			var inView = this.getBounds().contains(point),
				hit = hitItems && inView && view._project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				hitItem = hit && hit.item || null,
				handle = false,
				mouse = {};
			mouse[type.substr(5)] = true;

			if (hitItems && hitItem !== overItem) {
				if (overItem) {
					emitMouseEvent(overItem, null, 'mouseleave', event, point);
				}
				if (hitItem) {
					emitMouseEvent(hitItem, null, 'mouseenter', event, point);
				}
				overItem = hitItem;
			}
			if (wasInView ^ inView) {
				emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',
						event, point);
				overView = inView ? this : null;
				handle = true;
			}
			if ((inView || mouse.drag) && !point.equals(lastPoint)) {
				emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',
						event, point, lastPoint);
				handle = true;
			}
			wasInView = inView;
			if (mouse.down && inView || mouse.up && downPoint) {
				emitMouseEvents(this, hitItem, type, event, point, downPoint);
				if (mouse.down) {
					dblClick = hitItem === clickItem
						&& (Date.now() - clickTime < 300);
					downItem = clickItem = hitItem;
					if (!prevented && hitItem) {
						var item = hitItem;
						while (item && !item.responds('mousedrag'))
							item = item._parent;
						if (item)
							dragItem = hitItem;
					}
					downPoint = point;
				} else if (mouse.up) {
					if (!prevented && hitItem === downItem) {
						clickTime = Date.now();
						emitMouseEvents(this, hitItem, dblClick ? 'doubleclick'
								: 'click', event, point, downPoint);
						dblClick = false;
					}
					downItem = dragItem = null;
				}
				wasInView = false;
				handle = true;
			}
			lastPoint = point;
			if (handle && tool) {
				called = tool._handleMouseEvent(type, event, point, mouse)
					|| called;
			}

			if (
				event.cancelable !== false
				&& (called && !mouse.move || mouse.down && responds('mouseup'))
			) {
				event.preventDefault();
			}
		},

		_handleKeyEvent: function(type, event, key, character) {
			var scope = this._scope,
				tool = scope.tool,
				keyEvent;

			function emit(obj) {
				if (obj.responds(type)) {
					paper = scope;
					obj.emit(type, keyEvent = keyEvent
							|| new KeyEvent(type, event, key, character));
				}
			}

			if (this.isVisible()) {
				emit(this);
				if (tool && tool.responds(type))
					emit(tool);
			}
		},

		_countItemEvent: function(type, sign) {
			var itemEvents = this._itemEvents,
				native = itemEvents.native,
				virtual = itemEvents.virtual;
			for (var key in itemEventsMap) {
				native[key] = (native[key] || 0)
						+ (itemEventsMap[key][type] || 0) * sign;
			}
			virtual[type] = (virtual[type] || 0) + sign;
		},

		statics: {
			updateFocus: updateFocus,

			_resetState: function() {
				dragging = mouseDown = called = wasInView = false;
				prevFocus = tempFocus = overView = downPoint = lastPoint =
					downItem = overItem = dragItem = clickItem = clickTime =
					dblClick = null;
			}
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof window.HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ Base.slice(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		var ctx = this._context = canvas.getContext('2d');
		ctx.save();
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(ctx,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
		this._needsUpdate = true;
	},

	remove: function remove() {
		this._context.restore();
		return remove.base.call(this);
	},

	_setElementSize: function _setElementSize(width, height) {
		var pixelRatio = this._pixelRatio;
		_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
		if (pixelRatio !== 1) {
			var element = this._element,
				ctx = this._context;
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			ctx.restore();
			ctx.save();
			ctx.scale(pixelRatio, pixelRatio);
		}
	},

	getContext: function() {
		return this._context;
	},

	getPixelSize: function getPixelSize(size) {
		var agent = paper.agent,
			pixels;
		if (agent && agent.firefox) {
			pixels = getPixelSize.base.call(this, size);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		if (!this._needsUpdate)
			return false;
		var project = this._project,
			ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		if (project)
			project.draw(ctx, this._matrix, this._pixelRatio);
		this._needsUpdate = false;
		return true;
	}
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
		this.type = event && event.type;
	},

	prevented: false,
	stopped: false,

	preventDefault: function() {
		this.prevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.stopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getTimeStamp: function() {
		return this.event.timeStamp;
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(type, event, key, character) {
		this.type = type;
		this.event = event;
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	var keyLookup = {
			'\t': 'tab',
			' ': 'space',
			'\b': 'backspace',
			'\x7f': 'delete',
			'Spacebar': 'space',
			'Del': 'delete',
			'Win': 'meta',
			'Esc': 'escape'
		},

		charLookup = {
			'tab': '\t',
			'space': ' ',
			'enter': '\r'
		},

		keyMap = {},
		charMap = {},
		metaFixMap,
		downKey,

		modifiers = new Base({
			shift: false,
			control: false,
			alt: false,
			meta: false,
			capsLock: false,
			space: false
		}).inject({
			option: {
				get: function() {
					return this.alt;
				}
			},

			command: {
				get: function() {
					var agent = paper && paper.agent;
					return agent && agent.mac ? this.meta : this.control;
				}
			}
		});

	function getKey(event) {
		var key = event.key || event.keyIdentifier;
		key = /^U\+/.test(key)
				? String.fromCharCode(parseInt(key.substr(2), 16))
				: /^Arrow[A-Z]/.test(key) ? key.substr(5)
				: key === 'Unidentified'  || key === undefined
					? String.fromCharCode(event.keyCode)
					: key;
		return keyLookup[key] ||
				(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
	}

	function handleKey(down, key, character, event) {
		var type = down ? 'keydown' : 'keyup',
			view = View._focused,
			name;
		keyMap[key] = down;
		if (down) {
			charMap[key] = character;
		} else {
			delete charMap[key];
		}
		if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
			modifiers[name] = down;
			var agent = paper && paper.agent;
			if (name === 'meta' && agent && agent.mac) {
				if (down) {
					metaFixMap = {};
				} else {
					for (var k in metaFixMap) {
						if (k in charMap)
							handleKey(false, k, metaFixMap[k], event);
					}
					metaFixMap = null;
				}
			}
		} else if (down && metaFixMap) {
			metaFixMap[key] = character;
		}
		if (view) {
			view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,
					character);
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var key = getKey(event),
				agent = paper && paper.agent;
			if (key.length > 1 || agent && (agent.chrome && (event.altKey
						|| agent.mac && event.metaKey
						|| !agent.mac && event.ctrlKey))) {
				handleKey(true, key,
						charLookup[key] || (key.length > 1 ? '' : key), event);
			} else {
				downKey = key;
			}
		},

		keypress: function(event) {
			if (downKey) {
				var key = getKey(event),
					code = event.charCode,
					character = code >= 32 ? String.fromCharCode(code)
						: key.length > 1 ? '' : key;
				if (key !== downKey) {
					key = character.toLowerCase();
				}
				handleKey(true, key, character, event);
				downKey = null;
			}
		},

		keyup: function(event) {
			var key = getKey(event);
			if (key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		this.type = type;
		this.event = event;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return this.tool[/^mouse(down|up)$/.test(this.type)
				? '_downCount' : '_moveCount'];
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',
			'onKeyUp'],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._moveCount = -1;
		this._downCount = -1;
		this.set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_handleMouseEvent: function(type, event, point, mouse) {
		paper = this._scope;
		if (mouse.drag && !this.responds(type))
			type = 'mousemove';
		var move = mouse.move || mouse.drag,
			responds = this.responds(type),
			minDistance = this.minDistance,
			maxDistance = this.maxDistance,
			called = false,
			tool = this;
		function update(minDistance, maxDistance) {
			var pt = point,
				toolPoint = move ? tool._point : (tool._downPoint || pt);
			if (move) {
				if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
					return false;
				}
				if (toolPoint && (minDistance != null || maxDistance != null)) {
					var vector = pt.subtract(toolPoint),
						distance = vector.getLength();
					if (distance < (minDistance || 0))
						return false;
					if (maxDistance) {
						pt = toolPoint.add(vector.normalize(
								Math.min(distance, maxDistance)));
					}
				}
				tool._moveCount++;
			}
			tool._point = pt;
			tool._lastPoint = toolPoint || pt;
			if (mouse.down) {
				tool._moveCount = -1;
				tool._downPoint = pt;
				tool._downCount++;
			}
			return true;
		}

		function emit() {
			if (responds) {
				called = tool.emit(type, new ToolEvent(tool, type, event))
						|| called;
			}
		}

		if (mouse.down) {
			update();
			emit();
		} else if (mouse.up) {
			update(null, maxDistance);
			emit();
		} else if (responds) {
			while (update(minDistance, maxDistance))
				emit();
		}
		return called;
	}

});

var Tween = Base.extend(Emitter, {
	_class: 'Tween',

	statics: {
		easings: {
			linear: function(t) {
				return t;
			},

			easeInQuad: function(t) {
				return t * t;
			},

			easeOutQuad: function(t) {
				return t * (2 - t);
			},

			easeInOutQuad: function(t) {
				return t < 0.5
					? 2 * t * t
					: -1 + 2 * (2 - t) * t;
			},

			easeInCubic: function(t) {
				return t * t * t;
			},

			easeOutCubic: function(t) {
				return --t * t * t + 1;
			},

			easeInOutCubic: function(t) {
				return t < 0.5
					? 4 * t * t * t
					: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
			},

			easeInQuart: function(t) {
				return t * t * t * t;
			},

			easeOutQuart: function(t) {
				return 1 - (--t) * t * t * t;
			},

			easeInOutQuart: function(t) {
				return t < 0.5
					? 8 * t * t * t * t
					: 1 - 8 * (--t) * t * t * t;
			},

			easeInQuint: function(t) {
				return t * t * t * t * t;
			},

			easeOutQuint: function(t) {
				return 1 + --t * t * t * t * t;
			},

			easeInOutQuint: function(t) {
				return t < 0.5
					? 16 * t * t * t * t * t
					: 1 + 16 * (--t) * t * t * t * t;
			}
		}
	},

	initialize: function Tween(object, from, to, duration, easing, start) {
		this.object = object;
		var type = typeof easing;
		var isFunction = type === 'function';
		this.type = isFunction
			? type
			: type === 'string'
				? easing
				: 'linear';
		this.easing = isFunction ? easing : Tween.easings[this.type];
		this.duration = duration;
		this.running = false;

		this._then = null;
		this._startTime = null;
		var state = from || to;
		this._keys = state ? Object.keys(state) : [];
		this._parsedKeys = this._parseKeys(this._keys);
		this._from = state && this._getState(from);
		this._to = state && this._getState(to);
		if (start !== false) {
			this.start();
		}
	},

	then: function(then) {
		this._then = then;
		return this;
	},

	start: function() {
		this._startTime = null;
		this.running = true;
		return this;
	},

	stop: function() {
		this.running = false;
		return this;
	},

	update: function(progress) {
		if (this.running) {
			if (progress > 1) {
				progress = 1;
				this.running = false;
			}

			var factor = this.easing(progress),
				keys = this._keys,
				getValue = function(value) {
					return typeof value === 'function'
						? value(factor, progress)
						: value;
				};
			for (var i = 0, l = keys && keys.length; i < l; i++) {
				var key = keys[i],
					from = getValue(this._from[key]),
					to = getValue(this._to[key]),
					value = (from && to && from.__add && to.__add)
						? to.__subtract(from).__multiply(factor).__add(from)
						: ((to - from) * factor) + from;
				this._setProperty(this._parsedKeys[key], value);
			}

			if (!this.running && this._then) {
				this._then(this.object);
			}
			if (this.responds('update')) {
				this.emit('update', new Base({
					progress: progress,
					factor: factor
				}));
			}
		}
		return this;
	},

	_events: {
		onUpdate: {}
	},

	_handleFrame: function(time) {
		var startTime = this._startTime,
			progress = startTime
				? (time - startTime) / this.duration
				: 0;
		if (!startTime) {
			this._startTime = time;
		}
		this.update(progress);
	},

	_getState: function(state) {
		var keys = this._keys,
			result = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = this._parsedKeys[key],
				current = this._getProperty(path),
				value;
			if (state) {
				var resolved = this._resolveValue(current, state[key]);
				this._setProperty(path, resolved);
				value = this._getProperty(path);
				value = value && value.clone ? value.clone() : value;
				this._setProperty(path, current);
			} else {
				value = current && current.clone ? current.clone() : current;
			}
			result[key] = value;
		}
		return result;
	},

	_resolveValue: function(current, value) {
		if (value) {
			if (Array.isArray(value) && value.length === 2) {
				var operator = value[0];
				return (
					operator &&
					operator.match &&
					operator.match(/^[+\-\*\/]=/)
				)
					? this._calculate(current, operator[0], value[1])
					: value;
			} else if (typeof value === 'string') {
				var match = value.match(/^[+\-*/]=(.*)/);
				if (match) {
					var parsed = JSON.parse(match[1].replace(
						/(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
						'"$2": '
					));
					return this._calculate(current, value[0], parsed);
				}
			}
		}
		return value;
	},

	_calculate: function(left, operator, right) {
		return paper.PaperScript.calculateBinary(left, operator, right);
	},

	_parseKeys: function(keys) {
		var parsed = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = key
					.replace(/\.([^.]*)/g, '/$1')
					.replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
			parsed[key] = path.split('/');
		}
		return parsed;
	},

	_getProperty: function(path, offset) {
		var obj = this.object;
		for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
			obj = obj[path[i]];
		}
		return obj;
	},

	_setProperty: function(path, value) {
		var dest = this._getProperty(path, 1);
		if (dest) {
			dest[path[path.length - 1]] = value;
		}
	}
});

var Http = {
	request: function(options) {
		var xhr = new self.XMLHttpRequest();
		xhr.open((options.method || 'get').toUpperCase(), options.url,
				Base.pick(options.async, true));
		if (options.mimeType)
			xhr.overrideMimeType(options.mimeType);
		xhr.onload = function() {
			var status = xhr.status;
			if (status === 0 || status === 200) {
				if (options.onLoad) {
					options.onLoad.call(xhr, xhr.responseText);
				}
			} else {
				xhr.onerror();
			}
		};
		xhr.onerror = function() {
			var status = xhr.status,
				message = 'Could not load "' + options.url + '" (Status: '
						+ status + ')';
			if (options.onError) {
				options.onError(message, status);
			} else {
				throw new Error(message);
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		if (!window)
			return null;
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
			clear = false;
		}
		var ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('Canvas ' + canvas +
					' is unable to provide a 2D context.');
		}
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		var canvas = this.getCanvas(width, height);
		return canvas ? canvas.getContext('2d') : null;
	},

	release: function(obj) {
		var canvas = obj && obj.canvas ? obj.canvas : obj;
		if (canvas && canvas.getContext) {
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	if (ctx) {
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken
							? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	}

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SvgElement = new function() {
	var svg = 'http://www.w3.org/2000/svg',
		xmlns = 'http://www.w3.org/2000/xmlns',
		xlink = 'http://www.w3.org/1999/xlink',
		attributeNamespace = {
			href: xlink,
			xlink: xmlns,
			xmlns: xmlns + '/',
			'xmlns:xlink': xmlns + '/'
		};

	function create(tag, attributes, formatter) {
		return set(document.createElementNS(svg, tag), attributes, formatter);
	}

	function get(node, name) {
		var namespace = attributeNamespace[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		return value === 'null' ? null : value;
	}

	function set(node, attributes, formatter) {
		for (var name in attributes) {
			var value = attributes[name],
				namespace = attributeNamespace[name];
			if (typeof value === 'number' && formatter)
				value = formatter.number(value);
			if (namespace) {
				node.setAttributeNS(namespace, name, value);
			} else {
				node.setAttribute(name, value);
			}
		}
		return node;
	}

	return {
		svg: svg,
		xmlns: xmlns,
		xlink: xlink,

		create: create,
		get: get,
		set: set
	};
};

var SvgStyles = Base.each({
	fillColor: ['fill', 'color'],
	fillRule: ['fill-rule', 'string'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'style']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

new function() {
	var formatter;

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			var point;
			if (matrix.isInvertible()) {
				matrix = matrix._shiftless();
				point = matrix._inverseTransform(trans);
				trans = null;
			} else {
				point = new Point();
			}
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling,
					skew = decomposed.skewing;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (skew.x)
					parts.push('skewX(' + formatter.number(skew.x) + ')');
				if (skew.y)
					parts.push('skewY(' + formatter.number(skew.y) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = SvgElement.create('g', attrs, formatter);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = SvgElement.create('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					SvgElement.set(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages == false && image && image.src
				|| item.toDataURL();
		return SvgElement.create('image', attrs, formatter);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			length = segments.length,
			type,
			attrs = getTransform(item._matrix);
		if (matchShapes && length >= 2 && !item.hasHandles()) {
			if (length > 2) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for (var i = 0; i < length; i++) {
					parts.push(formatter.point(segments[i]._point));
				}
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var start = segments[0]._point,
					end = segments[1]._point;
				attrs.set({
					x1: start.x,
					y1: start.y,
					x2: end.x,
					y2: end.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return SvgElement.create('path', attrs, formatter);
	}

	function exportSymbolItem(item, options) {
		var attrs = getTransform(item._matrix, true),
			definition = item._definition,
			node = getDefinition(definition, 'symbol'),
			definitionItem = definition._item,
			bounds = definitionItem.getStrokeBounds();
		if (!node) {
			node = SvgElement.create('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			node.appendChild(exportSVG(definitionItem, options));
			setDefinition(definition, node, 'symbol');
		}
		attrs.href = '#' + node.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = bounds.width;
		attrs.height = bounds.height;
		attrs.overflow = 'visible';
		return SvgElement.create('use', attrs, formatter);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin(),
				destination = color.getDestination(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = SvgElement.create((radial ? 'radial' : 'linear')
					+ 'Gradient', attrs, formatter);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha(),
					offset = stop._offset;
				attrs = {
					offset: offset == null ? i / (l - 1) : offset
				};
				if (stopColor)
					attrs['stop-color'] = stopColor.toCSS(true);
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(
						SvgElement.create('stop', attrs, formatter));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = SvgElement.create('text', getTransform(item._matrix, true),
				formatter);
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		SymbolItem: exportSymbolItem,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent(),
			style = [];

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SvgStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				if (type === 'style') {
					style.push(entry.attribute + ': ' + value);
				} else {
					attrs[entry.attribute] = value == null ? 'none'
							: type === 'color' ? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array' ? value.join(',')
							: type === 'lookup' ? entry.toSVG[value]
							: value;
				}
			}
		});

		if (style.length)
			attrs.style = style.join(';');

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return SvgElement.set(node, attrs, formatter);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-'
				+ (item._id || item.__id || (item.__id = UID.get('svg')))];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + typeId;
		definitions.svgs[type + '-' + (item._id || item.__id)] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = SvgElement.create('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(SvgElement.create('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new self.XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var children = this._children,
				view = this.getView(),
				bounds = Base.pick(options.bounds, 'view'),
				mx = options.matrix || bounds === 'view' && view._matrix,
				matrix = mx && Matrix.read([mx]),
				rect = bounds === 'view'
					? new Rectangle([0, 0], view.getViewSize())
					: bounds === 'content'
						? Item._getBounds(children, matrix, { stroke: true })
							.rect
						: Rectangle.read([bounds], 0, { readNull: true }),
				attrs = {
					version: '1.1',
					xmlns: SvgElement.svg,
					'xmlns:xlink': SvgElement.xlink,
				};
			if (rect) {
				attrs.width = rect.width;
				attrs.height = rect.height;
				if (rect.x || rect.x === 0 || rect.y || rect.y === 0)
					attrs.viewBox = formatter.rectangle(rect);
			}
			var node = SvgElement.create('svg', attrs, formatter),
				parent = node;
			if (matrix && !matrix.isIdentity()) {
				parent = node.appendChild(SvgElement.create('g',
						getTransform(matrix), formatter));
			}
			for (var i = 0, l = children.length; i < l; i++) {
				parent.appendChild(exportSVG(children[i], options, true));
			}
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	var definitions = {},
		rootSize;

	function getValue(node, name, isString, allowNull, allowPercent,
			defaultValue) {
		var value = SvgElement.get(node, name) || defaultValue,
			res = value == null
				? allowNull
					? null
					: isString ? '' : 0
				: isString
					? value
					: parseFloat(value);
		return /%\s*$/.test(value)
			? (res / 100) * (allowPercent ? 1
				: rootSize[/x|^width/.test(name) ? 'width' : 'height'])
			: res;
	}

	function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
		x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
		y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull, allowPercent) {
		w = getValue(node, w || 'width', false, allowNull, allowPercent);
		h = getValue(node, h || 'height', false, allowNull, allowPercent);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none' ? null
				: type === 'number' ? parseFloat(value)
				: type === 'array' ?
					value ? value.split(/[\s,]+/g).map(parseFloat) : []
				: type === 'color' ? getDefinition(value) || value
				: type === 'lookup' ? lookup[value]
				: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			isDefs = type === 'defs',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip && !isDefs) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importNode(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& !/^defs$/i.test(childNode.nodeName)
					&& (child = importNode(childNode, options, false))
					&& !(child instanceof SymbolDefinition))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || isDefs) {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		return PathItem.create(node.getAttribute('d'));
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			radial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
			if (gradient._radial ^ radial) {
				gradient = gradient.clone();
				gradient._radial = radial;
			}
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, radial);
		}
		var origin, destination, highlight,
			scaleToBounds = getValue(node, 'gradientUnits', true) !==
				'userSpaceOnUse';
		if (radial) {
			origin = getPoint(node, 'cx', 'cy', false, scaleToBounds,
				'50%', '50%');
			destination = origin.add(
				getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
			highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
		} else {
			origin = getPoint(node, 'x1', 'y1', false, scaleToBounds,
				'0%', '0%');
			destination = getPoint(node, 'x2', 'y2', false, scaleToBounds,
				'100%', '0%');
		}
		var color = applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
		color._scaleToBounds = scaleToBounds;
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					return importNode(child, options, isRoot);
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node);
				this.setSize(size);
				var center = getPoint(node).add(size.divide(2));
				this._matrix.append(new Matrix().translate(center));
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new SymbolDefinition(
					importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node);
			return definition
					? definition instanceof SymbolDefinition
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(
					getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			return new Shape.Rectangle(new Rectangle(
						getPoint(node),
						getSize(node)
					), getSize(node, 'rx', 'ry'));
			},

		line: function(node) {
			return new Path.Line(
					getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node).add(
					getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		},

		switch: importGroup
	};

	function applyTransform(item, value, name, node) {
		if (item.transform) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.append(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1] || 0, v[2] || 0);
					break;
				case 'translate':
					matrix.translate(v[0], v[1] || 0);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	}

	function applyOpacity(item, value, name) {
		var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
			color = item[key] && item[key]();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SvgStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			if (item[entry.set]) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color') {
					var color = item[entry.get]();
					if (color) {
						if (color._scaleToBounds) {
							var bounds = item.getBounds();
							color.transform(new Matrix()
								.translate(bounds.getPoint())
								.scale(bounds.getSize()));
						}
					}
				}
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			if (item.setVisible)
				item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			if (item.setVisible)
				item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			if (item.setOffset) {
				var percent = value.match(/(.*)%$/);
				item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
			}
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, null, null, true),
				group,
				matrix;
			if (item instanceof Group) {
				var scale = size ? size.divide(rect.getSize()) : 1,
				matrix = new Matrix().scale(scale)
						.translate(rect.getPoint().negate());
				group = item;
			} else if (item instanceof SymbolDefinition) {
				if (size)
					rect.setSize(size);
				group = item._item;
			}
			if (group)  {
				if (getAttribute(node, 'overflow', styles) !== 'visible') {
					var clip = new Shape.Rectangle(rect);
					clip.setClipMask(true);
					group.addChild(clip);
				}
				if (matrix)
					group.transform(matrix);
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value && node.style) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value ? undefined
				: value === 'none' ? null
				: value;
	}

	function applyAttributes(item, node, isRoot) {
		var parent = node.parentNode,
			styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && !/^defs$/i.test(parent.tagName)
						&& DomElement.getStyles(parent) || {}
			};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			item = value !== undefined
					&& apply(item, value, name, node, styles) || item;
		});
		return item;
	}

	function getDefinition(value) {
		var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
			name = match && match[1],
			res = name && definitions[window
					? name.replace(window.location.href.split('#')[0] + '#', '')
					: name];
		if (res && res._scaleToBounds) {
			res = res.clone();
			res._scaleToBounds = true;
		}
		return res;
	}

	function importNode(node, options, isRoot) {
		var type = node.nodeName.toLowerCase(),
			isElement = type !== '#document',
			body = document.body,
			container,
			parent,
			next;
		if (isRoot && isElement) {
			rootSize = paper.getView().getSize();
			rootSize = getSize(node, null, null, true) || rootSize;
			container = SvgElement.create('svg', {
				style: 'stroke-width: 1px; stroke-miterlimit: 10'
			});
			parent = node.parentNode;
			next = node.nextSibling;
			container.appendChild(node);
			body.appendChild(container);
		}
		var settings = paper.settings,
			applyMatrix = settings.applyMatrix,
			insertItems = settings.insertItems;
		settings.applyMatrix = false;
		settings.insertItems = false;
		var importer = importers[type],
			item = importer && importer(node, type, options, isRoot) || null;
		settings.insertItems = insertItems;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (isElement && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport,
				data = isElement && node.getAttribute('data-paper-data');
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (container) {
			body.removeChild(container);
			if (parent) {
				if (next) {
					parent.insertBefore(node, next);
				} else {
					parent.appendChild(node);
				}
			}
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	function importSVG(source, options, owner) {
		if (!source)
			return null;
		options = typeof options === 'function' ? { onLoad: options }
				: options || {};
		var scope = paper,
			item = null;

		function onLoad(svg) {
			try {
				var node = typeof svg === 'object' ? svg : new self.DOMParser()
						.parseFromString(svg, 'image/svg+xml');
				if (!node.nodeName) {
					node = null;
					throw new Error('Unsupported SVG source: ' + source);
				}
				paper = scope;
				item = importNode(node, options, true);
				if (!options || options.insert !== false) {
					owner._insertItem(undefined, item);
				}
				var onLoad = options.onLoad;
				if (onLoad)
					onLoad(item, svg);
			} catch (e) {
				onError(e);
			}
		}

		function onError(message, status) {
			var onError = options.onError;
			if (onError) {
				onError(message, status);
			} else {
				throw new Error(message);
			}
		}

		if (typeof source === 'string' && !/^.*</.test(source)) {
			var node = document.getElementById(source);
			if (node) {
				onLoad(node);
			} else {
				Http.request({
					url: source,
					async: true,
					onLoad: onLoad,
					onError: onError
				});
			}
		} else if (typeof File !== 'undefined' && source instanceof File) {
			var reader = new FileReader();
			reader.onload = function() {
				onLoad(reader.result);
			};
			reader.onerror = function() {
				onError(reader.error);
			};
			return reader.readAsText(source);
		} else {
			onLoad(source);
		}

		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return importSVG(node, options, this);
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, this);
		}
	});
};

var paper = new (PaperScope.inject(Base.exports, {
	Base: Base,
	Numerical: Numerical,
	Key: Key,
	DomEvent: DomEvent,
	DomElement: DomElement,
	document: document,
	window: window,
	Symbol: SymbolDefinition,
	PlacedSymbol: SymbolItem
}))();

if (paper.agent.node) {
	require('./node/extend.js')(paper);
}

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
}.call(this, typeof self === 'object' ? self : null);

/* js-yaml 3.13.1 https://github.com/nodeca/js-yaml */
(function (f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f()
  } else if (typeof define === "function" && define.amd) {
    define([], f)
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window
    } else if (typeof global !== "undefined") {
      g = global
    } else if (typeof self !== "undefined") {
      g = self
    } else {
      g = this
    }
    g.jsyaml = f()
  }
})(function () {
    var define, module, exports;
    return (function () {
        function r(e, n, t) {
          function o(i, f) {
            if (!n[i]) {
              if (!e[i]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i, !0);
                if (u) return u(i, !0);
                var a = new Error("Cannot find module '" + i + "'");
                throw a.code = "MODULE_NOT_FOUND", a
              }
              var p = n[i] = {
                exports: {}
              };
              e[i][0].call(p.exports, function (r) {
                var n = e[i][1][r];
                return o(n || r)
              }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
          return o
        }
        return r
      })()({
          1: [function (require, module, exports) {
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":3,"./js-yaml/exception":4,"./js-yaml/loader":5,"./js-yaml/schema":7,"./js-yaml/schema/core":8,"./js-yaml/schema/default_full":9,"./js-yaml/schema/default_safe":10,"./js-yaml/schema/failsafe":11,"./js-yaml/schema/json":12,"./js-yaml/type":13}],2:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],3:[function(require,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this._flowArrLevel = (common.isNothing(options['_flowArrLevel']) ? -1 : options['_flowArrLevel']);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]' || (object !== null && object !== undefined && object.BYTES_PER_ELEMENT !== undefined)) {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state._flowArrLevel > level) && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":2,"./exception":4,"./schema/default_full":9,"./schema/default_safe":10}],4:[function(require,module,exports){
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],5:[function(require,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":2,"./exception":4,"./mark":6,"./schema/default_full":9,"./schema/default_safe":10}],6:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":2}],7:[function(require,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":2,"./exception":4,"./type":13}],8:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":7,"./json":12}],9:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":7,"../type/js/function":18,"../type/js/regexp":19,"../type/js/undefined":20,"./default_safe":10}],10:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":7,"../type/binary":14,"../type/merge":22,"../type/omap":24,"../type/pairs":25,"../type/set":27,"../type/timestamp":29,"./core":8}],11:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":7,"../type/map":21,"../type/seq":26,"../type/str":28}],12:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":7,"../type/bool":15,"../type/float":16,"../type/int":17,"../type/null":23,"./failsafe":11}],13:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":4}],14:[function(require,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
//fails-in-browser  NodeBuffer = _require('buffer').Buffer;
} catch (__) {}

var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":13}],15:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],16:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":2,"../type":13}],17:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":2,"../type":13}],18:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
//fails-in-browser  esprima = _require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":13}],19:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":13}],20:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":13}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

},{"../type":13}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":13}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":13}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":13}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

},{"../type":13}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":13}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

},{"../type":13}],29:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":13}],"/":[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":1}]},{},[])("/")
});

/*******************************************************************************
 *                                                                              *
 * Author    :  Angus Johnson                                                   *
 * Version   :  6.4.2                                                           *
 * Date      :  27 February 2017                                                *
 * Website   :  http://www.angusj.com                                           *
 * Copyright :  Angus Johnson 2010-2017                                         *
 *                                                                              *
 * License:                                                                     *
 * Use, modification & distribution is subject to Boost Software License Ver 1. *
 * http://www.boost.org/LICENSE_1_0.txt                                         *
 *                                                                              *
 * Attributions:                                                                *
 * The code in this library is an extension of Bala Vatti's clipping algorithm: *
 * "A generic solution to polygon clipping"                                     *
 * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
 * http://portal.acm.org/citation.cfm?id=129906                                 *
 *                                                                              *
 * Computer graphics and geometric modeling: implementation and algorithms      *
 * By Max K. Agoston                                                            *
 * Springer; 1 edition (January 4, 2005)                                        *
 * http://books.google.com/books?q=vatti+clipping+agoston                       *
 *                                                                              *
 * See also:                                                                    *
 * "Polygon Offsetting by Computing Winding Numbers"                            *
 * Paper no. DETC2005-85513 pp. 565-575                                         *
 * ASME 2005 International Design Engineering Technical Conferences             *
 * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
 * September 24-28, 2005 , Long Beach, California, USA                          *
 * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Author    :  Timo                                                            *
 * Version   :  6.4.2.2 (FPoint)                                                *
 * Date      :  8 September 2017                                                *
 *                                                                              *
 * This is a translation of the C# Clipper library to Javascript.               *
 *                                                                              *
 *******************************************************************************/
(function ()
{
	"use strict";
	var ClipperLib = {};
	ClipperLib.version = '6.4.2.2';

	//UseLines: Enables open path clipping. Adds a very minor cost to performance.
	ClipperLib.use_lines = true;

	//ClipperLib.use_xyz: adds a Z member to FPoint. Adds a minor cost to performance.
	ClipperLib.use_xyz = false;

	var isNode = false;
	if (typeof module !== 'undefined' && module.exports)
	{
		module.exports = ClipperLib;
		isNode = true;
	}
	else
	{
		if (typeof (document) !== "undefined") window.ClipperLib = ClipperLib;
		else self['ClipperLib'] = ClipperLib;
	}
	var navigator_appName;
	if (!isNode)
	{
		var nav = navigator.userAgent.toString().toLowerCase();
		navigator_appName = navigator.appName;
	}
	else
	{
		var nav = "chrome"; // Node.js uses Chrome's V8 engine
		navigator_appName = "Netscape"; // Firefox, Chrome and Safari returns "Netscape", so Node.js should also
	}
	// Browser test to speedup performance critical functions
	var browser = {};

	if (nav.indexOf("chrome") != -1 && nav.indexOf("chromium") == -1) browser.chrome = 1;
	else browser.chrome = 0;
	if (nav.indexOf("chromium") != -1) browser.chromium = 1;
	else browser.chromium = 0;
	if (nav.indexOf("safari") != -1 && nav.indexOf("chrome") == -1 && nav.indexOf("chromium") == -1) browser.safari = 1;
	else browser.safari = 0;
	if (nav.indexOf("firefox") != -1) browser.firefox = 1;
	else browser.firefox = 0;
	if (nav.indexOf("firefox/17") != -1) browser.firefox17 = 1;
	else browser.firefox17 = 0;
	if (nav.indexOf("firefox/15") != -1) browser.firefox15 = 1;
	else browser.firefox15 = 0;
	if (nav.indexOf("firefox/3") != -1) browser.firefox3 = 1;
	else browser.firefox3 = 0;
	if (nav.indexOf("opera") != -1) browser.opera = 1;
	else browser.opera = 0;
	if (nav.indexOf("msie 10") != -1) browser.msie10 = 1;
	else browser.msie10 = 0;
	if (nav.indexOf("msie 9") != -1) browser.msie9 = 1;
	else browser.msie9 = 0;
	if (nav.indexOf("msie 8") != -1) browser.msie8 = 1;
	else browser.msie8 = 0;
	if (nav.indexOf("msie 7") != -1) browser.msie7 = 1;
	else browser.msie7 = 0;
	if (nav.indexOf("msie ") != -1) browser.msie = 1;
	else browser.msie = 0;

	// Here starts the actual Clipper library:
	// Helper function to support Inheritance in Javascript
	var Inherit = function (ce, ce2)
	{
		var p;
		if (typeof (Object.getOwnPropertyNames) === 'undefined')
		{
			for (p in ce2.prototype)
				if (typeof (ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];
			for (p in ce2)
				if (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];
			ce.$baseCtor = ce2;
		}
		else
		{
			var props = Object.getOwnPropertyNames(ce2.prototype);
			for (var i = 0; i < props.length; i++)
				if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));
			for (p in ce2)
				if (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];
			ce.$baseCtor = ce2;
		}
	};

	/**
	* @constructor
	*/
	ClipperLib.Path = function ()
	{
		return [];
	};

	ClipperLib.Path.prototype.push = Array.prototype.push;

	/**
	* @constructor
	*/
	ClipperLib.Paths = function ()
	{
		return []; // Was previously [[]], but caused problems when pushed
	};

	ClipperLib.Paths.prototype.push = Array.prototype.push;

	// PolyTree & PolyNode start
	/**
	* @suppress {missingProperties}
	*/
	ClipperLib.PolyNode = function ()
	{
		this.m_Parent = null;
		this.m_polygon = new ClipperLib.Path();
		this.m_Index = 0;
		this.m_jointype = 0;
		this.m_endtype = 0;
		this.m_Childs = [];
		this.IsOpen = false;
	};

	ClipperLib.PolyNode.prototype.IsHoleNode = function ()
	{
		var result = true;
		var node = this.m_Parent;
		while (node !== null)
		{
			result = !result;
			node = node.m_Parent;
		}
		return result;
	};

	ClipperLib.PolyNode.prototype.ChildCount = function ()
	{
		return this.m_Childs.length;
	};

	ClipperLib.PolyNode.prototype.Contour = function ()
	{
		return this.m_polygon;
	};

	ClipperLib.PolyNode.prototype.AddChild = function (Child)
	{
		var cnt = this.m_Childs.length;
		this.m_Childs.push(Child);
		Child.m_Parent = this;
		Child.m_Index = cnt;
	};

	ClipperLib.PolyNode.prototype.GetNext = function ()
	{
		if (this.m_Childs.length > 0)
			return this.m_Childs[0];
		else
			return this.GetNextSiblingUp();
	};

	ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()
	{
		if (this.m_Parent === null)
			return null;
		else if (this.m_Index === this.m_Parent.m_Childs.length - 1)
			return this.m_Parent.GetNextSiblingUp();
		else
			return this.m_Parent.m_Childs[this.m_Index + 1];
	};

	ClipperLib.PolyNode.prototype.Childs = function ()
	{
		return this.m_Childs;
	};

	ClipperLib.PolyNode.prototype.Parent = function ()
	{
		return this.m_Parent;
	};

	ClipperLib.PolyNode.prototype.IsHole = function ()
	{
		return this.IsHoleNode();
	};

	// PolyTree : PolyNode
	/**
	 * @suppress {missingProperties}
	 * @constructor
	 */
	ClipperLib.PolyTree = function ()
	{
		this.m_AllPolys = [];
		ClipperLib.PolyNode.call(this);
	};

	ClipperLib.PolyTree.prototype.Clear = function ()
	{
		for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)
			this.m_AllPolys[i] = null;
		this.m_AllPolys.length = 0;
		this.m_Childs.length = 0;
	};

	ClipperLib.PolyTree.prototype.GetFirst = function ()
	{
		if (this.m_Childs.length > 0)
			return this.m_Childs[0];
		else
			return null;
	};

	ClipperLib.PolyTree.prototype.Total = function ()
	{
		var result = this.m_AllPolys.length;
		//with negative offsets, ignore the hidden outer polygon ...
		if (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;
		return result;
	};

	Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);

	// PolyTree & PolyNode end

	ClipperLib.Clear = function (a)
	{
		a.length = 0;
	};

	//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function
	ClipperLib.PI = 3.141592653589793;
	ClipperLib.PI2 = 2 * 3.141592653589793;
	/**
	* @constructor
	*/
	ClipperLib.FPoint = function ()
	{
		var a = arguments,
			alen = a.length;
		this.X = 0;
		this.Y = 0;
		if (ClipperLib.use_xyz)
		{
			this.Z = 0;
			if (alen === 3) // public FPoint(cInt x, cInt y, cInt z = 0)
			{
				this.X = a[0];
				this.Y = a[1];
				this.Z = a[2];
			}
			else if (alen === 2) // public FPoint(cInt x, cInt y)
			{
				this.X = a[0];
				this.Y = a[1];
				this.Z = 0;
			}
			else if (alen === 1)
			{
				if (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)
				{
					var dp = a[0];
					this.X = dp.X;
					this.Y = dp.Y;
					this.Z = 0;
				}
				else // public FPoint(FPoint pt)
				{
					var pt = a[0];
					if (typeof (pt.Z) === "undefined") pt.Z = 0;
					this.X = pt.X;
					this.Y = pt.Y;
					this.Z = pt.Z;
				}
			}
			else // public FPoint()
			{
				this.X = 0;
				this.Y = 0;
				this.Z = 0;
			}
		}
		else // if (!ClipperLib.use_xyz)
		{
			if (alen === 2) // public FPoint(cInt X, cInt Y)
			{
				this.X = a[0];
				this.Y = a[1];
			}
			else if (alen === 1)
			{
				if (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)
				{
					var dp = a[0];
					this.X = dp.X;
					this.Y = dp.Y;
				}
				else // public FPoint(FPoint pt)
				{
					var pt = a[0];
					this.X = pt.X;
					this.Y = pt.Y;
				}
			}
			else // public FPoint(FPoint pt)
			{
				this.X = 0;
				this.Y = 0;
			}
		}
	};

	ClipperLib.FPoint.op_Equality = function (a, b)
	{
		//return a == b;
		return a.X === b.X && a.Y === b.Y;
	};

	ClipperLib.FPoint.op_Inequality = function (a, b)
	{
		//return a !== b;
		return a.X !== b.X || a.Y !== b.Y;
	};

	/*
  ClipperLib.FPoint.prototype.Equals = function (obj)
  {
    if (obj === null)
        return false;
    if (obj instanceof ClipperLib.FPoint)
    {
        var a = Cast(obj, ClipperLib.FPoint);
        return (this.X == a.X) && (this.Y == a.Y);
    }
    else
        return false;
  };

	*/
	
	const Z_MISSING = -1
	/**
	* @constructor
	*/
	ClipperLib.FPoint0 = function ()
	{
		this.X = 0;
		this.Y = 0;
		if (ClipperLib.use_xyz)
			this.Z = Z_MISSING;
	};

	ClipperLib.FPoint0.prototype = ClipperLib.FPoint.prototype;

	/**
	* @constructor
	*/
	ClipperLib.FPoint1 = function (pt)
	{
		this.X = pt.X;
		this.Y = pt.Y;
		if (ClipperLib.use_xyz)
		{
			if (typeof pt.Z === "undefined") this.Z = 0;
			else this.Z = pt.Z;
		}
	};

	ClipperLib.FPoint1.prototype = ClipperLib.FPoint.prototype;

	/**
	* @constructor
	*/
	ClipperLib.FPoint1dp = function (dp)
	{
		this.X = dp.X;
		this.Y = dp.Y;
		if (ClipperLib.use_xyz)
			this.Z = 0;
	};

	ClipperLib.FPoint1dp.prototype = ClipperLib.FPoint.prototype;

	/**
	* @constructor
	*/
	ClipperLib.FPoint2 = function (x, y, z)
	{
		this.X = x;
		this.Y = y;
		if (ClipperLib.use_xyz)
		{
			if (typeof z === "undefined") this.Z = 0;
			else this.Z = z;
		}
	};

	ClipperLib.FPoint2.prototype = ClipperLib.FPoint.prototype;

	/**
	* @constructor
	*/
	ClipperLib.FRect = function ()
	{
		var a = arguments,
			alen = a.length;
		if (alen === 4) // function (l, t, r, b)
		{
			this.left = a[0];
			this.top = a[1];
			this.right = a[2];
			this.bottom = a[3];
		}
		else if (alen === 1) // function (ir)
		{
			var ir = a[0];
			this.left = ir.left;
			this.top = ir.top;
			this.right = ir.right;
			this.bottom = ir.bottom;
		}
		else // function ()
		{
			this.left = 0;
			this.top = 0;
			this.right = 0;
			this.bottom = 0;
		}
	};

	/**
	* @constructor
	*/
	ClipperLib.FRect0 = function ()
	{
		this.left = 0;
		this.top = 0;
		this.right = 0;
		this.bottom = 0;
	};

	ClipperLib.FRect0.prototype = ClipperLib.FRect.prototype;

	/**
	* @constructor
	*/
	ClipperLib.FRect1 = function (ir)
	{
		this.left = ir.left;
		this.top = ir.top;
		this.right = ir.right;
		this.bottom = ir.bottom;
	};

	ClipperLib.FRect1.prototype = ClipperLib.FRect.prototype;

	/**
	* @constructor
	*/
	ClipperLib.FRect4 = function (l, t, r, b)
	{
		this.left = l;
		this.top = t;
		this.right = r;
		this.bottom = b;
	};

	ClipperLib.FRect4.prototype = ClipperLib.FRect.prototype;

	ClipperLib.ClipType = {
		ctIntersection: 0,
		ctUnion: 1,
		ctDifference: 2,
		ctXor: 3
	};

	ClipperLib.PolyType = {
		ptSubject: 0,
		ptClip: 1
	};

	ClipperLib.PolyFillType = {
		pftEvenOdd: 0,
		pftNonZero: 1,
		pftPositive: 2,
		pftNegative: 3
	};

	ClipperLib.JoinType = {
		jtSquare: 0,
		jtRound: 1,
		jtMiter: 2,
		jtMiterAlways: 3
	};

	ClipperLib.EndType = {
		etOpenSquare: 0,
		etOpenRound: 1,
		etOpenButt: 2,
		etClosedLine: 3,
		etClosedPolygon: 4
	};

	ClipperLib.EdgeSide = {
		esLeft: 0,
		esRight: 1
	};

	ClipperLib.Direction = {
		dRightToLeft: 0,
		dLeftToRight: 1
	};

	/**
	* @constructor
	*/
	ClipperLib.TEdge = function ()
	{
		this.Bot = new ClipperLib.FPoint0();
		this.Curr = new ClipperLib.FPoint0(); //current (updated for every new scanbeam)
		this.Top = new ClipperLib.FPoint0();
		this.Delta = new ClipperLib.FPoint0();
		this.Dx = 0;
		this.PolyTyp = ClipperLib.PolyType.ptSubject;
		this.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly
		this.WindDelta = 0; //1 or -1 depending on winding direction
		this.WindCnt = 0;
		this.WindCnt2 = 0; //winding count of the opposite polytype
		this.OutIdx = 0;
		this.Next = null;
		this.Prev = null;
		this.NextInLML = null;
		this.NextInAEL = null;
		this.PrevInAEL = null;
		this.NextInSEL = null;
		this.PrevInSEL = null;
	};

	/**
	* @constructor
	*/
	ClipperLib.IntersectNode = function ()
	{
		this.Edge1 = null;
		this.Edge2 = null;
		this.Pt = new ClipperLib.FPoint0();
	};

	ClipperLib.MyIntersectNodeSort = function () {};

	ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)
	{
		var i = node2.Pt.Y - node1.Pt.Y;
		if (i > 0) return 1;
		else if (i < 0) return -1;
		else return 0;
	};

	/**
	* @constructor
	*/
	ClipperLib.LocalMinima = function ()
	{
		this.Y = 0;
		this.LeftBound = null;
		this.RightBound = null;
		this.Next = null;
	};

	/**
	* @constructor
	*/
	ClipperLib.Scanbeam = function ()
	{
		this.Y = 0;
		this.Next = null;
	};

	/**
	* @constructor
	*/
	ClipperLib.Maxima = function ()
	{
		this.X = 0;
		this.Next = null;
		this.Prev = null;
	};

	//OutRec: contains a path in the clipping solution. Edges in the AEL will
	//carry a pointer to an OutRec when they are part of the clipping solution.
	/**
	* @constructor
	*/
	ClipperLib.OutRec = function ()
	{
		this.Idx = 0;
		this.IsHole = false;
		this.IsOpen = false;
		this.FirstLeft = null; //see comments in clipper.pas
		this.Pts = null;
		this.BottomPt = null;
		this.PolyNode = null;
	};

	/**
	* @constructor
	*/
	ClipperLib.OutPt = function ()
	{
		this.Idx = 0;
		this.Pt = new ClipperLib.FPoint0();
		this.Next = null;
		this.Prev = null;
	};

	/**
	* @constructor
	*/
	ClipperLib.Join = function ()
	{
		this.OutPt1 = null;
		this.OutPt2 = null;
		this.OffPt = new ClipperLib.FPoint0();
	};

	ClipperLib.ClipperBase = function ()
	{
		this.m_MinimaList = null;
		this.m_CurrentLM = null;
		this.m_edges = new Array();
		this.m_HasOpenPaths = false;
		this.PreserveCollinear = false;
		this.m_Scanbeam = null;
		this.m_PolyOuts = null;
		this.m_ActiveEdges = null;
	};

	ClipperLib.ClipperBase.horizontal = -3.4E+38;
	ClipperLib.ClipperBase.Skip = -2;
	ClipperLib.ClipperBase.Unassigned = -1;
	ClipperLib.ClipperBase.tolerance = 1E-20;

	// The MAX_VALUE property has a value of 1.7976931348623157e+308. Values larger than MAX_VALUE are represented as "Infinity".
	//MIN_VALUE has a value of 5e-324. Values smaller than MIN_VALUE ("underflow values") are converted to 0.
	ClipperLib.ClipperBase.maxValue = Math.sqrt(Number.MAX_VALUE); // 1.3407807929942596e+154
	ClipperLib.ClipperBase.minValue = Math.sqrt(Number.MIN_VALUE); // 2.2227587494850775e-162

	ClipperLib.ClipperBase.near_zero = function (val)
	{
		return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);
	};

	ClipperLib.ClipperBase.IsHorizontal = function (e)
	{
		return e.Delta.Y === 0;
	};

	ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)
	{
		var pp2 = pp;
		do {
			if (ClipperLib.FPoint.op_Equality(pp2.Pt, pt))
				return true;
			pp2 = pp2.Next;
		}
		while (pp2 !== pp)
		return false;
	};

	ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2)
	{
			return ((pt.X === linePt1.X) && (pt.Y === linePt1.Y)) || ((pt.X === linePt2.X) && (pt.Y === linePt2.Y)) || (((pt.X > linePt1.X) === (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) === (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) === (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));
	};

	ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp)
	{
		var pp2 = pp;
		while (true)
		{
			if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt))
				return true;
			pp2 = pp2.Next;
			if (pp2 === pp)
				break;
		}
		return false;
	};

	ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()
	{
		var a = arguments,
			alen = a.length;
		var e1, e2, pt1, pt2, pt3, pt4;
		if (alen === 2) // function (e1, e2)
		{
			e1 = a[0];
			e2 = a[1];
			return e1.Delta.Y * e2.Delta.X === e1.Delta.X * e2.Delta.Y;
		}
		else if (alen === 3) // function (pt1, pt2, pt3)
		{
			pt1 = a[0];
			pt2 = a[1];
			pt3 = a[2];
			return (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) === 0;
		}
		else // function (pt1, pt2, pt3, pt4)
		{
			pt1 = a[0];
			pt2 = a[1];
			pt3 = a[2];
			pt4 = a[3];
			return (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) === 0;
		}
	};

	ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2)
	{
		return e1.Delta.Y * e2.Delta.X === e1.Delta.X * e2.Delta.Y;
	};

	ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3)
	{
		return (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) === 0;
	};

	ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4)
	{
		return (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) === 0;
	};

	ClipperLib.ClipperBase.prototype.Clear = function ()
	{
		this.DisposeLocalMinimaList();
		for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)
		{
			for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)
				this.m_edges[i][j] = null;
			ClipperLib.Clear(this.m_edges[i]);
		}
		ClipperLib.Clear(this.m_edges);
		this.m_HasOpenPaths = false;
	};

	ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()
	{
		while (this.m_MinimaList !== null)
		{
			var tmpLm = this.m_MinimaList.Next;
			this.m_MinimaList = null;
			this.m_MinimaList = tmpLm;
		}
		this.m_CurrentLM = null;
	};

	ClipperLib.ClipperBase.prototype.RangeTest = function (pt)
	{
		if(pt.X > ClipperLib.ClipperBase.maxValue || pt.X < -ClipperLib.ClipperBase.maxValue
		|| pt.Y > ClipperLib.ClipperBase.maxValue || pt.Y < -ClipperLib.ClipperBase.maxValue
|| (pt.X > 0 && pt.X < ClipperLib.ClipperBase.minValue) 
|| (pt.Y > 0 && pt.Y < ClipperLib.ClipperBase.minValue) 
|| (pt.X < 0 && pt.X > -ClipperLib.ClipperBase.minValue) 
|| (pt.Y < 0 && pt.Y > -ClipperLib.ClipperBase.minValue))
			ClipperLib.Error("Coordinate outside allowed range in RangeTest().");
	};

	ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)
	{
		e.Next = eNext;
		e.Prev = ePrev;
		//e.Curr = pt;
		e.Curr.X = pt.X;
		e.Curr.Y = pt.Y;
		if (ClipperLib.use_xyz) e.Curr.Z = pt.Z;
		e.OutIdx = -1;
	};

	ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)
	{
		if (e.Curr.Y >= e.Next.Curr.Y)
		{
			//e.Bot = e.Curr;
			e.Bot.X = e.Curr.X;
			e.Bot.Y = e.Curr.Y;
			if (ClipperLib.use_xyz) e.Bot.Z = e.Curr.Z;
			//e.Top = e.Next.Curr;
			e.Top.X = e.Next.Curr.X;
			e.Top.Y = e.Next.Curr.Y;
			if (ClipperLib.use_xyz) e.Top.Z = e.Next.Curr.Z;
		}
		else
		{
			//e.Top = e.Curr;
			e.Top.X = e.Curr.X;
			e.Top.Y = e.Curr.Y;
			if (ClipperLib.use_xyz) e.Top.Z = e.Curr.Z;
			//e.Bot = e.Next.Curr;
			e.Bot.X = e.Next.Curr.X;
			e.Bot.Y = e.Next.Curr.Y;
			if (ClipperLib.use_xyz) e.Bot.Z = e.Next.Curr.Z;
		}
		this.SetDx(e);
		e.PolyTyp = polyType;
	};

	ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)
	{
		var E2;
		for (;;)
		{
			while (ClipperLib.FPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.FPoint.op_Equality(E.Curr, E.Top))
				E = E.Next;
			if (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)
				break;
			while (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)
				E = E.Prev;
			E2 = E;
			while (E.Dx === ClipperLib.ClipperBase.horizontal)
				E = E.Next;
			if (E.Top.Y === E.Prev.Bot.Y)
				continue;
			//ie just an intermediate horz.
			if (E2.Prev.Bot.X < E.Bot.X)
				E = E2;
			break;
		}
		return E;
	};

	ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)
	{
		var EStart;
		var Result = E;
		var Horz;

		if (Result.OutIdx === ClipperLib.ClipperBase.Skip)
		{
			//check if there are edges beyond the skip edge in the bound and if so
			//create another LocMin and calling ProcessBound once more ...
			E = Result;
			if (LeftBoundIsForward)
			{
				while (E.Top.Y === E.Next.Bot.Y) E = E.Next;
				while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;
			}
			else
			{
				while (E.Top.Y === E.Prev.Bot.Y) E = E.Prev;
				while (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;
			}
			if (E === Result)
			{
				if (LeftBoundIsForward) Result = E.Next;
				else Result = E.Prev;
			}
			else
			{
				//there are more edges in the bound beyond result starting with E
				if (LeftBoundIsForward)
					E = Result.Next;
				else
					E = Result.Prev;
				var locMin = new ClipperLib.LocalMinima();
				locMin.Next = null;
				locMin.Y = E.Bot.Y;
				locMin.LeftBound = null;
				locMin.RightBound = E;
				E.WindDelta = 0;
				Result = this.ProcessBound(E, LeftBoundIsForward);
				this.InsertLocalMinima(locMin);
			}
			return Result;
		}

		if (E.Dx === ClipperLib.ClipperBase.horizontal)
		{
			//We need to be careful with open paths because this may not be a
			//true local minima (ie E may be following a skip edge).
			//Also, consecutive horz. edges may start heading left before going right.
			if (LeftBoundIsForward) EStart = E.Prev;
			else EStart = E.Next;

			if (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge
			{
				if (EStart.Bot.X !== E.Bot.X && EStart.Top.X !== E.Bot.X)
					this.ReverseHorizontal(E);
			}
			else if (EStart.Bot.X !== E.Bot.X)
				this.ReverseHorizontal(E);
		}

		EStart = E;
		if (LeftBoundIsForward)
		{
			while (Result.Top.Y === Result.Next.Bot.Y && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)
				Result = Result.Next;
			if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)
			{
				//nb: at the top of a bound, horizontals are added to the bound
				//only when the preceding edge attaches to the horizontal's left vertex
				//unless a Skip edge is encountered when that becomes the top divide
				Horz = Result;
				while (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)
					Horz = Horz.Prev;
				if (Horz.Prev.Top.X > Result.Next.Top.X)
					Result = Horz.Prev;
			}
			while (E !== Result)
			{
				E.NextInLML = E.Next;
				if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)
					this.ReverseHorizontal(E);
				E = E.Next;
			}
			if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)
				this.ReverseHorizontal(E);
			Result = Result.Next;
			//move to the edge just beyond current bound
		}
		else
		{
			while (Result.Top.Y === Result.Prev.Bot.Y && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)
				Result = Result.Prev;
			if (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)
			{
				Horz = Result;
				while (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)
					Horz = Horz.Next;
				if (Horz.Next.Top.X === Result.Prev.Top.X || Horz.Next.Top.X > Result.Prev.Top.X)
				{
					Result = Horz.Next;
				}
			}
			while (E !== Result)
			{
				E.NextInLML = E.Prev;
				if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)
					this.ReverseHorizontal(E);
				E = E.Prev;
			}
			if (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)
				this.ReverseHorizontal(E);
			Result = Result.Prev;
			//move to the edge just beyond current bound
		}

		return Result;
	};

	ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)
	{
		if (ClipperLib.use_lines)
		{
			if (!Closed && polyType === ClipperLib.PolyType.ptClip)
				ClipperLib.Error("AddPath: Open paths must be subject.");
		}
		else
		{
			if (!Closed)
				ClipperLib.Error("AddPath: Open paths have been disabled.");
		}
		var highI = pg.length - 1;
		if (Closed)
			while (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[0])))
				--highI;
		while (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[highI - 1])))
			--highI;
		if ((Closed && highI < 2) || (!Closed && highI < 1))
			return false;
		//create a new edge array ...
		var edges = new Array();
		for (var i = 0; i <= highI; i++)
			edges.push(new ClipperLib.TEdge());
		var IsFlat = true;
		//1. Basic (first) edge initialization ...

		//edges[1].Curr = pg[1];
		edges[1].Curr.X = pg[1].X;
		edges[1].Curr.Y = pg[1].Y;
		if (ClipperLib.use_xyz) edges[1].Curr.Z = pg[1].Z;

		this.RangeTest(pg[0]);

		this.RangeTest(pg[highI]);

		this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);
		this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);
		for (var i = highI - 1; i >= 1; --i)
		{
			this.RangeTest(pg[i]);

			this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);
		}

		var eStart = edges[0];
		//2. Remove duplicate vertices, and (when closed) collinear edges ...
		var E = eStart,
			eLoopStop = eStart;
		for (;;)
		{
			//console.log(E.Next, eStart);
			//nb: allows matching start and end points when not Closed ...
			if (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart))
			{
				if (E === E.Next)
					break;
				if (E === eStart)
					eStart = E.Next;
				E = this.RemoveEdge(E);
				eLoopStop = E;
				continue;
			}
			if (E.Prev === E.Next)
				break;
			else if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))
			{
				//Collinear edges are allowed for open paths but in closed paths
				//the default is to merge adjacent collinear edges into a single edge.
				//However, if the PreserveCollinear property is enabled, only overlapping
				//collinear edges (ie spikes) will be removed from closed paths.
				if (E === eStart)
					eStart = E.Next;
				E = this.RemoveEdge(E);
				E = E.Prev;
				eLoopStop = E;
				continue;
			}
			E = E.Next;
			if ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;
		}
		if ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))
			return false;
		if (!Closed)
		{
			this.m_HasOpenPaths = true;
			eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
		}
		//3. Do second stage of edge initialization ...
		E = eStart;
		do {
			this.InitEdge2(E, polyType);
			E = E.Next;
			if (IsFlat && E.Curr.Y !== eStart.Curr.Y)
				IsFlat = false;
		}
		while (E !== eStart)
		//4. Finally, add edge bounds to LocalMinima list ...
		//Totally flat paths must be handled differently when adding them
		//to LocalMinima list to avoid endless loops etc ...
		if (IsFlat)
		{
			if (Closed)
				return false;

			E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;

			var locMin = new ClipperLib.LocalMinima();
			locMin.Next = null;
			locMin.Y = E.Bot.Y;
			locMin.LeftBound = null;
			locMin.RightBound = E;
			locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
			locMin.RightBound.WindDelta = 0;

			for (;;)
			{
				if (E.Bot.X !== E.Prev.Top.X) this.ReverseHorizontal(E);
				if (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;
				E.NextInLML = E.Next;
				E = E.Next;
			}
			this.InsertLocalMinima(locMin);
			this.m_edges.push(edges);
			return true;
		}
		this.m_edges.push(edges);
		var leftBoundIsForward;
		var EMin = null;

		//workaround to avoid an endless loop in the while loop below when
		//open paths have matching start and end points ...
		if (ClipperLib.FPoint.op_Equality(E.Prev.Bot, E.Prev.Top))
			E = E.Next;

		for (;;)
		{
			E = this.FindNextLocMin(E);
			if (E === EMin)
				break;
			else if (EMin === null)
				EMin = E;
			//E and E.Prev now share a local minima (left aligned if horizontal).
			//Compare their slopes to find which starts which bound ...
			var locMin = new ClipperLib.LocalMinima();
			locMin.Next = null;
			locMin.Y = E.Bot.Y;
			if (E.Dx < E.Prev.Dx)
			{
				locMin.LeftBound = E.Prev;
				locMin.RightBound = E;
				leftBoundIsForward = false;
				//Q.nextInLML = Q.prev
			}
			else
			{
				locMin.LeftBound = E;
				locMin.RightBound = E.Prev;
				leftBoundIsForward = true;
				//Q.nextInLML = Q.next
			}
			locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;
			locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
			if (!Closed)
				locMin.LeftBound.WindDelta = 0;
			else if (locMin.LeftBound.Next === locMin.RightBound)
				locMin.LeftBound.WindDelta = -1;
			else
				locMin.LeftBound.WindDelta = 1;
			locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;
			E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);
			if (E.OutIdx === ClipperLib.ClipperBase.Skip)
				E = this.ProcessBound(E, leftBoundIsForward);
			var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);
			if (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);
			if (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)
				locMin.LeftBound = null;
			else if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)
				locMin.RightBound = null;
			this.InsertLocalMinima(locMin);
			if (!leftBoundIsForward)
				E = E2;
		}
		return true;
	};

	ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)
	{
		//  console.log("-------------------------------------------");
		//  console.log(JSON.stringify(ppg));
		var result = false;
		for (var i = 0, ilen = ppg.length; i < ilen; ++i)
			if (this.AddPath(ppg[i], polyType, closed))
				result = true;
		return result;
	};

	ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)
	{
		if ((ClipperLib.FPoint.op_Equality(pt1, pt3)) || (ClipperLib.FPoint.op_Equality(pt1, pt2)) || (ClipperLib.FPoint.op_Equality(pt3, pt2)))

			//if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))
			return false;

		else if (pt1.X !== pt3.X)
			return (pt2.X > pt1.X) === (pt2.X < pt3.X);
		else
			return (pt2.Y > pt1.Y) === (pt2.Y < pt3.Y);
	};

	ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)
	{
		//removes e from double_linked_list (but without removing from memory)
		e.Prev.Next = e.Next;
		e.Next.Prev = e.Prev;
		var result = e.Next;
		e.Prev = null; //flag as removed (see ClipperBase.Clear)
		return result;
	};

	ClipperLib.ClipperBase.prototype.SetDx = function (e)
	{
		e.Delta.X = (e.Top.X - e.Bot.X);
		e.Delta.Y = (e.Top.Y - e.Bot.Y);
		if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;
		else e.Dx = (e.Delta.X) / (e.Delta.Y);
	};

	ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)
	{
		if (this.m_MinimaList === null)
		{
			this.m_MinimaList = newLm;
		}
		else if (newLm.Y >= this.m_MinimaList.Y)
		{
			newLm.Next = this.m_MinimaList;
			this.m_MinimaList = newLm;
		}
		else
		{
			var tmpLm = this.m_MinimaList;
			while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))
				tmpLm = tmpLm.Next;
			newLm.Next = tmpLm.Next;
			tmpLm.Next = newLm;
		}
	};

	ClipperLib.ClipperBase.prototype.PopLocalMinima = function (Y, current)
	{
		current.v = this.m_CurrentLM;
		if (this.m_CurrentLM !== null && this.m_CurrentLM.Y === Y)
		{
			this.m_CurrentLM = this.m_CurrentLM.Next;
			return true;
		}
		return false;
	};

	ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)
	{
		//swap horizontal edges' top and bottom x's so they follow the natural
		//progression of the bounds - ie so their xbots will align with the
		//adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
		var tmp = e.Top.X;
		e.Top.X = e.Bot.X;
		e.Bot.X = tmp;
		if (ClipperLib.use_xyz)
		{
			tmp = e.Top.Z;
			e.Top.Z = e.Bot.Z;
			e.Bot.Z = tmp;
		}
	};

	ClipperLib.ClipperBase.prototype.Reset = function ()
	{
		this.m_CurrentLM = this.m_MinimaList;
		if (this.m_CurrentLM === null) //ie nothing to process
			return;
		//reset all edges ...
		this.m_Scanbeam = null;
		var lm = this.m_MinimaList;
		while (lm !== null)
		{
			this.InsertScanbeam(lm.Y);
			var e = lm.LeftBound;
			if (e !== null)
			{
				//e.Curr = e.Bot;
				e.Curr.X = e.Bot.X;
				e.Curr.Y = e.Bot.Y;
				if (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;
				e.OutIdx = ClipperLib.ClipperBase.Unassigned;
			}
			e = lm.RightBound;
			if (e !== null)
			{
				//e.Curr = e.Bot;
				e.Curr.X = e.Bot.X;
				e.Curr.Y = e.Bot.Y;
				if (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;
				e.OutIdx = ClipperLib.ClipperBase.Unassigned;
			}
			lm = lm.Next;
		}
		this.m_ActiveEdges = null;
	};

	ClipperLib.ClipperBase.prototype.InsertScanbeam = function (Y)
	{
		//single-linked list: sorted descending, ignoring dups.
		if (this.m_Scanbeam === null)
		{
			this.m_Scanbeam = new ClipperLib.Scanbeam();
			this.m_Scanbeam.Next = null;
			this.m_Scanbeam.Y = Y;
		}
		else if (Y > this.m_Scanbeam.Y)
		{
			var newSb = new ClipperLib.Scanbeam();
			newSb.Y = Y;
			newSb.Next = this.m_Scanbeam;
			this.m_Scanbeam = newSb;
		}
		else
		{
			var sb2 = this.m_Scanbeam;
			while (sb2.Next !== null && Y <= sb2.Next.Y)
			{
				sb2 = sb2.Next;
			}
			if (Y === sb2.Y)
			{
				return;
			} //ie ignores duplicates
			var newSb1 = new ClipperLib.Scanbeam();
			newSb1.Y = Y;
			newSb1.Next = sb2.Next;
			sb2.Next = newSb1;
		}
	};

	ClipperLib.ClipperBase.prototype.PopScanbeam = function (Y)
	{
		if (this.m_Scanbeam === null)
		{
			Y.v = 0;
			return false;
		}
		Y.v = this.m_Scanbeam.Y;
		this.m_Scanbeam = this.m_Scanbeam.Next;
		return true;
	};

	ClipperLib.ClipperBase.prototype.LocalMinimaPending = function ()
	{
		return (this.m_CurrentLM !== null);
	};

	ClipperLib.ClipperBase.prototype.CreateOutRec = function ()
	{
		var result = new ClipperLib.OutRec();
		result.Idx = ClipperLib.ClipperBase.Unassigned;
		result.IsHole = false;
		result.IsOpen = false;
		result.FirstLeft = null;
		result.Pts = null;
		result.BottomPt = null;
		result.PolyNode = null;
		this.m_PolyOuts.push(result);
		result.Idx = this.m_PolyOuts.length - 1;
		return result;
	};

	ClipperLib.ClipperBase.prototype.DisposeOutRec = function (index)
	{
		var outRec = this.m_PolyOuts[index];
		outRec.Pts = null;
		outRec = null;
		this.m_PolyOuts[index] = null;
	};

	ClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function (e)
	{
		if (e.NextInLML === null)
		{
			ClipperLib.Error("UpdateEdgeIntoAEL: invalid call");
		}
		var AelPrev = e.PrevInAEL;
		var AelNext = e.NextInAEL;
		e.NextInLML.OutIdx = e.OutIdx;
		if (AelPrev !== null)
		{
			AelPrev.NextInAEL = e.NextInLML;
		}
		else
		{
			this.m_ActiveEdges = e.NextInLML;
		}
		if (AelNext !== null)
		{
			AelNext.PrevInAEL = e.NextInLML;
		}
		e.NextInLML.Side = e.Side;
		e.NextInLML.WindDelta = e.WindDelta;
		e.NextInLML.WindCnt = e.WindCnt;
		e.NextInLML.WindCnt2 = e.WindCnt2;
		e = e.NextInLML;
		e.Curr.X = e.Bot.X;
		e.Curr.Y = e.Bot.Y;
		e.PrevInAEL = AelPrev;
		e.NextInAEL = AelNext;
		if (!ClipperLib.ClipperBase.IsHorizontal(e))
		{
			this.InsertScanbeam(e.Top.Y);
		}
		return e;
	};

	ClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2)
	{
		//check that one or other edge hasn't already been removed from AEL ...
		if (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL)
		{
			return;
		}

		if (edge1.NextInAEL === edge2)
		{
			var next = edge2.NextInAEL;
			if (next !== null)
			{
				next.PrevInAEL = edge1;
			}
			var prev = edge1.PrevInAEL;
			if (prev !== null)
			{
				prev.NextInAEL = edge2;
			}
			edge2.PrevInAEL = prev;
			edge2.NextInAEL = edge1;
			edge1.PrevInAEL = edge2;
			edge1.NextInAEL = next;
		}
		else if (edge2.NextInAEL === edge1)
		{
			var next1 = edge1.NextInAEL;
			if (next1 !== null)
			{
				next1.PrevInAEL = edge2;
			}
			var prev1 = edge2.PrevInAEL;
			if (prev1 !== null)
			{
				prev1.NextInAEL = edge1;
			}
			edge1.PrevInAEL = prev1;
			edge1.NextInAEL = edge2;
			edge2.PrevInAEL = edge1;
			edge2.NextInAEL = next1;
		}
		else
		{
			var next2 = edge1.NextInAEL;
			var prev2 = edge1.PrevInAEL;
			edge1.NextInAEL = edge2.NextInAEL;
			if (edge1.NextInAEL !== null)
			{
				edge1.NextInAEL.PrevInAEL = edge1;
			}
			edge1.PrevInAEL = edge2.PrevInAEL;
			if (edge1.PrevInAEL !== null)
			{
				edge1.PrevInAEL.NextInAEL = edge1;
			}
			edge2.NextInAEL = next2;
			if (edge2.NextInAEL !== null)
			{
				edge2.NextInAEL.PrevInAEL = edge2;
			}
			edge2.PrevInAEL = prev2;
			if (edge2.PrevInAEL !== null)
			{
				edge2.PrevInAEL.NextInAEL = edge2;
			}
		}

		if (edge1.PrevInAEL === null)
		{
			this.m_ActiveEdges = edge1;
		}
		else
		{
			if (edge2.PrevInAEL === null)
			{
				this.m_ActiveEdges = edge2;
			}
		}
	};

	ClipperLib.ClipperBase.prototype.DeleteFromAEL = function (e)
	{
		var AelPrev = e.PrevInAEL;
		var AelNext = e.NextInAEL;
		if (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges)
		{
			return;
		} //already deleted
		if (AelPrev !== null)
		{
			AelPrev.NextInAEL = AelNext;
		}
		else
		{
			this.m_ActiveEdges = AelNext;
		}
		if (AelNext !== null)
		{
			AelNext.PrevInAEL = AelPrev;
		}
		e.NextInAEL = null;
		e.PrevInAEL = null;
	}

	// public Clipper(int InitOptions = 0)
	/**
	 * @suppress {missingProperties}
	 */
	ClipperLib.Clipper = function (InitOptions)
	{
		if (typeof (InitOptions) === "undefined") InitOptions = 0;
		this.m_PolyOuts = null;
		this.m_ClipType = ClipperLib.ClipType.ctIntersection;
		this.m_Scanbeam = null;
		this.m_Maxima = null;
		this.m_ActiveEdges = null;
		this.m_SortedEdges = null;
		this.m_IntersectList = null;
		this.m_IntersectNodeComparer = null;
		this.m_ExecuteLocked = false;
		this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;
		this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;
		this.m_Joins = null;
		this.m_GhostJoins = null;
		this.m_UsingPolyTree = false;
		this.ReverseSolution = false;
		this.StrictlySimple = false;

		ClipperLib.ClipperBase.call(this);

		this.m_Scanbeam = null;
		this.m_Maxima = null;
		this.m_ActiveEdges = null;
		this.m_SortedEdges = null;
		this.m_IntersectList = new Array();
		this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;
		this.m_ExecuteLocked = false;
		this.m_UsingPolyTree = false;
		this.m_PolyOuts = new Array();
		this.m_Joins = new Array();
		this.m_GhostJoins = new Array();
		this.ReverseSolution = (1 & InitOptions) !== 0;
		this.StrictlySimple = (2 & InitOptions) !== 0;
		this.PreserveCollinear = (4 & InitOptions) !== 0;
		if (ClipperLib.use_xyz)
		{
			this.ZFillFunction = null; // function (FPoint bot1, FPoint top1, FPoint bot2, FPoint top2, ref FPoint intersectPt);
		}
	};

	ClipperLib.Clipper.ioReverseSolution = 1;
	ClipperLib.Clipper.ioStrictlySimple = 2;
	ClipperLib.Clipper.ioPreserveCollinear = 4;

	ClipperLib.Clipper.prototype.Clear = function ()
	{
		if (this.m_edges.length === 0)
			return;
		//avoids problems with ClipperBase destructor
		this.DisposeAllPolyPts();
		ClipperLib.ClipperBase.prototype.Clear.call(this);
	};

	ClipperLib.Clipper.prototype.InsertMaxima = function (X)
	{
		//double-linked list: sorted ascending, ignoring dups.
		var newMax = new ClipperLib.Maxima();
		newMax.X = X;
		if (this.m_Maxima === null)
		{
			this.m_Maxima = newMax;
			this.m_Maxima.Next = null;
			this.m_Maxima.Prev = null;
		}
		else if (X < this.m_Maxima.X)
		{
			newMax.Next = this.m_Maxima;
			newMax.Prev = null;
			this.m_Maxima = newMax;
		}
		else
		{
			var m = this.m_Maxima;
			while (m.Next !== null && X >= m.Next.X)
			{
				m = m.Next;
			}
			if (X === m.X)
			{
				return;
			} //ie ignores duplicates (& CG to clean up newMax)
			//insert newMax between m and m.Next ...
			newMax.Next = m.Next;
			newMax.Prev = m;
			if (m.Next !== null)
			{
				m.Next.Prev = newMax;
			}
			m.Next = newMax;
		}
	};

	// ************************************
	ClipperLib.Clipper.prototype.Execute = function ()
	{
		var a = arguments,
			alen = a.length,
			ispolytree = a[1] instanceof ClipperLib.PolyTree;
		if (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)
		{
			var clipType = a[0],
				solution = a[1],
				subjFillType = a[2],
				clipFillType = a[3];
			if (this.m_ExecuteLocked)
				return false;
			if (this.m_HasOpenPaths)
				ClipperLib.Error("Error: PolyTree struct is needed for open path clipping.");
			this.m_ExecuteLocked = true;
			ClipperLib.Clear(solution);
			this.m_SubjFillType = subjFillType;
			this.m_ClipFillType = clipFillType;
			this.m_ClipType = clipType;
			this.m_UsingPolyTree = false;
			try
			{
				var succeeded = this.ExecuteInternal();
				//build the return polygons ...
				if (succeeded) this.BuildResult(solution);
			}
			finally
			{
				this.DisposeAllPolyPts();
				this.m_ExecuteLocked = false;
			}
			return succeeded;
		}
		else if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)
		{
			var clipType = a[0],
				polytree = a[1],
				subjFillType = a[2],
				clipFillType = a[3];
			if (this.m_ExecuteLocked)
				return false;
			this.m_ExecuteLocked = true;
			this.m_SubjFillType = subjFillType;
			this.m_ClipFillType = clipFillType;
			this.m_ClipType = clipType;
			this.m_UsingPolyTree = true;
			try
			{
				var succeeded = this.ExecuteInternal();
				//build the return polygons ...
				if (succeeded) this.BuildResult2(polytree);
			}
			finally
			{
				this.DisposeAllPolyPts();
				this.m_ExecuteLocked = false;
			}
			return succeeded;
		}
		else if (alen === 2 && !ispolytree) // function (clipType, solution)
		{
			var clipType = a[0],
				solution = a[1];
			return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
		}
		else if (alen === 2 && ispolytree) // function (clipType, polytree)
		{
			var clipType = a[0],
				polytree = a[1];
			return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
		}
	};

	ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)
	{
		//skip if an outermost polygon or
		//already already points to the correct FirstLeft ...
		if (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))
			return;
		var orfl = outRec.FirstLeft;
		while (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))
			orfl = orfl.FirstLeft;
		outRec.FirstLeft = orfl;
	};

	ClipperLib.Clipper.prototype.ExecuteInternal = function ()
	{
		try
		{
			this.Reset();
			this.m_SortedEdges = null;
			this.m_Maxima = null;

			var botY = {},
				topY = {};

			if (!this.PopScanbeam(botY))
			{
				return false;
			}
			this.InsertLocalMinimaIntoAEL(botY.v);
			while (this.PopScanbeam(topY) || this.LocalMinimaPending())
			{
				this.ProcessHorizontals();
				this.m_GhostJoins.length = 0;
				if (!this.ProcessIntersections(topY.v))
				{
					return false;
				}
				this.ProcessEdgesAtTopOfScanbeam(topY.v);
				botY.v = topY.v;
				this.InsertLocalMinimaIntoAEL(botY.v);
			}

			//fix orientations ...
			var outRec, i, ilen;
			//fix orientations ...
			for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
			{
				outRec = this.m_PolyOuts[i];
				if (outRec.Pts === null || outRec.IsOpen) continue;
				if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))
					this.ReversePolyPtLinks(outRec.Pts);
			}

			this.JoinCommonEdges();

			for (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
			{
				outRec = this.m_PolyOuts[i];
				if (outRec.Pts === null)
					continue;
				else if (outRec.IsOpen)
					this.FixupOutPolyline(outRec);
				else
					this.FixupOutPolygon(outRec);
			}

			if (this.StrictlySimple) this.DoSimplePolygons();
			return true;
		}
		//catch { return false; }
		finally
		{
			this.m_Joins.length = 0;
			this.m_GhostJoins.length = 0;
		}
	};

	ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()
	{
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)
			this.DisposeOutRec(i);
		ClipperLib.Clear(this.m_PolyOuts);
	};

	ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)
	{
		var j = new ClipperLib.Join();
		j.OutPt1 = Op1;
		j.OutPt2 = Op2;
		//j.OffPt = OffPt;
		j.OffPt.X = OffPt.X;
		j.OffPt.Y = OffPt.Y;
		if (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;
		this.m_Joins.push(j);
	};

	ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)
	{
		var j = new ClipperLib.Join();
		j.OutPt1 = Op;
		//j.OffPt = OffPt;
		j.OffPt.X = OffPt.X;
		j.OffPt.Y = OffPt.Y;
		if (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;
		this.m_GhostJoins.push(j);
	};

	//if (ClipperLib.use_xyz)
	//{
	ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)
	{
		if (this.ZFillFunction !== null)
		{
			if (pt.Z !== Z_MISSING || this.ZFillFunction === null) return;
			else if (ClipperLib.FPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;
			else if (ClipperLib.FPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;
			else if (ClipperLib.FPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;
			else if (ClipperLib.FPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;
			else this.ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);
		}
	};
	//}

	ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)
	{
		var lm = {};

		var lb;
		var rb;
		while (this.PopLocalMinima(botY, lm))
		{
			lb = lm.v.LeftBound;
			rb = lm.v.RightBound;

			var Op1 = null;
			if (lb === null)
			{
				this.InsertEdgeIntoAEL(rb, null);
				this.SetWindingCount(rb);
				if (this.IsContributing(rb))
					Op1 = this.AddOutPt(rb, rb.Bot);
			}
			else if (rb === null)
			{
				this.InsertEdgeIntoAEL(lb, null);
				this.SetWindingCount(lb);
				if (this.IsContributing(lb))
					Op1 = this.AddOutPt(lb, lb.Bot);
				this.InsertScanbeam(lb.Top.Y);
			}
			else
			{
				this.InsertEdgeIntoAEL(lb, null);
				this.InsertEdgeIntoAEL(rb, lb);
				this.SetWindingCount(lb);
				rb.WindCnt = lb.WindCnt;
				rb.WindCnt2 = lb.WindCnt2;
				if (this.IsContributing(lb))
					Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);
				this.InsertScanbeam(lb.Top.Y);
			}
			if (rb !== null)
			{
				if (ClipperLib.ClipperBase.IsHorizontal(rb))
				{
					if (rb.NextInLML !== null)
					{
						this.InsertScanbeam(rb.NextInLML.Top.Y);
					}
					this.AddEdgeToSEL(rb);
				}
				else
				{
					this.InsertScanbeam(rb.Top.Y);
				}
			}
			if (lb === null || rb === null) continue;
			//if output polygons share an Edge with a horizontal rb, they'll need joining later ...
			if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)
			{
				for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)
				{
					//if the horizontal Rb and a 'ghost' horizontal overlap, then convert
					//the 'ghost' join to a real join ready for later ...
					var j = this.m_GhostJoins[i];

					if (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))
						this.AddJoin(j.OutPt1, Op1, j.OffPt);
				}
			}

			if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&
				lb.PrevInAEL.Curr.X === lb.Bot.X &&
				lb.PrevInAEL.OutIdx >= 0 &&
				ClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top) &&
				lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)
			{
				var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);
				this.AddJoin(Op1, Op2, lb.Top);
			}
			if (lb.NextInAEL !== rb)
			{
				if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&
					ClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top) &&
					rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)
				{
					var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);
					this.AddJoin(Op1, Op2, rb.Top);
				}
				var e = lb.NextInAEL;
				if (e !== null)
					while (e !== rb)
					{
						//nb: For calculating winding counts etc, IntersectEdges() assumes
						//that param1 will be to the right of param2 ABOVE the intersection ...
						this.IntersectEdges(rb, e, lb.Curr);
						//order important here
						e = e.NextInAEL;
					}
			}
		}
	};

	ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)
	{
		if (this.m_ActiveEdges === null)
		{
			edge.PrevInAEL = null;
			edge.NextInAEL = null;
			this.m_ActiveEdges = edge;
		}
		else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))
		{
			edge.PrevInAEL = null;
			edge.NextInAEL = this.m_ActiveEdges;
			this.m_ActiveEdges.PrevInAEL = edge;
			this.m_ActiveEdges = edge;
		}
		else
		{
			if (startEdge === null)
				startEdge = this.m_ActiveEdges;
			while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))
				startEdge = startEdge.NextInAEL;
			edge.NextInAEL = startEdge.NextInAEL;
			if (startEdge.NextInAEL !== null)
				startEdge.NextInAEL.PrevInAEL = edge;
			edge.PrevInAEL = startEdge;
			startEdge.NextInAEL = edge;
		}
	};

	ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)
	{
		if (e2.Curr.X === e1.Curr.X)
		{
			if (e2.Top.Y > e1.Top.Y)
				return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);
			else
				return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);
		}
		else
			return e2.Curr.X < e1.Curr.X;
	};

	ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)
	{
		if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)
			return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;
		else
			return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;
	};

	ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)
	{
		if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)
			return this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;
		else
			return this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;
	};

	ClipperLib.Clipper.prototype.IsContributing = function (edge)
	{
		var pft, pft2;
		if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)
		{
			pft = this.m_SubjFillType;
			pft2 = this.m_ClipFillType;
		}
		else
		{
			pft = this.m_ClipFillType;
			pft2 = this.m_SubjFillType;
		}
		switch (pft)
		{
		case ClipperLib.PolyFillType.pftEvenOdd:
			if (edge.WindDelta === 0 && edge.WindCnt !== 1)
				return false;
			break;
		case ClipperLib.PolyFillType.pftNonZero:
			if (Math.abs(edge.WindCnt) !== 1)
				return false;
			break;
		case ClipperLib.PolyFillType.pftPositive:
			if (edge.WindCnt !== 1)
				return false;
			break;
		default:
			if (edge.WindCnt !== -1)
				return false;
			break;
		}
		switch (this.m_ClipType)
		{
		case ClipperLib.ClipType.ctIntersection:
			switch (pft2)
			{
			case ClipperLib.PolyFillType.pftEvenOdd:
			case ClipperLib.PolyFillType.pftNonZero:
				return (edge.WindCnt2 !== 0);
			case ClipperLib.PolyFillType.pftPositive:
				return (edge.WindCnt2 > 0);
			default:
				return (edge.WindCnt2 < 0);
			}
		case ClipperLib.ClipType.ctUnion:
			switch (pft2)
			{
			case ClipperLib.PolyFillType.pftEvenOdd:
			case ClipperLib.PolyFillType.pftNonZero:
				return (edge.WindCnt2 === 0);
			case ClipperLib.PolyFillType.pftPositive:
				return (edge.WindCnt2 <= 0);
			default:
				return (edge.WindCnt2 >= 0);
			}
		case ClipperLib.ClipType.ctDifference:
			if (edge.PolyTyp === ClipperLib.PolyType.ptSubject)
				switch (pft2)
				{
				case ClipperLib.PolyFillType.pftEvenOdd:
				case ClipperLib.PolyFillType.pftNonZero:
					return (edge.WindCnt2 === 0);
				case ClipperLib.PolyFillType.pftPositive:
					return (edge.WindCnt2 <= 0);
				default:
					return (edge.WindCnt2 >= 0);
				}
			else
				switch (pft2)
				{
				case ClipperLib.PolyFillType.pftEvenOdd:
				case ClipperLib.PolyFillType.pftNonZero:
					return (edge.WindCnt2 !== 0);
				case ClipperLib.PolyFillType.pftPositive:
					return (edge.WindCnt2 > 0);
				default:
					return (edge.WindCnt2 < 0);
				}
		case ClipperLib.ClipType.ctXor:
			if (edge.WindDelta === 0)
				switch (pft2)
				{
				case ClipperLib.PolyFillType.pftEvenOdd:
				case ClipperLib.PolyFillType.pftNonZero:
					return (edge.WindCnt2 === 0);
				case ClipperLib.PolyFillType.pftPositive:
					return (edge.WindCnt2 <= 0);
				default:
					return (edge.WindCnt2 >= 0);
				}
			else
				return true;
		}
		return true;
	};

	ClipperLib.Clipper.prototype.SetWindingCount = function (edge)
	{
		var e = edge.PrevInAEL;
		//find the edge of the same polytype that immediately preceeds 'edge' in AEL
		while (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))
			e = e.PrevInAEL;
		if (e === null)
		{
			var pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);
			if (edge.WindDelta === 0)
			{
				edge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);
			}
			else
			{
				edge.WindCnt = edge.WindDelta;
			}
			edge.WindCnt2 = 0;
			e = this.m_ActiveEdges;
			//ie get ready to calc WindCnt2
		}
		else if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion)
		{
			edge.WindCnt = 1;
			edge.WindCnt2 = e.WindCnt2;
			e = e.NextInAEL;
			//ie get ready to calc WindCnt2
		}
		else if (this.IsEvenOddFillType(edge))
		{
			//EvenOdd filling ...
			if (edge.WindDelta === 0)
			{
				//are we inside a subj polygon ...
				var Inside = true;
				var e2 = e.PrevInAEL;
				while (e2 !== null)
				{
					if (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)
						Inside = !Inside;
					e2 = e2.PrevInAEL;
				}
				edge.WindCnt = (Inside ? 0 : 1);
			}
			else
			{
				edge.WindCnt = edge.WindDelta;
			}
			edge.WindCnt2 = e.WindCnt2;
			e = e.NextInAEL;
			//ie get ready to calc WindCnt2
		}
		else
		{
			//nonZero, Positive or Negative filling ...
			if (e.WindCnt * e.WindDelta < 0)
			{
				//prev edge is 'decreasing' WindCount (WC) toward zero
				//so we're outside the previous polygon ...
				if (Math.abs(e.WindCnt) > 1)
				{
					//outside prev poly but still inside another.
					//when reversing direction of prev poly use the same WC
					if (e.WindDelta * edge.WindDelta < 0)
						edge.WindCnt = e.WindCnt;
					else
						edge.WindCnt = e.WindCnt + edge.WindDelta;
				}
				else
					edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
			}
			else
			{
				//prev edge is 'increasing' WindCount (WC) away from zero
				//so we're inside the previous polygon ...
				if (edge.WindDelta === 0)
					edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);
				else if (e.WindDelta * edge.WindDelta < 0)
					edge.WindCnt = e.WindCnt;
				else
					edge.WindCnt = e.WindCnt + edge.WindDelta;
			}
			edge.WindCnt2 = e.WindCnt2;
			e = e.NextInAEL;
			//ie get ready to calc WindCnt2
		}
		//update WindCnt2 ...
		if (this.IsEvenOddAltFillType(edge))
		{
			//EvenOdd filling ...
			while (e !== edge)
			{
				if (e.WindDelta !== 0)
					edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);
				e = e.NextInAEL;
			}
		}
		else
		{
			//nonZero, Positive or Negative filling ...
			while (e !== edge)
			{
				edge.WindCnt2 += e.WindDelta;
				e = e.NextInAEL;
			}
		}
	};

	ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)
	{
		//SEL pointers in PEdge are use to build transient lists of horizontal edges.
		//However, since we don't need to worry about processing order, all additions
		//are made to the front of the list ...
		if (this.m_SortedEdges === null)
		{
			this.m_SortedEdges = edge;
			edge.PrevInSEL = null;
			edge.NextInSEL = null;
		}
		else
		{
			edge.NextInSEL = this.m_SortedEdges;
			edge.PrevInSEL = null;
			this.m_SortedEdges.PrevInSEL = edge;
			this.m_SortedEdges = edge;
		}
	};

	ClipperLib.Clipper.prototype.PopEdgeFromSEL = function (e)
	{
		//Pop edge from front of SEL (ie SEL is a FILO list)
		e.v = this.m_SortedEdges;
		if (e.v === null)
		{
			return false;
		}
		var oldE = e.v;
		this.m_SortedEdges = e.v.NextInSEL;
		if (this.m_SortedEdges !== null)
		{
			this.m_SortedEdges.PrevInSEL = null;
		}
		oldE.NextInSEL = null;
		oldE.PrevInSEL = null;
		return true;
	};

	ClipperLib.Clipper.prototype.CopyAELToSEL = function ()
	{
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while (e !== null)
		{
			e.PrevInSEL = e.PrevInAEL;
			e.NextInSEL = e.NextInAEL;
			e = e.NextInAEL;
		}
	};

	ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)
	{
		if (edge1.NextInSEL === null && edge1.PrevInSEL === null)
			return;
		if (edge2.NextInSEL === null && edge2.PrevInSEL === null)
			return;
		if (edge1.NextInSEL === edge2)
		{
			var next = edge2.NextInSEL;
			if (next !== null)
				next.PrevInSEL = edge1;
			var prev = edge1.PrevInSEL;
			if (prev !== null)
				prev.NextInSEL = edge2;
			edge2.PrevInSEL = prev;
			edge2.NextInSEL = edge1;
			edge1.PrevInSEL = edge2;
			edge1.NextInSEL = next;
		}
		else if (edge2.NextInSEL === edge1)
		{
			var next = edge1.NextInSEL;
			if (next !== null)
				next.PrevInSEL = edge2;
			var prev = edge2.PrevInSEL;
			if (prev !== null)
				prev.NextInSEL = edge1;
			edge1.PrevInSEL = prev;
			edge1.NextInSEL = edge2;
			edge2.PrevInSEL = edge1;
			edge2.NextInSEL = next;
		}
		else
		{
			var next = edge1.NextInSEL;
			var prev = edge1.PrevInSEL;
			edge1.NextInSEL = edge2.NextInSEL;
			if (edge1.NextInSEL !== null)
				edge1.NextInSEL.PrevInSEL = edge1;
			edge1.PrevInSEL = edge2.PrevInSEL;
			if (edge1.PrevInSEL !== null)
				edge1.PrevInSEL.NextInSEL = edge1;
			edge2.NextInSEL = next;
			if (edge2.NextInSEL !== null)
				edge2.NextInSEL.PrevInSEL = edge2;
			edge2.PrevInSEL = prev;
			if (edge2.PrevInSEL !== null)
				edge2.PrevInSEL.NextInSEL = edge2;
		}
		if (edge1.PrevInSEL === null)
			this.m_SortedEdges = edge1;
		else if (edge2.PrevInSEL === null)
			this.m_SortedEdges = edge2;
	};

	ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)
	{
		this.AddOutPt(e1, pt);
		if (e2.WindDelta === 0) this.AddOutPt(e2, pt);
		if (e1.OutIdx === e2.OutIdx)
		{
			e1.OutIdx = -1;
			e2.OutIdx = -1;
		}
		else if (e1.OutIdx < e2.OutIdx)
			this.AppendPolygon(e1, e2);
		else
			this.AppendPolygon(e2, e1);
	};

	ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)
	{
		var result;
		var e, prevE;
		if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))
		{
			result = this.AddOutPt(e1, pt);
			e2.OutIdx = e1.OutIdx;
			e1.Side = ClipperLib.EdgeSide.esLeft;
			e2.Side = ClipperLib.EdgeSide.esRight;
			e = e1;
			if (e.PrevInAEL === e2)
				prevE = e2.PrevInAEL;
			else
				prevE = e.PrevInAEL;
		}
		else
		{
			result = this.AddOutPt(e2, pt);
			e1.OutIdx = e2.OutIdx;
			e1.Side = ClipperLib.EdgeSide.esRight;
			e2.Side = ClipperLib.EdgeSide.esLeft;
			e = e2;
			if (e.PrevInAEL === e1)
				prevE = e1.PrevInAEL;
			else
				prevE = e.PrevInAEL;
		}

		if (prevE !== null && prevE.OutIdx >= 0 && prevE.Top.Y < pt.Y && e.Top.Y < pt.Y)
		{
			var xPrev = ClipperLib.Clipper.TopX(prevE, pt.Y);
			var xE = ClipperLib.Clipper.TopX(e, pt.Y);
			if ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5(new ClipperLib.FPoint2(xPrev, pt.Y), prevE.Top, new ClipperLib.FPoint2(xE, pt.Y), e.Top))
			{
				var outPt = this.AddOutPt(prevE, pt);
				this.AddJoin(result, outPt, e.Top);
			}
		}
		return result;
	};

	ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)
	{
		if (e.OutIdx < 0)
		{
			var outRec = this.CreateOutRec();
			outRec.IsOpen = (e.WindDelta === 0);
			var newOp = new ClipperLib.OutPt();
			outRec.Pts = newOp;
			newOp.Idx = outRec.Idx;
			//newOp.Pt = pt;
			newOp.Pt.X = pt.X;
			newOp.Pt.Y = pt.Y;
			if (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;
			newOp.Next = newOp;
			newOp.Prev = newOp;
			if (!outRec.IsOpen)
				this.SetHoleState(e, outRec);
			e.OutIdx = outRec.Idx;
			//nb: do this after SetZ !
			return newOp;
		}
		else
		{
			var outRec = this.m_PolyOuts[e.OutIdx];
			//OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
			var op = outRec.Pts;
			var ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);
			if (ToFront && ClipperLib.FPoint.op_Equality(pt, op.Pt))
				return op;
			else if (!ToFront && ClipperLib.FPoint.op_Equality(pt, op.Prev.Pt))
				return op.Prev;
			var newOp = new ClipperLib.OutPt();
			newOp.Idx = outRec.Idx;
			//newOp.Pt = pt;
			newOp.Pt.X = pt.X;
			newOp.Pt.Y = pt.Y;
			if (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;
			newOp.Next = op;
			newOp.Prev = op.Prev;
			newOp.Prev.Next = newOp;
			op.Prev = newOp;
			if (ToFront)
				outRec.Pts = newOp;
			return newOp;
		}
	};

	ClipperLib.Clipper.prototype.GetLastOutPt = function (e)
	{
		var outRec = this.m_PolyOuts[e.OutIdx];
		if (e.Side === ClipperLib.EdgeSide.esLeft)
		{
			return outRec.Pts;
		}
		else
		{
			return outRec.Pts.Prev;
		}
	};

	ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)
	{
		var tmp = new ClipperLib.FPoint1(pt1.Value);
		//pt1.Value = pt2.Value;
		pt1.Value.X = pt2.Value.X;
		pt1.Value.Y = pt2.Value.Y;
		if (ClipperLib.use_xyz) pt1.Value.Z = pt2.Value.Z;
		//pt2.Value = tmp;
		pt2.Value.X = tmp.X;
		pt2.Value.Y = tmp.Y;
		if (ClipperLib.use_xyz) pt2.Value.Z = tmp.Z;
	};

	ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)
	{
		var tmp;
		if (seg1a > seg1b)
		{
			tmp = seg1a;
			seg1a = seg1b;
			seg1b = tmp;
		}
		if (seg2a > seg2b)
		{
			tmp = seg2a;
			seg2a = seg2b;
			seg2b = tmp;
		}
		return (seg1a < seg2b) && (seg2a < seg1b);
	}

	ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)
	{
		var e2 = e.PrevInAEL;
		var eTmp = null;
		while (e2 !== null)
		{
			if (e2.OutIdx >= 0 && e2.WindDelta !== 0)
			{
				if (eTmp === null)
					eTmp = e2;
				else if (eTmp.OutIdx === e2.OutIdx)
					eTmp = null; //paired
			}
			e2 = e2.PrevInAEL;
		}

		if (eTmp === null)
		{
			outRec.FirstLeft = null;
			outRec.IsHole = false;
		}
		else
		{
			outRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];
			outRec.IsHole = !outRec.FirstLeft.IsHole;
		}
	};

	ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)
	{
		if (pt1.Y === pt2.Y)
			return ClipperLib.ClipperBase.horizontal;
		else
			return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);
	};

	ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)
	{
		var p = btmPt1.Prev;
		while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))
			p = p.Prev;
		var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
		p = btmPt1.Next;
		while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))
			p = p.Next;
		var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
		p = btmPt2.Prev;
		while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))
			p = p.Prev;
		var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
		p = btmPt2.Next;
		while ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))
			p = p.Next;
		var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));

		if (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n))
		{
			return this.Area(btmPt1) > 0; //if otherwise identical use orientation
		}
		else
		{
			return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);
		}
	};

	ClipperLib.Clipper.prototype.GetBottomPt = function (pp)
	{
		var dups = null;
		var p = pp.Next;
		while (p !== pp)
		{
			if (p.Pt.Y > pp.Pt.Y)
			{
				pp = p;
				dups = null;
			}
			else if (p.Pt.Y === pp.Pt.Y && p.Pt.X <= pp.Pt.X)
			{
				if (p.Pt.X < pp.Pt.X)
				{
					dups = null;
					pp = p;
				}
				else
				{
					if (p.Next !== pp && p.Prev !== pp)
						dups = p;
				}
			}
			p = p.Next;
		}
		if (dups !== null)
		{
			//there appears to be at least 2 vertices at bottomPt so ...
			while (dups !== p)
			{
				if (!this.FirstIsBottomPt(p, dups))
					pp = dups;
				dups = dups.Next;
				while (ClipperLib.FPoint.op_Inequality(dups.Pt, pp.Pt))
					dups = dups.Next;
			}
		}
		return pp;
	};

	ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)
	{
		//work out which polygon fragment has the correct hole state ...
		if (outRec1.BottomPt === null)
			outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);
		if (outRec2.BottomPt === null)
			outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);
		var bPt1 = outRec1.BottomPt;
		var bPt2 = outRec2.BottomPt;
		if (bPt1.Pt.Y > bPt2.Pt.Y)
			return outRec1;
		else if (bPt1.Pt.Y < bPt2.Pt.Y)
			return outRec2;
		else if (bPt1.Pt.X < bPt2.Pt.X)
			return outRec1;
		else if (bPt1.Pt.X > bPt2.Pt.X)
			return outRec2;
		else if (bPt1.Next === bPt1)
			return outRec2;
		else if (bPt2.Next === bPt2)
			return outRec1;
		else if (this.FirstIsBottomPt(bPt1, bPt2))
			return outRec1;
		else
			return outRec2;
	};

	ClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function (outRec1, outRec2)
	{
		do {
			outRec1 = outRec1.FirstLeft;
			if (outRec1 === outRec2)
				return true;
		}
		while (outRec1 !== null)
		return false;
	};

	ClipperLib.Clipper.prototype.GetOutRec = function (idx)
	{
		var outrec = this.m_PolyOuts[idx];
		while (outrec !== this.m_PolyOuts[outrec.Idx])
			outrec = this.m_PolyOuts[outrec.Idx];
		return outrec;
	};

	ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)
	{
		//get the start and ends of both output polygons ...
		var outRec1 = this.m_PolyOuts[e1.OutIdx];
		var outRec2 = this.m_PolyOuts[e2.OutIdx];
		var holeStateRec;
		if (this.OutRec1RightOfOutRec2(outRec1, outRec2))
			holeStateRec = outRec2;
		else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))
			holeStateRec = outRec1;
		else
			holeStateRec = this.GetLowermostRec(outRec1, outRec2);

		//get the start and ends of both output polygons and
		//join E2 poly onto E1 poly and delete pointers to E2 ...

		var p1_lft = outRec1.Pts;
		var p1_rt = p1_lft.Prev;
		var p2_lft = outRec2.Pts;
		var p2_rt = p2_lft.Prev;
		//join e2 poly onto e1 poly and delete pointers to e2 ...
		if (e1.Side === ClipperLib.EdgeSide.esLeft)
		{
			if (e2.Side === ClipperLib.EdgeSide.esLeft)
			{
				//z y x a b c
				this.ReversePolyPtLinks(p2_lft);
				p2_lft.Next = p1_lft;
				p1_lft.Prev = p2_lft;
				p1_rt.Next = p2_rt;
				p2_rt.Prev = p1_rt;
				outRec1.Pts = p2_rt;
			}
			else
			{
				//x y z a b c
				p2_rt.Next = p1_lft;
				p1_lft.Prev = p2_rt;
				p2_lft.Prev = p1_rt;
				p1_rt.Next = p2_lft;
				outRec1.Pts = p2_lft;
			}
		}
		else
		{
			if (e2.Side === ClipperLib.EdgeSide.esRight)
			{
				//a b c z y x
				this.ReversePolyPtLinks(p2_lft);
				p1_rt.Next = p2_rt;
				p2_rt.Prev = p1_rt;
				p2_lft.Next = p1_lft;
				p1_lft.Prev = p2_lft;
			}
			else
			{
				//a b c x y z
				p1_rt.Next = p2_lft;
				p2_lft.Prev = p1_rt;
				p1_lft.Prev = p2_rt;
				p2_rt.Next = p1_lft;
			}
		}
		outRec1.BottomPt = null;
		if (holeStateRec === outRec2)
		{
			if (outRec2.FirstLeft !== outRec1)
				outRec1.FirstLeft = outRec2.FirstLeft;
			outRec1.IsHole = outRec2.IsHole;
		}
		outRec2.Pts = null;
		outRec2.BottomPt = null;
		outRec2.FirstLeft = outRec1;
		var OKIdx = e1.OutIdx;
		var ObsoleteIdx = e2.OutIdx;
		e1.OutIdx = -1;
		//nb: safe because we only get here via AddLocalMaxPoly
		e2.OutIdx = -1;
		var e = this.m_ActiveEdges;
		while (e !== null)
		{
			if (e.OutIdx === ObsoleteIdx)
			{
				e.OutIdx = OKIdx;
				e.Side = e1.Side;
				break;
			}
			e = e.NextInAEL;
		}
		outRec2.Idx = outRec1.Idx;
	};

	ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)
	{
		if (pp === null)
			return;
		var pp1;
		var pp2;
		pp1 = pp;
		do {
			pp2 = pp1.Next;
			pp1.Next = pp1.Prev;
			pp1.Prev = pp2;
			pp1 = pp2;
		}
		while (pp1 !== pp)
	};

	ClipperLib.Clipper.SwapSides = function (edge1, edge2)
	{
		var side = edge1.Side;
		edge1.Side = edge2.Side;
		edge2.Side = side;
	};

	ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)
	{
		var outIdx = edge1.OutIdx;
		edge1.OutIdx = edge2.OutIdx;
		edge2.OutIdx = outIdx;
	};

	ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)
	{
		//e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
		//e2 in AEL except when e1 is being inserted at the intersection point ...
		var e1Contributing = (e1.OutIdx >= 0);
		var e2Contributing = (e2.OutIdx >= 0);

		if (ClipperLib.use_xyz)
			this.SetZ(pt, e1, e2);

		if (ClipperLib.use_lines)
		{
			//if either edge is on an OPEN path ...
			if (e1.WindDelta === 0 || e2.WindDelta === 0)
			{
				//ignore subject-subject open path intersections UNLESS they
				//are both open paths, AND they are both 'contributing maximas' ...
				if (e1.WindDelta === 0 && e2.WindDelta === 0) return;
				//if intersecting a subj line with a subj poly ...
				else if (e1.PolyTyp === e2.PolyTyp &&
					e1.WindDelta !== e2.WindDelta && this.m_ClipType === ClipperLib.ClipType.ctUnion)
				{
					if (e1.WindDelta === 0)
					{
						if (e2Contributing)
						{
							this.AddOutPt(e1, pt);
							if (e1Contributing)
								e1.OutIdx = -1;
						}
					}
					else
					{
						if (e1Contributing)
						{
							this.AddOutPt(e2, pt);
							if (e2Contributing)
								e2.OutIdx = -1;
						}
					}
				}
				else if (e1.PolyTyp !== e2.PolyTyp)
				{
					if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) === 1 &&
						(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))
					{
						this.AddOutPt(e1, pt);
						if (e1Contributing)
							e1.OutIdx = -1;
					}
					else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) === 1) &&
						(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))
					{
						this.AddOutPt(e2, pt);
						if (e2Contributing)
							e2.OutIdx = -1;
					}
				}
				return;
			}
		}
		//update winding counts...
		//assumes that e1 will be to the Right of e2 ABOVE the intersection
		if (e1.PolyTyp === e2.PolyTyp)
		{
			if (this.IsEvenOddFillType(e1))
			{
				var oldE1WindCnt = e1.WindCnt;
				e1.WindCnt = e2.WindCnt;
				e2.WindCnt = oldE1WindCnt;
			}
			else
			{
				if (e1.WindCnt + e2.WindDelta === 0)
					e1.WindCnt = -e1.WindCnt;
				else
					e1.WindCnt += e2.WindDelta;
				if (e2.WindCnt - e1.WindDelta === 0)
					e2.WindCnt = -e2.WindCnt;
				else
					e2.WindCnt -= e1.WindDelta;
			}
		}
		else
		{
			if (!this.IsEvenOddFillType(e2))
				e1.WindCnt2 += e2.WindDelta;
			else
				e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;
			if (!this.IsEvenOddFillType(e1))
				e2.WindCnt2 -= e1.WindDelta;
			else
				e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;
		}
		var e1FillType, e2FillType, e1FillType2, e2FillType2;
		if (e1.PolyTyp === ClipperLib.PolyType.ptSubject)
		{
			e1FillType = this.m_SubjFillType;
			e1FillType2 = this.m_ClipFillType;
		}
		else
		{
			e1FillType = this.m_ClipFillType;
			e1FillType2 = this.m_SubjFillType;
		}
		if (e2.PolyTyp === ClipperLib.PolyType.ptSubject)
		{
			e2FillType = this.m_SubjFillType;
			e2FillType2 = this.m_ClipFillType;
		}
		else
		{
			e2FillType = this.m_ClipFillType;
			e2FillType2 = this.m_SubjFillType;
		}
		var e1Wc, e2Wc;
		switch (e1FillType)
		{
		case ClipperLib.PolyFillType.pftPositive:
			e1Wc = e1.WindCnt;
			break;
		case ClipperLib.PolyFillType.pftNegative:
			e1Wc = -e1.WindCnt;
			break;
		default:
			e1Wc = Math.abs(e1.WindCnt);
			break;
		}
		switch (e2FillType)
		{
		case ClipperLib.PolyFillType.pftPositive:
			e2Wc = e2.WindCnt;
			break;
		case ClipperLib.PolyFillType.pftNegative:
			e2Wc = -e2.WindCnt;
			break;
		default:
			e2Wc = Math.abs(e2.WindCnt);
			break;
		}
		if (e1Contributing && e2Contributing)
		{
			if ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||
				(e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor))
			{
				this.AddLocalMaxPoly(e1, e2, pt);
			}
			else
			{
				this.AddOutPt(e1, pt);
				this.AddOutPt(e2, pt);
				ClipperLib.Clipper.SwapSides(e1, e2);
				ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
			}
		}
		else if (e1Contributing)
		{
			if (e2Wc === 0 || e2Wc === 1)
			{
				this.AddOutPt(e1, pt);
				ClipperLib.Clipper.SwapSides(e1, e2);
				ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
			}
		}
		else if (e2Contributing)
		{
			if (e1Wc === 0 || e1Wc === 1)
			{
				this.AddOutPt(e2, pt);
				ClipperLib.Clipper.SwapSides(e1, e2);
				ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
			}
		}
		else if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1))
		{
			//neither edge is currently contributing ...
			var e1Wc2, e2Wc2;
			switch (e1FillType2)
			{
			case ClipperLib.PolyFillType.pftPositive:
				e1Wc2 = e1.WindCnt2;
				break;
			case ClipperLib.PolyFillType.pftNegative:
				e1Wc2 = -e1.WindCnt2;
				break;
			default:
				e1Wc2 = Math.abs(e1.WindCnt2);
				break;
			}
			switch (e2FillType2)
			{
			case ClipperLib.PolyFillType.pftPositive:
				e2Wc2 = e2.WindCnt2;
				break;
			case ClipperLib.PolyFillType.pftNegative:
				e2Wc2 = -e2.WindCnt2;
				break;
			default:
				e2Wc2 = Math.abs(e2.WindCnt2);
				break;
			}
			if (e1.PolyTyp !== e2.PolyTyp)
			{
				this.AddLocalMinPoly(e1, e2, pt);
			}
			else if (e1Wc === 1 && e2Wc === 1)
				switch (this.m_ClipType)
				{
				case ClipperLib.ClipType.ctIntersection:
					if (e1Wc2 > 0 && e2Wc2 > 0)
						this.AddLocalMinPoly(e1, e2, pt);
					break;
				case ClipperLib.ClipType.ctUnion:
					if (e1Wc2 <= 0 && e2Wc2 <= 0)
						this.AddLocalMinPoly(e1, e2, pt);
					break;
				case ClipperLib.ClipType.ctDifference:
					if (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||
						((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))
						this.AddLocalMinPoly(e1, e2, pt);
					break;
				case ClipperLib.ClipType.ctXor:
					this.AddLocalMinPoly(e1, e2, pt);
					break;
				}
			else
				ClipperLib.Clipper.SwapSides(e1, e2);
		}
	};

	ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)
	{
		var SelPrev = e.PrevInSEL;
		var SelNext = e.NextInSEL;
		if (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))
			return;
		//already deleted
		if (SelPrev !== null)
			SelPrev.NextInSEL = SelNext;
		else
			this.m_SortedEdges = SelNext;
		if (SelNext !== null)
			SelNext.PrevInSEL = SelPrev;
		e.NextInSEL = null;
		e.PrevInSEL = null;
	};

	ClipperLib.Clipper.prototype.ProcessHorizontals = function ()
	{
		var horzEdge = {}; //m_SortedEdges;
		while (this.PopEdgeFromSEL(horzEdge))
		{
			this.ProcessHorizontal(horzEdge.v);
		}
	};

	ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)
	{
		if (HorzEdge.Bot.X < HorzEdge.Top.X)
		{
			$var.Left = HorzEdge.Bot.X;
			$var.Right = HorzEdge.Top.X;
			$var.Dir = ClipperLib.Direction.dLeftToRight;
		}
		else
		{
			$var.Left = HorzEdge.Top.X;
			$var.Right = HorzEdge.Bot.X;
			$var.Dir = ClipperLib.Direction.dRightToLeft;
		}
	};

	ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge)
	{
		var $var = {
			Dir: null,
			Left: null,
			Right: null
		};

		this.GetHorzDirection(horzEdge, $var);
		var dir = $var.Dir;
		var horzLeft = $var.Left;
		var horzRight = $var.Right;

		var IsOpen = horzEdge.WindDelta === 0;

		var eLastHorz = horzEdge,
			eMaxPair = null;
		while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))
			eLastHorz = eLastHorz.NextInLML;
		if (eLastHorz.NextInLML === null)
			eMaxPair = this.GetMaximaPair(eLastHorz);

		var currMax = this.m_Maxima;
		if (currMax !== null)
		{
			//get the first maxima in range (X) ...
			if (dir === ClipperLib.Direction.dLeftToRight)
			{
				while (currMax !== null && currMax.X <= horzEdge.Bot.X)
				{
					currMax = currMax.Next;
				}
				if (currMax !== null && currMax.X >= eLastHorz.Top.X)
				{
					currMax = null;
				}
			}
			else
			{
				while (currMax.Next !== null && currMax.Next.X < horzEdge.Bot.X)
				{
					currMax = currMax.Next;
				}
				if (currMax.X <= eLastHorz.Top.X)
				{
					currMax = null;
				}
			}
		}
		var op1 = null;
		for (;;) //loop through consec. horizontal edges
		{
			var IsLastHorz = (horzEdge === eLastHorz);
			var e = this.GetNextInAEL(horzEdge, dir);
			while (e !== null)
			{
				//this code block inserts extra coords into horizontal edges (in output
				//polygons) whereever maxima touch these horizontal edges. This helps
				//'simplifying' polygons (ie if the Simplify property is set).
				if (currMax !== null)
				{
					if (dir === ClipperLib.Direction.dLeftToRight)
					{
						while (currMax !== null && currMax.X < e.Curr.X)
						{
							if (horzEdge.OutIdx >= 0 && !IsOpen)
							{
								this.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.X, horzEdge.Bot.Y));
							}
							currMax = currMax.Next;
						}
					}
					else
					{
						while (currMax !== null && currMax.X > e.Curr.X)
						{
							if (horzEdge.OutIdx >= 0 && !IsOpen)
							{
								this.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.X, horzEdge.Bot.Y));
							}
							currMax = currMax.Prev;
						}
					}
				}

				if ((dir === ClipperLib.Direction.dLeftToRight && e.Curr.X > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr.X < horzLeft))
				{
					break;
				}

				//Also break if we've got to the end of an intermediate horizontal edge ...
				//nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
				if (e.Curr.X === horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)
					break;

				if (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times
				{
					if (ClipperLib.use_xyz)
					{
						if (dir === ClipperLib.Direction.dLeftToRight)
							this.SetZ(e.Curr, horzEdge, e);
						else this.SetZ(e.Curr, e, horzEdge);
					}

					op1 = this.AddOutPt(horzEdge, e.Curr);
					var eNextHorz = this.m_SortedEdges;
					while (eNextHorz !== null)
					{
						if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))
						{
							var op2 = this.GetLastOutPt(eNextHorz);
							this.AddJoin(op2, op1, eNextHorz.Top);
						}
						eNextHorz = eNextHorz.NextInSEL;
					}
					this.AddGhostJoin(op1, horzEdge.Bot);
				}

				//OK, so far we're still in range of the horizontal Edge  but make sure
				//we're at the last of consec. horizontals when matching with eMaxPair
				if (e === eMaxPair && IsLastHorz)
				{
					if (horzEdge.OutIdx >= 0)
					{
						this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);
					}
					this.DeleteFromAEL(horzEdge);
					this.DeleteFromAEL(eMaxPair);
					return;
				}

				if (dir === ClipperLib.Direction.dLeftToRight)
				{
					var Pt = new ClipperLib.FPoint2(e.Curr.X, horzEdge.Curr.Y);
					this.IntersectEdges(horzEdge, e, Pt);
				}
				else
				{
					var Pt = new ClipperLib.FPoint2(e.Curr.X, horzEdge.Curr.Y);
					this.IntersectEdges(e, horzEdge, Pt);
				}
				var eNext = this.GetNextInAEL(e, dir);
				this.SwapPositionsInAEL(horzEdge, e);
				e = eNext;
			} //end while(e !== null)

			//Break out of loop if HorzEdge.NextInLML is not also horizontal ...
			if (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))
			{
				break;
			}

			horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
			if (horzEdge.OutIdx >= 0)
			{
				this.AddOutPt(horzEdge, horzEdge.Bot);
			}

			$var = {
				Dir: dir,
				Left: horzLeft,
				Right: horzRight
			};

			this.GetHorzDirection(horzEdge, $var);
			dir = $var.Dir;
			horzLeft = $var.Left;
			horzRight = $var.Right;

		} //end for (;;)

		if (horzEdge.OutIdx >= 0 && op1 === null)
		{
			op1 = this.GetLastOutPt(horzEdge);
			var eNextHorz = this.m_SortedEdges;
			while (eNextHorz !== null)
			{
				if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))
				{
					var op2 = this.GetLastOutPt(eNextHorz);
					this.AddJoin(op2, op1, eNextHorz.Top);
				}
				eNextHorz = eNextHorz.NextInSEL;
			}
			this.AddGhostJoin(op1, horzEdge.Top);
		}

		if (horzEdge.NextInLML !== null)
		{
			if (horzEdge.OutIdx >= 0)
			{
				op1 = this.AddOutPt(horzEdge, horzEdge.Top);

				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
				if (horzEdge.WindDelta === 0)
				{
					return;
				}
				//nb: HorzEdge is no longer horizontal here
				var ePrev = horzEdge.PrevInAEL;
				var eNext = horzEdge.NextInAEL;
				if (ePrev !== null && ePrev.Curr.X === horzEdge.Bot.X && ePrev.Curr.Y === horzEdge.Bot.Y && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev)))
				{
					var op2 = this.AddOutPt(ePrev, horzEdge.Bot);
					this.AddJoin(op1, op2, horzEdge.Top);
				}
				else if (eNext !== null && eNext.Curr.X === horzEdge.Bot.X && eNext.Curr.Y === horzEdge.Bot.Y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext))
				{
					var op2 = this.AddOutPt(eNext, horzEdge.Bot);
					this.AddJoin(op1, op2, horzEdge.Top);
				}
			}
			else
			{
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
			}
		}
		else
		{
			if (horzEdge.OutIdx >= 0)
			{
				this.AddOutPt(horzEdge, horzEdge.Top);
			}
			this.DeleteFromAEL(horzEdge);
		}
	};

	ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)
	{
		return Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;
	};

	ClipperLib.Clipper.prototype.IsMinima = function (e)
	{
		return e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);
	};

	ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)
	{
		return (e !== null && e.Top.Y === Y && e.NextInLML === null);
	};

	ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)
	{
		return (e.Top.Y === Y && e.NextInLML !== null);
	};

	ClipperLib.Clipper.prototype.GetMaximaPair = function (e)
	{
		if ((ClipperLib.FPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)
		{
			return e.Next;
		}
		else
		{
			if ((ClipperLib.FPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)
			{
				return e.Prev;
			}
			else
			{
				return null;
			}
		}
	};

	ClipperLib.Clipper.prototype.GetMaximaPairEx = function (e)
	{
		//as above but returns null if MaxPair isn't in AEL (unless it's horizontal)
		var result = this.GetMaximaPair(e);
		if (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||
			((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result)))
		{
			return null;
		}
		return result;
	};

	ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)
	{
		if (this.m_ActiveEdges === null)
			return true;
		try
		{
			this.BuildIntersectList(topY);
			if (this.m_IntersectList.length === 0)
				return true;
			if (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())
				this.ProcessIntersectList();
			else
				return false;
		}
		catch ($$e2)
		{
			this.m_SortedEdges = null;
			this.m_IntersectList.length = 0;
			ClipperLib.Error("ProcessIntersections error");
		}
		this.m_SortedEdges = null;
		return true;
	};

	ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)
	{
		if (this.m_ActiveEdges === null)
			return;
		//prepare for sorting ...
		var e = this.m_ActiveEdges;
		//console.log(JSON.stringify(JSON.decycle( e )));
		this.m_SortedEdges = e;
		while (e !== null)
		{
			e.PrevInSEL = e.PrevInAEL;
			e.NextInSEL = e.NextInAEL;
			e.Curr.X = ClipperLib.Clipper.TopX(e, topY);
			e = e.NextInAEL;
		}
		//bubblesort ...
		var isModified = true;
		while (isModified && this.m_SortedEdges !== null)
		{
			isModified = false;
			e = this.m_SortedEdges;
			while (e.NextInSEL !== null)
			{
				var eNext = e.NextInSEL;
				var pt = new ClipperLib.FPoint0();
				//console.log("e.Curr.X: " + e.Curr.X + " eNext.Curr.X" + eNext.Curr.X);
				if (e.Curr.X > eNext.Curr.X)
				{
					this.IntersectPoint(e, eNext, pt);
					if (pt.Y < topY)
					{
						pt = new ClipperLib.FPoint2(ClipperLib.Clipper.TopX(e, topY), topY);
					}
					var newNode = new ClipperLib.IntersectNode();
					newNode.Edge1 = e;
					newNode.Edge2 = eNext;
					//newNode.Pt = pt;
					newNode.Pt.X = pt.X;
					newNode.Pt.Y = pt.Y;
					if (ClipperLib.use_xyz) newNode.Pt.Z = pt.Z;
					this.m_IntersectList.push(newNode);
					this.SwapPositionsInSEL(e, eNext);
					isModified = true;
				}
				else
					e = eNext;
			}
			if (e.PrevInSEL !== null)
				e.PrevInSEL.NextInSEL = null;
			else
				break;
		}
		this.m_SortedEdges = null;
	};

	ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)
	{
		return (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);
	};

	ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)
	{
		//the following typecast is safe because the differences in Pt.Y will
		//be limited to the height of the scanbeam.
		return (node2.Pt.Y - node1.Pt.Y);
	};

	ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()
	{
		//pre-condition: intersections are sorted bottom-most first.
		//Now it's crucial that intersections are made only between adjacent edges,
		//so to ensure this the order of intersections may need adjusting ...
		this.m_IntersectList.sort(this.m_IntersectNodeComparer);
		this.CopyAELToSEL();
		var cnt = this.m_IntersectList.length;
		for (var i = 0; i < cnt; i++)
		{
			if (!this.EdgesAdjacent(this.m_IntersectList[i]))
			{
				var j = i + 1;
				while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))
					j++;
				if (j === cnt)
					return false;
				var tmp = this.m_IntersectList[i];
				this.m_IntersectList[i] = this.m_IntersectList[j];
				this.m_IntersectList[j] = tmp;
			}
			this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);
		}
		return true;
	};

	ClipperLib.Clipper.prototype.ProcessIntersectList = function ()
	{
		for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)
		{
			var iNode = this.m_IntersectList[i];
			this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);
			this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);
		}
		this.m_IntersectList.length = 0;
	};

	ClipperLib.Clipper.TopX = function (edge, currentY)
	{
		//if (edge.Bot == edge.Curr) alert ("edge.Bot = edge.Curr");
		//if (edge.Bot == edge.Top) alert ("edge.Bot = edge.Top");
		if (currentY === edge.Top.Y)
			return edge.Top.X;
		return edge.Bot.X + edge.Dx * (currentY - edge.Bot.Y);
	};

	ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)
	{
		ip.X = 0;
		ip.Y = 0;
		var b1, b2;
		//nb: with very large coordinate values, it's possible for SlopesEqual() to
		//return false but for the edge.Dx value be equal due to double precision rounding.
		if (edge1.Dx === edge2.Dx)
		{
			ip.Y = edge1.Curr.Y;
			ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
			return;
		}
		if (edge1.Delta.X === 0)
		{
			ip.X = edge1.Bot.X;
			if (ClipperLib.ClipperBase.IsHorizontal(edge2))
			{
				ip.Y = edge2.Bot.Y;
			}
			else
			{
				b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);
				ip.Y = ip.X / edge2.Dx + b2;
			}
		}
		else if (edge2.Delta.X === 0)
		{
			ip.X = edge2.Bot.X;
			if (ClipperLib.ClipperBase.IsHorizontal(edge1))
			{
				ip.Y = edge1.Bot.Y;
			}
			else
			{
				b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);
				ip.Y = ip.X / edge1.Dx + b1;
			}
		}
		else
		{
			b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;
			b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;
			var q = (b2 - b1) / (edge1.Dx - edge2.Dx);
			ip.Y = q;
			if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
				ip.X = edge1.Dx * q + b1;
			else
				ip.X = edge2.Dx * q + b2;
		}
		if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)
		{
			if (edge1.Top.Y > edge2.Top.Y)
			{
				ip.Y = edge1.Top.Y;
				ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);
				return ip.X < edge1.Top.X;
			}
			else
				ip.Y = edge2.Top.Y;
			if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
				ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
			else
				ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);
		}
		//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...
		if (ip.Y > edge1.Curr.Y)
		{
			ip.Y = edge1.Curr.Y;
			//better to use the more vertical edge to derive X ...
			if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))
				ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);
			else
				ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
		}
	};

	ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)
	{
		var e = this.m_ActiveEdges;

		while (e !== null)
		{
			//1. process maxima, treating them as if they're 'bent' horizontal edges,
			//   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
			var IsMaximaEdge = this.IsMaxima(e, topY);
			if (IsMaximaEdge)
			{
				var eMaxPair = this.GetMaximaPairEx(e);
				IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));
			}
			if (IsMaximaEdge)
			{
				if (this.StrictlySimple)
				{
					this.InsertMaxima(e.Top.X);
				}
				var ePrev = e.PrevInAEL;
				this.DoMaxima(e);
				if (ePrev === null)
					e = this.m_ActiveEdges;
				else
					e = ePrev.NextInAEL;
			}
			else
			{
				//2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...
				if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))
				{
					e = this.UpdateEdgeIntoAEL(e);
					if (e.OutIdx >= 0)
						this.AddOutPt(e, e.Bot);
					this.AddEdgeToSEL(e);
				}
				else
				{
					e.Curr.X = ClipperLib.Clipper.TopX(e, topY);
					e.Curr.Y = topY;
				}

				if (ClipperLib.use_xyz)
				{
					if (e.Top.Y === topY) e.Curr.Z = e.Top.Z;
					else if (e.Bot.Y === topY) e.Curr.Z = e.Bot.Z;
					else e.Curr.Z = 0;
				}

				//When StrictlySimple and 'e' is being touched by another edge, then
				//make sure both edges have a vertex here ...        
				if (this.StrictlySimple)
				{
					var ePrev = e.PrevInAEL;
					if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&
						(ePrev.OutIdx >= 0) && (ePrev.Curr.X === e.Curr.X) &&
						(ePrev.WindDelta !== 0))
					{
						var ip = new ClipperLib.FPoint1(e.Curr);

						if (ClipperLib.use_xyz)
						{
							this.SetZ(ip, ePrev, e);
						}

						var op = this.AddOutPt(ePrev, ip);
						var op2 = this.AddOutPt(e, ip);
						this.AddJoin(op, op2, ip); //StrictlySimple (type-3) join
					}
				}
				e = e.NextInAEL;
			}
		}
		//3. Process horizontals at the Top of the scanbeam ...
		this.ProcessHorizontals();
		this.m_Maxima = null;
		//4. Promote intermediate vertices ...
		e = this.m_ActiveEdges;
		while (e !== null)
		{
			if (this.IsIntermediate(e, topY))
			{
				var op = null;
				if (e.OutIdx >= 0)
					op = this.AddOutPt(e, e.Top);
				e = this.UpdateEdgeIntoAEL(e);
				//if output polygons share an edge, they'll need joining later ...
				var ePrev = e.PrevInAEL;
				var eNext = e.NextInAEL;

				if (ePrev !== null && ePrev.Curr.X === e.Bot.X && ePrev.Curr.Y === e.Bot.Y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.Y === ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))
				{
					var op2 = this.AddOutPt(ePrev2, e.Bot);
					this.AddJoin(op, op2, e.Top);
				}
				else if (eNext !== null && eNext.Curr.X === e.Bot.X && eNext.Curr.Y === e.Bot.Y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.Y === eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0))
				{
					var op2 = this.AddOutPt(eNext, e.Bot);
					this.AddJoin(op, op2, e.Top);
				}
			}
			e = e.NextInAEL;
		}
	};

	ClipperLib.Clipper.prototype.DoMaxima = function (e)
	{
		var eMaxPair = this.GetMaximaPairEx(e);
		if (eMaxPair === null)
		{
			if (e.OutIdx >= 0)
				this.AddOutPt(e, e.Top);
			this.DeleteFromAEL(e);
			return;
		}
		var eNext = e.NextInAEL;
		while (eNext !== null && eNext !== eMaxPair)
		{
			this.IntersectEdges(e, eNext, e.Top);
			this.SwapPositionsInAEL(e, eNext);
			eNext = e.NextInAEL;
		}
		if (e.OutIdx === -1 && eMaxPair.OutIdx === -1)
		{
			this.DeleteFromAEL(e);
			this.DeleteFromAEL(eMaxPair);
		}
		else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)
		{
			if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);
			this.DeleteFromAEL(e);
			this.DeleteFromAEL(eMaxPair);
		}
		else if (ClipperLib.use_lines && e.WindDelta === 0)
		{
			if (e.OutIdx >= 0)
			{
				this.AddOutPt(e, e.Top);
				e.OutIdx = ClipperLib.ClipperBase.Unassigned;
			}
			this.DeleteFromAEL(e);
			if (eMaxPair.OutIdx >= 0)
			{
				this.AddOutPt(eMaxPair, e.Top);
				eMaxPair.OutIdx = ClipperLib.ClipperBase.Unassigned;
			}
			this.DeleteFromAEL(eMaxPair);
		}
		else
			ClipperLib.Error("DoMaxima error");
	};

	ClipperLib.Clipper.ReversePaths = function (polys)
	{
		for (var i = 0, len = polys.length; i < len; i++)
			polys[i].reverse();
	};

	ClipperLib.Clipper.Orientation = function (poly)
	{
		return ClipperLib.Clipper.Area(poly) >= 0;
	};

	ClipperLib.Clipper.prototype.PointCount = function (pts)
	{
		if (pts === null)
			return 0;
		var result = 0;
		var p = pts;
		do {
			result++;
			p = p.Next;
		}
		while (p !== pts)
		return result;
	};

	ClipperLib.Clipper.prototype.BuildResult = function (polyg)
	{
		ClipperLib.Clear(polyg);
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
		{
			var outRec = this.m_PolyOuts[i];
			if (outRec.Pts === null)
				continue;
			var p = outRec.Pts.Prev;
			var cnt = this.PointCount(p);
			if (cnt < 2)
				continue;
			var pg = new Array(cnt);
			for (var j = 0; j < cnt; j++)
			{
				pg[j] = p.Pt;
				p = p.Prev;
			}
			polyg.push(pg);
		}
	};

	ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)
	{
		polytree.Clear();
		//add each output polygon/contour to polytree ...
		//polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
		{
			var outRec = this.m_PolyOuts[i];
			var cnt = this.PointCount(outRec.Pts);
			if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))
				continue;
			this.FixHoleLinkage(outRec);
			var pn = new ClipperLib.PolyNode();
			polytree.m_AllPolys.push(pn);
			outRec.PolyNode = pn;
			pn.m_polygon.length = cnt;
			var op = outRec.Pts.Prev;
			for (var j = 0; j < cnt; j++)
			{
				pn.m_polygon[j] = op.Pt;
				op = op.Prev;
			}
		}
		//fixup PolyNode links etc ...
		//polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
		{
			var outRec = this.m_PolyOuts[i];
			if (outRec.PolyNode === null)
				continue;
			else if (outRec.IsOpen)
			{
				outRec.PolyNode.IsOpen = true;
				polytree.AddChild(outRec.PolyNode);
			}
			else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)
				outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);
			else
				polytree.AddChild(outRec.PolyNode);
		}
	};

	ClipperLib.Clipper.prototype.FixupOutPolyline = function (outRec)
	{
		var pp = outRec.Pts;
		var lastPP = pp.Prev;
		while (pp !== lastPP)
		{
			pp = pp.Next;
			if (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt))
			{
				if (pp === lastPP)
				{
					lastPP = pp.Prev;
				}
				var tmpPP = pp.Prev;
				tmpPP.Next = pp.Next;
				pp.Next.Prev = tmpPP;
				pp = tmpPP;
			}
		}
		if (pp === pp.Prev)
		{
			outRec.Pts = null;
		}
	};

	ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)
	{
		//FixupOutPolygon() - removes duplicate points and simplifies consecutive
		//parallel edges by removing the middle vertex.
		var lastOK = null;
		outRec.BottomPt = null;
		var pp = outRec.Pts;
		var preserveCol = this.PreserveCollinear || this.StrictlySimple;
		for (;;)
		{
			if (pp.Prev === pp || pp.Prev === pp.Next)
			{
				outRec.Pts = null;
				return;
			}

			//test for duplicate points and collinear edges ...
			if ((ClipperLib.FPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))
			{
				lastOK = null;
				pp.Prev.Next = pp.Next;
				pp.Next.Prev = pp.Prev;
				pp = pp.Prev;
			}
			else if (pp === lastOK)
				break;
			else
			{
				if (lastOK === null)
					lastOK = pp;
				pp = pp.Next;
			}
		}
		outRec.Pts = pp;
	};

	ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)
	{
		var result = new ClipperLib.OutPt();
		//result.Pt = outPt.Pt;
		result.Pt.X = outPt.Pt.X;
		result.Pt.Y = outPt.Pt.Y;
		if (ClipperLib.use_xyz) result.Pt.Z = outPt.Pt.Z;
		result.Idx = outPt.Idx;
		if (InsertAfter)
		{
			result.Next = outPt.Next;
			result.Prev = outPt;
			outPt.Next.Prev = result;
			outPt.Next = result;
		}
		else
		{
			result.Prev = outPt.Prev;
			result.Next = outPt;
			outPt.Prev.Next = result;
			outPt.Prev = result;
		}
		return result;
	};

	ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)
	{
		if (a1 < a2)
		{
			if (b1 < b2)
			{
				$val.Left = Math.max(a1, b1);
				$val.Right = Math.min(a2, b2);
			}
			else
			{
				$val.Left = Math.max(a1, b2);
				$val.Right = Math.min(a2, b1);
			}
		}
		else
		{
			if (b1 < b2)
			{
				$val.Left = Math.max(a2, b1);
				$val.Right = Math.min(a1, b2);
			}
			else
			{
				$val.Left = Math.max(a2, b2);
				$val.Right = Math.min(a1, b1);
			}
		}
		return $val.Left < $val.Right;
	};

	ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)
	{
		var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
		var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
		if (Dir1 === Dir2)
			return false;
		//When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
		//want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
		//So, to facilitate this while inserting Op1b and Op2b ...
		//when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
		//otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
		if (Dir1 === ClipperLib.Direction.dLeftToRight)
		{
			while (op1.Next.Pt.X <= Pt.X &&
				op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)
				op1 = op1.Next;
			if (DiscardLeft && (op1.Pt.X !== Pt.X))
				op1 = op1.Next;
			op1b = this.DupOutPt(op1, !DiscardLeft);
			if (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))
			{
				op1 = op1b;
				//op1.Pt = Pt;
				op1.Pt.X = Pt.X;
				op1.Pt.Y = Pt.Y;
				if (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;
				op1b = this.DupOutPt(op1, !DiscardLeft);
			}
		}
		else
		{
			while (op1.Next.Pt.X >= Pt.X &&
				op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)
				op1 = op1.Next;
			if (!DiscardLeft && (op1.Pt.X !== Pt.X))
				op1 = op1.Next;
			op1b = this.DupOutPt(op1, DiscardLeft);
			if (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))
			{
				op1 = op1b;
				//op1.Pt = Pt;
				op1.Pt.X = Pt.X;
				op1.Pt.Y = Pt.Y;
				if (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;
				op1b = this.DupOutPt(op1, DiscardLeft);
			}
		}
		if (Dir2 === ClipperLib.Direction.dLeftToRight)
		{
			while (op2.Next.Pt.X <= Pt.X &&
				op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)
				op2 = op2.Next;
			if (DiscardLeft && (op2.Pt.X !== Pt.X))
				op2 = op2.Next;
			op2b = this.DupOutPt(op2, !DiscardLeft);
			if (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))
			{
				op2 = op2b;
				//op2.Pt = Pt;
				op2.Pt.X = Pt.X;
				op2.Pt.Y = Pt.Y;
				if (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;
				op2b = this.DupOutPt(op2, !DiscardLeft);
			}
		}
		else
		{
			while (op2.Next.Pt.X >= Pt.X &&
				op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)
				op2 = op2.Next;
			if (!DiscardLeft && (op2.Pt.X !== Pt.X))
				op2 = op2.Next;
			op2b = this.DupOutPt(op2, DiscardLeft);
			if (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))
			{
				op2 = op2b;
				//op2.Pt = Pt;
				op2.Pt.X = Pt.X;
				op2.Pt.Y = Pt.Y;
				if (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;
				op2b = this.DupOutPt(op2, DiscardLeft);
			}
		}
		if ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft)
		{
			op1.Prev = op2;
			op2.Next = op1;
			op1b.Next = op2b;
			op2b.Prev = op1b;
		}
		else
		{
			op1.Next = op2;
			op2.Prev = op1;
			op1b.Prev = op2b;
			op2b.Next = op1b;
		}
		return true;
	};

	ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)
	{
		var op1 = j.OutPt1,
			op1b = new ClipperLib.OutPt();
		var op2 = j.OutPt2,
			op2b = new ClipperLib.OutPt();
		//There are 3 kinds of joins for output polygons ...
		//1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere
		//along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
		//2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
		//location at the Bottom of the overlapping segment (& Join.OffPt is above).
		//3. StrictlySimple joins where edges touch but are not collinear and where
		//Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
		var isHorizontal = (j.OutPt1.Pt.Y === j.OffPt.Y);
		if (isHorizontal && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))
		{
			//Strictly Simple join ...
			if (outRec1 !== outRec2) return false;

			op1b = j.OutPt1.Next;
			while (op1b !== op1 && (ClipperLib.FPoint.op_Equality(op1b.Pt, j.OffPt)))
				op1b = op1b.Next;
			var reverse1 = (op1b.Pt.Y > j.OffPt.Y);
			op2b = j.OutPt2.Next;
			while (op2b !== op2 && (ClipperLib.FPoint.op_Equality(op2b.Pt, j.OffPt)))
				op2b = op2b.Next;
			var reverse2 = (op2b.Pt.Y > j.OffPt.Y);
			if (reverse1 === reverse2)
				return false;
			if (reverse1)
			{
				op1b = this.DupOutPt(op1, false);
				op2b = this.DupOutPt(op2, true);
				op1.Prev = op2;
				op2.Next = op1;
				op1b.Next = op2b;
				op2b.Prev = op1b;
				j.OutPt1 = op1;
				j.OutPt2 = op1b;
				return true;
			}
			else
			{
				op1b = this.DupOutPt(op1, true);
				op2b = this.DupOutPt(op2, false);
				op1.Next = op2;
				op2.Prev = op1;
				op1b.Prev = op2b;
				op2b.Next = op1b;
				j.OutPt1 = op1;
				j.OutPt2 = op1b;
				return true;
			}
		}
		else if (isHorizontal)
		{
			//treat horizontal joins differently to non-horizontal joins since with
			//them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
			//may be anywhere along the horizontal edge.
			op1b = op1;
			while (op1.Prev.Pt.Y === op1.Pt.Y && op1.Prev !== op1b && op1.Prev !== op2)
				op1 = op1.Prev;
			while (op1b.Next.Pt.Y === op1b.Pt.Y && op1b.Next !== op1 && op1b.Next !== op2)
				op1b = op1b.Next;
			if (op1b.Next === op1 || op1b.Next === op2)
				return false;
			//a flat 'polygon'
			op2b = op2;
			while (op2.Prev.Pt.Y === op2.Pt.Y && op2.Prev !== op2b && op2.Prev !== op1b)
				op2 = op2.Prev;
			while (op2b.Next.Pt.Y === op2b.Pt.Y && op2b.Next !== op2 && op2b.Next !== op1)
				op2b = op2b.Next;
			if (op2b.Next === op2 || op2b.Next === op1)
				return false;
			//a flat 'polygon'
			//Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges

			var $val = {
				Left: null,
				Right: null
			};

			if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))
				return false;
			var Left = $val.Left;
			var Right = $val.Right;

			//DiscardLeftSide: when overlapping edges are joined, a spike will created
			//which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
			//on the discard Side as either may still be needed for other joins ...
			var Pt = new ClipperLib.FPoint0();
			var DiscardLeftSide;
			if (op1.Pt.X >= Left && op1.Pt.X <= Right)
			{
				//Pt = op1.Pt;
				Pt.X = op1.Pt.X;
				Pt.Y = op1.Pt.Y;
				if (ClipperLib.use_xyz) Pt.Z = op1.Pt.Z;
				DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);
			}
			else if (op2.Pt.X >= Left && op2.Pt.X <= Right)
			{
				//Pt = op2.Pt;
				Pt.X = op2.Pt.X;
				Pt.Y = op2.Pt.Y;
				if (ClipperLib.use_xyz) Pt.Z = op2.Pt.Z;
				DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);
			}
			else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)
			{
				//Pt = op1b.Pt;
				Pt.X = op1b.Pt.X;
				Pt.Y = op1b.Pt.Y;
				if (ClipperLib.use_xyz) Pt.Z = op1b.Pt.Z;
				DiscardLeftSide = op1b.Pt.X > op1.Pt.X;
			}
			else
			{
				//Pt = op2b.Pt;
				Pt.X = op2b.Pt.X;
				Pt.Y = op2b.Pt.Y;
				if (ClipperLib.use_xyz) Pt.Z = op2b.Pt.Z;
				DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);
			}
			j.OutPt1 = op1;
			j.OutPt2 = op2;
			return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
		}
		else
		{
			//nb: For non-horizontal joins ...
			//    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y
			//    2. Jr.OutPt1.Pt > Jr.OffPt.Y
			//make sure the polygons are correctly oriented ...
			op1b = op1.Next;
			while ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))
				op1b = op1b.Next;
			var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt));
			if (Reverse1)
			{
				op1b = op1.Prev;
				while ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))
					op1b = op1b.Prev;

				if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt))
					return false;
			}
			op2b = op2.Next;
			while ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))
				op2b = op2b.Next;

			var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt));
			if (Reverse2)
			{
				op2b = op2.Prev;
				while ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))
					op2b = op2b.Prev;

				if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt))
					return false;
			}
			if ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||
				((outRec1 === outRec2) && (Reverse1 === Reverse2)))
				return false;
			if (Reverse1)
			{
				op1b = this.DupOutPt(op1, false);
				op2b = this.DupOutPt(op2, true);
				op1.Prev = op2;
				op2.Next = op1;
				op1b.Next = op2b;
				op2b.Prev = op1b;
				j.OutPt1 = op1;
				j.OutPt2 = op1b;
				return true;
			}
			else
			{
				op1b = this.DupOutPt(op1, true);
				op2b = this.DupOutPt(op2, false);
				op1.Next = op2;
				op2.Prev = op1;
				op1b.Prev = op2b;
				op2b.Next = op1b;
				j.OutPt1 = op1;
				j.OutPt2 = op1b;
				return true;
			}
		}
	};

	ClipperLib.Clipper.GetBounds = function (paths)
	{
		var i = 0,
			cnt = paths.length;
		while (i < cnt && paths[i].length === 0) i++;
		if (i === cnt) return new ClipperLib.FRect(0, 0, 0, 0);
		var result = new ClipperLib.FRect();
		result.left = paths[i][0].X;
		result.right = result.left;
		result.top = paths[i][0].Y;
		result.bottom = result.top;
		for (; i < cnt; i++)
			for (var j = 0, jlen = paths[i].length; j < jlen; j++)
			{
				if (paths[i][j].X < result.left) result.left = paths[i][j].X;
				else if (paths[i][j].X > result.right) result.right = paths[i][j].X;
				if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;
				else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;
			}
		return result;
	}
	ClipperLib.Clipper.prototype.GetBounds2 = function (ops)
	{
		var opStart = ops;
		var result = new ClipperLib.FRect();
		result.left = ops.Pt.X;
		result.right = ops.Pt.X;
		result.top = ops.Pt.Y;
		result.bottom = ops.Pt.Y;
		ops = ops.Next;
		while (ops !== opStart)
		{
			if (ops.Pt.X < result.left)
				result.left = ops.Pt.X;
			if (ops.Pt.X > result.right)
				result.right = ops.Pt.X;
			if (ops.Pt.Y < result.top)
				result.top = ops.Pt.Y;
			if (ops.Pt.Y > result.bottom)
				result.bottom = ops.Pt.Y;
			ops = ops.Next;
		}
		return result;
	};

	ClipperLib.Clipper.PointInPolygon = function (pt, path)
	{
		//returns 0 if false, +1 if true, -1 if pt ON polygon boundary
		//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
		//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
		var result = 0,
			cnt = path.length;
		if (cnt < 3)
			return 0;
		var ip = path[0];
		for (var i = 1; i <= cnt; ++i)
		{
			var ipNext = (i === cnt ? path[0] : path[i]);
			if (ipNext.Y === pt.Y)
			{
				if ((ipNext.X === pt.X) || (ip.Y === pt.Y && ((ipNext.X > pt.X) === (ip.X < pt.X))))
					return -1;
			}
			if ((ip.Y < pt.Y) !== (ipNext.Y < pt.Y))
			{
				if (ip.X >= pt.X)
				{
					if (ipNext.X > pt.X)
						result = 1 - result;
					else
					{
						var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);
						if (d === 0)
							return -1;
						else if ((d > 0) === (ipNext.Y > ip.Y))
							result = 1 - result;
					}
				}
				else
				{
					if (ipNext.X > pt.X)
					{
						var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);
						if (d === 0)
							return -1;
						else if ((d > 0) === (ipNext.Y > ip.Y))
							result = 1 - result;
					}
				}
			}
			ip = ipNext;
		}
		return result;
	};

	ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)
	{
		//returns 0 if false, +1 if true, -1 if pt ON polygon boundary
		var result = 0;
		var startOp = op;
		var ptx = pt.X,
			pty = pt.Y;
		var poly0x = op.Pt.X,
			poly0y = op.Pt.Y;
		do {
			op = op.Next;
			var poly1x = op.Pt.X,
				poly1y = op.Pt.Y;
			if (poly1y === pty)
			{
				if ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))
					return -1;
			}
			if ((poly0y < pty) !== (poly1y < pty))
			{
				if (poly0x >= ptx)
				{
					if (poly1x > ptx)
						result = 1 - result;
					else
					{
						var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
						if (d === 0)
							return -1;
						if ((d > 0) === (poly1y > poly0y))
							result = 1 - result;
					}
				}
				else
				{
					if (poly1x > ptx)
					{
						var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
						if (d === 0)
							return -1;
						if ((d > 0) === (poly1y > poly0y))
							result = 1 - result;
					}
				}
			}
			poly0x = poly1x;
			poly0y = poly1y;
		} while (startOp !== op);

		return result;
	};

	ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)
	{
		var op = outPt1;
		do {
			//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
			var res = this.PointInPolygon(op.Pt, outPt2);
			if (res >= 0)
				return res > 0;
			op = op.Next;
		}
		while (op !== outPt1)
		return true;
	};

	ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)
	{
		var outRec, firstLeft;
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
		{
			outRec = this.m_PolyOuts[i];
			firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);
			if (outRec.Pts !== null && firstLeft === OldOutRec)
			{
				if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))
					outRec.FirstLeft = NewOutRec;
			}
		}
	}

	ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec)
	{
		//A polygon has split into two such that one is now the inner of the other.
		//It's possible that these polygons now wrap around other polygons, so check
		//every polygon that's also contained by OuterOutRec's FirstLeft container
		//(including nil) to see if they've become inner to the new inner polygon ...
		var orfl = outerOutRec.FirstLeft;
		var outRec, firstLeft;
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
		{
			outRec = this.m_PolyOuts[i];
			if (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)
				continue;
			firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);
			if (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)
				continue;
			if (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))
				outRec.FirstLeft = innerOutRec;
			else if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))
				outRec.FirstLeft = outerOutRec;
			else if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)
				outRec.FirstLeft = orfl;
		}
	}

	ClipperLib.Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec)
	{
		//same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()
		var outRec;
		var firstLeft;
		for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
		{
			outRec = this.m_PolyOuts[i];
			firstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);
			if (outRec.Pts !== null && firstLeft === OldOutRec)
				outRec.FirstLeft = NewOutRec;
		}
	}

	ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)
	{
		while (FirstLeft !== null && FirstLeft.Pts === null)
			FirstLeft = FirstLeft.FirstLeft;
		return FirstLeft;
	};

	ClipperLib.Clipper.prototype.JoinCommonEdges = function ()
	{
		for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)
		{
			var join = this.m_Joins[i];
			var outRec1 = this.GetOutRec(join.OutPt1.Idx);
			var outRec2 = this.GetOutRec(join.OutPt2.Idx);
			if (outRec1.Pts === null || outRec2.Pts === null)
				continue;

			if (outRec1.IsOpen || outRec2.IsOpen)
			{
				continue;
			}

			//get the polygon fragment with the correct hole state (FirstLeft)
			//before calling JoinPoints() ...
			var holeStateRec;
			if (outRec1 === outRec2)
				holeStateRec = outRec1;
			else if (this.OutRec1RightOfOutRec2(outRec1, outRec2))
				holeStateRec = outRec2;
			else if (this.OutRec1RightOfOutRec2(outRec2, outRec1))
				holeStateRec = outRec1;
			else
				holeStateRec = this.GetLowermostRec(outRec1, outRec2);

			if (!this.JoinPoints(join, outRec1, outRec2)) continue;

			if (outRec1 === outRec2)
			{
				//instead of joining two polygons, we've just created a new one by
				//splitting one polygon into two.
				outRec1.Pts = join.OutPt1;
				outRec1.BottomPt = null;
				outRec2 = this.CreateOutRec();
				outRec2.Pts = join.OutPt2;
				//update all OutRec2.Pts Idx's ...
				this.UpdateOutPtIdxs(outRec2);

				if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))
				{
					//outRec1 contains outRec2 ...
					outRec2.IsHole = !outRec1.IsHole;
					outRec2.FirstLeft = outRec1;
					if (this.m_UsingPolyTree)
						this.FixupFirstLefts2(outRec2, outRec1);
					if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))
						this.ReversePolyPtLinks(outRec2.Pts);
				}
				else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))
				{
					//outRec2 contains outRec1 ...
					outRec2.IsHole = outRec1.IsHole;
					outRec1.IsHole = !outRec2.IsHole;
					outRec2.FirstLeft = outRec1.FirstLeft;
					outRec1.FirstLeft = outRec2;
					if (this.m_UsingPolyTree)
						this.FixupFirstLefts2(outRec1, outRec2);

					if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))
						this.ReversePolyPtLinks(outRec1.Pts);
				}
				else
				{
					//the 2 polygons are completely separate ...
					outRec2.IsHole = outRec1.IsHole;
					outRec2.FirstLeft = outRec1.FirstLeft;
					//fixup FirstLeft pointers that may need reassigning to OutRec2
					if (this.m_UsingPolyTree)
						this.FixupFirstLefts1(outRec1, outRec2);
				}
			}
			else
			{
				//joined 2 polygons together ...
				outRec2.Pts = null;
				outRec2.BottomPt = null;
				outRec2.Idx = outRec1.Idx;
				outRec1.IsHole = holeStateRec.IsHole;
				if (holeStateRec === outRec2)
					outRec1.FirstLeft = outRec2.FirstLeft;
				outRec2.FirstLeft = outRec1;
				//fixup FirstLeft pointers that may need reassigning to OutRec1
				if (this.m_UsingPolyTree)
					this.FixupFirstLefts3(outRec2, outRec1);
			}
		}
	};

	ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)
	{
		var op = outrec.Pts;
		do {
			op.Idx = outrec.Idx;
			op = op.Prev;
		}
		while (op !== outrec.Pts)
	};

	ClipperLib.Clipper.prototype.DoSimplePolygons = function ()
	{
		var i = 0;
		while (i < this.m_PolyOuts.length)
		{
			var outrec = this.m_PolyOuts[i++];
			var op = outrec.Pts;
			if (op === null || outrec.IsOpen)
				continue;
			do //for each Pt in Polygon until duplicate found do ...
			{
				var op2 = op.Next;
				while (op2 !== outrec.Pts)
				{
					if ((ClipperLib.FPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op)
					{
						//split the polygon into two ...
						var op3 = op.Prev;
						var op4 = op2.Prev;
						op.Prev = op4;
						op4.Next = op;
						op2.Prev = op3;
						op3.Next = op2;
						outrec.Pts = op;
						var outrec2 = this.CreateOutRec();
						outrec2.Pts = op2;
						this.UpdateOutPtIdxs(outrec2);
						if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))
						{
							//OutRec2 is contained by OutRec1 ...
							outrec2.IsHole = !outrec.IsHole;
							outrec2.FirstLeft = outrec;
							if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);

						}
						else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))
						{
							//OutRec1 is contained by OutRec2 ...
							outrec2.IsHole = outrec.IsHole;
							outrec.IsHole = !outrec2.IsHole;
							outrec2.FirstLeft = outrec.FirstLeft;
							outrec.FirstLeft = outrec2;
							if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);
						}
						else
						{
							//the 2 polygons are separate ...
							outrec2.IsHole = outrec.IsHole;
							outrec2.FirstLeft = outrec.FirstLeft;
							if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);
						}
						op2 = op;
						//ie get ready for the next iteration
					}
					op2 = op2.Next;
				}
				op = op.Next;
			}
			while (op !== outrec.Pts)
		}
	};

	ClipperLib.Clipper.Area = function (poly)
	{
		if (!Array.isArray(poly))
			return 0;
		var cnt = poly.length;
		if (cnt < 3)
			return 0;
		var a = 0;
		for (var i = 0, j = cnt - 1; i < cnt; ++i)
		{
			a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);
			j = i;
		}
		return -a * 0.5;
	};

	ClipperLib.Clipper.prototype.Area = function (op)
	{
		var opFirst = op;
		if (op === null) return 0;
		var a = 0;
		do {
			a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);
			op = op.Next;
		} while (op !== opFirst); // && typeof op !== 'undefined');
		return a * 0.5;
	}

	ClipperLib.Clipper.prototype.Area$1 = function (outRec)
	{
		return this.Area(outRec.Pts);
	};

	ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)
	{
		var result = new Array();
		var c = new ClipperLib.Clipper(0);
		c.StrictlySimple = true;
		c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);
		c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
		return result;
	};

	ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)
	{
		if (typeof (fillType) === "undefined") fillType = ClipperLib.PolyFillType.pftEvenOdd;
		var result = new Array();
		var c = new ClipperLib.Clipper(0);
		c.StrictlySimple = true;
		c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);
		c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
		return result;
	};

	ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)
	{
		var dx = (pt1.X - pt2.X);
		var dy = (pt1.Y - pt2.Y);
		return (dx * dx + dy * dy);
	};

	ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)
	{
		//The equation of a line in general form (Ax + By + C = 0)
		//given 2 points (x¹,y¹) & (x²,y²) is ...
		//(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0
		//A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹
		//perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
		//see http://en.wikipedia.org/wiki/Perpendicular_distance
		var A = ln1.Y - ln2.Y;
		var B = ln2.X - ln1.X;
		var C = A * ln1.X + B * ln1.Y;
		C = A * pt.X + B * pt.Y - C;
		return (C * C) / (A * A + B * B);
	};

	ClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)
	{
		//this function is more accurate when the point that's GEOMETRICALLY
		//between the other 2 points is the one that's tested for distance.
		//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts
		if (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))
		{
			if ((pt1.X > pt2.X) === (pt1.X < pt3.X))
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
			else if ((pt2.X > pt1.X) === (pt2.X < pt3.X))
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
			else
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
		}
		else
		{
			if ((pt1.Y > pt2.Y) === (pt1.Y < pt3.Y))
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
			else if ((pt2.Y > pt1.Y) === (pt2.Y < pt3.Y))
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
			else
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
		}
	}

	ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)
	{
		var dx = pt1.X - pt2.X;
		var dy = pt1.Y - pt2.Y;
		return ((dx * dx) + (dy * dy) <= distSqrd);
	};

	ClipperLib.Clipper.ExcludeOp = function (op)
	{
		var result = op.Prev;
		result.Next = op.Next;
		op.Next.Prev = result;
		result.Idx = 0;
		return result;
	};

	ClipperLib.Clipper.CleanPolygon = function (path, distance)
	{
		if (typeof (distance) === "undefined") distance = 1.415;
		//distance = proximity in units/pixels below which vertices will be stripped.
		//Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have
		//both x & y coords within 1 unit, then the second vertex will be stripped.
		var cnt = path.length;
		if (cnt === 0)
			return new Array();
		var outPts = new Array(cnt);
		for (var i = 0; i < cnt; ++i)
			outPts[i] = new ClipperLib.OutPt();
		for (var i = 0; i < cnt; ++i)
		{
			outPts[i].Pt = path[i];
			outPts[i].Next = outPts[(i + 1) % cnt];
			outPts[i].Next.Prev = outPts[i];
			outPts[i].Idx = 0;
		}
		var distSqrd = distance * distance;
		var op = outPts[0];
		while (op.Idx === 0 && op.Next !== op.Prev)
		{
			if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))
			{
				op = ClipperLib.Clipper.ExcludeOp(op);
				cnt--;
			}
			else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))
			{
				ClipperLib.Clipper.ExcludeOp(op.Next);
				op = ClipperLib.Clipper.ExcludeOp(op);
				cnt -= 2;
			}
			else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))
			{
				op = ClipperLib.Clipper.ExcludeOp(op);
				cnt--;
			}
			else
			{
				op.Idx = 1;
				op = op.Next;
			}
		}
		if (cnt < 3)
			cnt = 0;
		var result = new Array(cnt);
		for (var i = 0; i < cnt; ++i)
		{
			result[i] = new ClipperLib.FPoint1(op.Pt);
			op = op.Next;
		}
		outPts = null;
		return result;
	};

	ClipperLib.Clipper.CleanPolygons = function (polys, distance)
	{
		var result = new Array(polys.length);
		for (var i = 0, ilen = polys.length; i < ilen; i++)
			result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);
		return result;
	};

	ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)
	{
		var delta = (IsClosed ? 1 : 0);
		var polyCnt = pattern.length;
		var pathCnt = path.length;
		var result = new Array();
		if (IsSum)
			for (var i = 0; i < pathCnt; i++)
			{
				var p = new Array(polyCnt);
				for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
					p[j] = new ClipperLib.FPoint2(path[i].X + ip.X, path[i].Y + ip.Y);
				result.push(p);
			}
		else
			for (var i = 0; i < pathCnt; i++)
			{
				var p = new Array(polyCnt);
				for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
					p[j] = new ClipperLib.FPoint2(path[i].X - ip.X, path[i].Y - ip.Y);
				result.push(p);
			}
		var quads = new Array();
		for (var i = 0; i < pathCnt - 1 + delta; i++)
			for (var j = 0; j < polyCnt; j++)
			{
				var quad = new Array();
				quad.push(result[i % pathCnt][j % polyCnt]);
				quad.push(result[(i + 1) % pathCnt][j % polyCnt]);
				quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);
				quad.push(result[i % pathCnt][(j + 1) % polyCnt]);
				if (!ClipperLib.Clipper.Orientation(quad))
					quad.reverse();
				quads.push(quad);
			}
		return quads;
	};

	ClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed)
	{
		if (!(path_or_paths[0] instanceof Array))
		{
			var path = path_or_paths;
			var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);
			var c = new ClipperLib.Clipper();
			c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
			c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
			return paths;
		}
		else
		{
			var paths = path_or_paths;
			var solution = new ClipperLib.Paths();
			var c = new ClipperLib.Clipper();
			for (var i = 0; i < paths.length; ++i)
			{
				var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);
				c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);
				if (pathIsClosed)
				{
					var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);
					c.AddPath(path, ClipperLib.PolyType.ptClip, true);
				}
			}
			c.Execute(ClipperLib.ClipType.ctUnion, solution,
				ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
			return solution;
		}
	}

	ClipperLib.Clipper.TranslatePath = function (path, delta)
	{
		var outPath = new ClipperLib.Path();
		for (var i = 0; i < path.length; i++)
			outPath.push(new ClipperLib.FPoint2(path[i].X + delta.X, path[i].Y + delta.Y));
		return outPath;
	}

	ClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)
	{
		var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);
		var c = new ClipperLib.Clipper();
		c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
		c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
		return paths;
	}

	ClipperLib.Clipper.PolyTreeToPaths = function (polytree)
	{
		var result = new Array();
		//result.set_Capacity(polytree.get_Total());
		ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);
		return result;
	};

	ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)
	{
		var match = true;
		switch (nt)
		{
			case ClipperLib.Clipper.NodeType.ntOpen:
				return;
			case ClipperLib.Clipper.NodeType.ntClosed:
				match = !polynode.IsOpen;
				break;
			default:
				break;
		}
		if (polynode.m_polygon.length > 0 && match)
			paths.push(polynode.m_polygon);
		for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])
			ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);
	};

	ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)
	{
		var result = new ClipperLib.Paths();
		//result.set_Capacity(polytree.ChildCount());
		for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)
			if (polytree.Childs()[i].IsOpen)
				result.push(polytree.Childs()[i].m_polygon);
		return result;
	};

	ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)
	{
		var result = new ClipperLib.Paths();
		//result.set_Capacity(polytree.Total());
		ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);
		return result;
	};

	Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);
	ClipperLib.Clipper.NodeType = {
		ntAny: 0,
		ntOpen: 1,
		ntClosed: 2
	};

	/**
	* @constructor
	*/
	ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)
	{
		if (typeof (miterLimit) === "undefined") miterLimit = 2;
		if (typeof (arcTolerance) === "undefined") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;
		this.m_destPolys = new ClipperLib.Paths();
		this.m_srcPoly = new ClipperLib.Path();
		this.m_destPoly = new ClipperLib.Path();
		this.m_normals = new Array();
		this.m_delta = 0;
		this.m_sinA = 0;
		this.m_sin = 0;
		this.m_cos = 0;
		this.m_miterLim = 0;
		this.m_StepsPerRad = 0;
		this.m_lowest = new ClipperLib.FPoint0();
		this.m_polyNodes = new ClipperLib.PolyNode();
		this.MiterLimit = miterLimit;
		this.ArcTolerance = arcTolerance;
		this.m_lowest.X = -1;
	};

	ClipperLib.ClipperOffset.two_pi = 6.28318530717959;
	ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;
	ClipperLib.ClipperOffset.prototype.Clear = function ()
	{
		ClipperLib.Clear(this.m_polyNodes.Childs());
		this.m_lowest.X = -1;
	};

	ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)
	{
		var highI = path.length - 1;
		if (highI < 0)
			return;
		var newNode = new ClipperLib.PolyNode();
		newNode.m_jointype = joinType;
		newNode.m_endtype = endType;
		//strip duplicate points from path and also get index to the lowest point ...
		if (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)
			while (highI > 0 && ClipperLib.FPoint.op_Equality(path[0], path[highI]))
				highI--;
		//newNode.m_polygon.set_Capacity(highI + 1);
		newNode.m_polygon.push(path[0]);
		var j = 0,
			k = 0;
		for (var i = 1; i <= highI; i++)
			if (ClipperLib.FPoint.op_Inequality(newNode.m_polygon[j], path[i]))
			{
				j++;
				newNode.m_polygon.push(path[i]);
				if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y === newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))
					k = j;
			}
		if (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;

		this.m_polyNodes.AddChild(newNode);
		//if this path's lowest pt is lower than all the others then update m_lowest
		if (endType !== ClipperLib.EndType.etClosedPolygon)
			return;
		if (this.m_lowest.X < 0)
			this.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);
		else
		{
			var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];
			if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y === ip.Y && newNode.m_polygon[k].X < ip.X))
				this.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);
		}
	};

	ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)
	{
		for (var i = 0, ilen = paths.length; i < ilen; i++)
			this.AddPath(paths[i], joinType, endType);
	};

	ClipperLib.ClipperOffset.prototype.FixOrientations = function ()
	{
		//fixup orientations of all closed paths if the orientation of the
		//closed path with the lowermost vertex is wrong ...
		if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))
		{
			for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
			{
				var node = this.m_polyNodes.Childs()[i];
				if (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))
					node.m_polygon.reverse();
			}
		}
		else
		{
			for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
			{
				var node = this.m_polyNodes.Childs()[i];
				if (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))
					node.m_polygon.reverse();
			}
		}
	};

	ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)
	{
		var dx = (pt2.X - pt1.X);
		var dy = (pt2.Y - pt1.Y);
		if ((dx === 0) && (dy === 0))
			return new ClipperLib.FPoint2(0, 0);
		var f = 1 / Math.sqrt(dx * dx + dy * dy);
		dx *= f;
		dy *= f;
		return new ClipperLib.FPoint2(dy, -dx);
	};

	ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)
	{
		this.m_destPolys = new Array();
		this.m_delta = delta;
		//if Zero offset, just copy any CLOSED polygons to m_p and return ...
		if (ClipperLib.ClipperBase.near_zero(delta))
		{
			//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);
			for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
			{
				var node = this.m_polyNodes.Childs()[i];
				if (node.m_endtype === ClipperLib.EndType.etClosedPolygon)
					this.m_destPolys.push(node.m_polygon);
			}
			return;
		}
		//see offset_triginometry3.svg in the documentation folder ...
		//if (this.MiterLimit > 1)  Shy: don't know why this was here
			this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
		//else
			//this.m_miterLim = 0.5;
		var y;
		if (this.ArcTolerance <= 0)
			y = ClipperLib.ClipperOffset.def_arc_tolerance;
		else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)
			y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;
		else
			y = this.ArcTolerance;
		//see offset_triginometry2.svg in the documentation folder ...
		var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));
		this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);
		this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);
		this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;
		if (delta < 0)
			this.m_sin = -this.m_sin;
		//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);
		for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
		{
			var node = this.m_polyNodes.Childs()[i];
			this.m_srcPoly = node.m_polygon;
			var len = this.m_srcPoly.length;
			if (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))
				continue;
			this.m_destPoly = new Array();
			if (len === 1)
			{
				if (node.m_jointype === ClipperLib.JoinType.jtRound)
				{
					var X = 1,
						Y = 0;
					for (var j = 1; j <= steps; j++)
					{
						this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].X + X * delta, this.m_srcPoly[0].Y + Y * delta, this.m_srcPoly[0].Z));
						var X2 = X;
						X = X * this.m_cos - this.m_sin * Y;
						Y = X2 * this.m_sin + Y * this.m_cos;
					}
				}
				else
				{
					var X = -1,
						Y = -1;
					for (var j = 0; j < 4; ++j)
					{
						this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].X + X * delta, this.m_srcPoly[0].Y + Y * delta, this.m_srcPoly[0].Z));
						if (X < 0)
							X = 1;
						else if (Y < 0)
							Y = 1;
						else
							X = -1;
					}
				}
				this.m_destPolys.push(this.m_destPoly);
				continue;
			}
			//build m_normals ...
			this.m_normals.length = 0;
			//this.m_normals.set_Capacity(len);
			for (var j = 0; j < len - 1; j++)
				this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));
			if (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)
				this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));
			else
				this.m_normals.push(new ClipperLib.FPoint1(this.m_normals[len - 2]));
			if (node.m_endtype === ClipperLib.EndType.etClosedPolygon)
			{
				var k = len - 1;
				for (var j = 0; j < len; j++)
					k = this.OffsetPoint(j, k, node.m_jointype);
				this.m_destPolys.push(this.m_destPoly);
			}
			else if (node.m_endtype === ClipperLib.EndType.etClosedLine)
			{
				var k = len - 1;
				for (var j = 0; j < len; j++)
					k = this.OffsetPoint(j, k, node.m_jointype);
				this.m_destPolys.push(this.m_destPoly);
				this.m_destPoly = new Array();
				//re-build m_normals ...
				var n = this.m_normals[len - 1];
				for (var j = len - 1; j > 0; j--)
					this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);
				this.m_normals[0] = new ClipperLib.FPoint2(-n.X, -n.Y);
				k = 0;
				for (var j = len - 1; j >= 0; j--)
					k = this.OffsetPoint(j, k, node.m_jointype);
				this.m_destPolys.push(this.m_destPoly);
			}
			else
			{
				var k = 0;
				for (var j = 1; j < len - 1; ++j)
					k = this.OffsetPoint(j, k, node.m_jointype);
				var pt1;
				if (node.m_endtype === ClipperLib.EndType.etOpenButt)
				{
					var j = len - 1;
					pt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[j].X * delta, this.m_srcPoly[j].Y + this.m_normals[j].Y * delta, this.m_srcPoly[j].Z);
					this.m_destPoly.push(pt1);
					pt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].X - this.m_normals[j].X * delta, this.m_srcPoly[j].Y - this.m_normals[j].Y * delta, this.m_srcPoly[j].Z);
					this.m_destPoly.push(pt1);
				}
				else
				{
					var j = len - 1;
					k = len - 2;
					this.m_sinA = 0;
					this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j].X, -this.m_normals[j].Y);
					if (node.m_endtype === ClipperLib.EndType.etOpenSquare)
						this.DoSquare(j, k);
					else
						this.DoRound(j, k);
				}
				//re-build m_normals ...
				for (var j = len - 1; j > 0; j--)
					this.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);
				this.m_normals[0] = new ClipperLib.FPoint2(-this.m_normals[1].X, -this.m_normals[1].Y);
				k = len - 1;
				for (var j = k - 1; j > 0; --j)
					k = this.OffsetPoint(j, k, node.m_jointype);
				if (node.m_endtype === ClipperLib.EndType.etOpenButt)
				{
					pt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].X - this.m_normals[0].X * delta, this.m_srcPoly[0].Y - this.m_normals[0].Y * delta, this.m_srcPoly[0].Z);
					this.m_destPoly.push(pt1);
					pt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].X + this.m_normals[0].X * delta, this.m_srcPoly[0].Y + this.m_normals[0].Y * delta, this.m_srcPoly[0].Z);
					this.m_destPoly.push(pt1);
				}
				else
				{
					k = 1;
					this.m_sinA = 0;
					if (node.m_endtype === ClipperLib.EndType.etOpenSquare)
						this.DoSquare(0, 1);
					else
						this.DoRound(0, 1);
				}
				this.m_destPolys.push(this.m_destPoly);
			}
		}
	};

	ClipperLib.ClipperOffset.prototype.Execute = function ()
	{
		var a = arguments,
			ispolytree = a[0] instanceof ClipperLib.PolyTree;
		if (!ispolytree) // function (solution, delta)
		{
			var solution = a[0],
				delta = a[1];
			ClipperLib.Clear(solution);
			this.FixOrientations();
			this.DoOffset(delta);
			//now clean up 'corners' ...
			var clpr = new ClipperLib.Clipper(0);
			clpr.ZFillFunction = this.ZFillFunction
			clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
			if (delta > 0)
			{
				clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
			}
			else
			{
				var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
				var outer = new ClipperLib.Path();
				outer.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));
				outer.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));
				outer.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));
				outer.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));
				clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
				clpr.ReverseSolution = true;
				clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
				if (solution.length > 0)
					solution.splice(0, 1);
			}
			//console.log(JSON.stringify(solution));
		}
		else // function (polytree, delta)
		{
			var solution = a[0],
				delta = a[1];
			solution.Clear();
			this.FixOrientations();
			this.DoOffset(delta);
			//now clean up 'corners' ...
			var clpr = new ClipperLib.Clipper(0);
			clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
			if (delta > 0)
			{
				clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
			}
			else
			{
				var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
				var outer = new ClipperLib.Path();
				outer.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));
				outer.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));
				outer.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));
				outer.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));
				clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
				clpr.ReverseSolution = true;
				clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
				//remove the outer PolyNode rectangle ...
				if (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0)
				{
					var outerNode = solution.Childs()[0];
					//solution.Childs.set_Capacity(outerNode.ChildCount);
					solution.Childs()[0] = outerNode.Childs()[0];
					solution.Childs()[0].m_Parent = solution;
					for (var i = 1; i < outerNode.ChildCount(); i++)
						solution.AddChild(outerNode.Childs()[i]);
				}
				else
					solution.Clear();
			}
		}
	};

	ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)
	{
		//cross product ...
		this.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);

		if (this.m_sinA === 0)
		{
      return k;
		}

/*
		else if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)
{
			console.log(this.m_sinA);
      return k;
}
*/
/*
		if (Math.abs(this.m_sinA * this.m_delta) < 1.0)
		{
			//dot product ...
			var cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);
			if (cosA > 0) // angle ==> 0 degrees
			{
				this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta,
					this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta));
				return k;
			}
			//else angle ==> 180 degrees
		}
*/
		else if (this.m_sinA > 1)
			this.m_sinA = 1.0;
		else if (this.m_sinA < -1)
			this.m_sinA = -1.0;
		if (this.m_sinA * this.m_delta < 0)
		{
			this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta,
				this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta, this.m_srcPoly[j].Z));
			this.m_destPoly.push(new ClipperLib.FPoint1(this.m_srcPoly[j]));
			this.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta,
				this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta, this.m_srcPoly[j].Z));
		}
		else
			switch (jointype)
			{
			case ClipperLib.JoinType.jtMiter:
			case ClipperLib.JoinType.jtMiterAlways:
				{
					var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);
					if (r >= this.m_miterLim || jointype === ClipperLib.JoinType.jtMiterAlways)
						this.DoMiter(j, k, r);
					else
						this.DoSquare(j, k);
					break;
				}
			
			case ClipperLib.JoinType.jtSquare:
				this.DoSquare(j, k);
				break;
			case ClipperLib.JoinType.jtRound:
				this.DoRound(j, k);
				break;
			}
		k = j;
		return k;
	};

	ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)
	{
		var dx = Math.tan(Math.atan2(this.m_sinA,
			this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4 ) ;
		this.m_destPoly.push(new ClipperLib.FPoint2(
			this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx),
			this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx), this.m_srcPoly[j].Z));
		this.m_destPoly.push(new ClipperLib.FPoint2(
			this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx),
			this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx), this.m_srcPoly[j].Z));
	};

	ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)
	{
		var q = this.m_delta / r;
		this.m_destPoly.push(new ClipperLib.FPoint2(
			this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q,
			this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q, this.m_srcPoly[j].Z));
	};

	ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)
	{
		var a = Math.atan2(this.m_sinA,
			this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);

		var steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);

		var X = this.m_normals[k].X,
			Y = this.m_normals[k].Y,
			X2;
		for (var i = 0; i < steps; ++i)
		{
			this.m_destPoly.push(new ClipperLib.FPoint2(
				this.m_srcPoly[j].X + X * this.m_delta,
				this.m_srcPoly[j].Y + Y * this.m_delta, this.m_srcPoly[j].Z));
			X2 = X;
			X = X * this.m_cos - this.m_sin * Y;
			Y = X2 * this.m_sin + Y * this.m_cos;
		}
		this.m_destPoly.push(new ClipperLib.FPoint2(
			this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta,
			this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta, this.m_srcPoly[j].Z));
	};

	ClipperLib.Error = function (message)
	{
		//try
		{
			throw new Error(message);
		}
		/*catch (err)
		{
			alert(err.message);
		}*/
	};

	// ---------------------------------------------

	// JS extension by Timo 2013
	ClipperLib.JS = {};

	ClipperLib.JS.AreaOfPolygon = function (poly)
	{
		return ClipperLib.Clipper.Area(poly);
	};

	ClipperLib.JS.AreaOfPolygons = function (poly)
	{
		var area = 0;
		for (var i = 0; i < poly.length; i++)
		{
			area += ClipperLib.Clipper.Area(poly[i]);
		}
		return area;
	};

	ClipperLib.JS.BoundsOfPath = function (path)
	{
		return ClipperLib.JS.BoundsOfPaths([path]);
	};

	ClipperLib.JS.BoundsOfPaths = function (paths)
	{
		var bounds = ClipperLib.Clipper.GetBounds(paths);
		return bounds;
	};

	// Clean() joins vertices that are too near each other
	// and causes distortion to offsetted polygons without cleaning
	ClipperLib.JS.Clean = function (polygon, delta)
	{
		if (!(polygon instanceof Array)) return [];
		var isPolygons = polygon[0] instanceof Array;
		var polygon = ClipperLib.JS.Clone(polygon);
		if (typeof delta !== "number" || delta === null)
		{
			ClipperLib.Error("Delta is not a number in Clean().");
			return polygon;
		}
		if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;
		if (!isPolygons) polygon = [polygon];
		var k_length = polygon.length;
		var len, poly, result, d, p, j, i;
		var results = [];
		for (var k = 0; k < k_length; k++)
		{
			poly = polygon[k];
			len = poly.length;
			if (len === 0) continue;
			else if (len < 3)
			{
				result = poly;
				results.push(result);
				continue;
			}
			result = poly;
			d = delta * delta;
			//d = Math.floor(c_delta * c_delta);
			p = poly[0];
			j = 1;
			for (i = 1; i < len; i++)
			{
				if ((poly[i].X - p.X) * (poly[i].X - p.X) +
					(poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)
					continue;
				result[j] = poly[i];
				p = poly[i];
				j++;
			}
			p = poly[j - 1];
			if ((poly[0].X - p.X) * (poly[0].X - p.X) +
				(poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)
				j--;
			if (j < len)
				result.splice(j, len - j);
			if (result.length) results.push(result);
		}
		if (!isPolygons && results.length) results = results[0];
		else if (!isPolygons && results.length === 0) results = [];
		else if (isPolygons && results.length === 0) results = [
			[]
		];
		return results;
	}
	// Make deep copy of Polygons or Polygon
	// so that also FPoint objects are cloned and not only referenced
	// This should be the fastest way
	ClipperLib.JS.Clone = function (polygon)
	{
		if (!(polygon instanceof Array)) return [];
		if (polygon.length === 0) return [];
		else if (polygon.length === 1 && polygon[0].length === 0) return [
			[]
		];
		var isPolygons = polygon[0] instanceof Array;
		if (!isPolygons) polygon = [polygon];
		var len = polygon.length,
			plen, i, j, result;
		var results = new Array(len);
		for (i = 0; i < len; i++)
		{
			plen = polygon[i].length;
			result = new Array(plen);
			for (j = 0; j < plen; j++)
			{
				result[j] = {
					X: polygon[i][j].X,
					Y: polygon[i][j].Y,
					Z: polygon[i][j].Z
				};

			}
			results[i] = result;
		}
		if (!isPolygons) results = results[0];
		return results;
	};

	// Removes points that doesn't affect much to the visual appearance.
	// If middle point is at or under certain distance (tolerance) of the line segment between
	// start and end point, the middle point is removed.
	ClipperLib.JS.Lighten = function (polygon, tolerance)
	{
		if (!(polygon instanceof Array)) return [];
		if (typeof tolerance !== "number" || tolerance === null)
		{
			ClipperLib.Error("Tolerance is not a number in Lighten().")
			return ClipperLib.JS.Clone(polygon);
		}
		if (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0)
		{
			return ClipperLib.JS.Clone(polygon);
		}
		var isPolygons = polygon[0] instanceof Array;
		if (!isPolygons) polygon = [polygon];
		var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;
		var bxax, byay, l, ax, ay;
		var len = polygon.length;
		var toleranceSq = tolerance * tolerance;
		var results = [];
		for (i = 0; i < len; i++)
		{
			poly = polygon[i];
			plen = poly.length;
			if (plen === 0) continue;
			for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count
			{
				poly2 = [];
				plen = poly.length;
				// the first have to added to the end, if first and last are not the same
				// this way we ensure that also the actual last point can be removed if needed
				if (poly[plen - 1].X !== poly[0].X || poly[plen - 1].Y !== poly[0].Y)
				{
					addlast = 1;
					poly.push(
					{
						X: poly[0].X,
						Y: poly[0].Y,
						Z: poly[0].Z
					});
					plen = poly.length;
				}
				else addlast = 0;
				rem = []; // Indexes of removed points
				for (j = 0; j < plen - 2; j++)
				{
					A = poly[j]; // Start point of line segment
					P = poly[j + 1]; // Middle point. This is the one to be removed.
					B = poly[j + 2]; // End point of line segment
					ax = A.X;
					ay = A.Y;
					bxax = B.X - ax;
					byay = B.Y - ay;
					if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.
					{
						l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);
						if (l > 1)
						{
							ax = B.X;
							ay = B.Y;
						}
						else if (l > 0)
						{
							ax += bxax * l;
							ay += byay * l;
						}
					}
					bxax = P.X - ax;
					byay = P.Y - ay;
					d = bxax * bxax + byay * byay;
					if (d <= toleranceSq)
					{
						rem[j + 1] = 1;
						j++; // when removed, transfer the pointer to the next one
					}
				}
				// add all unremoved points to poly2
				poly2.push(
				{
					X: poly[0].X,
					Y: poly[0].Y,
					Z: poly[0].Z
				});
				for (j = 1; j < plen - 1; j++)
					if (!rem[j]) poly2.push(
					{
						X: poly[j].X,
						Y: poly[j].Y,
						Z: poly[j].Z
					});
				poly2.push(
				{
					X: poly[plen - 1].X,
					Y: poly[plen - 1].Y,
					Z: poly[plen - 1].Z
				});
				// if the first point was added to the end, remove it
				if (addlast) poly.pop();
				// break, if there was not anymore removed points
				if (!rem.length) break;
				// else continue looping using poly2, to check if there are points to remove
				else poly = poly2;
			}
			plen = poly2.length;
			// remove duplicate from end, if needed
			if (poly2[plen - 1].X === poly2[0].X && poly2[plen - 1].Y === poly2[0].Y)
			{
				poly2.pop();
			}
			if (poly2.length > 2) // to avoid two-point-polygons
				results.push(poly2);
		}
		if (!isPolygons)
		{
			results = results[0];
		}
		if (typeof (results) === "undefined")
		{
			results = [];
		}
		return results;
	}

	ClipperLib.JS.PerimeterOfPath = function (path, closed)
	{
		if (typeof (path) === "undefined") return 0;
		var sqrt = Math.sqrt;
		var perimeter = 0.0;
		var p1, p2, p1x = 0.0,
			p1y = 0.0,
			p2x = 0.0,
			p2y = 0.0;
		var j = path.length;
		if (j < 2) return 0;
		if (closed)
		{
			path[j] = path[0];
			j++;
		}
		while (--j)
		{
			p1 = path[j];
			p1x = p1.X;
			p1y = p1.Y;
			p2 = path[j - 1];
			p2x = p2.X;
			p2y = p2.Y;
			perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));
		}
		if (closed) path.pop();
		return perimeter;
	};

	ClipperLib.JS.PerimeterOfPaths = function (paths, closed)
	{
		var perimeter = 0;
		for (var i = 0; i < paths.length; i++)
		{
			perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed);
		}
		return perimeter;
	};

	/**
	* @constructor
	*/
	ClipperLib.ExPolygons = function ()
	{
		return [];
	}
	/**
	* @constructor
	*/
	ClipperLib.ExPolygon = function ()
	{
		this.outer = null;
		this.holes = null;
	};

	ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)
	{
		var ep = new ClipperLib.ExPolygon();
		ep.outer = polynode.Contour();
		var childs = polynode.Childs();
		var ilen = childs.length;
		ep.holes = new Array(ilen);
		var node, n, i, j, childs2, jlen;
		for (i = 0; i < ilen; i++)
		{
			node = childs[i];
			ep.holes[i] = node.Contour();
			//Add outer polygons contained by (nested within) holes ...
			for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)
			{
				n = childs2[j];
				ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);
			}
		}
		expolygons.push(ep);
	};

	ClipperLib.JS.ExPolygonsToPaths = function (expolygons)
	{
		var a, i, alen, ilen;
		var paths = new ClipperLib.Paths();
		for (a = 0, alen = expolygons.length; a < alen; a++)
		{
			paths.push(expolygons[a].outer);
			for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)
			{
				paths.push(expolygons[a].holes[i]);
			}
		}
		return paths;
	}
	ClipperLib.JS.PolyTreeToExPolygons = function (polytree)
	{
		var expolygons = new ClipperLib.ExPolygons();
		var node, i, childs, ilen;
		for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)
		{
			node = childs[i];
			ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);
		}
		return expolygons;
	};

})();
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */

(function() {

var ACE_NAMESPACE = "";

var global = (function() { return this; })();
if (!global && typeof window != "undefined") global = window; // strict mode


if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
    return;


var define = function(module, deps, payload) {
    if (typeof module !== "string") {
        if (define.original)
            define.original.apply(this, arguments);
        else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
        }
        return;
    }
    if (arguments.length == 2)
        payload = deps;
    if (!define.modules[module]) {
        define.payloads[module] = payload;
        define.modules[module] = null;
    }
};

define.modules = {};
define.payloads = {};

/**
 * Get at functionality define()ed using the function above
 */
var _require = function(parentId, module, callback) {
    if (typeof module === "string") {
        var payload = lookup(parentId, module);
        if (payload != undefined) {
            callback && callback();
            return payload;
        }
    } else if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && require.original)
                return;
            params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
    }
};

var require = function(module, callback) {
    var packagedModule = _require("", module, callback);
    if (packagedModule == undefined && require.original)
        return require.original.apply(this, arguments);
    return packagedModule;
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
        module = define.payloads[moduleName];
        if (typeof module === 'function') {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: '',
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _require(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
        }
        module = define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        define.original = root.define;
        root.define = define;
        root.define.packaged = true;
    }

    if (!root.require || !root.require.packaged) {
        require.original = root.require;
        root.require = require;
        root.require.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

define("ace/lib/regexp",["require","exports","module"], function(require, exports, module) {
"use strict";

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    if (compliantLastIndexIncrement && compliantExecNpcg)
        return;
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };
    if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function (str) {
            var match = real.exec.call(this, str);
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    }

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    }

});

define("ace/lib/es5-shim",["require","exports","module"], function(require, exports, module) {

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        var target = this;
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        var args = slice.call(arguments, 1); // for normal call
        var bound = function () {

            if (this instanceof bound) {

                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
}
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;
        
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;            
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}
if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;
        descriptor =  { enumerable: true, configurable: true };
        if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;
                return descriptor;
            }
        }
        descriptor.value = object[property];
        return descriptor;
    };
}
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        }
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
    }
}
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
        }
        if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}
if (!Object.seal) {
    Object.seal = function seal(object) {
        return object;
    };
}
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        return object;
    };
}
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        return object;
    };
}
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(require, exports, module) {
"use strict";

require("./regexp");
require("./es5-shim");
if (typeof Element != "undefined" && !Element.prototype.remove) {
    Object.defineProperty(Element.prototype, "remove", {
        enumerable: false,
        writable: true,
        configurable: true,
        value: function() { this.parentNode && this.parentNode.removeChild(this); }
    });
}


});

define("ace/lib/useragent",["require","exports","module"], function(require, exports, module) {
"use strict";
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};
var _navigator = typeof navigator == "object" ? navigator : {};

var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
var ua = _navigator.userAgent || "";
var appName = _navigator.appName || "";
exports.isWin = (os == "win");
exports.isMac = (os == "mac");
exports.isLinux = (os == "linux");
exports.isIE = 
    (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
    
exports.isOldIE = exports.isIE && exports.isIE < 9;
exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isAndroid = ua.indexOf("Android") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;

if (exports.isIOS) exports.isMac = true;

exports.isMobile = exports.isIOS || exports.isAndroid;

});

define("ace/lib/dom",["require","exports","module","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var useragent = require("./useragent"); 
var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.buildDom = function buildDom(arr, parent, refs) {
    if (typeof arr == "string" && arr) {
        var txt = document.createTextNode(arr);
        if (parent)
            parent.appendChild(txt);
        return txt;
    }
    
    if (!Array.isArray(arr)) {
        if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
        return arr;
    }
    if (typeof arr[0] != "string" || !arr[0]) {
        var els = [];
        for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
        }
        return els;
    }
    
    var el = document.createElement(arr[0]);
    var options = arr[1];
    var childIndex = 1;
    if (options && typeof options == "object" && !Array.isArray(options))
        childIndex = 2;
    for (var i = childIndex; i < arr.length; i++)
        buildDom(arr[i], el, refs);
    if (childIndex == 2) {
        Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
                el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
                el[n] = val;
            } else if (n === "ref") {
                if (refs) refs[val] = el;
            } else if (val != null) {
                el.setAttribute(n, val);
            }
        });
    }
    if (parent)
        parent.appendChild(el);
    return el;
};

exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
};

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.removeChildren = function(element) {
    element.innerHTML = "";
};

exports.createTextNode = function(textContent, element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createTextNode(textContent);
};

exports.createFragment = function(element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createDocumentFragment();
};

exports.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if ((sheets = doc.querySelectorAll("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id)
                return true;
    }
};

exports.importCssString = function importCssString(cssText, id, target) {
    var container = target;
    if (!target || !target.getRootNode) {
        container = document;
    } else {
        container = target.getRootNode();
        if (!container || container == target)
            container = document;
    }
    
    var doc = container.ownerDocument || container;
    if (id && exports.hasCssString(id, container))
        return null;
    
    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    
    var style = exports.createElement("style");
    style.appendChild(doc.createTextNode(cssText));
    if (id)
        style.id = id;

    if (container == doc)
        container = exports.getDocumentHead(doc);
    container.insertBefore(style, container.firstChild);
};

exports.importCssStylsheet = function(uri, doc) {
    exports.buildDom(["link", {rel: "stylesheet", href: uri}], exports.getDocumentHead(doc));
};
exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};

if (typeof document == "undefined") {
    exports.importCssString = function() {};
}

exports.computedStyle = function(element, style) {
    return window.getComputedStyle(element, "") || {};
};

exports.setStyle = function(styles, property, value) {
    if (styles[property] !== value) {
        styles[property] = value;
    }
};

exports.HAS_CSS_ANIMATION = false;
exports.HAS_CSS_TRANSFORMS = false;
exports.HI_DPI = useragent.isWin
    ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
    : true;

if (typeof document !== "undefined") {
    var div = document.createElement("div");
    if (exports.HI_DPI && div.style.transform  !== undefined)
        exports.HAS_CSS_TRANSFORMS = true;
    if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
        exports.HAS_CSS_ANIMATION = true;
    div = null;
}

if (exports.HAS_CSS_TRANSFORMS) {
    exports.translate = function(element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) +"px)";
    };
} else {
    exports.translate = function(element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
    };
}

});

define("ace/lib/oop",["require","exports","module"], function(require, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define("ace/lib/keys",["require","exports","module","ace/lib/oop"], function(require, exports, module) {
"use strict";

var oop = require("./oop");
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
            91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
            "super": 8, "meta": 8, "command": 8, "cmd": 8, 
            "control": 1
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
          219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
        }
    };
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    ret[173] = '-';
    
    (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i = Math.pow(2, mods.length); i--;) {            
            ret.KEY_MODS[i] = mods.filter(function(x) {
                return i & ret.KEY_MODS[x];
            }).join("-") + "-";
        }
    })();

    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var keys = require("./keys");
var useragent = require("./useragent");

var pressedKeys = null;
var ts = 0;

var activeListenerOptions;
function detectListenerOptionsSupport() {
    activeListenerOptions = false;
    try {
        document.createComment("").addEventListener("test", function() {}, { 
            get passive() { 
                activeListenerOptions = {passive: false};
            }
        });
    } catch(e) {}
}

function getListenerOptions() {
    if (activeListenerOptions == undefined)
        detectListenerOptionsSupport();
    return activeListenerOptions;
}

function EventListener(elem, type, callback) {
    this.elem = elem;
    this.type = type;
    this.callback = callback;
}
EventListener.prototype.destroy = function() {
    removeListener(this.elem, this.type, this.callback);
    this.elem = this.type = this.callback = undefined;
};

var addListener = exports.addListener = function(elem, type, callback, destroyer) {
    elem.addEventListener(type, callback, getListenerOptions());
    if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
};

var removeListener = exports.removeListener = function(elem, type, callback) {
    elem.removeEventListener(type, callback, getListenerOptions());
};
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
};
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;
    return e.button;
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        removeListener(document, "mousemove", eventHandler);
        removeListener(document, "mouseup", onMouseUp);
        removeListener(document, "dragstart", onMouseUp);
    }

    addListener(document, "mousemove", eventHandler);
    addListener(document, "mouseup", onMouseUp);
    addListener(document, "dragstart", onMouseUp);
    
    return onMouseUp;
};

exports.addMouseWheelListener = function(el, callback, destroyer) {
    if ("onmousewheel" in el) {
        addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
        }, destroyer);
    } else if ("onwheel" in el) {
        addListener(el, "wheel",  function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = e.deltaX * factor || 0;
                    e.wheelY = e.deltaY * factor || 0;
                    break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                    e.wheelX = (e.deltaX || 0) * 5;
                    e.wheelY = (e.deltaY || 0) * 5;
                    break;
            }
            
            callback(e);
        }, destroyer);
    } else {
        addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
        }, destroyer);
    }
};

exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
    var clicks = 0;
    var startX, startY, timer; 
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        
        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function(el) {
        addListener(el, "mousedown", onMousedown, destroyer);
    });
};

var getModifierHash = function(e) {
    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
};

exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }
    
    if (!hashId && keyCode === 13) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    return callback(e, hashId, keyCode);
}


exports.addCommandKeyListener = function(el, callback, destroyer) {
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        }, destroyer);
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        }, destroyer);
    } else {
        var lastDefaultPrevented = null;

        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        }, destroyer);

        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        }, destroyer);

        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        }, destroyer);

        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
        }
    }
};
function resetPressedKeys() {
    pressedKeys = Object.create(null);
}

if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + (postMessageId++);
        
        var listener = function(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                removeListener(win, "message", listener);
                callback();
            }
        };
        
        addListener(win, "message", listener);
        win.postMessage(messageName, "*");
    };
}

exports.$idleBlocked = false;
exports.onIdle = function(cb, timeout) {
    return setTimeout(function handler() {
        if (!exports.$idleBlocked) {
            cb();
        } else {
            setTimeout(handler, 100);
        }
    }, timeout);
};

exports.$idleBlockId = null;
exports.blockIdle = function(delay) {
    if (exports.$idleBlockId)
        clearTimeout(exports.$idleBlockId);
        
    exports.$idleBlocked = true;
    exports.$idleBlockId = setTimeout(function() {
        exports.$idleBlocked = false;
    }, delay || 100);
};

exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});

define("ace/range",["require","exports","module"], function(require, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

define("ace/lib/lang",["require","exports","module"], function(require, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

define("ace/clipboard",["require","exports","module"], function(require, exports, module) {
"use strict";

var $cancelT;
module.exports = { 
    lineMode: false,
    pasteCancelled: function() {
        if ($cancelT && $cancelT > Date.now() - 50)
            return true;
        return $cancelT = false;
    },
    cancel: function() {
        $cancelT = Date.now();
    }
};

});

define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/clipboard","ace/lib/keys"], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var clipboard = require("../clipboard");
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;
var HAS_FOCUS_ARGS = useragent.isChrome > 63;
var MAX_LINE_LENGTH = 400;

var KEYS = require("../lib/keys");
var MODS = KEYS.KEY_MODS;
var isIOS = useragent.isIOS;
var valueResetRegex = isIOS ? /\s/ : /\n/;
var isMobile = useragent.isMobile;

var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    parentNode.insertBefore(text, parentNode.firstChild);

    var copied = false;
    var pasted = false;
    var inComposition = false;
    var sendingText = false;
    var tempStyle = '';
    
    if (!isMobile)
        text.style.fontSize = "1px";

    var commandMode = false;
    var ignoreFocusEvents = false;
    
    var lastValue = "";
    var lastSelectionStart = 0;
    var lastSelectionEnd = 0;
    var lastRestoreEnd = 0;
    try { var isFocused = document.activeElement === text; } catch(e) {}
    
    event.addListener(text, "blur", function(e) {
        if (ignoreFocusEvents) return;
        host.onBlur(e);
        isFocused = false;
    }, host);
    event.addListener(text, "focus", function(e) {
        if (ignoreFocusEvents) return;
        isFocused = true;
        if (useragent.isEdge) {
            try {
                if (!document.hasFocus())
                    return;
            } catch(e) {}
        }
        host.onFocus(e);
        if (useragent.isEdge)
            setTimeout(resetSelection);
        else
            resetSelection();
    }, host);
    this.$focusScroll = false;
    this.focus = function() {
        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });

        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "0px";
        try {
            var isTransformed = text.getBoundingClientRect().top != 0;
        } catch(e) {
            return;
        }
        var ancestors = [];
        if (isTransformed) {
            var t = text.parentElement;
            while (t && t.nodeType == 1) {
                ancestors.push(t);
                t.setAttribute("ace_nocontext", true);
                if (!t.parentElement && t.getRootNode)
                    t = t.getRootNode().host;
                else
                    t = t.parentElement;
            }
        }
        text.focus({ preventScroll: true });
        if (isTransformed) {
            ancestors.forEach(function(p) {
                p.removeAttribute("ace_nocontext");
            });
        }
        setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
                text.style.top = top;
        }, 0);
    };
    this.blur = function() {
        text.blur();
    };
    this.isFocused = function() {
        return isFocused;
    };
    
    host.on("beforeEndOperation", function() {
        var curOp = host.curOp;
        var commandName = curOp && curOp.command && curOp.command.name;
        if (commandName == "insertstring")
            return;
        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
        if (inComposition && isUserAction) {
            lastValue = text.value = "";
            onCompositionEnd();
        }
        resetSelection();
    });
    
    var resetSelection = isIOS
    ? function(value) {
        if (!isFocused || (copied && !value) || sendingText) return;
        if (!value) 
            value = "";
        var newValue = "\n ab" + value + "cde fg\n";
        if (newValue != text.value)
            text.value = lastValue = newValue;
        
        var selectionStart = 4;
        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));

        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
            text.setSelectionRange(selectionStart, selectionEnd);
        }
        lastSelectionStart = selectionStart;
        lastSelectionEnd = selectionEnd;
    }
    : function() {
        if (inComposition || sendingText)
            return;
        if (!isFocused && !afterContextMenu)
            return;
        inComposition = true;
        
        var selectionStart = 0;
        var selectionEnd = 0;
        var line = "";

        if (host.session) {
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            selectionStart = range.start.column;
            selectionEnd = range.end.column;
            line = host.session.getLine(row);

            if (range.start.row != row) {
                var prevLine = host.session.getLine(row - 1);
                selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                selectionEnd += prevLine.length + 1;
                line = prevLine + "\n" + line;
            }
            else if (range.end.row != row) {
                var nextLine = host.session.getLine(row + 1);
                selectionEnd = range.end.row > row  + 1 ? nextLine.length : selectionEnd;
                selectionEnd += line.length + 1;
                line = line + "\n" + nextLine;
            }
            else if (isMobile && row > 0) {
                line = "\n" + line;
                selectionEnd += 1;
                selectionStart += 1;
            }

            if (line.length > MAX_LINE_LENGTH) {
                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                    line = line.slice(0, MAX_LINE_LENGTH);
                } else {
                    line = "\n";
                    selectionStart = 0;
                    selectionEnd = 1;
                }
            }
        }

        var newValue = line + "\n\n";
        if (newValue != lastValue) {
            text.value = lastValue = newValue;
            lastSelectionStart = lastSelectionEnd = newValue.length;
        }
        if (afterContextMenu) {
            lastSelectionStart = text.selectionStart;
            lastSelectionEnd = text.selectionEnd;
        }
        if (
            lastSelectionEnd != selectionEnd 
            || lastSelectionStart != selectionStart 
            || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
        ) {
            try {
                text.setSelectionRange(selectionStart, selectionEnd);
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
            } catch(e){}
        }
        inComposition = false;
    };
    this.resetSelection = resetSelection;

    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length
            && text.value === lastValue && lastValue
            && text.selectionEnd !== lastSelectionEnd;
    };

    var onSelect = function(e) {
        if (inComposition)
            return;
        if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb;};
    this.getInputHandler = function() {return inputHandler;};
    var afterContextMenu = false;
    
    var sendText = function(value, fromInput) {
        if (afterContextMenu)
            afterContextMenu = false;
        if (pasted) {
            resetSelection();
            if (value)
                host.onPaste(value);
            pasted = false;
            return "";
        } else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
        
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
        
            var i = 0;
            while (extendLeft > 0 && lastValue[i] == value[i]) {
                i++;
                extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {
                i++;
                extendRight--;
            }
            restoreStart -= i-1;
            restoreEnd -= i-1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
                extendLeft = -endIndex;
                endIndex = 0;
            } 
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                return "";
            sendingText = true;
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                host.onTextInput(inserted);
            } else {
                host.onTextInput(inserted, {
                    extendLeft: extendLeft,
                    extendRight: extendRight,
                    restoreStart: restoreStart,
                    restoreEnd: restoreEnd
                });
            }
            sendingText = false;
            
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return inserted;
        }
    };
    var onInput = function(e) {
        if (inComposition)
            return onCompositionUpdate();
        if (e && e.inputType) {
            if (e.inputType == "historyUndo") return host.execCommand("undo");
            if (e.inputType == "historyRedo") return host.execCommand("redo");
        }
        var data = text.value;
        var inserted = sendText(data, true);
        if (
            data.length > MAX_LINE_LENGTH + 100 
            || valueResetRegex.test(inserted)
            || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd
        ) {
            resetSelection();
        }
    };
    
    var handleClipboardData = function(e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                return clipboardData.setData(mime, data) !== false;
            } else {
                return clipboardData.getData(mime);
            }
        } catch(e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            if (isIOS) {
                resetSelection(data);
                copied = data;
                setTimeout(function () {
                    copied = false;
                }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    
    var onCut = function(e) {
        doCopy(e, true);
    };
    
    var onCopy = function(e) {
        doCopy(e, false);
    };
    
    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (clipboard.pasteCancelled())
            return;
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);

    event.addListener(text, "select", onSelect, host);
    event.addListener(text, "input", onInput, host);

    event.addListener(text, "cut", onCut, host);
    event.addListener(text, "copy", onCopy, host);
    event.addListener(text, "paste", onPaste, host);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        }, host);
    }
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly) 
            return;
        
        inComposition = {};

        if (commandMode)
            return;
        
        if (e.data)
            inComposition.useTextareaForIME = false;
        
        setTimeout(onCompositionUpdate, 0);
        host._signal("compositionStart");
        host.on("mousedown", cancelComposition);
        
        var range = host.getSelectionRange();
        range.end.row = range.start.row;
        range.end.column = range.start.column;
        inComposition.markerRange = range;
        inComposition.selectionStart = lastSelectionStart;
        host.onCompositionStart(inComposition);
        
        if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
        }
        else {
            if (text.msGetInputContext)
                inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
                inComposition.context = text.getInputContext();
        }
    };

    var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        if (commandMode)
            return cancelComposition();
        
        if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
        }
        else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
                if (inComposition.context) {
                    inComposition.markerRange.start.column = inComposition.selectionStart
                        = inComposition.context.compositionStartOffset;
                }
                inComposition.markerRange.end.column = inComposition.markerRange.start.column
                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        inComposition = false;
        host.onCompositionEnd();
        host.off("mousedown", cancelComposition);
        if (e) onInput();
    };
    

    function cancelComposition() {
        ignoreFocusEvents = true;
        text.blur();
        text.focus();
        ignoreFocusEvents = false;
    }

    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
    
    function onKeyup(e) {
        if (e.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
                lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
        }
        syncComposition();
    }

    event.addListener(text, "compositionstart", onCompositionStart, host);
    event.addListener(text, "compositionupdate", onCompositionUpdate, host);
    event.addListener(text, "keyup", onKeyup, host);
    event.addListener(text, "keydown", syncComposition, host);
    event.addListener(text, "compositionend", onCompositionEnd, host);

    this.getElement = function() {
        return text;
    };
    this.setCommandMode = function(value) {
       commandMode = value;
       text.readOnly = false;
    };
    
    this.setReadOnly = function(readOnly) {
        if (!commandMode)
            text.readOnly = readOnly;
    };

    this.setCopyWithEmptySelection = function(value) {
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection();
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };
    
    this.moveToMouse = function(e, bringToFront) {
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + (useragent.isIE ? "opacity:0.1;" : "")
            + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
        }; 
        move(e);

        if (e.type != "mousedown")
            return;

        host.renderer.$isMousePressed = true;

        clearTimeout(closeTimeout);
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
                host.renderer.$moveTextAreaToCursor();
        }, 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu, host);
    event.addListener(text, "mousedown", function(e) {
        e.preventDefault();
        onContextMenuClose();
    }, host);
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
    event.addListener(text, "contextmenu", onContextMenu, host);
    
    if (isIOS)
        addIosSelectionHandler(parentNode, host, text);

    function addIosSelectionHandler(parentNode, host, text) {
        var typingResetTimeout = null;
        var typing = false;
 
        text.addEventListener("keydown", function (e) {
            if (typingResetTimeout) clearTimeout(typingResetTimeout);
            typing = true;
        }, true);

        text.addEventListener("keyup", function (e) {
            typingResetTimeout = setTimeout(function () {
                typing = false;
            }, 100);
        }, true);
        var detectArrowKeys = function(e) {
            if (document.activeElement !== text) return;
            if (typing || inComposition || host.$mouseHandler.isMousePressed) return;

            if (copied) {
                return;
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
                key = KEYS.up;
            } else if (selectionStart == 1) {
                key = KEYS.home;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                key = KEYS.end;
            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                key = KEYS.left;
                modifier = MODS.option;
            } else if (
                selectionStart < lastSelectionStart
                || (
                    selectionStart == lastSelectionStart 
                    && lastSelectionEnd != lastSelectionStart
                    && selectionStart == selectionEnd
                )
            ) {
                key = KEYS.left;
            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                key = KEYS.down;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                key = KEYS.right;
                modifier = MODS.option;
            } else if (
                selectionEnd > lastSelectionEnd
                || (
                    selectionEnd == lastSelectionEnd 
                    && lastSelectionEnd != lastSelectionStart
                    && selectionStart == selectionEnd
                )
            ) {
                key = KEYS.right;
            }
            
            if (selectionStart !== selectionEnd)
                modifier |= MODS.shift;

            if (key) {
                var result = host.onCommandKey({}, modifier, key);
                if (!result && host.commands) {
                    key = KEYS.keyCodeToString(key);
                    var command = host.commands.findKeyCommand(modifier, key);
                    if (command)
                        host.execCommand(command);
                }
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                resetSelection("");
            }
        };
        document.addEventListener("selectionchange", detectArrowKeys);
        host.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
        });
    }
};

exports.TextInput = TextInput;
exports.$setUserAgentForTests = function(_isMobile, _isIOS) {
    isMobile = _isMobile;
    isIOS = _isIOS;
};
});

define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var useragent = require("../lib/useragent");

var DRAG_OFFSET = 0; // pixels
var SCROLL_COOLDOWN_T = 550; // milliseconds

function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}

(function() {

    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                    ev.preventDefault();
            }
            return;
        }

        this.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    };

    this.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        if (!this.mousedownEvent) return;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
    };

    this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
    this.selectAllEnd =
    this.selectByWordsEnd =
    this.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    };

    this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    };

    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };

    this.onQuadClick = function(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
        if (ev.getAccelKey())
            return;
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }
        
        var editor = this.editor;
        
        if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
        
        var prevScroll = this.$lastScroll;
        var t = ev.domEvent.timeStamp;
        var dt = t - prevScroll.t;
        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
        if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
        }
        
        var direction = Math.abs(vx / vy);
        
        var canScroll = false;
        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;
            
        if (canScroll) {
            prevScroll.allowed = t;
        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
            if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
            }
            else {
                prevScroll.allowed = 0;
            }
        }
        
        prevScroll.t = t;
        prevScroll.vx = vx;
        prevScroll.vy = vy;

        if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}

});

define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
function Tooltip (parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}

(function() {
    this.$init = function() {
        this.$element = dom.createElement("div");
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };
    this.getElement = function() {
        return this.$element || this.$init();
    };
    this.setText = function(text) {
        this.getElement().textContent = text;
    };
    this.setHtml = function(html) {
        this.getElement().innerHTML = html;
    };
    this.setPosition = function(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    };
    this.setClassName = function(className) {
        dom.addCssClass(this.getElement(), className);
    };
    this.show = function(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    };

    this.hide = function() {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
        }
    };
    this.getHeight = function() {
        return this.getElement().offsetHeight;
    };
    this.getWidth = function() {
        return this.getElement().offsetWidth;
    };
    
    this.destroy = function() {
        this.isOpen = false;
        if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
        }
    };

}).call(Tooltip.prototype);

exports.Tooltip = Tooltip;
});

define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(require, exports, module) {
"use strict";
var dom = require("../lib/dom");
var oop = require("../lib/oop");
var event = require("../lib/event");
var Tooltip = require("../tooltip").Tooltip;

function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltipAnnotation;

    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");

        tooltip.setHtml(tooltipAnnotation);
        tooltip.show();
        editor._signal("showGutterTooltip", tooltip);
        editor.on("mousewheel", hideTooltip);

        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        } else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
        }
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor._signal("hideGutterTooltip", tooltip);
            editor.off("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    }, editor);
    
    editor.on("changeSession", hideTooltip);
}

function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}

oop.inherits(GutterTooltip, Tooltip);

(function(){
    this.setPosition = function(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };

}).call(GutterTooltip.prototype);



exports.GutterHandler = GutterHandler;

});

define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;
    
    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {  
    
    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    
    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    
    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    };
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };
    
    this.getAccelKey = useragent.isMac
        ? function() { return this.domEvent.metaKey; }
        : function() { return this.domEvent.ctrlKey; };
    
}).call(MouseEvent.prototype);

});

define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

     exports.forEach(function(x) {
         mouseHandler[x] = this[x];
    }, this);
    editor.on("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
        }
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };

    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };

    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };

    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.selection.fromOrientedRange(range);
        if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

(function() {

    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.DragdropHandler = DragdropHandler;

});

define("ace/mouse/touch_handler",["require","exports","module","ace/mouse/mouse_event","ace/lib/event","ace/lib/dom"], function(require, exports, module) {
"use strict";

var MouseEvent = require("./mouse_event").MouseEvent;
var event = require("../lib/event");
var dom = require("../lib/dom");

exports.addTouchListeners = function(el, editor) {
    var mode = "scroll";
    var startX;
    var startY;
    var touchStartT;
    var lastT;
    var longTouchTimer;
    var animationTimer;
    var animationSteps = 0;
    var pos;
    var clickCount = 0;
    var vX = 0;
    var vY = 0;
    var pressed;
    var contextMenu;
    
    function createContextMenu() {
        var clipboard = window.navigator && window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(
                dom.buildDom(isOpen ? ["span",
                    !selected && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
                    selected && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
                    selected && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
                    clipboard && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
                    hasUndo && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
                    ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
                    ["span", { class: "ace_mobile-button", action: "openCommandPallete" }, "Pallete"]
                ] : ["span"]),
                contextMenu.firstChild
            );
        };
        var handleClick = function(e) {
            var action = e.target.getAttribute("action");

            if (action == "more" || !isOpen) {
                isOpen = !isOpen;
                return updateMenu();
            }
            if (action == "paste") {
                clipboard.readText().then(function (text) {
                    editor.execCommand(action, text);
                });
            }
            else if (action) {
                if (action == "cut" || action == "copy") {
                    if (clipboard)
                        clipboard.writeText(editor.getCopyText());
                    else
                        document.execCommand("copy");
                }
                editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPallete")
                editor.focus();
        };
        contextMenu = dom.buildDom(["div",
            {
                class: "ace_mobile-menu",
                ontouchstart: function(e) {
                    mode = "menu";
                    e.stopPropagation();
                    e.preventDefault();
                    editor.textInput.focus();
                },
                ontouchend: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    handleClick(e);
                },
                onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
        ], editor.container);
    }
    function showContextMenu() {
        if (!contextMenu) createContextMenu();
        var cursor = editor.selection.cursor;
        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var rect = editor.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
        contextMenu.style.right = "10px";
        contextMenu.style.display = "";
        contextMenu.firstChild.style.display = "none";
        editor.on("input", hideContextMenu);
    }
    function hideContextMenu(e) {
        if (contextMenu)
            contextMenu.style.display = "none";
        editor.off("input", hideContextMenu);
    }

    function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
        }
        mode = "wait";
        showContextMenu();
    }
    function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor.selection.moveToPosition(pos);
        var range = clickCount >= 2
            ? editor.selection.getLineRange(pos.row)
            : editor.session.getBracketRange(pos);
        if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
        } else {
            editor.selection.selectWord();
        }
        mode = "wait";
    }
    event.addListener(el, "contextmenu", function(e) {
        if (!pressed) return;
        var textarea = editor.textInput.getElement();
        textarea.focus();
    }, editor);
    event.addListener(el, "touchstart", function (e) {
        var touches = e.touches;
        if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
        }
        
        pressed = editor.$mouseHandler.isMousePressed = true;
        var h = editor.renderer.layerConfig.lineHeight;
        var w = editor.renderer.layerConfig.lineHeight;
        var t = e.timeStamp;
        lastT = t;
        var touchObj = touches[0];
        var x = touchObj.clientX;
        var y = touchObj.clientY;
        if (Math.abs(startX - x) + Math.abs(startY - y) > h)
            touchStartT = -1;
        
        startX = e.clientX = x;
        startY = e.clientY = y;
        vX = vY = 0;
        
        var ev = new MouseEvent(e, editor);
        pos = ev.getDocumentPosition();

        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
        } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var weightedDistance = function(x, y) {
                x = x / w;
                y = y / h - 0.75;
                return x * x + y * y;
            };
            
            if (e.clientX < rect.left) {
                mode = "zoom";
                return;
            }
            
            var diff1 = weightedDistance(
                e.clientX - rect.left - cursorPos.left,
                e.clientY - rect.top - cursorPos.top
            );
            var diff2 = weightedDistance(
                e.clientX - rect.left - anchorPos.left,
                e.clientY - rect.top - anchorPos.top
            );
            if (diff1 < 3.5 && diff2 < 3.5)
                mode = diff1 > diff2 ? "cursor" : "anchor";
                
            if (diff2 < 3.5)
                mode = "anchor";
            else if (diff1 < 3.5)
                mode = "cursor";
            else
                mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t;
    }, editor);

    event.addListener(el, "touchend", function (e) {
        pressed = editor.$mouseHandler.isMousePressed = false;
        if (animationTimer) clearInterval(animationTimer);
        if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
        } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
        } else if (mode == "scroll") {
            animate();
            hideContextMenu();
        } else {
            showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
    }, editor);
    event.addListener(el, "touchmove", function (e) {
        if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }
        var touches = e.touches;
        if (touches.length > 1 || mode == "zoom") return;

        var touchObj = touches[0];

        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;

        if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
                mode = "cursor";
            else
                return e.preventDefault();
        }

        startX = touchObj.clientX;
        startY = touchObj.clientY;

        e.clientX = touchObj.clientX;
        e.clientY = touchObj.clientY;

        var t = e.timeStamp;
        var dt = t - lastT;
        lastT = t;
        if (mode == "scroll") {
            var mouseEvent = new MouseEvent(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
            if (dt != 0) {
                vX = wheelX / dt;
                vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
                vX = vY = 0;
            }
        }
        else {
            var ev = new MouseEvent(e, editor);
            var pos = ev.getDocumentPosition();
            if (mode == "cursor")
                editor.selection.moveCursorToPosition(pos);
            else if (mode == "anchor")
                editor.selection.setSelectionAnchor(pos.row, pos.column);
            editor.renderer.scrollCursorIntoView(pos);
            e.preventDefault();
        }
    }, editor);

    function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
                clearInterval(animationTimer);
                animationTimer = null;
            }
            if (Math.abs(vX) < 0.01) vX = 0;
            if (Math.abs(vY) < 0.01) vY = 0;
            if (animationSteps < 20) vX = 0.9 * vX;
            if (animationSteps < 20) vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
                animationSteps = 0;
        }, 10);
    }
};

});

define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";
var dom = require("./dom");

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
};

});

define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        return new Promise(function(resolve) {
            callback = resolve;
        });
    }
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;
};

exports.EventEmitter = EventEmitter;

});

define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
"no use strict";

var oop = require("./oop");
var EventEmitter = require("./event_emitter").EventEmitter;

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
                return !options[key].hidden;
            });
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
}

var AppConfig = function() {
    this.$defaultOptions = {};
};

(function() {
    oop.implement(this, EventEmitter);
    this.defineOptions = function(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);

        return this;
    };

    this.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    };

    this.setDefaultValue = function(path, name, value) {
        if (!path) {
            for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                    break;
            if (!this.$defaultOptions[path][name])
                return false;
        }
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };

    this.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };
    
    this.warn = warn;
    this.reportError = reportError;
    
}).call(AppConfig.prototype);

exports.AppConfig = AppConfig;

});

define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(require, exports, module) {
"no use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var net = require("./lib/net");
var AppConfig = require("./lib/app_config").AppConfig;

module.exports = exports = new AppConfig();

var global = (function() {
    return this || typeof window != "undefined" && window;
})();

var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {},
    loadWorkerFromBlob: true,
    sharedPopups: false
};

exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    return options[key];
};

exports.set = function(key, value) {
    if (options.hasOwnProperty(key))
        options[key] = value;
    else if (this.setDefaultValue("", key, value) == false)
        throw new Error("Unknown config key: " + key);
};

exports.all = function() {
    return lang.copyObject(options);
};

exports.$modes = {};
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};

exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

exports.$loading = {};
exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }

    try {
        module = require(moduleName);
    } catch (e) {}
    if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
        return;

    var afterLoad = function() {
        require([moduleName], function(module) {
            exports._emit("load.module", {name: moduleName, module: module});
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
                onLoad && onLoad(module);
            });
        });
    };

    if (!exports.get("packaged"))
        return afterLoad();
    
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
    reportErrorIfPathIsNotConfigured();
};

var reportErrorIfPathIsNotConfigured = function() {
    if (
        !options.basePath && !options.workerPath 
        && !options.modePath && !options.themePath
        && !Object.keys(options.$moduleUrls).length
    ) {
        console.error(
            "Unable to infer path to ace from script src,",
            "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes",
            "or with webpack use ace/webpack-resolver"
        );
        reportErrorIfPathIsNotConfigured = function() {};
    }
};
init(true);function init(packaged) {

    if (!global || !global.document)
        return;
    
    options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);

    var scriptOptions = {};
    var scriptUrl = "";
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;
    
    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
}

exports.init = init;

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}

exports.version = "1.4.10";

});

define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/mouse/touch_handler","ace/config"], function(require, exports, module) {
"use strict";

var event = require("../lib/event");
var useragent = require("../lib/useragent");
var DefaultHandlers = require("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
var MouseEvent = require("./mouse_event").MouseEvent;
var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
var addTouchListeners = require("./touch_handler").addTouchListeners;
var config = require("../config");

var MouseHandler = function(editor) {
    var _self = this;
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var focusEditor = function(e) {
        var windowBlurred = !document.hasFocus || !document.hasFocus()
            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
        if (windowBlurred)
            window.focus();
        editor.focus();
    };

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
    event.addMultiMouseDownListener([
        mouseTarget,
        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
        editor.textInput && editor.textInput.getElement()
    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
    addTouchListeners(editor.container, editor);

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);

    event.addListener(mouseTarget, "mousedown", focusEditor, editor);
    event.addListener(gutterEl, "mousedown", focusEditor, editor);
    if (useragent.isIE && editor.renderer.scrollBarV) {
        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
    }

    editor.on("mousemove", function(e){
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;

        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;

        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
        } else {
            renderer.setCursorStyle("");
        }
    }, editor);
};

(function() {
    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    };
    
    this.setState = function(state) {
        this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;
        var editor = this.editor;
        var renderer = this.editor.renderer;
        renderer.$isMousePressed = true;

        var self = this;
        var onMouseMove = function(e) {
            if (!e) return;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            editor.off("beforeEndOperation", onOperationEnd);
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            self.isMousePressed = renderer.$isMousePressed = false;
            if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
            editor.endOperation();
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        var onOperationEnd = function(e) {
            if (!self.releaseMouse) return;
            if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self[self.state + "End"] && self[self.state + "End"]();
                self.state = "";
                self.releaseMouse();
            }
        };

        editor.on("beforeEndOperation", onOperationEnd);
        editor.startOperation({command: {name: "mouse"}});

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };
}).call(MouseHandler.prototype);

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimeout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
});


exports.MouseHandler = MouseHandler;
});

define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";
var dom = require("../lib/dom");

function FoldHandler(editor) {

    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);

            e.stop();
        }
        
        var target = e.domEvent && e.domEvent.target;
        if (target && dom.hasCssClass(target, "ace_inline_button")) {
            if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                session.setOption("wrap", !session.getUseWrapMode());
                editor.renderer.scrollCursorIntoView();
            }
        }
    });

    editor.on("gutterclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });

    editor.on("gutterdblclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;

            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                if (fold) {
                    session.removeFold(fold);
                } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                }
            }
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});

define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module) {
"use strict";

var keyUtil  = require("../lib/keys");
var event = require("../lib/event");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = {editor: editor};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};

(function() {
    this.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };

    this.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
        if (!kb)
            return;
        if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };
    
    this.getStatusText = function() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    };

    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == "null") {
                success = true;
            } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 && 
                toExecute.passEvent != true && toExecute.command.passEvent != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        
        if (!success && hashId == -1) {
            toExecute = {command: "insertstring"};
            success = commands.exec("insertstring", this.$editor, keyString);
        }
        
        if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);
        
        return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
        return this.$callKeyboardHandlers(-1, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});

define("ace/lib/bidiutil",["require","exports","module"], function(require, exports, module) {
"use strict";

var ArabicAlefBetIntervalsBegine = ['\u0621', '\u0641'];
var ArabicAlefBetIntervalsEnd = ['\u063A', '\u064a'];
var dir = 0, hiLevel = 0;
var lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;

var impTab_LTR = [	[	0,		3,		0,		1,		0,		0,		0	],	[	0,		3,		0,		1,		2,		2,		0	],	[	0,		3,		0,		0x11,		2,		0,		1	],	[	0,		3,		5,		5,		4,		1,		0	],	[	0,		3,		0x15,		0x15,		4,		0,		1	],	[	0,		3,		5,		5,		4,		2,		0	]
];

var impTab_RTL = [	[	2,		0,		1,		1,		0,		1,		0	],	[	2,		0,		1,		1,		0,		2,		0	],	[	2,		0,		2,		1,		3,		2,		0	],	[	2,		0,		2,		0x21,		3,		1,		1	]
];

var LTR = 0, RTL = 1;

var L = 0;
var R = 1;
var EN = 2;
var AN = 3;
var ON = 4;
var B = 5;
var S = 6;
var AL = 7;
var WS = 8;
var CS = 9;
var ES = 10;
var ET = 11;
var NSM = 12;
var LRE = 13;
var RLE = 14;
var PDF = 15;
var LRO = 16;
var RLO = 17;
var BN = 18;

var UnicodeTBL00 = [
BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
];

var UnicodeTBL20 = [
WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
];

function _computeLevels(chars, levels, len, charTypes) {
	var impTab = dir ? impTab_RTL : impTab_LTR
		, prevState = null, newClass = null, newLevel = null, newState = 0
		, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];

	if (!charTypes) {
		for (i = 0, charTypes = []; i < len; i++) {
			charTypes[i] = _getCharacterType(chars[i]);
		}
	}
	hiLevel = dir;
	lastArabic = false;
	hasUBAT_AL = false;
	hasUBAT_B = false;
	hasUBAT_S = false;
	for (ix = 0; ix < len; ix++){
		prevState = newState;
		classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
		newState = impTab[prevState][newClass];
		action = newState & 0xF0;
		newState &= 0x0F;
		levels[ix] = newLevel = impTab[newState][5];
		if (action > 0){
			if (action == 0x10){
				for(i = condPos; i < ix; i++){
					levels[i] = 1;
				}
				condPos = -1;
			} else {
				condPos = -1;
			}
		}
		cond = impTab[newState][6];
		if (cond){
			if(condPos == -1){
				condPos = ix;
			}
		}else{
			if (condPos > -1){
				for(i = condPos; i < ix; i++){
					levels[i] = newLevel;
				}
				condPos = -1;
			}
		}
		if (charTypes[ix] == B){
			levels[ix] = 0;
		}
		hiLevel |= newLevel;
	}
	if (hasUBAT_S){
		for(i = 0; i < len; i++){
			if(charTypes[i] == S){
				levels[i] = dir;
				for(var j = i - 1; j >= 0; j--){
					if(charTypes[j] == WS){
						levels[j] = dir;
					}else{
						break;
					}
				}
			}
		}
	}
}

function _invertLevel(lev, levels, _array) {
	if (hiLevel < lev){
		return;
	}
	if (lev == 1 && dir == RTL && !hasUBAT_B){
		_array.reverse();
		return;
	}
	var len = _array.length, start = 0, end, lo, hi, tmp;
	while(start < len){
		if (levels[start] >= lev){
			end = start + 1;
		while(end < len && levels[end] >= lev){
			end++;
		}
		for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
			tmp = _array[lo];
			_array[lo] = _array[hi];
			_array[hi] = tmp;
		}
		start = end;
	}
	start++;
	}
}

function _getCharClass(chars, types, classes, ix) {			
	var cType = types[ix], wType, nType, len, i;
	switch(cType){
		case L:
		case R:
			lastArabic = false;
		case ON:
		case AN:
			return cType;
		case EN:
			return lastArabic ? AN : EN;
		case AL:
			lastArabic = true;
			hasUBAT_AL = true;
			return R;
		case WS:
			return ON;
		case CS:
			if (ix < 1 || (ix + 1) >= types.length ||
				((wType = classes[ix - 1]) != EN && wType != AN) ||
				((nType = types[ix + 1]) != EN && nType != AN)){
				return ON;
			}
			if (lastArabic){nType = AN;}
			return nType == wType ? nType : ON;
		case ES:
			wType = ix > 0 ? classes[ix - 1] : B;
			if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
				return EN;
			}
			return ON;
		case ET:
			if (ix > 0 && classes[ix - 1] == EN){
				return EN;
			}
			if (lastArabic){
				return ON;
			}
			i = ix + 1;
			len = types.length;
			while (i < len && types[i] == ET){
				i++;
			}
			if (i < len && types[i] == EN){
				return EN;
			}
			return ON;
		case NSM:
			len = types.length;
			i = ix + 1;
			while (i < len && types[i] == NSM){
				i++;
			}
			if (i < len){
				var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
				
				wType = types[i];
				if (rtlCandidate && (wType == R || wType == AL)){
					return R;
				}
			}

			if (ix < 1 || (wType = types[ix - 1]) == B){
				return ON;
			}
			return classes[ix - 1];
		case B:
			lastArabic = false;
			hasUBAT_B = true;
			return dir;
		case S:
			hasUBAT_S = true;
			return ON;
		case LRE:
		case RLE:
		case LRO:
		case RLO:
		case PDF:
			lastArabic = false;
		case BN:
			return ON;
	}
}

function _getCharacterType( ch ) {		
	var uc = ch.charCodeAt(0), hi = uc >> 8;
	
	if (hi == 0) {		
		return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
	} else if (hi == 5) {
		return (/[\u0591-\u05f4]/.test(ch) ? R : L);
	} else if (hi == 6) {
		if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
			return NSM;
		else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
			return AN;
		else if (uc == 0x066A)
			return ET;
		else if (/[\u06f0-\u06f9]/.test(ch))
			return EN;			
		else
			return AL;
	} else if (hi == 0x20 && uc <= 0x205F) {
		return UnicodeTBL20[uc & 0xFF];
	} else if (hi == 0xFE) {
		return (uc >= 0xFE70 ? AL : ON);
	}		
	return ON;	
}

function _isArabicDiacritics( ch ) {
	return (ch >= '\u064b' && ch <= '\u0655');
}
exports.L = L;
exports.R = R;
exports.EN = EN;
exports.ON_R = 3;
exports.AN = 4;
exports.R_H = 5;
exports.B = 6;
exports.RLE = 7;

exports.DOT = "\xB7";
exports.doBidiReorder = function(text, textCharTypes, isRtl) {
	if (text.length < 2)
		return {};
		
	var chars = text.split(""), logicalFromVisual = new Array(chars.length),
		bidiLevels = new Array(chars.length), levels = []; 

	dir = isRtl ? RTL : LTR;

	_computeLevels(chars, levels, chars.length, textCharTypes);

	for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);

	_invertLevel(2, levels, logicalFromVisual);
	_invertLevel(1, levels, logicalFromVisual);

	for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
		if (textCharTypes[i] === AN) {
			levels[i] = exports.AN;
		} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) 
			|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
			levels[i] = exports.ON_R;
		} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
			levels[i - 1] = levels[i] = exports.R_H;
			i++;
		}
	}
	if (chars[chars.length - 1] === exports.DOT)
		levels[chars.length - 1] = exports.B;
				
	if (chars[0] === '\u202B')
		levels[0] = exports.RLE;
				
	for (var i = 0; i < logicalFromVisual.length; i++) {
		bidiLevels[i] = levels[logicalFromVisual[i]];
	}

	return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
};
exports.hasBidiCharacters = function(text, textCharTypes){
	var ret = false;
	for (var i = 0; i < text.length; i++){
		textCharTypes[i] = _getCharacterType(text.charAt(i));
		if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
			ret = true;
	}
	return ret;
};	
exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
	for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
		if (rowMap.logicalFromVisual[i] == logIdx)
			return i;
	}
	return 0;
};

});

define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"], function(require, exports, module) {
"use strict";

var bidiUtil = require("./lib/bidiutil");
var lang = require("./lib/lang");
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
var BidiHandler = function(session) {
    this.session = session;
    this.bidiMap = {};
    this.currentRow = null;
    this.bidiUtil = bidiUtil;
    this.charWidths = [];
    this.EOL = "\xAC";
    this.showInvisibles = true;
    this.isRtlDir = false;
    this.$isRtl = false;
    this.line = "";
    this.wrapIndent = 0;
    this.EOF = "\xB6";
    this.RLE = "\u202B";
    this.contentWidth = 0;
    this.fontMetrics = null;
    this.rtlLineOffset = 0;
    this.wrapOffset = 0;
    this.isMoveLeftOperation = false;
    this.seenBidi = bidiRE.test(session.getValue());
};

(function() {
    this.isBidiRow = function(screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
            return false;
        if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
    };

    this.onChange = function(delta) {
        if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
            }
        } 
        else {
            this.currentRow = null;
        }
    };

    this.getDocumentRow = function() {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index >= 0)
                docRow = this.session.$docRowCache[index];
        }

        return docRow;
    };

    this.getSplitIndex = function() {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                    break;

                prevIndex = currentIndex;
                splitIndex++;
            }
        } else {
            splitIndex = this.currentRow;
        }

        return splitIndex;
    };

    this.updateRowLine = function(docRow, splitIndex) {
        if (docRow === undefined)
            docRow = this.getDocumentRow();
            
        var isLastRow = (docRow === this.session.getLength() - 1),
            endOfLine = isLastRow ? this.EOF : this.EOL;

        this.wrapIndent = 0;
        this.line = this.session.getLine(docRow);
        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
        if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
                if (splitIndex === undefined)
                    splitIndex = this.getSplitIndex();

                if(splitIndex > 0 && splits.length) {
                    this.wrapIndent = splits.indent;
                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                    this.line = (splitIndex < splits.length) ?
                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                            this.line.substring(splits[splits.length - 1]);
                } else {
                    this.line = this.line.substring(0, splits[splitIndex]);
                }
            }
            if (splitIndex == splits.length)
                this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
        } else {
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        }
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
        });

        if (this.isRtlDir) {
            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
        }
    };
    
    this.updateBidiMap = function() {
        var textCharTypes = [];
        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
        } else {
            this.bidiMap = {};
        }
    };
    this.markAsDirty = function() {
        this.currentRow = null;
    };
    this.updateCharacterWidths = function(fontMetrics) {
        if (this.characterWidth === fontMetrics.$characterSize.width)
            return;

        this.fontMetrics = fontMetrics;
        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");

        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;

        this.currentRow = null;
    };

    this.setShowInvisibles = function(showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
    };

    this.setEolChar = function(eolChar) {
        this.EOL = eolChar; 
    };

    this.setContentWidth = function(width) {
        this.contentWidth = width;
    };

    this.isRtlLine = function(row) {
        if (this.$isRtl) return true;
        if (row != undefined)
            return (this.session.getLine(row).charAt(0) == this.RLE);
        else
            return this.isRtlDir; 
    };

    this.setRtlDirection = function(editor, isRtlDir) {
        var cursor = editor.getCursorPosition(); 
        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);
        }
    };
    this.getPosLeft = function(col) {
        col -= this.wrapIndent;
        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),
            levels = this.bidiMap.bidiLevels, left = 0;

        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
            visualIdx++;
            
        for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
        }

        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
            left += this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        if (this.isRtlDir)
            left += this.rtlLineOffset;

        return left;
    };
    this.getSelections = function(startCol, endCol) {
        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,
            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
                isSelected = false, isSelectedPrev = false, selectionStart = 0;
            
        if (this.wrapIndent)
            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;

        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
            if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
            } else if (!isSelected && isSelectedPrev) {
                selections.push({left: selectionStart, width: offset - selectionStart});
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
        }

        if (isSelected && (visIdx === levels.length)) {
            selections.push({left: selectionStart, width: offset - selectionStart});
        }

        if(this.isRtlDir) {
            for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
            }
        }
        return selections;
    };
    this.offsetToCol = function(posX) {
        if(this.isRtlDir)
            posX -= this.rtlLineOffset;

        var logicalIdx = 0, posX = Math.max(posX, 0),
            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
                charWidth = this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
    
        while(posX > offset + charWidth/2) {
            offset += charWidth;
            if(visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
        }
    
        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
            if(posX < offset)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];

        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);

        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        } else {
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }

        if (logicalIdx === 0 && this.isRtlDir)
            logicalIdx++;

        return (logicalIdx + this.wrapIndent);
    };

}).call(BidiHandler.prototype);

exports.BidiHandler = BidiHandler;
});

define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.cursor = this.lead = this.doc.createAnchor(0, 0);
    this.anchor = this.doc.createAnchor(0, 0);
    this.$silent = false;

    var self = this;
    this.cursor.on("change", function(e) {
        self.$cursorChanged = true;
        if (!self.$silent)
            self._emit("changeCursor");
        if (!self.$isEmpty && !self.$silent)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.anchor.on("change", function() {
        self.$anchorChanged = true;
        if (!self.$isEmpty && !self.$silent)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);
    this.isEmpty = function() {
        return this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        );
    };
    this.isMultiLine = function() {
        return !this.$isEmpty && this.anchor.row != this.cursor.row;
    };
    this.getCursor = function() {
        return this.lead.getPosition();
    };
    this.setSelectionAnchor = function(row, column) {
        this.$isEmpty = false;
        this.anchor.setPosition(row, column);
    };
    this.getAnchor = 
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead();
        
        return this.anchor.getPosition();
    };
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.$isEmpty)
            return Range.fromPoints(lead, lead);

        return this.isBackwards()
            ? Range.fromPoints(lead, anchor)
            : Range.fromPoints(anchor, lead);
    };
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };
    this.selectAll = function() {
        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
    };
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        var start = reverse ? range.end : range.start;
        var end = reverse ? range.start : range.end;
        this.$setSelection(start.row, start.column, end.row, end.column);
    };

    this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
        if (this.$silent)
            return;
        var wasEmpty = this.$isEmpty;
        var wasMultiselect = this.inMultiSelectMode;
        this.$silent = true;
        this.$cursorChanged = this.$anchorChanged = false;
        this.anchor.setPosition(anchorRow, anchorColumn);
        this.cursor.setPosition(cursorRow, cursorColumn);
        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
        this.$silent = false;
        if (this.$cursorChanged)
            this._emit("changeCursor");
        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit("changeSelection");
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };
    this.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };
    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };
    this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;

        if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
        }
        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length-1 == tabSize;
    };
    this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
            } else {
                this.moveCursorBy(0, -1);
            }
        }
    };
    this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
            } else {
                this.moveCursorBy(0, 1);
            }
        }
    };
    this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }
        if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
        var index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    };

    this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        var offsetX;

        if (chars === 0) {
            if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
            }

            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }
        
        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows < 0)
                rows -= widget.rowsAbove || 0;
            else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
        }
        
        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
        
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
            else
                column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };
    this.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
        } catch(e) {
            return Range.fromPoints(start, start);
        } finally {
            this.moveCursorToPosition(start);
        }
    };

    this.toJSON = function() {
        if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };

    this.fromJSON = function(data) {
        if (data.start == undefined) {
            if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else {
                data = data[0];
            }
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});

define("ace/tokenizer",["require","exports","module","ace/config"], function(require, exports, module) {
"use strict";

var config = require("./config");
var MAX_TOKEN_COUNT = 2000;
var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";

        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
                flag = "gi";
            if (rule.regex == null)
                continue;

            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", { 
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }

            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;

            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
        }
        
        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
        }
        
        splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);

        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};

(function() {
    this.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    
    this.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    };

    this.$arrayTokens = function(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };

    this.removeCapturingGroups = function(src) {
        var r = src.replace(
            /\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    };

    this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack;
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        if (src.charAt(0) != "^") src = "^" + src;
        if (src.charAt(src.length - 1) != "$") src += "$";
        
        return new RegExp(src, (flag||"").replace("g", ""));
    };
    this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
            }
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack, line);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }
                    
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                    lastIndex = index;
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 500),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    };
    
    this.reportError = config.reportError;
    
}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});

define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");

var TextHighlightRules = function() {

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == "string") {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
    };

    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    rule = {};
                }
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == "string" ? rule : rule.include;
                if (includeName) {
                    if (Array.isArray(includeName))
                        toInsert = includeName.map(function(x) { return rules[x]; });
                    else
                        toInsert = rules[includeName];
                }

                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    i--;
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
                a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
                keywords[list[i]] = className;
        });
        if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }
            : function(value) {return keywords[value] || defaultToken; };
    };

    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});

define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module) {
"use strict";

var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    };
    
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    };
    
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    };
    
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    };
    
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    };

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});

define("ace/token_iterator",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("./range").Range;
var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() { 
    this.stepBackward = function() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };   
    this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentTokenRow = function () {
        return this.$row;
    };     
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    };
    this.getCurrentTokenPosition = function() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
    };
    this.getCurrentTokenRange = function() {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
    };
    
}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});

define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var defaultQuotes = {'"' : '"', "'" : "'"};

var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};

var CstyleBehaviour = function(options) {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) 
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                
                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;
                
                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                
                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair && /string\.end/.test(rightToken.type))
                        pair = false;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    var charBefore = line[cursor.column - 2];
                    if (leftChar == quote &&  (charBefore == quote || wordRe.test(charBefore)))
                        return null;
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;

        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};

    
CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};

CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

define("ace/unicode",["require","exports","module"], function(require, exports, module) {
"use strict";
var wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];

var code = 0;
var str = [];
for (var i = 0; i < wordChars.length; i += 2) {
    str.push(code += wordChars[i]);
    if (wordChars[i + 1])
        str.push(45, code += wordChars[i + 1]);
}

exports.wordChars = String.fromCharCode.apply(null, str);

});

define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module) {
"use strict";
var config = require("../config");

var Tokenizer = require("../tokenizer").Tokenizer;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var unicode = require("../unicode");
var lang = require("../lib/lang");
var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
};

(function() {
    this.$defaultBehaviour = new CstyleBehaviour();

    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");

    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");

    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === "comment")
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            
            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };
            
            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                var Mode = mapping[i];
                var id = Mode.prototype.$id;
                var mode = config.$modes[id];
                if (!mode)
                    config.$modes[id] = mode = new Mode();
                if (!config.$modes[i])
                    config.$modes[i] = mode;
                this.$embeds.push(i);
                this.$modes[i] = mode;
            }
        }

        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              };
            }(this));
        }
    };

    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0] || "start";
        if (typeof state != "string") {
            if (Array.isArray(state[2])) {
                var language = state[2][state[2].length - 1];
                var mode = this.$modes[language];
                if (mode)
                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
        }
            
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    
    this.getKeywords = function(append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/apply_delta",["require","exports","module"], function(require, exports, module) {
"use strict";

function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

exports.applyDelta = function(docLines, delta, doNotValidate) {
    
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
};
});

define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;
            
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
            
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.off("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    };
    
    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };
    
    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };
    
    this.pos = function(row, column) {
        return {row: row, column: column};
    };
    
    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({row: row, column: column}, lines);
    };    
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    };
    this.remove = function(range, add_inf) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end}),
            add_inf: add_inf
        });
        return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
        }
    };
    
    this.$safeApplyDelta = function(delta) {
        var docLength = this.$lines.length;
        if (
            delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength
            || delta.action == "insert" && delta.start.row <= docLength
        ) {
            this.applyDelta(delta);
        }
    };
    
    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row; 
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function(delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: index + lines[l-1].length + newlineLength};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;

        var startLine = currentLine;
        while (self.lines[currentLine])
            currentLine++;
        
        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines ++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;
        
        if (endLine == -1)
            endLine = currentLine;
        
        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};

(function(){

    oop.implement(this, EventEmitter);
    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    };
    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    };
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    };
    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };
    
    this.scheduleStart = function() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    };

    this.$updateOnChange = function(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    };
    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];

        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});

define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};

(function() {
    this.MAX_RANGES = 500;
    
    this.setRegexp = function(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                markerLayer.drawSingleLineMarker(
                    html, ranges[j].toScreenRange(session), this.clazz, config);
            }
        }
    };

}).call(SearchHighlight.prototype);

exports.SearchHighlight = SearchHighlight;
});

define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    };

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    };

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    };

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };

    this.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);
        
        if (!pos || pos.kind == "inside")
            return null;
            
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    };

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});

define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";
var Range = require("./range").Range;
var comparePoints = Range.comparePoints;

var RangeList = function() {
    this.ranges = [];
    this.$bias = 1;
};

(function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    };

    this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    };

    this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    };

    this.contains = function(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };

    this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    };

    this.detach = function() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };

    this.$onChange = function(delta) {
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var ranges = this.ranges;
        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row >= startRow)
                break;
        }
        
        if (delta.action == "insert") {
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                    break;
    
                if (r.start.row == startRow && r.start.column >= start.column) {
                    if (r.start.column == start.column && this.$bias <= 0) {
                    } else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                    if (r.end.column == start.column && this.$bias < 0) {
                        continue;
                    }
                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                        if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                            r.end.column -= colDiff;
                    }
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                }
            }
        } else {
            var lineDif = startRow - endRow;
            var colDiff = start.column - end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                
                if (r.start.row > endRow)
                    break;
                    
                if (r.end.row < endRow
                    && (
                        startRow < r.end.row 
                        || startRow == r.end.row && start.column < r.end.column
                    )
                ) {
                    r.end.row = startRow;
                    r.end.column = start.column;
                }
                else if (r.end.row == endRow) {
                    if (r.end.column <= end.column) {
                        if (lineDif || r.end.column > start.column) {
                            r.end.column = start.column;
                            r.end.row = start.row;
                        }
                    }
                    else {
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
                else if (r.end.row > endRow) {
                    r.end.row += lineDif;
                }
                
                if (r.start.row < endRow
                    && (
                        startRow < r.start.row 
                        || startRow == r.start.row && start.column < r.start.column
                    )
                ) {
                    r.start.row = startRow;
                    r.start.column = start.column;
                }
                else if (r.start.row == endRow) {
                    if (r.start.column <= end.column) {
                        if (lineDif || r.start.column > start.column) {
                            r.start.column = start.column;
                            r.start.row = start.row;
                        }
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                else if (r.start.row > endRow) {
                    r.start.row += lineDif;
                }
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };

}).call(RangeList.prototype);

exports.RangeList = RangeList;
});

define("ace/edit_session/fold",["require","exports","module","ace/range_list","ace/lib/oop"], function(require, exports, module) {
"use strict";

var RangeList = require("../range_list").RangeList;
var oop = require("../lib/oop");
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};

oop.inherits(Fold, RangeList);

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
            return;
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];
        var firstConsumed = 0;

        if (cmp == 0) {
            if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
            else
                firstConsumed = 1;
        }
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        if (cmp == 0)  j++;
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
        for (var k = firstConsumed; k < last; k++) {
            fold.addSubFold(consumedFolds[k]);
        }
        fold.setFoldLine(this.foldLine);

        return fold;
    };
    
    this.restoreRange = function(range) {
        return restoreRange(range, this.start);
    };

}).call(Fold.prototype);

function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var FoldLine = require("./fold_line").FoldLine;
var Fold = require("./fold").Fold;
var TokenIterator = require("../token_iterator").TokenIterator;

function Folding() {
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                    continue;
                } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                    continue;
                }
                return folds[i];
            }
        }
    };
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if (start < last) {
                    if (start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            } else if (end >= first){
                if (start >= first) // fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;
        
        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    };
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token.type;
        if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
                type += "|doc-start";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token && re.test(token.type));
                iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);
            
            if (dir != -1) {
                var lastRow = -1;
                do {
                    token = iterator.stepForward();
                    if (lastRow == -1) {
                        var state = this.getState(iterator.$row);
                        if (!re.test(state))
                            lastRow = iterator.$row;
                    } else if (iterator.$row > lastRow) {
                        break;
                    }
                } while (token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow, depth) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                try {
                    var fold = this.addFold("...", range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch(e) {}
            }
        }
    };
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;
            
        this.$foldMode = foldMode;
        
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    };

    this.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };
    
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }

        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    
    
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}

exports.Folding = Folding;

});

define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module) {
"use strict";

var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;


function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };
    this.getMatchingBracketRanges = function(pos) {
        var line = this.getLine(pos.row);

        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        }

        if (!match)
            return null;

        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
            : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
            return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);

        return [startRange, endRange];
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };
}
exports.BracketMatch = BracketMatch;

});

define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var BidiHandler = require("./bidihandler").BidiHandler;
var config = require("./config");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Selection = require("./selection").Selection;
var TextMode = require("./mode/text").Mode;
var Range = require("./range").Range;
var Document = require("./document").Document;
var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = require("./search_highlight").SearchHighlight;

var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.id = "session" + (++EditSession.$uid);
    this.$foldData.toString = function() {
        return this.join("\n");
    };
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
        text = new Document(text);

    this.setDocument(text);
    this.selection = new Selection(this);
    this.$bidiHandler = new BidiHandler(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
};


EditSession.$uid = 0;

(function() {

    oop.implement(this, EventEmitter);
    this.setDocument = function(doc) {
        if (this.doc)
            this.doc.removeListener("change", this.$onChange);

        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    };
    this.getDocument = function() {
        return this.doc;
    };
    this.$resetRowCache = function(docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    };

    this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
            this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);

        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager) {
            if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                    action: "removeFolds",
                    folds:  removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
            }
            this.$undoManager.add(delta, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;
            
            this.$informUndoManager.schedule();
        }

        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    };
    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };
    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        
        if (this.$informUndoManager)
            this.$informUndoManager.cancel();
        
        if (undoManager) {
            var self = this;
            undoManager.addSession(this);
            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();
                self.mergeUndoDeltas = false;
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        } else {
            this.$syncInformUndoManager = function() {};
        }
    };
    this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    
    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        hasUndo: function() {},
        hasRedo: function() {},
        reset: function() {},
        add: function() {},
        addSelection: function() {},
        startNewGroup: function() {},
        addSession: function() {}
    };
    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };
    this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
    };
    this.getTabSize = function() {
        return this.$tabSize;
    };
    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };
    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
    };
    this.getNavigateWithinSoftTabs = function() {
        return this.$navigateWithinSoftTabs;
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
    };
    this.getOverwrite = function() {
        return this.$overwrite;
    };
    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    };
    this.getBreakpoints = function() {
        return this.$breakpoints;
    };
    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    };
    this.setBreakpoint = function(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    };
    this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    };
    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        delete (markers[markerId]);
        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
    };
    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };
    this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    };
    this.getAnnotations = function() {
        return this.$annotations || [];
    };
    this.clearAnnotations = function() {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };
    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function() { return this.$useWorker; };
    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    };

    this.$modes = config.$modes;
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode) 
            return;
            
        var oldMode = this.$mode;
        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.on !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.on("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.on("update", function(e) {
                _self._signal("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;

        
        if (!$isPlaceholder) {
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode", {oldMode: oldMode, mode: mode});
        }
    };

    this.$stopWorker = function() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };

    this.$startWorker = function() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    };
    this.getMode = function() {
        return this.$mode;
    };

    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function() {
        return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets) 
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    
    this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };
    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function() {
        return this.doc.getLength();
    };
    this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function(range, add_inf) {
        return this.doc.remove(range, add_inf);
    };
    this.removeFullLines = function(firstRow, lastRow){
        return this.doc.removeFullLines(firstRow, lastRow);
    };
    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
            } else if (delta.folds) {
                this.addFolds(delta.folds);
            }
        }
        if (!dontSelect && this.$undoSelect) {
            if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
        }
        this.$fromUndo = false;
    };
    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
            }
        }

        if (!dontSelect && this.$undoSelect) {
            if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
        }
        this.$fromUndo = false;
    };
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }

        var range, point;

        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (!delta.start) continue; // skip folds
            if (!range) {
                if (isInsert(delta)) {
                    range = Range.fromPoints(delta.start, delta.end);
                } else {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
            }
            
            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
            } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
            }
        }
        return range;
    };
    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    };
    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.doc.insertInLine({row: row, column: 0}, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });
        
        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };
    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    };
    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    };
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    };
    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function() {
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        
        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            var len = screenPos - lastSplit;
            for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2) len -= 1;
            }

            if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    };
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    };

    this.lineWidgets = null;
    this.getRowLength = function(row) {
        var h = 1;
        if (this.lineWidgets)
            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        
        if (!this.$useWrapMode || !this.$wrapData[row])
            return h;
        else
            return this.$wrapData[row].length + h;
    };
    this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    };

    this.getRowWrapIndent = function(screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
            return 0;
        }
    };
    this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - (screenColumn % this.$tabSize | 0);
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);

        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    };
    this.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;


        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }
        
        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
            screenRow += this.lineWidgets[row].rowsAbove;

        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    };
    this.$setFontMetrics = function(fm) {
        if (!this.$enableVarChar) return;
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            
            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "\t") {
                    screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }
            
            return [screenColumn, column];
        };
    };
    
    this.destroy = function() {
        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
        }
        this.$stopWorker();
        this.removeAllListeners();
        this.selection.detach();
    };

    this.isFullWidth = isFullWidth;
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    }

}).call(EditSession.prototype);

require("./edit_session/folding").Folding.call(EditSession.prototype);
require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },    
    wrapMethod: {
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: {
        set: function() {
            if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
            }
        },
        initialValue: true 
    },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
                this.$modified = true;
                this.$rowLengthCache = [];
                this.$tabSize = tabSize;
                this._signal("changeTabSize");
            }
        },
        initialValue: 4,
        handlesSet: true
    },
    navigateWithinSoftTabs: {initialValue: false},
    foldStyle: {
        set: function(val) {this.setFoldStyle(val);},
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val);},
        get: function() {return this.doc.getNewLineMode();},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val); },
        get: function() { return this.$modeId; },
        handlesSet: true
    }
});

exports.EditSession = EditSession;
});

define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module) {
"use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var Search = function() {
    this.$options = {};
};

(function() {
    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function(options) {
        this.$options = options;
    };
    this.find = function(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && options.start.start
                && options.skipCurrent != false && firstRange.isEqual(options.start)
            ) {
                firstRange = null;
                return false;
            }
            
            return true;
        });

        return firstRange;
    };
    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;
                
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                
                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;

            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;
            
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    };
    this.replace = function(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }
        
        return replacement;
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        if (options.wholeWord)
            needle = addWordBoundary(needle, options);

        var modifier = options.caseSensitive ? "gm" : "gmi";

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        return re;
    };

    this.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
         
        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;
        
        if (backwards) {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row--; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
            };
        }
        else {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row = row + 1; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
            };
        }
        
        if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0) return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1) return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(startRow + i);
                    if (line.search(re[i]) == -1)
                        return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset) return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                    return true;
            };
        }
        else if (backwards) {
            var forEachInLine = function(row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                        if (last >= line.length) break;
                        re.lastIndex = last += 1;
                    }
                    if (m.index + length > endIndex)
                        break;
                    matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                        return true;
                }
            };
        }
        else {
            var forEachInLine = function(row, startIndex, callback) {
                var line = session.getLine(row);
                var last;
                var m;
                re.lastIndex = startIndex;
                while((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row,last + length))
                        return true;
                    if (!length) {
                        re.lastIndex = last += 1;
                        if (last >= line.length) return false;
                    }
                }
            };
        }
        return {forEach: forEach};
    };

}).call(Search.prototype);

function addWordBoundary(needle, options) {
    function wordBoundary(c) {
        if (/\w/.test(c) || options.regExp) return "\\b";
        return "";
    }
    return wordBoundary(needle[0]) + needle
        + wordBoundary(needle[needle.length - 1]);
}

exports.Search = Search;
});

define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var keyUtil = require("../lib/keys");
var useragent = require("../lib/useragent");
var KEY_MODS = keyUtil.KEY_MODS;

function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}

function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}

MultiHashHandler.prototype = HashHandler.prototype;

(function() {
    

    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    };

    this.removeCommand = function(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };

    this.bindKey = function(key, command, position) {
        if (typeof key == "object" && key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || key});
        
        key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    };
    
    function getPosition(command) {
        return typeof command == "object" && command.bindKey
            && command.bindKey.position 
            || (command.isDefault ? -100 : 0);
    }
    this._addCommandToBinding = function(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }
            
            if (typeof position != "number") {
                position = getPosition(command);
            }

            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    };

    this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x;});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        if (keyCode < 0) return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        
        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }
        
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return {command: command};
    };
    
    this.getStatusText = function(editor, data) {
        return data.$keyChain || "";
    };

}).call(HashHandler.prototype);

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;
});

define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var CommandManager = function(platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
        return e.command.exec(e.editor, e.args || {});
    });
};

oop.inherits(CommandManager, MultiHashHandler);

(function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }

        if (typeof command === "string")
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
            return false;

        var e = {editor: editor, command: command, args: args};
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.off("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});

define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module) {
"use strict";

var lang = require("../lib/lang");
var config = require("../config");
var Range = require("../range").Range;

function bindKey(win, mac) {
    return {win: win, mac: mac};
}
exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "F4"),
    exec: function(editor) {
        config.loadModule("./ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
    exec: function(editor) {
        config.loadModule("./ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    description: "Select all",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    description: "Center selection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    description: "Go to line...",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor, line) {
        if (typeof line === "number" && !isNaN(line))
            editor.gotoLine(line);
        editor.prompt({ $type: "gotoLine" });
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    description: "Fold all",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    description: "Fold other",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    description: "Unfold all",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    description: "Find next",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    description: "Find previous",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    description: "Select or find next",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    description: "Select or find previous",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    description: "Find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor);});
    },
    readOnly: true
}, {
    name: "overwrite",
    description: "Overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    description: "Select to start",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    description: "Go to start",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    description: "Select up",
    bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    description: "Go line up",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    description: "Select to end",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    description: "Go to end",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    description: "Select down",
    bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    description: "Go line down",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    description: "Select word left",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    description: "Go to word left",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    description: "Select to line start",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    description: "Go to line start",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    description: "Select left",
    bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    description: "Go to left",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    description: "Select word right",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    description: "Go to word right",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    description: "Select to line end",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    description: "Go to line end",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    description: "Select right",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    description: "Go to right",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    description: "Select page down",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    description: "Page down",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    description: "Go to page down",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    description: "Select page up",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    description: "Page up",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    description: "Go to page up",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    description: "Scroll up",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    description: "Scroll down",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    description: "Select line start",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    description: "Select line end",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    description: "Toggle recording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    description: "Replay macro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    description: "Jump to matching",
    bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    description: "Select to matching",
    bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    description: "Expand to matching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    description: "Pass keys to browser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
}, {
    name: "copy",
    description: "Copy",
    exec: function(editor) {
    },
    readOnly: true
},
{
    name: "cut",
    description: "Cut",
    exec: function(editor) {
        var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
        var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
        editor._emit("cut", range);

        if (!range.isEmpty())
            editor.session.remove(range);
        editor.clearSelection();
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "paste",
    description: "Paste",
    exec: function(editor, args) {
        editor.$handlePaste(args);
    },
    scrollIntoView: "cursor"
}, {
    name: "removeline",
    description: "Remove line",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    description: "Duplicate selection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    description: "Sort lines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    description: "Toggle comment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    description: "Toggle block comment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    description: "Modify number up",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    description: "Modify number down",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    description: "Replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true);});
    }
}, {
    name: "undo",
    description: "Undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    description: "Redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    description: "Copy lines up",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    description: "Move lines up",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    description: "Copy lines down",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    description: "Move lines down",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    description: "Delete",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    description: "Backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    description: "Cut or delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    description: "Remove to line start",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    description: "Remove to line end",
    bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestarthard",
    description: "Remove to line start hard",
    bindKey: bindKey("Ctrl-Shift-Backspace", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.start.column = 0;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineendhard",
    description: "Remove to line end hard",
    bindKey: bindKey("Ctrl-Shift-Delete", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.end.column = Number.MAX_VALUE;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    description: "Remove word left",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    description: "Remove word right",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    description: "Outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    description: "Indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    description: "Block outdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    description: "Block indent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    description: "Insert string",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    description: "Insert text",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    description: "Split line",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    description: "Transpose letters",
    bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    description: "To uppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    description: "To lowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "autoindent",
    description: "Auto Indent",
    bindKey: bindKey(null, null),
    exec: function(editor) { editor.autoIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "animate"
}, {
    name: "expandtoline",
    description: "Expand to line",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "joinlines",
    description: "Join lines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    description: "Invert selection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}, {
    name: "addLineAfter",
    exec: function(editor) {
        editor.selection.clearSelection();
        editor.navigateLineEnd();
        editor.insert("\n");
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "addLineBefore",
    exec: function(editor) {
        editor.selection.clearSelection();
        var cursor = editor.getCursorPosition();
        editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
        editor.insert("\n");
        if (cursor.row === 0) editor.navigateUp();
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "openCommandPallete",
    description: "Open command pallete",
    bindKey: bindKey("F1", "F1"),
    exec: function(editor) {
        editor.prompt({ $type: "commands" });
    },
    readOnly: true
}, {
    name: "modeSelect",
    description: "Change language mode...",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        editor.prompt({ $type: "modes" });
    },
    readOnly: true
}];

});

define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/clipboard"], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var lang = require("./lib/lang");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var FoldHandler = require("./mouse/fold_handler").FoldHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var EditSession = require("./edit_session").EditSession;
var Search = require("./search").Search;
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;
var config = require("./config");
var TokenIterator = require("./token_iterator").TokenIterator;

var clipboard = require("./clipboard");
var Editor = function(renderer, session, options) {
    this.$toDestroy = [];
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;
    this.id = "editor" + (++Editor.$uid);

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    if (typeof document == "object") {
        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
    }

    this.keyBinding = new KeyBinding(this);

    this.$search = new Search().set({
        wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();
    
    this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    
    this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || options && options.session || new EditSession(""));
    config.resetOptions(this);
    if (options)
        this.setOptions(options);
    config._signal("editor", this);
};

Editor.$uid = 0;

(function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);

        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
        this.on("change", function() {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.docChanged = true;
        }.bind(this), true);
        
        this.on("changeSelection", function() {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commandEvent) {
        if (this.curOp) {
            if (!commandEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commandEvent) {
            this.previousCommand = null;
            commandEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = this.session.curOp = {
            command: commandEvent.command || {},
            args: commandEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        this.curOp.selectionBefore = this.selection.toJSON();
    };

    this.endOperation = function(e) {
        if (this.curOp && this.session) {
            if (e && e.returnValue === false || !this.session)
                return (this.curOp = null);
            if (e == true && this.curOp.command && this.curOp.command.name == "mouse")
                return;
            this._signal("beforeEndOperation");
            if (!this.curOp) return;
            var command = this.curOp.command;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            var sel = this.selection.toJSON();
            this.curOp.selectionAfter = sel;
            this.$lastSel = this.selection.toJSON();
            this.session.getUndoManager().addSelection(sel);
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    };
    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function(session) {
        if (this.session == session)
            return;
        if (this.curOp) this.endOperation();
        this.curOp = {};

        var oldSession = this.session;
        if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
    
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
    
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
    
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
    
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
    
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
    
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
    
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
    
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
    
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
    
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
    
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
    
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
    
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
    
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
    
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
    
            this.onChangeMode();
    
            this.onCursorChange();
    
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });
        
        this.curOp = null;
        
        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        session && session._signal("changeEditor", {editor: this});
        
        if (session && session.bgTokenizer)
            session.bgTokenizer.scheduleStart();
    };
    this.getSession = function() {
        return this.session;
    };
    this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    };
    this.getValue = function() {
        return this.session.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.resize = function(force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function(theme, cb) {
        this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function() {
        return this.renderer.getTheme();
    };
    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container).fontSize;
    };
    this.setFontSize = function(size) {
        this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function () {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                    session.removeMarker(id);
                });
                session.$bracketHighlight = null;
            }
            var ranges = session.getMatchingBracketRanges(self.getCursorPosition());
            if (!ranges && session.$mode.getMatching) 
                ranges = session.$mode.getMatching(self.session);
            if (!ranges)
                return;

            var markerType = "ace_bracket";
            if (!Array.isArray(ranges)) {
                ranges = [ranges];
            } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
            }
            if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
            }

            session.$bracketHighlight = {
                ranges: ranges,
                markerIds: ranges.map(function(range) {
                    return session.addMarker(range, markerType, "text");
                })
            };
        }, 50);
    };
    this.$highlightTags = function() {
        if (this.$highlightTagPending)
            return;
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
            self.$highlightTagPending = false;
            
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            
            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            if (token.type.indexOf("tag-open") != -1) {
                token = iterator.stepForward();
                if (!token)
                    return;
            }
            
            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            
            if (prevToken.value == '<'){
                do {
                    prevToken = token;
                    token = iterator.stepForward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<'){
                            depth++;
                        } else if (prevToken.value === '</'){
                            depth--;
                        }
                    }
                    
                } while (token && depth >= 0);
            } else {
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<') {
                            depth++;
                        } else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                } while (prevToken && depth <= 0);
                iterator.stepForward();
            }
            
            if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column+token.value.length);
            var sbm = session.$backMarkers[session.$tagHighlight];
            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
            }
            
            if (!session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.focus = function() {
        var _self = this;
        setTimeout(function() {
            if (!_self.isFocused())
                _self.textInput.focus();
        });
        this.textInput.focus();
    };
    this.isFocused = function() {
        return this.textInput.isFocused();
    };
    this.blur = function() {
        this.textInput.blur();
    };
    this.onFocus = function(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    };
    this.onBlur = function(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    };

    this.$cursorChange = function() {
        this.renderer.updateCursor();
        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
    };
    this.onDocumentChange = function(delta) {
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);

        this._signal("change", delta);
        this.$cursorChange();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function() {
        this.$cursorChange();
        this._signal("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        var highlight;
        if (this.$highlightActiveLine) {
            if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startColumn = selection.start.column;
        var endColumn = selection.end.column;
        var line = session.getLine(selection.start.row);
        
        var needle = line.substring(startColumn, endColumn);
        if (needle.length > 5000 || !/[\w\d]/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });
        
        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
        if (!re.test(wordWithBoundary))
            return;
        
        return re;
    };


    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function() {
        var text = this.getSelectedText();
        var nl = this.session.doc.getNewLineCharacter();
        var copyLine= false;
        if (!text && this.$copyWithEmptySelection) {
            copyLine = true;
            var ranges = this.selection.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                    continue;
                text += this.session.getLine(range.start.row) + nl;
            }
        }
        var e = {text: text};
        this._signal("copy", e);
        clipboard.lineMode = copyLine ? e.text : "";
        return e.text;
    };
    this.onCopy = function() {
        this.commands.exec("copy", this);
    };
    this.onCut = function() {
        this.commands.exec("cut", this);
    };
    this.onPaste = function(text, event) {
        var e = {text: text, event: event};
        this.commands.exec("paste", this, e);
    };
    
    this.$handlePaste = function(e) {
        if (typeof e == "string") 
            e = {text: e};
        this._signal("paste", e);
        var text = e.text;

        var lineMode = text == clipboard.lineMode;
        var session = this.session;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
            else
                this.insert(text);
        } else if (lineMode) {
            this.selection.rangeList.ranges.forEach(function(range) {
                session.insert({ row: range.start.row, column: 0 }, text);
            });
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
    
            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
            if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
    
            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    session.remove(range);
    
                session.insert(range.start, lines[i]);
            }
        }
    };

    this.execCommand = function(command, args) {
        return this.commands.exec(command, this, args);
    };
    this.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    if (!this.inVirtualSelectionMode) {
                        this.session.mergeUndoDeltas = false;
                        this.mergeNextCommand = false;
                    }
                }
                text = transform.text;

            }
        }
        
        if (text == "\t")
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range, "remove_in_insert");
            this.clearSelection();
        }
        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }
        if (this.$enableAutoIndent) {
            if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                session.insert({row: cursor.row+1, column: 0}, lineIndent);
            }
            if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
        }
    };

    this.autoIndent = function () {
        var session = this.session;
        var mode = session.getMode();

        var startRow, endRow;
        if (this.selection.isEmpty()) {
            startRow = 0;
            endRow = session.doc.getLength() - 1;
        } else {
            var selectedRange = this.getSelectionRange();

            startRow = selectedRange.start.row;
            endRow = selectedRange.end.row;
        }

        var prevLineState = "";
        var prevLine = "";
        var lineIndent = "";
        var line, currIndent, range;
        var tab = session.getTabString();

        for (var row = startRow; row <= endRow; row++) {
            if (row > 0) {
                prevLineState = session.getState(row - 1);
                prevLine = session.getLine(row - 1);
                lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
            }

            line = session.getLine(row);
            currIndent = mode.$getIndent(line);
            if (lineIndent !== currIndent) {
                if (currIndent.length > 0) {
                    range = new Range(row, 0, row, currIndent.length);
                    session.remove(range);
                }
                if (lineIndent.length > 0) {
                    session.insert({row: row, column: 0}, lineIndent);
                }
            }

            mode.autoOutdent(prevLineState, session, row);
        }
    };


    this.onTextInput = function(text, composition) {
        if (!composition)
            return this.keyBinding.onTextInput(text);
        
        this.startOperation({command: { name: "insertstring" }});
        var applyComposition = this.applyComposition.bind(this, text, composition);
        if (this.selection.rangeCount)
            this.forEachSelection(applyComposition);
        else
            applyComposition();
        this.endOperation();
    };
    
    this.applyComposition = function(text, composition) {
        if (composition.extendLeft || composition.extendRight) {
            var r = this.selection.getRange();
            r.start.column -= composition.extendLeft;
            r.end.column += composition.extendRight;
            if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
            }
            this.selection.setRange(r);
            if (!text && !r.isEmpty())
                this.remove();
        }
        if (text || !this.selection.isEmpty())
            this.insert(text, true);
        if (composition.restoreStart || composition.restoreEnd) {
            var r = this.selection.getRange();
            r.start.column -= composition.restoreStart;
            r.end.column -= composition.restoreEnd;
            this.selection.setRange(r);
        }
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        return this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function() {
        return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);

    };
    this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
    };
    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();
        if (this.selection.isEmpty())
            this.selection.selectLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
    };
    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }
        
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };
    this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (var i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    };
    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        } else {
            this.toggleWord();
        }
    };

    this.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
    ];

    this.toggleWord = function () {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        this.selection.selectWord();
        var currentState = this.getSelectedText();
        var currWordStart = this.selection.getWordRange().start.column;
        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
        var delta = column - currWordStart - 1;
        if (delta < 0) delta = 0;
        var curLength = 0, itLength = 0;
        var that = this;
        if (currentState.match(/[A-Za-z0-9_]+/)) {
            wordParts.forEach(function (item, i) {
                itLength = curLength + item.length;
                if (delta >= curLength && delta <= itLength) {
                    currentState = item;
                    that.selection.clearSelection();
                    that.moveCursorTo(row, curLength + currWordStart);
                    that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
            });
        }

        var wordPairs = this.$toggleWordPairs;
        var reg;
        for (var i = 0; i < wordPairs.length; i++) {
            var item = wordPairs[i];
            for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
                if (firstCondition) {
                    var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
                    if (secondCondition) {
                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
                            var res = item[negate];
                            if (result.toUpperCase() == result) {
                                res = res.toUpperCase();
                            } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                            }
                            return res;
                        });
                        this.insert(reg);
                        reg = "";
                    }
                }
            }
        }
    };
    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    };

    this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function() {
        this.$moveLines(1, false);
    };
    this.moveLinesUp = function() {
        this.$moveLines(-1, false);
    };
    this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function() {
        this.$moveLines(-1, true);
    };
    this.copyLinesDown = function() {
        this.$moveLines(1, true);
    };
    this.$moveLines = function(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }
            
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };
    this.$getSelectedRows = function(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };

    this.onCompositionStart = function(compositionState) {
        this.renderer.showComposition(compositionState);
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };
    this.selectAll = function() {
        this.selection.selectAll();
    };
    this.clearSelection = function() {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken || iterator.stepForward();

        if (!token) return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };
        
        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                        break;
                    }
                }
            }
            else if (token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }
                
                if (prevToken.value === '<') {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }
                
                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);
        if (!matchType)
            return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1) 
                var tag = token.value;
            else
                return;

            range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
            );
            if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (prevToken) {
                        if (prevToken.type.indexOf('tag-close') !== -1) {
                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        }

                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<') {
                                depth[tag]++;
                            }
                            else if (prevToken.value === '</') {
                                depth[tag]--;
                            }
                            
                            if (depth[tag] === 0)
                                found = true;
                        }
                    }
                } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
                pos = range.start;
                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    pos = range.end;
            }
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                } else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            } else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
    };
    this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }

        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);

        return replaced;
    };
    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);

        return replaced;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };
    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };
    this.find = function(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    };
    this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
        this.session.unfold(range);
        this.selection.setSelectionRange(range);

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function() {
        this.session.getUndoManager().undo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function() {
        this.session.getUndoManager().redo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function() {
        if (this.$toDestroy) {
            this.$toDestroy.forEach(function(el) {
                el.destroy();
            });
            this.$toDestroy = null;
        }
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session)
            this.session.destroy();
        if (this._$emitInputEvent)
            this._$emitInputEvent.cancel();
        this.removeAllListeners();
    };
    this.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    };


    this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };
    this.prompt = function(message, options, callback) {
        var editor = this;
        config.loadModule("./ext/prompt", function (module) {
            module.prompt(editor, message, options, callback);
        });
    };

}).call(Editor.prototype);



config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle(); 
        },
        initialValue: false
    },
    copyWithEmptySelection: {
        set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    enableAutoIndent: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val);}
    },
    keyboardHandler: {
        set: function(val) { this.setKeyboardHandler(val); },
        get: function() { return this.$keybindingId; },
        handlesSet: true
    },
    value: {
        set: function(val) { this.session.setValue(val); },
        get: function() { return this.getValue(); },
        handlesSet: true,
        hidden: true
    },
    session: {
        set: function(val) { this.setSession(val); },
        get: function() { return this.session; },
        handlesSet: true,
        hidden: true
    },
    
    showLineNumbers: {
        set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        },
        initialValue: true
    },
    relativeLineNumbers: {
        set: function(value) {
            if (this.$showLineNumbers && value)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        }
    },
    placeholder: {
        set: function(message) {
            if (!this.$updatePlaceholder) {
                this.$updatePlaceholder = function() {
                    var value = this.session && (this.renderer.$composition || this.getValue());
                    if (value && this.renderer.placeholderNode) {
                        this.renderer.off("afterRender", this.$updatePlaceholder);
                        dom.removeCssClass(this.container, "ace_hasPlaceholder");
                        this.renderer.placeholderNode.remove();
                        this.renderer.placeholderNode = null;
                    } else if (!value && !this.renderer.placeholderNode) {
                        this.renderer.on("afterRender", this.$updatePlaceholder);
                        dom.addCssClass(this.container, "ace_hasPlaceholder");
                        var el = dom.createElement("div");
                        el.className = "ace_placeholder";
                        el.textContent = this.$placeholder || "";
                        this.renderer.placeholderNode = el;
                        this.renderer.content.appendChild(this.renderer.placeholderNode);
                    } else if (!value && this.renderer.placeholderNode) {
                        this.renderer.placeholderNode.textContent = this.$placeholder || "";
                    }
                }.bind(this);
                this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
        }
    },

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    displayIndentGuides: "renderer",
    showGutter: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",
    hasCssTransforms: "renderer",
    maxPixelHeight: "renderer",
    useTextareaForIME: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimeout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    navigateWithinSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});


var relativeNumberRenderer = {
    getText: function(session, row) {
        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
    },
    getWidth: function(session, lastLineNumber, config) {
        return Math.max(
            lastLineNumber.toString().length,
            (config.lastRow + 1).toString().length,
            2
        ) * config.characterWidth;
    },
    update: function(e, editor) {
        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
    },
    attach: function(editor) {
        editor.renderer.$gutterLayer.$renderer = this;
        editor.on("changeSelection", this.update);
        this.update(null, editor);
    },
    detach: function(editor) {
        if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
        editor.off("changeSelection", this.update);
        this.update(null, editor);
    }
};

exports.Editor = Editor;
});

define("ace/undomanager",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";
var UndoManager = function() {
    this.$maxRev = 0;
    this.$fromUndo = false;
    this.reset();
};

(function() {
    
    this.addSession = function(session) {
        this.$session = session;
    };
    this.add = function(delta, allowMerge, session) {
        if (this.$fromUndo) return;
        if (delta == this.$lastDelta) return;
        if (!this.$keepRedoStack) this.$redoStack.length = 0;
        if (allowMerge === false || !this.lastDeltas) {
            this.lastDeltas = [];
            this.$undoStack.push(this.lastDeltas);
            delta.id = this.$rev = ++this.$maxRev;
        }
        if (delta.action == "remove" || delta.action == "insert")
            this.$lastDelta = delta;
        this.lastDeltas.push(delta);
    };
    
    this.addSelection = function(selection, rev) {
        this.selections.push({
            value: selection,
            rev: rev || this.$rev
        });
    };
    
    this.startNewGroup = function() {
        this.lastDeltas = null;
        return this.$rev;
    };
    
    this.markIgnored = function(from, to) {
        if (to == null) to = this.$rev + 1;
        var stack = this.$undoStack;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id <= from)
                break;
            if (delta.id < to)
                delta.ignore = true;
        }
        this.lastDeltas = null;
    };
    
    this.getSelection = function(rev, after) {
        var stack = this.selections;
        for (var i = stack.length; i--;) {
            var selection = stack[i];
            if (selection.rev < rev) {
                if (after)
                    selection = stack[i + 1];
                return selection;
            }
        }
    };
    
    this.getRevision = function() {
        return this.$rev;
    };
    
    this.getDeltas = function(from, to) {
        if (to == null) to = this.$rev + 1;
        var stack = this.$undoStack;
        var end = null, start = 0;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id < to && !end)
                end = i+1;
            if (delta.id <= from) {
                start = i + 1;
                break;
            }
        }
        return stack.slice(start, end);
    };
    
    this.getChangedRanges = function(from, to) {
        if (to == null) to = this.$rev + 1;
        
    };
    
    this.getChangedLines = function(from, to) {
        if (to == null) to = this.$rev + 1;
        
    };
    this.undo = function(session, dontSelect) {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        
        if (!rearrangeUndoStack(stack, stack.length))
            return;
        
        if (!session)
            session = this.$session;
        
        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
            this.$redoStack = [];
        
        this.$fromUndo = true;
        
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
            this.$redoStack.push(deltaSet);
            this.$syncRev();
        }
        
        this.$fromUndo = false;

        return undoSelectionRange;
    };
    this.redo = function(session, dontSelect) {
        this.lastDeltas = null;
        
        if (!session)
            session = this.$session;
        
        this.$fromUndo = true;
        if (this.$redoStackBaseRev != this.$rev) {
            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            rebaseRedoStack(this.$redoStack, diff);
            this.$redoStackBaseRev = this.$rev;
            this.$redoStack.forEach(function(x) {
                x[0].id = ++this.$maxRev;
            }, this);
        }
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        
        if (deltaSet) {
            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
            this.$undoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        
        return redoSelectionRange;
    };
    
    this.$syncRev = function() {
        var stack = this.$undoStack;
        var nextDelta = stack[stack.length - 1];
        var id = nextDelta && nextDelta[0].id || 0;
        this.$redoStackBaseRev = id;
        this.$rev = id;
    };
    this.reset = function() {
        this.lastDeltas = null;
        this.$lastDelta = null;
        this.$undoStack = [];
        this.$redoStack = [];
        this.$rev = 0;
        this.mark = 0;
        this.$redoStackBaseRev = this.$rev;
        this.selections = [];
    };
    this.canUndo = function() {
        return this.$undoStack.length > 0;
    };
    this.canRedo = function() {
        return this.$redoStack.length > 0;
    };
    this.bookmark = function(rev) {
        if (rev == undefined)
            rev = this.$rev;
        this.mark = rev;
    };
    this.isAtBookmark = function() {
        return this.$rev === this.mark;
    };
    
    this.toJSON = function() {
        
    };
    
    this.fromJSON = function() {
        
    };
    
    this.hasUndo = this.canUndo;
    this.hasRedo = this.canRedo;
    this.isClean = this.isAtBookmark;
    this.markClean = this.bookmark;
    
    this.$prettyPrint = function(delta) {
        if (delta) return stringifyDelta(delta);
        return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
    };
}).call(UndoManager.prototype);

function rearrangeUndoStack(stack, pos) {
    for (var i = pos; i--; ) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].ignore) {
            while(i < pos - 1) {
                var swapped = swapGroups(stack[i], stack[i + 1]);
                stack[i] = swapped[0];
                stack[i + 1] = swapped[1];
                i++;
            }
            return true;
        }
    }
}

var Range = require("./range").Range;
var cmp = Range.comparePoints;
var comparePoints = Range.comparePoints;

function $updateMarkers(delta) {
    var isInsert = delta.action == "insert";
    var start = delta.start;
    var end = delta.end;
    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
    if (isInsert) end = start;

    for (var i in this.marks) {
        var point = this.marks[i];
        var cmp = comparePoints(point, start);
        if (cmp < 0) {
            continue; // delta starts after the range
        }
        if (cmp === 0) {
            if (isInsert) {
                if (point.bias == 1) {
                    cmp = 1;
                }
                else {
                    point.bias == -1;
                    continue;
                }
            }
        }
        var cmp2 = isInsert ? cmp : comparePoints(point, end);
        if (cmp2 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
        }
        if (!isInsert && cmp2 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp2 === 0)
                point.bias = 1;
        }
    }
}



function clonePos(pos) {
    return {row: pos.row,column: pos.column};
}
function cloneDelta(d) {
    return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice()
    };
}
function stringifyDelta(d) {
    d = d || this;
    if (Array.isArray(d)) {
        return d.map(stringifyDelta).join("\n");
    }
    var type = "";
    if (d.action) {
        type = d.action == "insert" ? "+" : "-";
        type += "[" + d.lines + "]";
    } else if (d.value) {
        if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join("\n");
        } else {
            type = stringifyRange(d.value);
        }
    }
    if (d.start) {
        type += stringifyRange(d);
    }
    if (d.id || d.rev) {
        type += "\t(" + (d.id || d.rev) + ")";
    }
    return type;
}
function stringifyRange(r) {
    return r.start.row + ":" + r.start.column 
        + "=>" + r.end.row + ":" + r.end.column;
}

function swap(d1, d2) {
    var i1 = d1.action == "insert";
    var i2 = d2.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    } else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        } else {
            return null;
        }
    } else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        } else {
            return null;
        }
    }
    return [d2, d1];
}
function swapGroups(ds1, ds2) {
    for (var i = ds1.length; i--; ) {
        for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
                while (i < ds1.length) {
                    while (j--) {
                        swap(ds2[j], ds1[i]);
                    }
                    j = ds2.length;
                    i++;
                }                
                return [ds1, ds2];
            }
        }
    }
    ds1.selectionBefore = ds2.selectionBefore = 
    ds1.selectionAfter = ds2.selectionAfter = null;
    return [ds2, ds1];
}
function xform(d1, c1) {
    var i1 = d1.action == "insert";
    var i2 = c1.action == "insert";
    
    if (i1 && i2) {
        if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
        } else {
            shift(d1, c1, 1);
        }
    } else if (i1 && !i2) {
        if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
        } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, +1);
        } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, +1);
        }
    } else if (!i1 && i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, +1);
        } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, +1);
        }
    } else if (!i1 && !i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
        } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
                before = d1;
                d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
                after = splitDelta(d1, c1.end);
            }

            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
                d1.lines = after.lines;
                d1.start = after.start;
                d1.end = after.end;
                after = d1;
            }

            return [c1, before, after].filter(Boolean);
        }
    }
    return [c1, d1];
}
    
function shift(d1, d2, dir) {
    shiftPos(d1.start, d2.start, d2.end, dir);
    shiftPos(d1.end, d2.start, d2.end, dir);
}
function shiftPos(pos, start, end, dir) {
    if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
    }
    pos.row += dir * (end.row - start.row);
}
function splitDelta(c, pos) {
    var lines = c.lines;
    var end = c.end;
    c.end = clonePos(pos);    
    var rowsBefore = c.end.row - c.start.row;
    var otherLines = lines.splice(rowsBefore, lines.length);
    
    var col = rowsBefore ? pos.column : pos.column - c.start.column;
    lines.push(otherLines[0].substring(0, col));
    otherLines[0] = otherLines[0].substr(col)   ; 
    var rest = {
        start: clonePos(pos),
        end: end,
        lines: otherLines,
        action: c.action
    };
    return rest;
}

function moveDeltasByOne(redoStack, d) {
    d = cloneDelta(d);
    for (var j = redoStack.length; j--;) {
        var deltaSet = redoStack[j];
        for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
                if (xformed[2]) {
                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                    i++;
                } else if (!xformed[1]) {
                    deltaSet.splice(i, 1);
                    i--;
                }
            }
        }
        if (!deltaSet.length) {
            redoStack.splice(j, 1); 
        }
    }
    return redoStack;
}
function rebaseRedoStack(redoStack, deltaSets) {
    for (var i = 0; i < deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
        }
    }
}

exports.UndoManager = UndoManager;

});

define("ace/layer/lines",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");

var Lines = function(element, canvasHeight) {
    this.element = element;
    this.canvasHeight = canvasHeight || 500000;
    this.element.style.height = (this.canvasHeight * 2) + "px";
    
    this.cells = [];
    this.cellCache = [];
    this.$offsetCoefficient = 0;
};

(function() {
    
    this.moveContainer = function(config) {
        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
    };    
    
    this.pageChanged = function(oldConfig, newConfig) {
        return (
            Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)
        );
    };
    
    this.computeLineTop = function(row, config, session) {
        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / this.canvasHeight);
        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
        return lineTop - (screenPage * this.canvasHeight);
    };
    
    this.computeLineHeight = function(row, config, session) {
        return config.lineHeight * session.getRowLineCount(row);
    };
    
    this.getLength = function() {
        return this.cells.length;
    };
    
    this.get = function(index) {
        return this.cells[index];
    };
    
    this.shift = function() {
        this.$cacheCell(this.cells.shift());
    };
    
    this.pop = function() {
        this.$cacheCell(this.cells.pop());
    };
    
    this.push = function(cell) {
        if (Array.isArray(cell)) {
            this.cells.push.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i=0; i<cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            this.element.appendChild(fragment);
        } else {
            this.cells.push(cell);
            this.element.appendChild(cell.element);
        }
    };
    
    this.unshift = function(cell) {
        if (Array.isArray(cell)) {
            this.cells.unshift.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i=0; i<cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
            else
                this.element.appendChild(fragment);
        } else {
            this.cells.unshift(cell);
            this.element.insertAdjacentElement("afterbegin", cell.element);
        }
    };
    
    this.last = function() {
        if (this.cells.length)
            return this.cells[this.cells.length-1];
        else
            return null;
    };
    
    this.$cacheCell = function(cell) {
        if (!cell)
            return;
            
        cell.element.remove();
        this.cellCache.push(cell);
    };
    
    this.createCell = function(row, config, session, initElement) {
        var cell = this.cellCache.pop();
        if (!cell) {
            var element = dom.createElement("div");
            if (initElement)
                initElement(element);
            
            this.element.appendChild(element);
            
            cell = {
                element: element,
                text: "",
                row: row
            };
        }
        cell.row = row;
        
        return cell;
    };
    
}).call(Lines.prototype);

exports.Lines = Lines;

});

define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var Lines = require("./lines").Lines;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    
    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);
    
    this.$lines = new Lines(this.element);
    this.$lines.$offsetCoefficient = 1;
};

(function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        if (this.session)
            this.session.off("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: []};
           
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);

            var type = annotation.type;
            if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };

    this.$updateAnnotations = function (delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
        } else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };

    this.update = function(config) {
        this.config = config;
        
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
            
        this.oldLastRow = lastRow;
        this.config = config;
        
        this.$lines.moveContainer(config);
        this.$updateCursorRow();
            
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;

        var cell = null;
        var index = -1;
        var row = firstRow;
        
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                    this.$lines.pop();
                    
                break;
            }

            cell = this.$lines.get(++index);
            if (cell) {
                cell.row = row;
            } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
            }

            this.$renderCell(cell, config, fold, row);
            row++;
        }
        
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    };

    this.$updateGutterWidth = function(config) {
        var session = this.session;
        
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        
        var firstLineNumber = session.$firstLineNumber;
        var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
        
        if (this.$fixedWidth || session.$useWrapMode)
            lastLineText = session.getLength() + firstLineNumber - 1;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineText, config)
            : lastLineText.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.parentNode.style.width = 
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._signal("changeGutterWidth", gutterWidth);
        }
    };
    
    this.$updateCursorRow = function() {
        if (!this.$highlightGutterLine)
            return;
            
        var position = this.session.selection.getCursor();
        if (this.$cursorRow === position.row)
            return;
        
        this.$cursorRow = position.row;
    };
    
    this.updateLineHighlight = function() {
        if (!this.$highlightGutterLine)
            return;
        var row = this.session.selection.cursor.row;
        this.$cursorRow = row;

        if (this.$cursorCell && this.$cursorCell.row == row)
            return;
        if (this.$cursorCell)
            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
        var cells = this.$lines.cells;
        this.$cursorCell = null;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                    var fold = this.session.getFoldLine(this.$cursorRow);
                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                        cell = cells[i - 1];
                    else
                        break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
            }
        }
    };
    
    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;
        
        this.$updateCursorRow();
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        
        this.$lines.moveContainer(config);

        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            this.session.getLength() - 1);
        var oldLastRow = this.oldLastRow;
        this.oldLastRow = lastRow;
        
        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);

        if (lastRow < oldConfig.firstRow)
            return this.update(config);

        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                this.$lines.shift();

        if (oldLastRow > lastRow)
            for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)
                this.$lines.pop();

        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
        }

        if (lastRow > oldLastRow) {
            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
        }
        
        this.updateLineHighlight();
        
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    };

    this.$renderLines = function(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$renderCell(cell, config, foldLine, row);
            fragment.push(cell);

            row++;
        }
        return fragment;
    };
    
    this.$renderCell = function(cell, config, fold, row) {
        var element = cell.element;
        
        var session = this.session;
        
        var textNode = element.childNodes[0];
        var foldWidget = element.childNodes[1];

        var firstLineNumber = session.$firstLineNumber;
        
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
        
        var className = "ace_gutter-cell ";
        if (this.$highlightGutterLine) {
            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                    if (this.$cursorCell)
                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                    this.$cursorCell = cell;
                }
            }
        }
        
        if (breakpoints[row])
            className += breakpoints[row];
        if (decorations[row])
            className += decorations[row];
        if (this.$annotations[row])
            className += this.$annotations[row].className;
        if (element.className != className)
            element.className = className;

        if (foldWidgets) {
            var c = foldWidgets[row];
            if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
        }

        if (c) {
            var className = "ace_fold-widget ace_" + c;
            if (c == "start" && row == foldStart && row < fold.end.row)
                className += " ace_closed";
            else
                className += " ace_open";
            if (foldWidget.className != className)
                foldWidget.className = className;

            var foldHeight = config.lineHeight + "px";
            dom.setStyle(foldWidget.style, "height", foldHeight);
            dom.setStyle(foldWidget.style, "display", "inline-block");
        } else {
            if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
            }
        }
        
        var text = (gutterRenderer
            ? gutterRenderer.getText(session, row)
            : row + firstLineNumber).toString();
            
        if (text !== textNode.data) {
            textNode.data = text;
        }
        
        dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
        dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
        
        cell.text = text;
        return cell;
    };

    this.$fixedWidth = false;
    
    this.$highlightGutterLine = true;
    this.$renderer = "";
    this.setHighlightGutterLine = function(highlightGutterLine) {
        this.$highlightGutterLine = highlightGutterLine;
    };
    
    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
            getWidth: function() {return 0;},
            getText: function() {return "";}
        };
    };
    
    this.getShowLineNumbers = function() {
        return this.$showLineNumbers;
    };
    
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    
    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
            + (parseInt(style.paddingLeft) || 0) + 1;
        this.$padding.right = (parseInt(style.borderRightWidth) || 0)
            + (parseInt(style.paddingRight) || 0);
        return this.$padding;
    };

    this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };

}).call(Gutter.prototype);

function onCreateCell(element) {
    var textNode = document.createTextNode('');
    element.appendChild(textNode);
    
    var foldWidget = dom.createElement("span");
    element.appendChild(foldWidget);
    
    return element;
}

exports.Gutter = Gutter;

});

define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var dom = require("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };
    
    this.setMarkers = function(markers) {
        this.markers = markers;
    };
    
    this.elt = function(className, css) {
        var x = this.i != -1 && this.element.childNodes[this.i];
        if (!x) {
            x = document.createElement("div");
            this.element.appendChild(x);
            this.i = -1;
        } else {
            this.i++;
        }
        x.style.cssText = css;
        x.className = className;
    };

    this.update = function(config) {
        if (!config) return;

        this.config = config;

        this.i = 0;
        var html;
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
        }
        if (this.i !=-1) {
            while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
        }
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };

    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0; 
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, 
                clazz + (row == start  ? " ace_start" : "") + " ace_br"
                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),
                layerConfig, row == end ? 0 : 1, extraStyle);
        }
    };
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
           var range1 = range.clone();
           range1.end.row = range1.start.row;
           range1.end.column = this.session.getLine(range1.start.row).length;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
        } else {
            this.elt(
                clazz + " ace_br1 ace_start",
                "height:"+ height+ "px;"+ "right:0;"+ "top:"+top+ "px;left:"+ left+ "px;" + (extraStyle || "")
            );
        }
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
           var range1 = range.clone();
           range1.start.row = range1.end.row;
           range1.start.column = 0;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
        } else {
            top = this.$getTop(range.end.row, config);
            var width = range.end.column * config.characterWidth;

            this.elt(
                clazz + " ace_br12",
                "height:"+ height+ "px;"+
                "width:"+ width+ "px;"+
                "top:"+ top+ "px;"+
                "left:"+ padding+ "px;"+ (extraStyle || "")
            );
        }
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

        this.elt(
            clazz + (radiusClass ? " ace_br" + radiusClass : ""),
            "height:"+ height+ "px;"+
            "right:0;"+
            "top:"+ top+ "px;"+
            "left:"+ padding+ "px;"+ (extraStyle || "")
        );
    };
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        if (this.session.$bidiHandler.isBidiRow(range.start.row))
            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "width:"+ width+ "px;"+
            "top:"+ top+ "px;"+
            "left:"+ left+ "px;"+ (extraStyle || "")
        );
    };
    this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);

        selections.forEach(function(selection) {
            this.elt(
                clazz,
                "height:" + height + "px;" +
                "width:" + selection.width + (extraLength || 0) + "px;" +
                "top:" + top + "px;" +
                "left:" + (padding + selection.left) + "px;" + (extraStyle || "")
            );
        }, this);
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "top:"+ top+ "px;"+
            "left:0;right:0;"+ (extraStyle || "")
        );
    };
    
    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        this.elt(
            clazz,
            "height:"+ height+ "px;"+
            "top:"+ top+ "px;"+
            "left:0;right:0;"+ (extraStyle || "")
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});

define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var Lines = require("./lines").Lines;
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.dom = dom; 
    this.element = this.dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
    this.$lines = new Lines(this.element);
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2014"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;
    this.MAX_LINE_LENGTH = 10000;

    this.$updateEolChar = function() {
        var doc = this.session.doc;
        var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    };

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.margin = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
    };
    
    this.$setFontMetrics = function(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    };

    this.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function(session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };

    this.showInvisibles = false;
    this.showSpaces = false;
    this.showTabs = false;
    this.showEOL = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        if (typeof showInvisibles == "string") {
            this.showSpaces = /tab/i.test(showInvisibles);
            this.showTabs = /space/i.test(showInvisibles);
            this.showEOL = /eol/i.test(showInvisibles);
        } else {
            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
        }
        this.$computeTabString();
        return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
            } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
            var spaceContent = this.showSpaces
                ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
                : lang.stringRepeat(" ", this.tabSize);

            var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
            var tabContent = this.showTabs 
                ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
                : spaceContent;

            var span = this.dom.createElement("span");
            span.className = className + spaceClass;
            span.textContent = spaceContent;
            this.$tabStrings[" "] = span;
            
            var span = this.dom.createElement("span");
            span.className = className + tabClass;
            span.textContent = tabContent;
            this.$tabStrings["\t"] = span;
        }
    };

    this.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            return this.update(config);
        }
        
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var heightChanged = false;
        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(
                    lineElement, row, row == foldStart ? foldLine : false
                );

                if (heightChanged)
                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";

                var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
                if (lineElement.style.height != height) {
                    heightChanged = true;
                    lineElement.style.height = height;
                }
            }
            row++;
        }
        if (heightChanged) {
            while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
            }
        }
    };

    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;

        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
            
        this.$lines.moveContainer(config);
        
        var lastRow = config.lastRow;
        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;

        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);

        if (lastRow < oldConfig.firstRow)
            return this.update(config);

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                this.$lines.shift();

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                this.$lines.pop();

        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
        }

        if (config.lastRow > oldConfig.lastRow) {
            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var line = this.$lines.createCell(row, config, this.session);
            
            var lineEl = line.element;
            this.dom.removeChildren(lineEl);
            dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
            dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);

            if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
            } else {
                lineEl.className = "ace_line";
            }
            fragment.push(line);

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.$lines.moveContainer(config);
        
        this.config = config;

        var firstRow = config.firstRow;
        var lastRow = config.lastRow;

        var lines = this.$lines;
        while (lines.getLength())
            lines.pop();
            
        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(parent, screenColumn, token, value) {
        var self = this;
        var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
        
        var valueFragment = this.dom.createFragment(this.element);

        var m;
        var i = 0;
        while (m = re.exec(value)) {
            var tab = m[1];
            var simpleSpace = m[2];
            var controlCharacter = m[3];
            var cjkSpace = m[4];
            var cjk = m[5];
            
            if (!self.showSpaces && simpleSpace)
                continue;

            var before = i != m.index ? value.slice(i, m.index) : "";

            i = m.index + m[0].length;
            
            if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
            }
                
            if (tab) {
                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
            } else if (simpleSpace) {
                if (self.showSpaces) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space";
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                    valueFragment.appendChild(span);
                } else {
                    valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                }
            } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
            } else if (cjkSpace) {
                screenColumn += 1;
                
                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
            } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
            }
        }
        
        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var span = this.dom.createElement("span");
            if (token.type == "fold")
                span.style.width = (token.value.length * this.config.characterWidth) + "px";
                
            span.className = classes;
            span.appendChild(valueFragment);
            
            parent.appendChild(span);
        }
        else {
            parent.appendChild(valueFragment);
        }
        
        return screenColumn + value.length;
    };

    this.renderIndentGuide = function(parent, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            var count = cols/this.tabSize;
            for (var i=0; i<count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
            }
            return value.substr(cols);
        } else if (value[0] == "\t") {
            for (var i=0; i<cols; i++) {
                parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
            }
            return value.substr(cols);
        }
        return value;
    };

    this.$createLineElement = function(parent) {
        var lineEl = this.dom.createElement("div");
        lineEl.className = "ace_line";
        lineEl.style.height = this.config.lineHeight + "px";
        
        return lineEl;
    };

    this.$renderWrappedLine = function(parent, tokens, splits) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        var lineEl = this.$createLineElement();
        parent.appendChild(lineEl);
        
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        lineEl, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    lineEl = this.$createLineElement();
                    parent.appendChild(lineEl);

                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        lineEl, screenColumn, token, value
                    );
                }
            }
        }
        
        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
            this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
    };

    this.$renderSimpleLine = function(parent, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
            value = this.renderIndentGuide(parent, value);
        if (value)
            screenColumn = this.$renderToken(parent, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
            screenColumn = this.$renderToken(parent, screenColumn, token, value);
        }
    };
    
    this.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
        token && this.$renderToken(parent, screenColumn, token,
            value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            
        var overflowEl = this.dom.createElement("span");
        overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
        overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
        
        parent.appendChild(overflowEl);        
    };
    this.$renderLine = function(parent, row, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);

        var lastLineEl = parent;
        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
            } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                    lastLineEl = this.$createLineElement();
                    parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
            }
        } else if (this.$useLineGroups()) {
            lastLineEl = this.$createLineElement();
            parent.appendChild(lastLineEl);
        }

        if (this.showEOL && lastLineEl) {
            if (foldLine)
                row = foldLine.end.row;

            var invisibleEl = this.dom.createElement("span");
            invisibleEl.className = "ace_invisible ace_invisible_eol";
            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
            
            lastLineEl.appendChild(invisibleEl);
        }
    };

    this.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    };

    this.$useLineGroups = function() {
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {};
}).call(Text.prototype);

exports.Text = Text;

});

define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);
    
    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = this.$updateOpacity.bind(this);
};

(function() {
    
    this.$updateOpacity = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
    };

    this.$startCssAnimation = function() {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.animationDuration = this.blinkInterval + "ms";

        setTimeout(function() {
            dom.addCssClass(this.element, "ace_animate-blinking");
        }.bind(this));
    };
    
    this.$stopCssAnimation = function() {
        dom.removeCssClass(this.element, "ace_animate-blinking");
    };

    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };

    this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.restartTimer();
        }
    };

    this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };

    this.removeCursor = function() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        this.$stopCssAnimation();

        if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        
        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
        }

        if (this.smoothBlinking) {
            setTimeout(function(){
                dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
        }
        
        if (dom.HAS_CSS_ANIMATION) {
            this.$startCssAnimation();
        } else {
            var blink = function(){
                this.timeoutId = setTimeout(function() {
                    update(false);
                }, 0.6 * this.blinkInterval);
            }.bind(this);
    
            this.intervalId = setInterval(function() {
                update(true);
                blink();
            }, this.blinkInterval);
            blink();
        }
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : pos.column * this.config.characterWidth);

        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    };

    this.isCursorInView = function(pixelPos, config) {
        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
    };

    this.update = function(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var element = this.cursors[cursorIndex++] || this.addCursor();
            var style = element.style;
            
            if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                    dom.setStyle(style, "display", "none");
                } else {
                    dom.setStyle(style, "display", "block");
                    dom.translate(element, pixelPos.left, pixelPos.top);
                    dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                    dom.setStyle(style, "height", config.lineHeight + "px");
                }
            } else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };
    
    this.drawCursor = null;

    this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };

    this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});

define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var MAX_SCROLL_H = 0x8000;
var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.inner.textContent = "\xa0";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};

(function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    renderer.$scrollbarWidth = 
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
    this.element.style.width = (this.width || 15) + 5 + "px";
    this.$minWidth = 0;
};

oop.inherits(VScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-v';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    };
    this.getWidth = function() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    };
    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };
    this.setInnerHeight = 
    this.setScrollHeight = function(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
            this.coeff = 1;
        }
        this.inner.style.height = height + "px";
    };
    this.setScrollTop = function(scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    };

}).call(VScrollBar.prototype);
var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
    this.element.style.height = (this.height || 15) + 5 + "px";
};

oop.inherits(HScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-h';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    };
    this.getHeight = function() {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function(width) {
        this.element.style.width = width + "px";
    };
    this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function(scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };

}).call(HScrollBar.prototype);


exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility

exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;
});

define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module) {
"use strict";

var event = require("./lib/event");


var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.$recursionLimit = 2;
    this.window = win || window;
    var _self = this;
    this._flush = function(ts) {
        _self.pending = false;
        var changes = _self.changes;

        if (changes) {
            event.blockIdle(100);
            _self.changes = 0;
            _self.onRender(changes);
        }
        
        if (_self.changes) {
            if (_self.$recursionLimit-- < 0) return;
            _self.schedule();
        } else {
            _self.$recursionLimit = 2;
        }
    };
};

(function() {

    this.schedule = function(change) {
        this.changes = this.changes | change;
        if (this.changes && !this.pending) {
            event.nextFrame(this._flush);
            this.pending = true;
        }
    };

    this.clear = function(change) {
        var changes = this.changes;
        this.changes = 0;
        return changes;
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});

define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module) {

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var event = require("../lib/event");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var CHAR_COUNT = 256;
var USE_OBSERVER = typeof ResizeObserver == "function";
var L = 200;

var FontMetrics = exports.FontMetrics = function(parentEl) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);
    
    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);
    
    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);
    
    
    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);
    
    this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
    
    this.$characterSize = {width: 0, height: 0};
    
    
    if (USE_OBSERVER)
        this.$addObserver();
    else
        this.checkForSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);
        
    this.$characterSize = {width: 0, height: 0};
    
    this.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    };

    this.checkForSizeChanges = function(size) {
        if (size === undefined)
            size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    };
    
    this.$addObserver = function() {
        var self = this;
        this.$observer = new window.ResizeObserver(function(e) {
            self.checkForSizeChanges();
        });
        this.$observer.observe(this.$measureNode);
    };

    this.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
        var self = this;
        
        return this.$pollSizeChangesTimer = event.onIdle(function cb() {
            self.checkForSizeChanges();
            event.onIdle(cb, 500);
        }, 500);
    };
    
    this.setPolling = function(val) {
        if (val) {
            this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    };

    this.$measureSizes = function(node) {
        var size = {
            height: (node || this.$measureNode).clientHeight,
            width: (node || this.$measureNode).clientWidth / CHAR_COUNT
        };
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    };

    this.$measureCharWidth = function(ch) {
        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    };
    
    this.getCharacterWidth = function(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$observer)
            this.$observer.disconnect();
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };

    
    this.$getZoom = function getZoom(element) {
        if (!element) return 1;
        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);
    };
    this.$initTransformMeasureNodes = function() {
        var t = function(t, l) {
            return ["div", {
                style: "position: absolute;top:" + t + "px;left:" + l + "px;"
            }];
        };
        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
    };
    this.transformCoordinates = function(clientPos, elPos) {
        if (clientPos) {
            var zoom = this.$getZoom(this.el);
            clientPos = mul(1 / zoom, clientPos);
        }
        function solve(l1, l2, r) {
            var det = l1[1] * l2[0] - l1[0] * l2[1];
            return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
            ];
        }
        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
        function mul(a, b) { return [a * b[0], a * b[1]]; }

        if (!this.els)
            this.$initTransformMeasureNodes();
        
        function p(el) {
            var r = el.getBoundingClientRect();
            return [r.left, r.top];
        }

        var a = p(this.els[0]);
        var b = p(this.els[1]);
        var c = p(this.els[2]);
        var d = p(this.els[3]);

        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));

        var m1 = mul(1 + h[0], sub(b, a));
        var m2 = mul(1 + h[1], sub(c, a));
        
        if (elPos) {
            var x = elPos;
            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
            var ut = add(mul(x[0], m1), mul(x[1], m2));
            return  add(mul(1 / k / L, ut), a);
        }
        var u = sub(clientPos, a);
        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
        return mul(L, f);
    };
    
}).call(FontMetrics.prototype);

});

define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/lib/useragent"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var config = require("./config");
var GutterLayer = require("./layer/gutter").Gutter;
var MarkerLayer = require("./layer/marker").Marker;
var TextLayer = require("./layer/text").Text;
var CursorLayer = require("./layer/cursor").Cursor;
var HScrollBar = require("./scrollbar").HScrollBar;
var VScrollBar = require("./scrollbar").VScrollBar;
var RenderLoop = require("./renderloop").RenderLoop;
var FontMetrics = require("./layer/font_metrics").FontMetrics;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var editorCss = "\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
.ace_editor {\
position: relative;\
overflow: hidden;\
padding: 0;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
box-sizing: border-box;\
min-width: 100%;\
contain: style size layout;\
font-variant-ligatures: no-common-ligatures;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
contain: style size layout;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
contain: strict;\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
contain: strict;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: transparent;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
}\
.ace_composition_placeholder { color: transparent }\
.ace_composition_marker { \
border-bottom: 1px solid;\
position: absolute;\
border-radius: 0;\
margin-top: 1px;\
}\
[ace_nocontext=true] {\
transform: none!important;\
filter: none!important;\
clip-path: none!important;\
mask : none!important;\
contain: none!important;\
perspective: none!important;\
mix-blend-mode: initial!important;\
z-index: auto;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
height: 1000000px;\
contain: style size layout;\
}\
.ace_text-layer {\
font: inherit !important;\
position: absolute;\
height: 1000000px;\
width: 1000000px;\
contain: style size layout;\
}\
.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\
contain: style size layout;\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
}\
.ace_hidpi .ace_text-layer,\
.ace_hidpi .ace_gutter-layer,\
.ace_hidpi .ace_content,\
.ace_hidpi .ace_gutter {\
contain: strict;\
will-change: transform;\
}\
.ace_hidpi .ace_text-layer > .ace_line, \
.ace_hidpi .ace_text-layer > .ace_line_group {\
contain: strict;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\
opacity: 0;\
}\
.ace_smooth-blinking .ace_cursor {\
transition: opacity 0.18s;\
}\
.ace_animate-blinking .ace_cursor {\
animation-duration: 1000ms;\
animation-timing-function: step-end;\
animation-name: blink-ace-animate;\
animation-iteration-count: infinite;\
}\
.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\
animation-duration: 1000ms;\
animation-timing-function: ease-in-out;\
animation-name: blink-ace-animate-smooth;\
}\
@keyframes blink-ace-animate {\
from, to { opacity: 1; }\
60% { opacity: 0; }\
}\
@keyframes blink-ace-animate-smooth {\
from, to { opacity: 1; }\
45% { opacity: 1; }\
60% { opacity: 0; }\
85% { opacity: 0; }\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_error_bracket {\
position: absolute;\
border-bottom: 1px solid #DE5555;\
border-radius: 0;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_inline_button {\
border: 1px solid lightgray;\
display: inline-block;\
margin: -1px 8px;\
padding: 0 5px;\
pointer-events: auto;\
cursor: pointer;\
}\
.ace_inline_button:hover {\
border-color: gray;\
background: rgba(200,200,200,0.2);\
display: inline-block;\
pointer-events: auto;\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_mobile-menu {\
position: absolute;\
line-height: 1.5;\
border-radius: 4px;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
background: white;\
box-shadow: 1px 3px 2px grey;\
border: 1px solid #dcdcdc;\
color: black;\
}\
.ace_dark > .ace_mobile-menu {\
background: #333;\
color: #ccc;\
box-shadow: 1px 3px 2px grey;\
border: 1px solid #444;\
}\
.ace_mobile-button {\
padding: 2px;\
cursor: pointer;\
overflow: hidden;\
}\
.ace_mobile-button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_mobile-button:active {\
background-color: #ddd;\
}\
.ace_placeholder {\
font-family: arial;\
transform: scale(0.9);\
transform-origin: left;\
white-space: pre;\
opacity: 0.7;\
margin: 0 10px;\
}";

var useragent = require("./lib/useragent");
var HIDE_TEXTAREA = useragent.isIE;

dom.importCssString(editorCss, "ace_editor.css");

var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");

    dom.addCssClass(this.container, "ace_editor");
    if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);
    this.$gutter.setAttribute("aria-hidden", true);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar = 
    this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.on("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.on("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$fontMetrics = new FontMetrics(this.container);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.on("changeCharacterSize", function(e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e);
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 0,
        characterWidth : 0,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1,
        gutterOffset: 1
    };
    
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };
    
    this.margin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };
    
    this.$keepTextAreaAtCursor = !useragent.isIOS;

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._signal("renderer", this);
};

(function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
        dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
    };
    this.setSession = function(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            
        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;
        
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };
    this.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeNewLineMode = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
    };
    
    this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

        
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
    };
    
    this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            
            this.gutterWidth = gutterWidth;
            
            dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
            dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
            dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
            
            var right = this.scrollBarV.getWidth() + "px";
            dom.setStyle(this.scrollBarH.element.style, "right", right);
            dom.setStyle(this.scroller.style, "right", right);
            dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
            }
        }
        
        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };

    this.onGutterResize = function(width) {
        var gutterWidth = this.$showGutter ? width : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
        }
    };
    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function() {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function(){
        return this.getOption("showGutter");
    };
    this.setShowGutter = function(show){
        return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
        return this.getOption("fadeFoldWidgets");
    };

    this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        
        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function() {
        return this.container;
    };
    this.getMouseEventTarget = function() {
        return this.scroller;
    };
    this.getTextAreaContainer = function() {
        return this.container;
    };
    this.$moveTextAreaToCursor = function() {
        if (this.$isMousePressed) return;
        var style = this.textarea.style;
        var composition = this.$composition;
        if (!this.$keepTextAreaAtCursor && !composition) {
            dom.translate(this.textarea, -100, 0);
            return;
        }
        var pixelPos = this.$cursorLayer.$pixelPos;
        if (!pixelPos)
            return;
        if (composition && composition.markerRange)
            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
        
        var config = this.layerConfig;
        var posTop = pixelPos.top;
        var posLeft = pixelPos.left;
        posTop -= config.offset;

        var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;
        if (posTop < 0 || posTop > config.height - h) {
            dom.translate(this.textarea, 0, 0);
            return;
        }

        var w = 1;
        var maxTop = this.$size.height - h;
        if (!composition) {
            posTop += this.lineHeight;
        }
        else {
            if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
            }
            else {
                posTop += this.lineHeight + 2;
            }
        }
        
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth + this.margin.left;

        dom.setStyle(style, "height", h + "px");
        dom.setStyle(style, "width", w + "px");
        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
    };
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function() {
        var config = this.layerConfig;
        var lastRow = config.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    };
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    
    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };
    
    this.setMargin = function(top, bottom, left, right) {
        var sm = this.margin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    
    this.$frozen = false;
    this.freeze = function() {
        this.$frozen = true;
    };
    
    this.unfreeze = function() {
        this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return; 
        } 
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        
        this._signal("beforeRender", changes);
        
        if (this.session && this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);

        var config = this.layerConfig;
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig() | this.$loop.clear();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            
            var width = config.width + 2 * this.$padding + "px";
            var height = config.minHeight + "px";
            
            dom.setStyle(this.content.style, "width", width);
            dom.setStyle(this.content.style, "height", height);
        }
        if (changes & this.CHANGE_H_SCROLL) {
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }
        if (changes & this.CHANGE_SCROLL) {
            this.$changedLines = null;
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                    this.$gutterLayer.update(config);
                else
                    this.$gutterLayer.scrollLines(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_CURSOR) {
            if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config);
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender", changes);
    };

    
    this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight, 
            Math.max((this.$minLines || 1) * this.lineHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;
        
        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
        var vScroll = !hideScrollbars && height > maxHeight;
        
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            
            this._signal("autosize");
        }
    };
    
    this.$computeLayerConfig = function() {
        var session = this.session;
        var size = this.$size;
        
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var longestLine = this.$getLongestLine();
        
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var minHeight = size.scrollerHeight + this.lineHeight;
        
        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;
        
        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
        
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var offset = this.scrollTop % this.lineHeight;
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (this.layerConfig.width != longestLine || hScrollChanged) 
            changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        
        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height : this.$size.scrollerHeight
        };

        if (this.session.$bidiHandler)
            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);

        return changes;
    };

    this.$updateLines = function() {
        if (!this.$changedLines) return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;
            
        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var left = pos.left;
        var top = pos.top;
        
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        
        if (scrollTop + topMargin > top) {
            if (offset && scrollTop + topMargin > top + this.lineHeight)
                top -= offset * this.$size.scrollerHeight;
            if (top === 0)
                top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
                top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
        }
    };
    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };
    this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        
        if (fromValue == toValue)
            return;
        
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
            if (!_self.session) 
                return clearInterval(_self.$timer);
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
            }
        }, 10);
    };
    this.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
    };
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = {top:0, left: 0};
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        } else {
            canvasPos = this.scroller.getBoundingClientRect();
        }
        
        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};
    };

    this.screenToTextCoordinates = function(x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = {top:0, left: 0};
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        } else {
            canvasPos = this.scroller.getBoundingClientRect();
        }

        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);

        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);

        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
    };
    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
             ? this.session.$bidiHandler.getPosLeft(pos.column)
             : Math.round(pos.column * this.characterWidth));
        
        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function(composition) {
        this.$composition = composition;
        if (!composition.cssText) {
            composition.cssText = this.textarea.style.cssText;
        }
        if (composition.useTextareaForIME == undefined)
            composition.useTextareaForIME = this.$useTextareaForIME;
        
        if (this.$useTextareaForIME) {
            dom.addCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = "";
            this.$moveTextAreaToCursor();
            this.$cursorLayer.element.style.display = "none";
        }
        else {
            composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
        }
    };
    this.setCompositionText = function(text) {
        var cursor = this.session.selection.cursor;
        this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function() {
        if (!this.$composition)
            return;
        
        if (this.$composition.markerId)
            this.session.removeMarker(this.$composition.markerId);

        dom.removeCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = this.$composition.cssText;
        var cursor = this.session.selection.cursor;
        this.removeExtraToken(cursor.row, cursor.column);
        this.$composition = null;
        this.$cursorLayer.element.style.display = "";
    };
    
    this.addToken = function(text, type, row, column) {
        var session = this.session;
        session.bgTokenizer.lines[row] = null;
        var newToken = {type: type, value: text};
        var tokens = session.getTokens(row);
        if (column == null) {
            tokens.push(newToken);
        } else {
            var l = 0;
            for (var i =0; i < tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column <= l) {
                    var diff = token.value.length - (l - column);
                    var before = token.value.slice(0, diff);
                    var after = token.value.slice(diff);
    
                    tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});
                    break;
                }
            }
        }
        this.updateLines(row, row);
    };

    this.removeExtraToken = function(row, column) {
        this.updateLines(row, row);
    };
    this.setTheme = function(theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module || !module.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
            if (module.$id)
                _self.$themeId = module.$id;
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container
            );

            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);

            var padding = "padding" in module ? module.padding 
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();
        }
    };
    this.getTheme = function() {
        return this.$themeId;
    };
    this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
    };
    
    this.setCursorStyle = function(style) {
        dom.setStyle(this.scroller.style, "cursor", style);
    };
    this.setMouseCursor = function(cursorStyle) {
        dom.setStyle(this.scroller.style, "cursor", cursorStyle);
    };
    
    this.attachToShadowRoot = function() {
        dom.importCssString(editorCss, "ace_editor.css", this.container);
    };
    this.destroy = function() {
        this.freeze();
        this.$fontMetrics.destroy();
        this.$cursorLayer.destroy();
        this.removeAllListeners();
        this.container.textContent = "";
    };

}).call(VirtualRenderer.prototype);


config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn; 
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize: {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function(val) {
            if (!(this.$minLines < 0x1ffffffffffff))
                this.$minLines = 0;
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function(val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    theme: {
        set: function(val) { this.setTheme(val); },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    },
    hasCssTransforms: {
    },
    useTextareaForIME: {
        initialValue: !useragent.isMobile && !useragent.isIE
    }
});

exports.VirtualRenderer = VirtualRenderer;
});

define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var net = require("../lib/net");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var config = require("../config");

function $workerBlob(workerUrl) {
    var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
    try {
        return new Blob([script], {"type": "application/javascript"});
    } catch (e) { // Backwards-compatibility
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob("application/javascript");
    }
}

function createWorker(workerUrl) {
    if (typeof Worker == "undefined")
        return { postMessage: function() {}, terminate: function() {} };
    if (config.get("loadWorkerFromBlob")) {
        var blob = $workerBlob(workerUrl);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);
        return new Worker(blobURL);
    }
    return new Worker(workerUrl);
}

var WorkerClient = function(worker) {
    if (!worker.postMessage)
        worker = this.$createWorkerFromOldConfig.apply(this, arguments);

    this.$worker = worker;
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
        if (require.nameToUrl && !require.toUrl)
            require.toUrl = require.nameToUrl;

        if (config.get("packaged") || !require.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
        } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
                tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
        }

        this.$worker = createWorker(workerUrl);
        if (importScripts) {
            this.send("importScripts", importScripts);
        }
        this.$worker.postMessage({
            init : true,
            tlns : tlns,
            module : mod,
            classname : classname
        });
        return this.$worker;
    };

    this.onMessage = function(e) {
        var msg = e.data;
        switch (msg.type) {
            case "event":
                this._signal(msg.name, {data: msg.data});
                break;
            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case "error":
                this.reportError(msg.data);
                break;
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
        }
    };
    
    this.reportError = function(err) {
        window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            if (data.data && data.data.err)
                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if (this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(delta) {
        if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
        else
            this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);

    var messageBuffer = [];
    var workerClient = new WorkerClient({
        messageBuffer: messageBuffer,
        terminate: function() {},
        postMessage: function(e) {
            messageBuffer.push(e);
            if (!main) return;
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    });

    workerClient.setEmitSync = function(val) { emitSync = val; };

    var processNext = function() {
        var msg = messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        workerClient.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (messageBuffer.length)
            processNext();
    });

    return workerClient;
};

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;
exports.createWorker = createWorker;


});

define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module) {
"use strict";

var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var oop = require("./lib/oop");

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;
    
    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };
    
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth = undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);
    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function() {
        if (this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
        });
    };
    this.hideOtherMarkers = function() {
        if (!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function(delta) {
        if (this.$updating)
            return this.updateAnchors(delta);
            
        var range = delta;
        if (range.start.row !== range.end.row) return;
        if (range.start.row !== this.pos.row) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;
        
        this.updateAnchors(delta);
        
        if (inMainRange)
            this.length += lengthDiff;

        if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            } else if (delta.action === 'remove') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }
        
        this.$updating = false;
        this.updateMarkers();
    };
    
    this.updateAnchors = function(delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    };
    
    this.updateMarkers = function() {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    };

    this.onCursorChange = function(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };    
    this.detach = function() {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.off("change", this.$onUpdate);
        this.session.selection.off("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    };
    this.cancel = function() {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(this.session, true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});

define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module) {

var event = require("../lib/event");
var useragent = require("../lib/useragent");
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    
    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    
    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }
    
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        editor.inVirtualSelectionMode = true;
        
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;        
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
        };
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);            
        else
            selection.moveToPosition(pos);
        
        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.onMouseDown = onMouseDown;

});

define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module) {
exports.defaultCommands = [{
    name: "addCursorAbove",
    description: "Add cursor above",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelow",
    description: "Add cursor below",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorAboveSkipCurrent",
    description: "Add cursor above (skip current)",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelowSkipCurrent",
    description: "Add cursor below (skip current)",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreBefore",
    description: "Select more before",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreAfter",
    description: "Select more after",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextBefore",
    description: "Select next before",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextAfter",
    description: "Select next after",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "toggleSplitSelectionIntoLines",
    description: "Split into lines",
    exec: function(editor) {
        if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
        else
            editor.multiSelect.splitIntoLines();
    },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
}, {
    name: "splitSelectionIntoLines",
    description: "Split into lines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    readOnly: true
}, {
    name: "alignCursors",
    description: "Align cursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    description: "Find all",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
}];
exports.multiSelectCommands = [{
    name: "singleSelection",
    description: "Single selection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}
}];

var HashHandler = require("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module) {

var RangeList = require("./range_list").RangeList;
var Range = require("./range").Range;
var Selection = require("./selection").Selection;
var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
var event = require("./lib/event");
var lang = require("./lib/lang");
var commands = require("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = require("./search").Search;
var search = new Search();

function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = require("./edit_session").EditSession;
(function() {
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function() {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };
    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
    };

    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };
    this.splitIntoLines = function () {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
                newRanges.push(range.clone());
            } else {
                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                while (++row < endRow)
                    newRanges.push(this.getLineRange(row, true));
                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
                newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--;)
            this.addRange(newRanges[i]);
    };
    
    this.joinSelections = function () {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);

        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        var docEnd;
        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);
var Editor = require("./editor").Editor;
(function() {
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    }; 
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        
        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};

        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
        
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        
        return result;
    };
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    
    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row 
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
                this.multiSelect.mergeOverlappingRanges();
        }
    };
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }    
        this.$search.set(options);
        
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
        
        return ranges.length;
    };
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
    };
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });
        
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                
                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

function addAltCursorListeners(editor){
    if (!editor.textInput) return;
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    }, editor);

    event.addListener(el, "keyup", reset, editor);
    event.addListener(el, "blur", reset, editor);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
        }
    }
}

exports.MultiSelect = MultiSelect;


require("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function(val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});



});

define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../../range").Range;

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel) {
                var token = session.getTokenAt(row, 0);
                if (!token || token.type !== "string")
                    break;
            }

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";

exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
exports.$id = "ace/theme/textmate";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

define("ace/line_widgets",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
"use strict";

var dom = require("./lib/dom");

function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);
    
    this.session.on("change", this.updateOnChange);
    this.session.on("changeFold", this.updateOnFold);
    this.session.on("changeEditor", this.$onChangeEditor);
}

(function() {
    this.getRowLength = function(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };

    this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    };    
    
    this.$onChangeEditor = function(e) {
        this.attach(e.editor);
    };
    
    this.attach = function(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        this.editor = editor;
        
        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    };
    this.detach = function(e) {
        var editor = this.editor;
        if (!editor)
            return;
        
        this.editor = null;
        editor.widgetManager = null;
        
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };

    this.updateOnFold = function(e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == "add";
        for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            } else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    };
    
    this.updateOnChange = function(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
        } else if (delta.action == "remove") {
            var removed = lineWidgets.splice(startRow + 1, len);
            if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
            }
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                    startRow++;
            }
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    
    this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };

    this.$registerLineWidget = function(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        
        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }
            
        this.session.lineWidgets[w.row] = w;
        return w;
    };
    
    this.addLineWidget = function(w) {
        this.$registerLineWidget(w);
        w.session = this.session;
        
        if (!this.editor) return w;
        
        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
            
            if (!w.coverGutter) {
                w.el.style.zIndex = 3;
            }
            if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
            }
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }
        
        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }
            
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        
        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    };
    
    this.removeLineWidget = function(w) {
        w._inDocument = false;
        w.session = null;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            } else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    };
    
    this.getWidgetsAtRow = function(row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets && lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    };
    
    this.onWidgetChanged = function(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };
    
    this.measureWidgets = function(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        
        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el) continue;
            if (w.session != this.session) continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            
            w.h = w.el.offsetHeight;
            
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    
    this.renderWidgets = function(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        
        while (first > 0 && !lineWidgets[first])
            first--;
        
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            
            if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            
            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    };
    
}).call(LineWidgets.prototype);


exports.LineWidgets = LineWidgets;

});

define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(require, exports, module) {
"use strict";
var LineWidgets = require("../line_widgets").LineWidgets;
var dom = require("../lib/dom");
var Range = require("../range").Range;

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}

function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
        return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");
    
    el.appendChild(dom.createElement("div"));
    
    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };
    
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
    
    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});

define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");

var dom = require("./lib/dom");
var event = require("./lib/event");

var Range = require("./range").Range;
var Editor = require("./editor").Editor;
var EditSession = require("./edit_session").EditSession;
var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;
require("./worker/worker_client");
require("./keyboard/hash_handler");
require("./placeholder");
require("./multi_select");
require("./mode/folding/fold_mode");
require("./theme/textmate");
require("./ext/error_marker");

exports.config = require("./config");
exports.require = require;

if (typeof define === "function")
    exports.define = define;
exports.edit = function(el, options) {
    if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
        value = el.textContent;
        el.innerHTML = "";
    }

    var doc = exports.createEditSession(value);

    var editor = new Editor(new Renderer(el), doc, options);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
};
exports.Range = Range;
exports.Editor = Editor;
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.VirtualRenderer = Renderer;
exports.version = exports.config.version;
});            (function() {
                window.require(["ace/ace"], function(a) {
                    if (a) {
                        a.config.init(true);
                        a.define = window.define;
                    }
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                    window.ace["default"] = window.ace;
                    if (typeof module == "object" && typeof exports == "object" && module) {
                        module.exports = window.ace;
                    }
                });
            })();
        
define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var DocCommentHighlightRules = function() {
    this.$rules = {
        "start" : [ {
            token : "comment.doc.tag",
            regex : "@[\\w\\d_]+" // TODO: fix email addresses
        }, 
        DocCommentHighlightRules.getTagRule(),
        {
            defaultToken : "comment.doc",
            caseInsensitive: true
        }]
    };
};

oop.inherits(DocCommentHighlightRules, TextHighlightRules);

DocCommentHighlightRules.getTagRule = function(start) {
    return {
        token : "comment.doc.tag.storage.type",
        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
};

DocCommentHighlightRules.getStartRule = function(start) {
    return {
        token : "comment.doc", // doc comment
        regex : "\\/\\*(?=\\*)",
        next  : start
    };
};

DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token : "comment.doc", // closing comment
        regex : "\\*\\/",
        next  : start
    };
};


exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

define("ace/mode/c_cpp_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var cFunctions = exports.cFunctions = "\\b(?:hypot(?:f|l)?|s(?:scanf|ystem|nprintf|ca(?:nf|lb(?:n(?:f|l)?|ln(?:f|l)?))|i(?:n(?:h(?:f|l)?|f|l)?|gn(?:al|bit))|tr(?:s(?:tr|pn)|nc(?:py|at|mp)|c(?:spn|hr|oll|py|at|mp)|to(?:imax|d|u(?:l(?:l)?|max)|k|f|l(?:d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(?:jmp|vbuf|locale|buf)|qrt(?:f|l)?|w(?:scanf|printf)|rand)|n(?:e(?:arbyint(?:f|l)?|xt(?:toward(?:f|l)?|after(?:f|l)?))|an(?:f|l)?)|c(?:s(?:in(?:h(?:f|l)?|f|l)?|qrt(?:f|l)?)|cos(?:h(?:f)?|f|l)?|imag(?:f|l)?|t(?:ime|an(?:h(?:f|l)?|f|l)?)|o(?:s(?:h(?:f|l)?|f|l)?|nj(?:f|l)?|pysign(?:f|l)?)|p(?:ow(?:f|l)?|roj(?:f|l)?)|e(?:il(?:f|l)?|xp(?:f|l)?)|l(?:o(?:ck|g(?:f|l)?)|earerr)|a(?:sin(?:h(?:f|l)?|f|l)?|cos(?:h(?:f|l)?|f|l)?|tan(?:h(?:f|l)?|f|l)?|lloc|rg(?:f|l)?|bs(?:f|l)?)|real(?:f|l)?|brt(?:f|l)?)|t(?:ime|o(?:upper|lower)|an(?:h(?:f|l)?|f|l)?|runc(?:f|l)?|gamma(?:f|l)?|mp(?:nam|file))|i(?:s(?:space|n(?:ormal|an)|cntrl|inf|digit|u(?:nordered|pper)|p(?:unct|rint)|finite|w(?:space|c(?:ntrl|type)|digit|upper|p(?:unct|rint)|lower|al(?:num|pha)|graph|xdigit|blank)|l(?:ower|ess(?:equal|greater)?)|al(?:num|pha)|gr(?:eater(?:equal)?|aph)|xdigit|blank)|logb(?:f|l)?|max(?:div|abs))|di(?:v|fftime)|_Exit|unget(?:c|wc)|p(?:ow(?:f|l)?|ut(?:s|c(?:har)?|wc(?:har)?)|error|rintf)|e(?:rf(?:c(?:f|l)?|f|l)?|x(?:it|p(?:2(?:f|l)?|f|l|m1(?:f|l)?)?))|v(?:s(?:scanf|nprintf|canf|printf|w(?:scanf|printf))|printf|f(?:scanf|printf|w(?:scanf|printf))|w(?:scanf|printf)|a_(?:start|copy|end|arg))|qsort|f(?:s(?:canf|e(?:tpos|ek))|close|tell|open|dim(?:f|l)?|p(?:classify|ut(?:s|c|w(?:s|c))|rintf)|e(?:holdexcept|set(?:e(?:nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(?:aiseexcept|ror)|get(?:e(?:nv|xceptflag)|round))|flush|w(?:scanf|ide|printf|rite)|loor(?:f|l)?|abs(?:f|l)?|get(?:s|c|pos|w(?:s|c))|re(?:open|e|ad|xp(?:f|l)?)|m(?:in(?:f|l)?|od(?:f|l)?|a(?:f|l|x(?:f|l)?)?))|l(?:d(?:iv|exp(?:f|l)?)|o(?:ngjmp|cal(?:time|econv)|g(?:1(?:p(?:f|l)?|0(?:f|l)?)|2(?:f|l)?|f|l|b(?:f|l)?)?)|abs|l(?:div|abs|r(?:int(?:f|l)?|ound(?:f|l)?))|r(?:int(?:f|l)?|ound(?:f|l)?)|gamma(?:f|l)?)|w(?:scanf|c(?:s(?:s(?:tr|pn)|nc(?:py|at|mp)|c(?:spn|hr|oll|py|at|mp)|to(?:imax|d|u(?:l(?:l)?|max)|k|f|l(?:d|l)?|mbs)|pbrk|ftime|len|r(?:chr|tombs)|xfrm)|to(?:b|mb)|rtomb)|printf|mem(?:set|c(?:hr|py|mp)|move))|a(?:s(?:sert|ctime|in(?:h(?:f|l)?|f|l)?)|cos(?:h(?:f|l)?|f|l)?|t(?:o(?:i|f|l(?:l)?)|exit|an(?:h(?:f|l)?|2(?:f|l)?|f|l)?)|b(?:s|ort))|g(?:et(?:s|c(?:har)?|env|wc(?:har)?)|mtime)|r(?:int(?:f|l)?|ound(?:f|l)?|e(?:name|alloc|wind|m(?:ove|quo(?:f|l)?|ainder(?:f|l)?))|a(?:nd|ise))|b(?:search|towc)|m(?:odf(?:f|l)?|em(?:set|c(?:hr|py|mp)|move)|ktime|alloc|b(?:s(?:init|towcs|rtowcs)|towc|len|r(?:towc|len))))\\b";

var c_cppHighlightRules = function() {

    var keywordControls = (
        "break|case|continue|default|do|else|for|goto|if|_Pragma|" +
        "return|switch|while|catch|operator|try|throw|using"
    );
    
    var storageType = (
        "asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|" +
        "_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void|" +
        "class|wchar_t|template|char16_t|char32_t"
    );

    var storageModifiers = (
        "const|extern|register|restrict|static|volatile|inline|private|" +
        "protected|public|friend|explicit|virtual|export|mutable|typename|" +
        "constexpr|new|delete|alignas|alignof|decltype|noexcept|thread_local"
    );

    var keywordOperators = (
        "and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|" +
        "const_cast|dynamic_cast|reinterpret_cast|static_cast|sizeof|namespace"
    );

    var builtinConstants = (
        "NULL|true|false|TRUE|FALSE|nullptr"
    );

    var keywordMapper = this.$keywords = this.createKeywordMapper({
        "keyword.control" : keywordControls,
        "storage.type" : storageType,
        "storage.modifier" : storageModifiers,
        "keyword.operator" : keywordOperators,
        "variable.language": "this",
        "constant.language": builtinConstants
    }, "identifier");

    var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";
    var escapeRe = /\\(?:['"?\\abfnrtv]|[0-7]{1,3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}U[a-fA-F\d]{8}|.)/.source;
    var formatRe = "%"
          + /(\d+\$)?/.source // field (argument #)
          + /[#0\- +']*/.source // flags
          + /[,;:_]?/.source // separator character (AltiVec)
          + /((-?\d+)|\*(-?\d+\$)?)?/.source // minimum field width
          + /(\.((-?\d+)|\*(-?\d+\$)?)?)?/.source // precision
          + /(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?/.source // length modifier
          + /(\[[^"\]]+\]|[diouxXDOUeEfFgGaACcSspn%])/.source; // conversion type

    this.$rules = { 
        "start" : [
            {
                token : "comment",
                regex : "//$",
                next : "start"
            }, {
                token : "comment",
                regex : "//",
                next : "singleLineComment"
            },
            {
                token : "comment",  // SHY ADDED
                regex : "#",
                next : "singleLineComment"
            },
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : "\\/\\*",
                next : "comment"
            }, {
                token : "string", // character
                regex : "'(?:" + escapeRe + "|.)?'"
            }, {
                token : "string.start",
                regex : '"', 
                stateName: "qqstring",
                next: [
                    { token: "string", regex: /\\\s*$/, next: "qqstring" },
                    { token: "constant.language.escape", regex: escapeRe },
                    { token: "constant.language.escape", regex: formatRe },
                    { token: "string.end", regex: '"|$', next: "start" },
                    { defaultToken: "string"}
                ]
            }, {
                token : "string.start",
                regex : 'R"\\(', 
                stateName: "rawString",
                next: [
                    { token: "string.end", regex: '\\)"', next: "start" },
                    { defaultToken: "string"}
                ]
            }, {
                token : "constant.numeric", // hex
                regex : "0[xX][0-9a-fA-F]+(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b"
            }, {
                token : "constant.numeric", // float
                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b"
            }, {
                token : "keyword", // pre-compiler directives
                regex : "#\\s*(?:include|import|pragma|line|define|undef)\\b",
                next  : "directive"
            }, {
                token : "keyword", // special case pre-compiler directive
                regex : "#\\s*(?:endif|if|ifdef|else|elif|ifndef)\\b"
            }, {
                token : "support.function.C99.c",
                regex : cFunctions
            }, {
                token : keywordMapper,
                regex : "[a-zA-Z_$][a-zA-Z0-9_$]*"
            }, {
                token : "keyword.operator",
                regex : /--|\+\+|<<=|>>=|>>>=|<>|&&|\|\||\?:|[*%\/+\-&\^|~!<>=]=?/
            }, {
              token : "punctuation.operator",
              regex : "\\?|\\:|\\,|\\;|\\."
            }, {
                token : "paren.lparen",
                regex : "[[({]"
            }, {
                token : "paren.rparen",
                regex : "[\\])}]"
            }, {
                token : "text",
                regex : "\\s+"
            }
        ],
        "comment" : [
            {
                token : "comment", // closing comment
                regex : "\\*\\/",
                next : "start"
            }, {
                defaultToken : "comment"
            }
        ],
        "singleLineComment" : [
            {
                token : "comment",
                regex : /\\$/,
                next : "singleLineComment"
            }, {
                token : "comment",
                regex : /$/,
                next : "start"
            }, {
                defaultToken: "comment"
            }
        ],
        "directive" : [
            {
                token : "constant.other.multiline",
                regex : /\\/
            },
            {
                token : "constant.other.multiline",
                regex : /.*\\/
            },
            {
                token : "constant.other",
                regex : "\\s*<.+?>",
                next : "start"
            },
            {
                token : "constant.other", // single line
                regex : '\\s*["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]',
                next : "start"
            }, 
            {
                token : "constant.other", // single line
                regex : "\\s*['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']",
                next : "start"
            },
            {
                token : "constant.other",
                regex : /[^\\\/]+/,
                next : "start"
            }
        ]
    };

    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("start") ]);
    this.normalizeRules();
};

oop.inherits(c_cppHighlightRules, TextHighlightRules);

exports.c_cppHighlightRules = c_cppHighlightRules;
});

define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {
    
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
    
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
    
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
    
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
    
        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

define("ace/mode/c_cpp",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/c_cpp_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var c_cppHighlightRules = require("./c_cpp_highlight_rules").c_cppHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var Range = require("../range").Range;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = c_cppHighlightRules;

    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();

    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start") {
            var match = line.match(/^.*[\{\(\[]\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState == "start") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.$id = "ace/mode/c_cpp";
    this.snippetFileId = "ace/snippets/c_cpp";
}).call(Mode.prototype);

exports.Mode = Mode;
});

define("ace/mode/glsl_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/c_cpp_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var c_cppHighlightRules = require("./c_cpp_highlight_rules").c_cppHighlightRules;

var glslHighlightRules = function() {

    var keywords = (
        "attribute|const|uniform|varying|break|continue|do|for|while|" +
        "if|else|in|out|inout|float|int|void|bool|true|false|" +
        "lowp|mediump|highp|precision|invariant|discard|return|mat2|mat3|" +
        "mat4|vec2|vec3|vec4|ivec2|ivec3|ivec4|bvec2|bvec3|bvec4|sampler2D|" +
        "samplerCube|struct"
    );

    var buildinConstants = (
        "radians|degrees|sin|cos|tan|asin|acos|atan|pow|" +
        "exp|log|exp2|log2|sqrt|inversesqrt|abs|sign|floor|ceil|fract|mod|" +
        "min|max|clamp|mix|step|smoothstep|length|distance|dot|cross|" +
        "normalize|faceforward|reflect|refract|matrixCompMult|lessThan|" +
        "lessThanEqual|greaterThan|greaterThanEqual|equal|notEqual|any|all|" +
        "not|dFdx|dFdy|fwidth|texture2D|texture2DProj|texture2DLod|" +
        "texture2DProjLod|textureCube|textureCubeLod|" +
        "gl_MaxVertexAttribs|gl_MaxVertexUniformVectors|gl_MaxVaryingVectors|" +
        "gl_MaxVertexTextureImageUnits|gl_MaxCombinedTextureImageUnits|" +
        "gl_MaxTextureImageUnits|gl_MaxFragmentUniformVectors|gl_MaxDrawBuffers|" +
        "gl_DepthRangeParameters|gl_DepthRange|" +
        "gl_Position|gl_PointSize|" +
        "gl_FragCoord|gl_FrontFacing|gl_PointCoord|gl_FragColor|gl_FragData"
    );

    var keywordMapper = this.createKeywordMapper({
        "variable.language": "this",
        "keyword": keywords,
        "constant.language": buildinConstants
    }, "identifier");

    this.$rules = new c_cppHighlightRules().$rules;
    this.$rules.start.forEach(function(rule) {
        if (typeof rule.token == "function")
            rule.token = keywordMapper;
    });
};

oop.inherits(glslHighlightRules, c_cppHighlightRules);

exports.glslHighlightRules = glslHighlightRules;
});

define("ace/mode/glsl",["require","exports","module","ace/lib/oop","ace/mode/c_cpp","ace/mode/glsl_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var CMode = require("./c_cpp").Mode;
var glslHighlightRules = require("./glsl_highlight_rules").glslHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var Range = require("../range").Range;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = glslHighlightRules;
    
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, CMode);

(function() {
    this.$id = "ace/mode/glsl";
}).call(Mode.prototype);

exports.Mode = Mode;
});                (function() {
                    window.require(["ace/mode/glsl"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            
define("ace/theme/tomorrow_night_bright",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = true;
exports.cssClass = "ace-tomorrow-night-bright";
exports.cssText = ".ace-tomorrow-night-bright .ace_gutter {\
background: #333333;\
color: #9e9e9e\
}\
.ace-tomorrow-night-bright .ace_print-margin {\
width: 1px;\
background: #1a1a1a\
}\
.ace-tomorrow-night-bright {\
background-color: #404040;\
color: #fff\
}\
.ace-tomorrow-night-bright .ace_cursor {\
color: #9F9F9F\
}\
.ace-tomorrow-night-bright .ace_marker-layer .ace_selection {\
background: #6e72a5\
}\
.ace-tomorrow-night-bright.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #000000;\
}\
.ace-tomorrow-night-bright .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-tomorrow-night-bright .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #888888\
}\
.ace-tomorrow-night-bright .ace_marker-layer .ace_highlight {\
border: 1px solid rgb(110, 119, 0);\
border-bottom: 0;\
box-shadow: inset 0 -1px rgb(110, 119, 0);\
margin: -1px 0 0 -1px;\
background: rgba(255, 235, 0, 0.1)\
}\
.ace-tomorrow-night-bright .ace_marker-layer .ace_active-line {\
background: #505050\
}\
.ace-tomorrow-night-bright .ace_gutter-active-line {\
background-color: #404040\
}\
.ace-tomorrow-night-bright .ace_stack {\
background-color: rgb(66, 90, 44)\
}\
.ace-tomorrow-night-bright .ace_marker-layer .ace_selected-word {\
border: 1px solid #888888\
}\
.ace-tomorrow-night-bright .ace_invisible {\
color: #343434\
}\
.ace-tomorrow-night-bright .ace_keyword,\
.ace-tomorrow-night-bright .ace_meta,\
.ace-tomorrow-night-bright .ace_storage,\
.ace-tomorrow-night-bright .ace_storage.ace_type,\
.ace-tomorrow-night-bright .ace_support.ace_type {\
color: #5ef7e9\
}\
.ace-tomorrow-night-bright .ace_keyword.ace_operator {\
color: #ffffff\
}\
.ace-tomorrow-night-bright .ace_constant.ace_character,\
.ace-tomorrow-night-bright .ace_constant.ace_language,\
.ace-tomorrow-night-bright .ace_constant.ace_numeric,\
.ace-tomorrow-night-bright .ace_keyword.ace_other.ace_unit,\
.ace-tomorrow-night-bright .ace_support.ace_constant,\
.ace-tomorrow-night-bright .ace_variable.ace_parameter {\
color: #ffff00\
}\
.ace-tomorrow-night-bright .ace_constant.ace_other {\
color: #EEEEEE\
}\
.ace-tomorrow-night-bright .ace_invalid {\
color: #CED2CF;\
background-color: #DF5F5F\
}\
.ace-tomorrow-night-bright .ace_invalid.ace_deprecated {\
color: #CED2CF;\
background-color: #B798BF\
}\
.ace-tomorrow-night-bright .ace_fold {\
background-color: #7AA6DA;\
border-color: #DEDEDE\
}\
.ace-tomorrow-night-bright .ace_entity.ace_name.ace_function,\
.ace-tomorrow-night-bright .ace_support.ace_function,\
.ace-tomorrow-night-bright .ace_variable {\
color: #aad1ff\
}\
.ace-tomorrow-night-bright .ace_support.ace_class,\
.ace-tomorrow-night-bright .ace_support.ace_type {\
color: #E7C547\
}\
.ace-tomorrow-night-bright .ace_heading,\
.ace-tomorrow-night-bright .ace_markup.ace_heading,\
.ace-tomorrow-night-bright .ace_string {\
color: #B9CA4A\
}\
.ace-tomorrow-night-bright .ace_entity.ace_name.ace_tag,\
.ace-tomorrow-night-bright .ace_entity.ace_other.ace_attribute-name,\
.ace-tomorrow-night-bright .ace_meta.ace_tag,\
.ace-tomorrow-night-bright .ace_string.ace_regexp,\
.ace-tomorrow-night-bright .ace_variable {\
color: #D54E53\
}\
.ace-tomorrow-night-bright .ace_comment {\
color: #969896\
}\
.ace-tomorrow-night-bright .ace_c9searchresults.ace_keyword {\
color: #88fbf0\
}\
.ace-tomorrow-night-bright .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYFBXV/8PAAJoAXX4kT2EAAAAAElFTkSuQmCC) right repeat-y\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});                (function() {
                    window.require(["ace/theme/tomorrow_night_bright"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            
// https://d3js.org/d3-contour/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Array) { 'use strict';

var array = Array.prototype;

var slice = array.slice;

function ascending(a, b) {
  return a - b;
}

function area(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}

function constant(x) {
  return function() {
    return x;
  };
}

function contains(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
}

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function noop() {}

var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

function contours() {
  var dx = 1,
      dy = 1,
      threshold = d3Array.thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
      tz = d3Array.tickStep(start, stop, tz);
      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

function density() {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = constant(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (+x(d, i, data) + o) >> k,
          yi = (+y(d, i, data) + o) >> k,
          wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });

    // TODO Optimize.
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = d3Array.max(values0);
      tz = d3Array.tickStep(0, stop, tz);
      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
  };

  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant(+_), density) : weight;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
}

exports.contours = contours;
exports.contourDensity = density;

Object.defineProperty(exports, '__esModule', { value: true });

})));

/* Copyright (C) 2001-2013 Peter Selinger.
 *
 * A javascript port of Potrace (http://potrace.sourceforge.net).
 * 
 * Licensed under the GPL
 * 
 * Usage
 *   loadImageFromFile(file) : load image from File API
 *   loadImageFromUrl(url): load image from URL
 *     because of the same-origin policy, can not load image from another domain.
 *     input color/grayscale image is simply converted to binary image. no pre-
 *     process is performed.
 * 
 *   setParameter({para1: value, ...}) : set parameters
 *     parameters:
 *        turnpolicy ("black" / "white" / "left" / "right" / "minority" / "majority")
 *          how to resolve ambiguities in path decomposition. (default: "minority")       
 *        turdsize
 *          suppress speckles of up to this size (default: 2)
 *        optcurve (true / false)
 *          turn on/off curve optimization (default: true)
 *        alphamax
 *          corner threshold parameter (default: 1)
 *        opttolerance 
 *          curve optimization tolerance (default: 0.2)
 *       
 *   process(callback) : wait for the image be loaded, then run potrace algorithm,
 *                       then call callback function.
 * 
 *   getSVG(size, opt_type) : return a string of generated SVG image.
 *                                    result_image_size = original_image_size * size
 *                                    optional parameter opt_type can be "curve"
 */

var Potrace = (function() {

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  
  Point.prototype.copy = function(){
    return new Point(this.x, this.y);
  };

  function Bitmap(arr, w, h, thresh) {
    this.w = w;
    this.h = h;
    this.size = w * h;
    this.thresh = thresh
    //this.arraybuffer = new ArrayBuffer(this.size);
    this.data = arr //new Int8Array(this.arraybuffer);
  }

  Bitmap.prototype.at = function (x, y) {
    return (x >= 0 && x < this.w && y >=0 && y < this.h) && 
        this.data[this.w * y + x] >= this.thresh;  // ===
  };

  Bitmap.prototype.index = function(i) {
    var point = new Point();
    point.y = Math.floor(i / this.w);
    point.x = i - point.y * this.w;
    return point;
  };

  Bitmap.prototype.flip = function(x, y) {
    if (this.at(x, y)) {
      this.data[this.w * y + x] = 0;
    } else {
      this.data[this.w * y + x] = this.thresh;
    }
  };
    
  Bitmap.prototype.copy = function() {
    var d = new Uint8Array(this.w * this.h)
    d.set(this.data)
    return new Bitmap(d, this.w, this.h, this.thresh);
  };

  function Path() {
    this.area = 0;
    this.len = 0;
    this.curve = {};
    this.pt = [];
    this.minX = 100000;
    this.minY = 100000;
    this.maxX= -1;
    this.maxY = -1;
  }

  function Curve(n) {
    this.n = n;
    this.tag = new Array(n);
    this.c = new Array(n * 3);
    this.alphaCurve = 0;
    this.vertex = new Array(n);
    this.alpha = new Array(n);
    this.alpha0 = new Array(n);
    this.beta = new Array(n);
  }

  var imgElement = null,  //document.createElement("img"),
      imgCanvas = null, //document.createElement("canvas"),
      bm = null,
      pathlist = [],
      callback,
      info = {
        isReady: false,
        turnpolicy: "minority", 
        turdsize: 2,
        optcurve: true,
        alphamax: 1,
        opttolerance: 0.2
      };

  /*imgElement.onload = function() {
    loadCanvas();
    loadBm();
  };*/

  function loadImageFromFile(file) {
    if (info.isReady) {
      clear();
    }
    imgElement.file = file;
    var reader = new FileReader();
    reader.onload = (function(aImg) {
      return function(e) {
        aImg.src = e.target.result;
      };
    })(imgElement);
    reader.readAsDataURL(file);
  }
  
  function loadImageFromUrl(url) {
    if (info.isReady) {
      clear();
    }
    imgElement.src = url;
    
  }
  
  function setParameter(obj) {
   var key;
   for (key in obj) {
     if (obj.hasOwnProperty(key)) {
       info[key] = obj[key];
     }
    }
  }
  
  function loadCanvas() {
    imgCanvas.width = imgElement.width;
    imgCanvas.height = imgElement.height;
    var ctx = imgCanvas.getContext('2d');
    ctx.drawImage(imgElement, 0, 0);
  }
  
  /*function loadBm() {
    var ctx = imgCanvas.getContext('2d');
    bm = new Bitmap(imgCanvas.width, imgCanvas.height);
    var imgdataobj = ctx.getImageData(0, 0, bm.w, bm.h);
    var l = imgdataobj.data.length, i, j, color;
    for (i = 0, j = 0; i < l; i += 4, j++) {
      color = 0.2126 * imgdataobj.data[i] + 0.7153 * imgdataobj.data[i + 1] +
          0.0721 * imgdataobj.data[i + 2];
      bm.data[j] = (color < 128 ? 1 : 0);
    }
    info.isReady = true;
  }*/
  
  function setBm(arr, width, height, thresh) { // arr is Int8Array with 0,1 values
    bm = new Bitmap(arr, width, height, thresh)
    info.isReady = true;
  }
  
  function bmToPathlist() {
  
    var bm1 = bm.copy(),
      currentPoint = new Point(0, 0),
      path;
    
    function findNext(point) {
      var i = bm1.w * point.y + point.x;
      while (i < bm1.size && bm1.data[i] < bm1.thresh) { // !==
        i++;
      }
      return i < bm1.size && bm1.index(i);
    }
    
    function majority(x, y) {
      var i, a, ct;
      for (i = 2; i < 5; i++) {
        ct = 0;
        for (a = -i + 1; a <= i - 1; a++) {
          ct += bm1.at(x + a, y + i - 1) ? 1 : -1;
          ct += bm1.at(x + i - 1, y + a - 1) ? 1 : -1;
          ct += bm1.at(x + a - 1, y - i) ? 1 : -1;
          ct += bm1.at(x - i, y + a) ? 1 : -1;
        }
        if (ct > 0) {
          return 1;
        } else if (ct < 0) {
          return 0;
        }
      }
      return 0;
    }
    
    function findPath(point) {
      var path = new Path(),
        x = point.x, y = point.y,
        dirx = 0, diry = 1, tmp;
      
      path.sign = bm.at(point.x, point.y) ? "+" : "-";
      
      while (1) {
        path.pt.push(new Point(x, y));
        if (x > path.maxX)
          path.maxX = x;
        if (x < path.minX)
          path.minX = x;
        if (y > path.maxY)
          path.maxY = y;
        if (y < path.minY)
          path.minY = y;
        path.len++;
        
        x += dirx;
        y += diry;
        path.area -= x * diry;
        
        if (x === point.x && y === point.y)
          break;
        
        var l = bm1.at(x + (dirx + diry - 1 ) / 2, y + (diry - dirx - 1) / 2);
        var r = bm1.at(x + (dirx - diry - 1) / 2, y + (diry + dirx - 1) / 2);
        
        if (r && !l) {
          if (info.turnpolicy === "right" ||
          (info.turnpolicy === "black" && path.sign === '+') ||
          (info.turnpolicy === "white" && path.sign === '-') ||
          (info.turnpolicy === "majority" && majority(x, y)) ||
          (info.turnpolicy === "minority" && !majority(x, y))) {
            tmp = dirx;
            dirx = -diry;
            diry = tmp;
          } else {
            tmp = dirx;
            dirx = diry;
            diry = -tmp;
          }
        } else if (r) {
          tmp = dirx;
          dirx = -diry;
          diry = tmp;
        } else if (!l) {
          tmp = dirx;
          dirx = diry;
          diry = -tmp;
        }
      }
      return path;
    }
    
    function xorPath(path){
      var y1 = path.pt[0].y,
        len = path.len,
        x, y, maxX, minY, i, j;
      for (i = 1; i < len; i++) {
        x = path.pt[i].x;
        y = path.pt[i].y;
        
        if (y !== y1) {
          minY = y1 < y ? y1 : y;
          maxX = path.maxX;
          for (j = x; j < maxX; j++) {
            bm1.flip(j, minY);
          }
          y1 = y;
        }
      }
      
    }
    
    while (currentPoint = findNext(currentPoint)) {

      path = findPath(currentPoint);
      
      xorPath(path);
      if (path.area === -1)
        throw new Error("bad potrace")
      if (path.area > info.turdsize) {
        pathlist.push(path);
      }
    }
    
  }
  

  function processPath() {
  
    function Quad() {
      this.data = [0,0,0,0,0,0,0,0,0];
    }

    Quad.prototype.at = function(x, y) {
      return this.data[x * 3 + y];
    };
    
    function Sum(x, y, xy, x2, y2) {
      this.x = x;
      this.y = y;
      this.xy = xy;
      this.x2 = x2;
      this.y2 = y2;
    }
    
    function mod(a, n) {
        return a >= n ? a % n : a>=0 ? a : n-1-(-1-a) % n;
    }
  
    function xprod(p1, p2) {
      return p1.x * p2.y - p1.y * p2.x;
    }
    
    function cyclic(a, b, c) {
      if (a <= c) {
        return (a <= b && b < c);
      } else {
        return (a <= b || b < c);
      }
    }
      
    function sign(i) {
      return i > 0 ? 1 : i < 0 ? -1 : 0;
    }
    
    function quadform(Q, w) {
      var v = new Array(3), i, j, sum;
    
      v[0] = w.x;
      v[1] = w.y;
      v[2] = 1;
      sum = 0.0;
    
      for (i=0; i<3; i++) {
        for (j=0; j<3; j++) {
          sum += v[i] * Q.at(i, j) * v[j];
        }
      }
      return sum;
    }
  
    function interval(lambda, a, b) {
      var res = new Point();
    
      res.x = a.x + lambda * (b.x - a.x);
      res.y = a.y + lambda * (b.y - a.y);
      return res;
    }
    
    function dorth_infty(p0, p2) {
      var r = new Point();
      
      r.y = sign(p2.x - p0.x);
      r.x = -sign(p2.y - p0.y);
    
      return r;
    }
    
    function ddenom(p0, p2) {
      var r = dorth_infty(p0, p2);
    
      return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
    }
    
    function dpara(p0, p1, p2) {
      var x1, y1, x2, y2;
    
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
    
      return x1 * y2 - x2 * y1;
    }
    
    function cprod(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
    
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
    
      return x1 * y2 - x2 * y1;
    }
      
    function iprod(p0, p1, p2) {
      var x1, y1, x2, y2;
    
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
    
      return x1*x2 + y1*y2;
    }
      
    function iprod1(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
    
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
    
      return x1 * x2 + y1 * y2;
    }
    
    function ddist(p, q) {
      return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
    }
    
    function bezier(t, p0, p1, p2, p3) {
      var s = 1 - t, res = new Point();
    
      res.x = s*s*s*p0.x + 3*(s*s*t)*p1.x + 3*(t*t*s)*p2.x + t*t*t*p3.x;
      res.y = s*s*s*p0.y + 3*(s*s*t)*p1.y + 3*(t*t*s)*p2.y + t*t*t*p3.y;
    
      return res;
    }
  
    function tangent(p0, p1, p2, p3, q0, q1) {
      var A, B, C, a, b, c, d, s, r1, r2;
    
      A = cprod(p0, p1, q0, q1);
      B = cprod(p1, p2, q0, q1);
      C = cprod(p2, p3, q0, q1);
    
      a = A - 2 * B + C;
      b = -2 * A + 2 * B;
      c = A;
      
      d = b * b - 4 * a * c;
    
      if (a===0 || d<0) {
        return -1.0;
      }
    
      s = Math.sqrt(d);
    
      r1 = (-b + s) / (2 * a);
      r2 = (-b - s) / (2 * a);
    
      if (r1 >= 0 && r1 <= 1) {
        return r1;
      } else if (r2 >= 0 && r2 <= 1) {
        return r2;
      } else {
        return -1.0;
      }
    }
    
    function calcSums(path) {
      var i, x, y;
      path.x0 = path.pt[0].x;
      path.y0 = path.pt[0].y;
      
      path.sums = [];
      var s = path.sums;
      s.push(new Sum(0, 0, 0, 0, 0));
      for(i = 0; i < path.len; i++){
        x = path.pt[i].x - path.x0;
        y = path.pt[i].y - path.y0;
        s.push(new Sum(s[i].x + x, s[i].y + y, s[i].xy + x * y,
            s[i].x2 + x * x, s[i].y2 + y * y));
      }
    }
   
    function calcLon(path) {
      
      var n = path.len, pt = path.pt, dir,
        pivk = new Array(n),
        nc = new Array(n),
        ct = new Array(4);
      path.lon = new Array(n);
      
      var constraint = [new Point(), new Point()],
          cur = new Point(),
          off = new Point(),
          dk = new Point(),
          foundk;
      
      var i, j, k1, a, b, c, d, k = 0;
      for(i = n - 1; i >= 0; i--){
        if (pt[i].x != pt[k].x && pt[i].y != pt[k].y) {
          k = i + 1;
        }
        nc[i] = k;
      }
      
      for (i = n - 1; i >= 0; i--) {
        ct[0] = ct[1] = ct[2] = ct[3] = 0;
        dir = (3 + 3 * (pt[mod(i + 1, n)].x - pt[i].x) + 
            (pt[mod(i + 1, n)].y - pt[i].y)) / 2;
        ct[dir]++;
        
        constraint[0].x = 0;
        constraint[0].y = 0;
        constraint[1].x = 0;
        constraint[1].y = 0;
        
        k = nc[i];
        k1 = i;
        while (1) {
          foundk = 0;
          dir =  (3 + 3 * sign(pt[k].x - pt[k1].x) + 
              sign(pt[k].y - pt[k1].y)) / 2;
          ct[dir]++;
          
          if (ct[0] && ct[1] && ct[2] && ct[3]) {
            pivk[i] = k1;
            foundk = 1;
            break;
          }
          
          cur.x = pt[k].x - pt[i].x;
          cur.y = pt[k].y - pt[i].y;
          
          if (xprod(constraint[0], cur) < 0 || xprod(constraint[1], cur) > 0) {
            break;
          }
              
          if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {
          
          } else {
            off.x = cur.x + ((cur.y >= 0 && (cur.y > 0 || cur.x < 0)) ? 1 : -1);
            off.y = cur.y + ((cur.x <= 0 && (cur.x < 0 || cur.y < 0)) ? 1 : -1);
            if (xprod(constraint[0], off) >= 0) {
              constraint[0].x = off.x;
              constraint[0].y = off.y;
            }
            off.x = cur.x + ((cur.y <= 0 && (cur.y < 0 || cur.x < 0)) ? 1 : -1);
            off.y = cur.y + ((cur.x >= 0 && (cur.x > 0 || cur.y < 0)) ? 1 : -1);
            if (xprod(constraint[1], off) <= 0) {
              constraint[1].x = off.x;
              constraint[1].y = off.y;
            }
          }
          k1 = k;
          k = nc[k1];
          if (!cyclic(k, i, k1)) {
            break;
          }
        }
        if (foundk === 0) {
          dk.x = sign(pt[k].x-pt[k1].x);
          dk.y = sign(pt[k].y-pt[k1].y);
          cur.x = pt[k1].x - pt[i].x;
          cur.y = pt[k1].y - pt[i].y;
  
          a = xprod(constraint[0], cur);
          b = xprod(constraint[0], dk);
          c = xprod(constraint[1], cur);
          d = xprod(constraint[1], dk);
  
          j = 10000000;
          if (b < 0) {
            j = Math.floor(a / -b);
          }
          if (d > 0) {
            j = Math.min(j, Math.floor(-c / d));
          }
          pivk[i] = mod(k1+j,n);
        }
      }
      
      j=pivk[n-1];
      path.lon[n-1]=j;
      for (i=n-2; i>=0; i--) {
        if (cyclic(i+1,pivk[i],j)) {
          j=pivk[i];
        }
        path.lon[i]=j;
      }
  
      for (i=n-1; cyclic(mod(i+1,n),j,path.lon[i]); i--) {
        path.lon[i] = j;
      }
    }
    
    function bestPolygon(path) {
      
      function penalty3(path, i, j) {
        
        var n = path.len, pt = path.pt, sums = path.sums;
        var x, y, xy, x2, y2,
          k, a, b, c, s,
          px, py, ex, ey,
          r = 0;
        if (j>=n) {
          j -= n;
          r = 1;
        }
        
        if (r === 0) {
          x = sums[j+1].x - sums[i].x;
          y = sums[j+1].y - sums[i].y;
          x2 = sums[j+1].x2 - sums[i].x2;
          xy = sums[j+1].xy - sums[i].xy;
          y2 = sums[j+1].y2 - sums[i].y2;
          k = j+1 - i;
        } else {
          x = sums[j+1].x - sums[i].x + sums[n].x;
          y = sums[j+1].y - sums[i].y + sums[n].y;
          x2 = sums[j+1].x2 - sums[i].x2 + sums[n].x2;
          xy = sums[j+1].xy - sums[i].xy + sums[n].xy;
          y2 = sums[j+1].y2 - sums[i].y2 + sums[n].y2;
          k = j+1 - i + n;
        } 
      
        px = (pt[i].x + pt[j].x) / 2.0 - pt[0].x;
        py = (pt[i].y + pt[j].y) / 2.0 - pt[0].y;
        ey = (pt[j].x - pt[i].x);
        ex = -(pt[j].y - pt[i].y);
      
        a = ((x2 - 2*x*px) / k + px*px);
        b = ((xy - x*py - y*px) / k + px*py);
        c = ((y2 - 2*y*py) / k + py*py);
        
        s = ex*ex*a + 2*ex*ey*b + ey*ey*c;
      
        return Math.sqrt(s);
      }
      
      var i, j, m, k,    
      n = path.len,
      pen = new Array(n + 1),
      prev = new Array(n + 1),
      clip0 = new Array(n),
      clip1 = new Array(n + 1),
      seg0 = new Array (n + 1),
      seg1 = new Array(n + 1),
      thispen, best, c;
      
      for (i=0; i<n; i++) {
        c = mod(path.lon[mod(i-1,n)]-1,n);
        if (c == i) {
          c = mod(i+1,n);
        }
        if (c < i) {
          clip0[i] = n;
        } else {
          clip0[i] = c;
        }
      }
      
      j = 1;
      for (i=0; i<n; i++) {
        while (j <= clip0[i]) {
          clip1[j] = i;
          j++;
        }
      }
      
      i = 0;
      for (j=0; i<n; j++) {
        seg0[j] = i;
        i = clip0[i];
      }
      seg0[j] = n;
      m = j;
    
      i = n;
      for (j=m; j>0; j--) {
        seg1[j] = i;
        i = clip1[i];
      }
      seg1[0] = 0;
      
      pen[0]=0;
      for (j=1; j<=m; j++) {
        for (i=seg1[j]; i<=seg0[j]; i++) {
          best = -1;
          for (k=seg0[j-1]; k>=clip1[i]; k--) {
            thispen = penalty3(path, k, i) + pen[k];
            if (best < 0 || thispen < best) {
              prev[i] = k;
              best = thispen;
            }
          }
          pen[i] = best;
        }
      }
      path.m = m;
      path.po = new Array(m);
    
      for (i=n, j=m-1; i>0; j--) {
        i = prev[i];
        path.po[j] = i;
      }
    }
    
    function adjustVertices(path) {
      
      function pointslope(path, i, j, ctr, dir) {
    
        var n = path.len, sums = path.sums,
          x, y, x2, xy, y2,
          k, a, b, c, lambda2, l, r=0;
      
        while (j>=n) {
          j-=n;
          r+=1;
        }
        while (i>=n) {
          i-=n;
          r-=1;
        }
        while (j<0) {
          j+=n;
          r-=1;
        }
        while (i<0) {
          i+=n;
          r+=1;
        }
        
        x = sums[j+1].x-sums[i].x+r*sums[n].x;
        y = sums[j+1].y-sums[i].y+r*sums[n].y;
        x2 = sums[j+1].x2-sums[i].x2+r*sums[n].x2;
        xy = sums[j+1].xy-sums[i].xy+r*sums[n].xy;
        y2 = sums[j+1].y2-sums[i].y2+r*sums[n].y2;
        k = j+1-i+r*n;
        
        ctr.x = x/k;
        ctr.y = y/k;
      
        a = (x2-x*x/k)/k;
        b = (xy-x*y/k)/k;
        c = (y2-y*y/k)/k;
        
        lambda2 = (a+c+Math.sqrt((a-c)*(a-c)+4*b*b))/2;
      
        a -= lambda2;
        c -= lambda2;
      
        if (Math.abs(a) >= Math.abs(c)) {
          l = Math.sqrt(a*a+b*b);
          if (l!==0) {
            dir.x = -b/l;
            dir.y = a/l;
          }
        } else {
          l = Math.sqrt(c*c+b*b);
          if (l!==0) {
            dir.x = -c/l;
            dir.y = b/l;
          }
        }
        if (l===0) {
          dir.x = dir.y = 0; 
        }
      }
      
      var m = path.m, po = path.po, n = path.len, pt = path.pt,
        x0 = path.x0, y0 = path.y0,
        ctr = new Array(m), dir = new Array(m),
        q = new Array(m),
        v = new Array(3), d, i, j, k, l,
        s = new Point();
      
      path.curve = new Curve(m);
  
      for (i=0; i<m; i++) {
        j = po[mod(i+1,m)];
        j = mod(j-po[i],n)+po[i];
        ctr[i] = new Point();
        dir[i] = new Point();
        pointslope(path, po[i], j, ctr[i], dir[i]);
      }
    
      for (i=0; i<m; i++) {
        q[i] = new Quad();
        d = dir[i].x * dir[i].x + dir[i].y * dir[i].y;
        if (d === 0.0) {
          for (j=0; j<3; j++) {
            for (k=0; k<3; k++) {
              q[i].data[j * 3 + k] = 0;
            }
          }
        } else {
          v[0] = dir[i].y;
          v[1] = -dir[i].x;
          v[2] = - v[1] * ctr[i].y - v[0] * ctr[i].x;
          for (l=0; l<3; l++) {
            for (k=0; k<3; k++) {
              q[i].data[l * 3 + k] = v[l] * v[k] / d;
            }
          }
        }
      }
     
      var Q, w, dx, dy, det, min, cand, xmin, ymin, z;
      for (i=0; i<m; i++) {
        Q = new Quad();
        w = new Point();
    
        s.x = pt[po[i]].x-x0;
        s.y = pt[po[i]].y-y0;
    
        j = mod(i-1,m);
        
        for (l=0; l<3; l++) {
          for (k=0; k<3; k++) {
            Q.data[l * 3 + k] = q[j].at(l, k) + q[i].at(l, k);
          }
        }
        
        while(1) {
          
          det = Q.at(0, 0)*Q.at(1, 1) - Q.at(0, 1)*Q.at(1, 0);
          if (det !== 0.0) {
            w.x = (-Q.at(0, 2)*Q.at(1, 1) + Q.at(1, 2)*Q.at(0, 1)) / det;
            w.y = ( Q.at(0, 2)*Q.at(1, 0) - Q.at(1, 2)*Q.at(0, 0)) / det;
            break;
          }
    
          if (Q.at(0, 0)>Q.at(1, 1)) {
            v[0] = -Q.at(0, 1);
            v[1] = Q.at(0, 0);
          } else if (Q.at(1, 1)) {
            v[0] = -Q.at(1, 1);
            v[1] = Q.at(1, 0);
          } else {
            v[0] = 1;
            v[1] = 0;
          }
          d = v[0] * v[0] + v[1] * v[1];
          v[2] = - v[1] * s.y - v[0] * s.x;
          for (l=0; l<3; l++) {
            for (k=0; k<3; k++) {
              Q.data[l * 3 + k] += v[l] * v[k] / d;
            }
          }
        }
        dx = Math.abs(w.x-s.x);
        dy = Math.abs(w.y-s.y);
        if (dx <= 0.5 && dy <= 0.5) {
          path.curve.vertex[i] = new Point(w.x+x0, w.y+y0);
          continue;
        }
    
        min = quadform(Q, s);
        xmin = s.x;
        ymin = s.y;
    
        if (Q.at(0, 0) !== 0.0) {
          for (z=0; z<2; z++) {
            w.y = s.y-0.5+z;
            w.x = - (Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
            dx = Math.abs(w.x-s.x);
            cand = quadform(Q, w);
            if (dx <= 0.5 && cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
  
        if (Q.at(1, 1) !== 0.0) {
          for (z=0; z<2; z++) {
            w.x = s.x-0.5+z;
            w.y = - (Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
            dy = Math.abs(w.y-s.y);
            cand = quadform(Q, w);
            if (dy <= 0.5 && cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
  
        for (l=0; l<2; l++) {
          for (k=0; k<2; k++) {
            w.x = s.x-0.5+l;
            w.y = s.y-0.5+k;
            cand = quadform(Q, w);
            if (cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
    
        path.curve.vertex[i] = new Point(xmin + x0, ymin + y0);
      }
    }
    
    function reverse(path) {
      var curve = path.curve, m = curve.n, v = curve.vertex, i, j, tmp;
    
      for (i=0, j=m-1; i<j; i++, j--) {
        tmp = v[i];
        v[i] = v[j];
        v[j] = tmp;
      }
    }
    
    function smooth(path) {
      var m = path.curve.n, curve = path.curve;

      var i, j, k, dd, denom, alpha,
        p2, p3, p4;
    
      for (i=0; i<m; i++) {
        j = mod(i+1, m);
        k = mod(i+2, m);
        p4 = interval(1/2.0, curve.vertex[k], curve.vertex[j]);
    
        denom = ddenom(curve.vertex[i], curve.vertex[k]);
        if (denom !== 0.0) {
          dd = dpara(curve.vertex[i], curve.vertex[j], curve.vertex[k]) / denom;
          dd = Math.abs(dd);
          alpha = dd>1 ? (1 - 1.0/dd) : 0;
          alpha = alpha / 0.75;
        } else {
          alpha = 4/3.0;
        }
        curve.alpha0[j] = alpha;
    
        if (alpha >= info.alphamax) { 
          curve.tag[j] = "CORNER";
          curve.c[3 * j + 1] = curve.vertex[j];
          curve.c[3 * j + 2] = p4;
        } else {
          if (alpha < 0.55) {
            alpha = 0.55;
          } else if (alpha > 1) {
            alpha = 1;
          }
          p2 = interval(0.5+0.5*alpha, curve.vertex[i], curve.vertex[j]);
          p3 = interval(0.5+0.5*alpha, curve.vertex[k], curve.vertex[j]);
          curve.tag[j] = "CURVE";
          curve.c[3 * j + 0] = p2;
          curve.c[3 * j + 1] = p3;
          curve.c[3 * j + 2] = p4;
        }
        curve.alpha[j] = alpha;  
        curve.beta[j] = 0.5;
      }
      curve.alphacurve = 1;
    }
    
    function optiCurve(path) {
      function Opti(){
        this.pen = 0;
        this.c = [new Point(), new Point()];
        this.t = 0;
        this.s = 0;
        this.alpha = 0;
      }
      
      function opti_penalty(path, i, j, res, opttolerance, convc, areac) {
        var m = path.curve.n, curve = path.curve, vertex = curve.vertex, 
          k, k1, k2, conv, i1,
          area, alpha, d, d1, d2,
          p0, p1, p2, p3, pt,
          A, R, A1, A2, A3, A4,
          s, t;
      
        if (i==j) {
          return 1;
        }
      
        k = i;
        i1 = mod(i+1, m);
        k1 = mod(k+1, m);
        conv = convc[k1];
        if (conv === 0) {
          return 1;
        }
        d = ddist(vertex[i], vertex[i1]);
        for (k=k1; k!=j; k=k1) {
          k1 = mod(k+1, m);
          k2 = mod(k+2, m);
          if (convc[k1] != conv) {
            return 1;
          }
          if (sign(cprod(vertex[i], vertex[i1], vertex[k1], vertex[k2])) !=
              conv) {
            return 1;
          }
          if (iprod1(vertex[i], vertex[i1], vertex[k1], vertex[k2]) <
              d * ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
            return 1;
          }
        }
    
        p0 = curve.c[mod(i,m) * 3 + 2].copy();
        p1 = vertex[mod(i+1,m)].copy();
        p2 = vertex[mod(j,m)].copy();
        p3 = curve.c[mod(j,m) * 3 + 2].copy();
      
        area = areac[j] - areac[i];
        area -= dpara(vertex[0], curve.c[i * 3 + 2], curve.c[j * 3 + 2])/2;
        if (i>=j) {
          area += areac[m];
        }
      
        A1 = dpara(p0, p1, p2);
        A2 = dpara(p0, p1, p3);
        A3 = dpara(p0, p2, p3);
  
        A4 = A1+A3-A2;    
        
        if (A2 == A1) {
          return 1;
        }
      
        t = A3/(A3-A4);
        s = A2/(A2-A1);
        A = A2 * t / 2.0;
        
        if (A === 0.0) {
          return 1;
        }
      
        R = area / A;
        alpha = 2 - Math.sqrt(4 - R / 0.3);
      
        res.c[0] = interval(t * alpha, p0, p1);
        res.c[1] = interval(s * alpha, p3, p2);
        res.alpha = alpha;
        res.t = t;
        res.s = s;
      
        p1 = res.c[0].copy();
        p2 = res.c[1].copy(); 
      
        res.pen = 0;
      
        for (k=mod(i+1,m); k!=j; k=k1) {
          k1 = mod(k+1,m);
          t = tangent(p0, p1, p2, p3, vertex[k], vertex[k1]);
          if (t<-0.5) {
            return 1;
          }
          pt = bezier(t, p0, p1, p2, p3);
          d = ddist(vertex[k], vertex[k1]);
          if (d === 0.0) {
            return 1;
          }
          d1 = dpara(vertex[k], vertex[k1], pt) / d;
          if (Math.abs(d1) > opttolerance) {
            return 1;
          }
          if (iprod(vertex[k], vertex[k1], pt) < 0 ||
              iprod(vertex[k1], vertex[k], pt) < 0) {
            return 1;
          }
          res.pen += d1 * d1;
        }
      
        for (k=i; k!=j; k=k1) {
          k1 = mod(k+1,m);
          t = tangent(p0, p1, p2, p3, curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
          if (t<-0.5) {
            return 1;
          }
          pt = bezier(t, p0, p1, p2, p3);
          d = ddist(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
          if (d === 0.0) {
            return 1;
          }
          d1 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], pt) / d;
          d2 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], vertex[k1]) / d;
          d2 *= 0.75 * curve.alpha[k1];
          if (d2 < 0) {
            d1 = -d1;
            d2 = -d2;
          }
          if (d1 < d2 - opttolerance) {
            return 1;
          }
          if (d1 < d2) {
            res.pen += (d1 - d2) * (d1 - d2);
          }
        }
      
        return 0;
      }
    
      var curve = path.curve, m = curve.n, vert = curve.vertex, 
        pt = new Array(m + 1),
        pen = new Array(m + 1),
        len = new Array(m + 1),
        opt = new Array(m + 1),
        om, i,j,r,
        o = new Opti(), p0,
        i1, area, alpha, ocurve,
        s, t;
      
      var convc = new Array(m), areac = new Array(m + 1);
      
      for (i=0; i<m; i++) {
        if (curve.tag[i] == "CURVE") {
          convc[i] = sign(dpara(vert[mod(i-1,m)], vert[i], vert[mod(i+1,m)]));
        } else {
          convc[i] = 0;
        }
      }
    
      area = 0.0;
      areac[0] = 0.0;
      p0 = curve.vertex[0];
      for (i=0; i<m; i++) {
        i1 = mod(i+1, m);
        if (curve.tag[i1] == "CURVE") {
          alpha = curve.alpha[i1];
          area += 0.3 * alpha * (4-alpha) *
              dpara(curve.c[i * 3 + 2], vert[i1], curve.c[i1 * 3 + 2])/2;
          area += dpara(p0, curve.c[i * 3 + 2], curve.c[i1 * 3 + 2])/2;
        }
        areac[i+1] = area;
      }
    
      pt[0] = -1;
      pen[0] = 0;
      len[0] = 0;
    
    
      for (j=1; j<=m; j++) {
        pt[j] = j-1;
        pen[j] = pen[j-1];
        len[j] = len[j-1]+1;
    
        for (i=j-2; i>=0; i--) {
          r = opti_penalty(path, i, mod(j,m), o, info.opttolerance, convc, 
              areac);
          if (r) {
            break;
          }
            if (len[j] > len[i]+1 ||
                (len[j] == len[i]+1 && pen[j] > pen[i] + o.pen)) {
              pt[j] = i;
              pen[j] = pen[i] + o.pen;
              len[j] = len[i] + 1;
              opt[j] = o;
              o = new Opti();
            }
        }
      }
      om = len[m];
      ocurve = new Curve(om);
      s = new Array(om);
      t = new Array(om);
    
      j = m;
      for (i=om-1; i>=0; i--) {
        if (pt[j]==j-1) {
          ocurve.tag[i]     = curve.tag[mod(j,m)];
          ocurve.c[i * 3 + 0]    = curve.c[mod(j,m) * 3 + 0];
          ocurve.c[i * 3 + 1]    = curve.c[mod(j,m) * 3 + 1];
          ocurve.c[i * 3 + 2]    = curve.c[mod(j,m) * 3 + 2];
          ocurve.vertex[i]  = curve.vertex[mod(j,m)];
          ocurve.alpha[i]   = curve.alpha[mod(j,m)];
          ocurve.alpha0[i]  = curve.alpha0[mod(j,m)];
          ocurve.beta[i]    = curve.beta[mod(j,m)];
          s[i] = t[i] = 1.0;
        } else {
          ocurve.tag[i] = "CURVE";
          ocurve.c[i * 3 + 0] = opt[j].c[0];
          ocurve.c[i * 3 + 1] = opt[j].c[1];
          ocurve.c[i * 3 + 2] = curve.c[mod(j,m) * 3 + 2];
          ocurve.vertex[i] = interval(opt[j].s, curve.c[mod(j,m) * 3 + 2],
                                       vert[mod(j,m)]);
          ocurve.alpha[i] = opt[j].alpha;
          ocurve.alpha0[i] = opt[j].alpha;
          s[i] = opt[j].s;
          t[i] = opt[j].t;
        }
        j = pt[j];
      }
    
      for (i=0; i<om; i++) {
        i1 = mod(i+1,om);
        ocurve.beta[i] = s[i] / (s[i] + t[i1]);
      }
      ocurve.alphacurve = 1;
      path.curve = ocurve;
    }
    
    for (var i = 0; i < pathlist.length; i++) {
      var path = pathlist[i];
      calcSums(path);
      calcLon(path);
      bestPolygon(path);
      adjustVertices(path);
      
      if (path.sign === "-") {
        reverse(path);
      }
      
      smooth(path);
      
      if (info.optcurve) {
        optiCurve(path);
      }
    }
  
  }

  function process() {
    
    bmToPathlist();
    processPath();
    //callback();
    callback = null;
    return pathlist
  }

  function do_processPath(pl) {
    pathlist = pl
    processPath();
    return pathlist
  }

  function clear() {
    bm = null;
    pathlist = [];
    callback = null;
    info.isReady = false;
  }
  
  function getSVG(size, opt_type) {
  
    function path(curve) {
    
      function bezier(i) {
        var b = 'C ' + (curve.c[i * 3 + 0].x * size).toFixed(3) + ' ' +
            (curve.c[i * 3 + 0].y * size).toFixed(3) + ',';
        b += (curve.c[i * 3 + 1].x * size).toFixed(3) + ' ' +
            (curve.c[i * 3 + 1].y * size).toFixed(3) + ',';
        b += (curve.c[i * 3 + 2].x * size).toFixed(3) + ' ' +
            (curve.c[i * 3 + 2].y * size).toFixed(3) + ' ';
        return b;
      }
    
      function segment(i) {
        var s = 'L ' + (curve.c[i * 3 + 1].x * size).toFixed(3) + ' ' +
            (curve.c[i * 3 + 1].y * size).toFixed(3) + ' ';
        s += (curve.c[i * 3 + 2].x * size).toFixed(3) + ' ' +
            (curve.c[i * 3 + 2].y * size).toFixed(3) + ' ';
        return s;
      }

      var n = curve.n, i;
      var p = 'M ' + (curve.c[(n - 1) * 3 + 2].x * size).toFixed(3) +
          ' ' + (curve.c[(n - 1) * 3 + 2].y * size).toFixed(3) + ' ';
      for (i = 0; i < n; i++) {
        if (curve.tag[i] === "CURVE") {
          p += bezier(i);
        } else if (curve.tag[i] === "CORNER") {
          p += segment(i);
        }
      }
      //p += 
      return p;
    }

    var w = bm.w * size, h = bm.h * size,
      len = pathlist.length, c, i, strokec, fillc, fillrule;

    var svg = '<svg id="svg" version="1.1" width="' + w + '" height="' + h +
        '" xmlns="http://www.w3.org/2000/svg">';
    svg += '<path d="';
    for (i = 0; i < len; i++) {
      c = pathlist[i].curve;
      svg += path(c);
    }
    if (opt_type === "curve") {
      strokec = "black";
      fillc = "none";
      fillrule = '';
    } else {
      strokec = "none";
      fillc = "black";
      fillrule = ' fill-rule="evenodd"';
    }
    svg += '" stroke="' + strokec + '" fill="' + fillc + '"' + fillrule + '/></svg>';
    return svg;
  }
  
  return{
    loadImageFromFile: loadImageFromFile,
    loadImageFromUrl: loadImageFromUrl,
    setParameter: setParameter,
    process: process,
    getSVG: getSVG,
    //img: imgElement
    setBm: setBm,
    clear: clear,
    do_processPath: do_processPath
  };
})();

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.b2 = {}));
}(this, (function (exports) { 'use strict';

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2BlockAllocator {
  }

  /*
  * Copyright (c) 2011 Erin Catto http://box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Color for debug drawing. Each value has the range [0,1].
  class b2Color {
      constructor(r = 0.5, g = 0.5, b = 0.5, a = 1.0) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
      }
      Clone() {
          return new b2Color().Copy(this);
      }
      Copy(other) {
          this.r = other.r;
          this.g = other.g;
          this.b = other.b;
          this.a = other.a;
          return this;
      }
      IsEqual(color) {
          return (this.r === color.r) && (this.g === color.g) && (this.b === color.b) && (this.a === color.a);
      }
      IsZero() {
          return (this.r === 0) && (this.g === 0) && (this.b === 0) && (this.a === 0);
      }
      Set(r, g, b, a = this.a) {
          this.SetRGBA(r, g, b, a);
      }
      SetByteRGB(r, g, b) {
          this.r = r / 0xff;
          this.g = g / 0xff;
          this.b = b / 0xff;
          return this;
      }
      SetByteRGBA(r, g, b, a) {
          this.r = r / 0xff;
          this.g = g / 0xff;
          this.b = b / 0xff;
          this.a = a / 0xff;
          return this;
      }
      SetRGB(rr, gg, bb) {
          this.r = rr;
          this.g = gg;
          this.b = bb;
          return this;
      }
      SetRGBA(rr, gg, bb, aa) {
          this.r = rr;
          this.g = gg;
          this.b = bb;
          this.a = aa;
          return this;
      }
      SelfAdd(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          this.a += color.a;
          return this;
      }
      Add(color, out) {
          out.r = this.r + color.r;
          out.g = this.g + color.g;
          out.b = this.b + color.b;
          out.a = this.a + color.a;
          return out;
      }
      SelfSub(color) {
          this.r -= color.r;
          this.g -= color.g;
          this.b -= color.b;
          this.a -= color.a;
          return this;
      }
      Sub(color, out) {
          out.r = this.r - color.r;
          out.g = this.g - color.g;
          out.b = this.b - color.b;
          out.a = this.a - color.a;
          return out;
      }
      SelfMul(s) {
          this.r *= s;
          this.g *= s;
          this.b *= s;
          this.a *= s;
          return this;
      }
      Mul(s, out) {
          out.r = this.r * s;
          out.g = this.g * s;
          out.b = this.b * s;
          out.a = this.a * s;
          return out;
      }
      Mix(mixColor, strength) {
          b2Color.MixColors(this, mixColor, strength);
      }
      static MixColors(colorA, colorB, strength) {
          const dr = (strength * (colorB.r - colorA.r));
          const dg = (strength * (colorB.g - colorA.g));
          const db = (strength * (colorB.b - colorA.b));
          const da = (strength * (colorB.a - colorA.a));
          colorA.r += dr;
          colorA.g += dg;
          colorA.b += db;
          colorA.a += da;
          colorB.r -= dr;
          colorB.g -= dg;
          colorB.b -= db;
          colorB.a -= da;
      }
      MakeStyleString(alpha = this.a) {
          return b2Color.MakeStyleString(this.r, this.g, this.b, alpha);
      }
      static MakeStyleString(r, g, b, a = 1.0) {
          // function clamp(x: number, lo: number, hi: number) { return x < lo ? lo : hi < x ? hi : x; }
          r *= 255; // r = clamp(r, 0, 255);
          g *= 255; // g = clamp(g, 0, 255);
          b *= 255; // b = clamp(b, 0, 255);
          // a = clamp(a, 0, 1);
          if (a < 1) {
              return `rgba(${r},${g},${b},${a})`;
          }
          else {
              return `rgb(${r},${g},${b})`;
          }
      }
  }
  b2Color.ZERO = new b2Color(0, 0, 0, 0);
  b2Color.RED = new b2Color(1, 0, 0);
  b2Color.GREEN = new b2Color(0, 1, 0);
  b2Color.BLUE = new b2Color(0, 0, 1);
  class b2TypedColor {
      constructor(...args) {
          if (args[0] instanceof Float32Array) {
              if (args[0].length !== 4) {
                  throw new Error();
              }
              this.data = args[0];
          }
          else {
              const rr = typeof args[0] === "number" ? args[0] : 0.5;
              const gg = typeof args[1] === "number" ? args[1] : 0.5;
              const bb = typeof args[2] === "number" ? args[2] : 0.5;
              const aa = typeof args[3] === "number" ? args[3] : 1.0;
              this.data = new Float32Array([rr, gg, bb, aa]);
          }
      }
      get r() { return this.data[0]; }
      set r(value) { this.data[0] = value; }
      get g() { return this.data[1]; }
      set g(value) { this.data[1] = value; }
      get b() { return this.data[2]; }
      set b(value) { this.data[2] = value; }
      get a() { return this.data[3]; }
      set a(value) { this.data[3] = value; }
      Clone() {
          return new b2TypedColor(new Float32Array(this.data));
      }
      Copy(other) {
          if (other instanceof b2TypedColor) {
              this.data.set(other.data);
          }
          else {
              this.r = other.r;
              this.g = other.g;
              this.b = other.b;
              this.a = other.a;
          }
          return this;
      }
      IsEqual(color) {
          return (this.r === color.r) && (this.g === color.g) && (this.b === color.b) && (this.a === color.a);
      }
      IsZero() {
          return (this.r === 0) && (this.g === 0) && (this.b === 0) && (this.a === 0);
      }
      Set(r, g, b, a = this.a) {
          this.SetRGBA(r, g, b, a);
      }
      SetByteRGB(r, g, b) {
          this.r = r / 0xff;
          this.g = g / 0xff;
          this.b = b / 0xff;
          return this;
      }
      SetByteRGBA(r, g, b, a) {
          this.r = r / 0xff;
          this.g = g / 0xff;
          this.b = b / 0xff;
          this.a = a / 0xff;
          return this;
      }
      SetRGB(rr, gg, bb) {
          this.r = rr;
          this.g = gg;
          this.b = bb;
          return this;
      }
      SetRGBA(rr, gg, bb, aa) {
          this.r = rr;
          this.g = gg;
          this.b = bb;
          this.a = aa;
          return this;
      }
      SelfAdd(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          this.a += color.a;
          return this;
      }
      Add(color, out) {
          out.r = this.r + color.r;
          out.g = this.g + color.g;
          out.b = this.b + color.b;
          out.a = this.a + color.a;
          return out;
      }
      SelfSub(color) {
          this.r -= color.r;
          this.g -= color.g;
          this.b -= color.b;
          this.a -= color.a;
          return this;
      }
      Sub(color, out) {
          out.r = this.r - color.r;
          out.g = this.g - color.g;
          out.b = this.b - color.b;
          out.a = this.a - color.a;
          return out;
      }
      SelfMul(s) {
          this.r *= s;
          this.g *= s;
          this.b *= s;
          this.a *= s;
          return this;
      }
      Mul(s, out) {
          out.r = this.r * s;
          out.g = this.g * s;
          out.b = this.b * s;
          out.a = this.a * s;
          return out;
      }
      Mix(mixColor, strength) {
          b2Color.MixColors(this, mixColor, strength);
      }
      MakeStyleString(alpha = this.a) {
          return b2Color.MakeStyleString(this.r, this.g, this.b, alpha);
      }
  }
  (function (b2DrawFlags) {
      b2DrawFlags[b2DrawFlags["e_none"] = 0] = "e_none";
      b2DrawFlags[b2DrawFlags["e_shapeBit"] = 1] = "e_shapeBit";
      b2DrawFlags[b2DrawFlags["e_jointBit"] = 2] = "e_jointBit";
      b2DrawFlags[b2DrawFlags["e_aabbBit"] = 4] = "e_aabbBit";
      b2DrawFlags[b2DrawFlags["e_pairBit"] = 8] = "e_pairBit";
      b2DrawFlags[b2DrawFlags["e_centerOfMassBit"] = 16] = "e_centerOfMassBit";
      // #if B2_ENABLE_PARTICLE
      b2DrawFlags[b2DrawFlags["e_particleBit"] = 32] = "e_particleBit";
      // #endif
      // #if B2_ENABLE_CONTROLLER
      b2DrawFlags[b2DrawFlags["e_controllerBit"] = 64] = "e_controllerBit";
      // #endif
      b2DrawFlags[b2DrawFlags["e_all"] = 63] = "e_all";
  })(exports.DrawFlags || (exports.DrawFlags = {}));
  /// Implement and register this class with a b2World to provide debug drawing of physics
  /// entities in your game.
  class b2Draw {
      constructor() {
          this.m_drawFlags = 0;
      }
      SetFlags(flags) {
          this.m_drawFlags = flags;
      }
      GetFlags() {
          return this.m_drawFlags;
      }
      AppendFlags(flags) {
          this.m_drawFlags |= flags;
      }
      ClearFlags(flags) {
          this.m_drawFlags &= ~flags;
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  // import { b2_lengthUnitsPerMeter } from "./b2_settings.js";
  function b2Assert(condition, ...args) {
      if (!condition) {
          // debugger;
          throw new Error(...args);
      }
  }
  function b2Maybe(value, def) {
      return value !== undefined ? value : def;
  }
  const b2_maxFloat = 1E+37; // FLT_MAX instead of Number.MAX_VALUE;
  const b2_epsilon = 1E-5; // FLT_EPSILON instead of Number.EPSILON;
  const b2_epsilon_sq = (b2_epsilon * b2_epsilon);
  const b2_pi = 3.14159265359; // Math.PI;
  /// @file
  /// Global tuning constants based on meters-kilograms-seconds (MKS) units.
  ///
  // Tunable Constants
  /// You can use this to change the length scale used by your game.
  /// For example for inches you could use 39.4.
  const b2_lengthUnitsPerMeter = 1.0;
  /// The maximum number of vertices on a convex polygon. You cannot increase
  /// this too much because b2BlockAllocator has a maximum object size.
  const b2_maxPolygonVertices = 8;
  // Collision
  /// The maximum number of contact points between two convex shapes. Do
  /// not change this value.
  const b2_maxManifoldPoints = 2;
  /// This is used to fatten AABBs in the dynamic tree. This allows proxies
  /// to move by a small amount without triggering a tree adjustment.
  /// This is in meters.
  const b2_aabbExtension = 0.1 * b2_lengthUnitsPerMeter;
  /// This is used to fatten AABBs in the dynamic tree. This is used to predict
  /// the future position based on the current displacement.
  /// This is a dimensionless multiplier.
  const b2_aabbMultiplier = 4;
  /// A small length used as a collision and constraint tolerance. Usually it is
  /// chosen to be numerically significant, but visually insignificant.
  const b2_linearSlop = 0.005 * b2_lengthUnitsPerMeter;
  /// A small angle used as a collision and constraint tolerance. Usually it is
  /// chosen to be numerically significant, but visually insignificant.
  const b2_angularSlop = 2 / 180 * b2_pi;
  /// The radius of the polygon/edge shape skin. This should not be modified. Making
  /// this smaller means polygons will have an insufficient buffer for continuous collision.
  /// Making it larger may create artifacts for vertex collision.
  const b2_polygonRadius = 2 * b2_linearSlop;
  /// Maximum number of sub-steps per contact in continuous physics simulation.
  const b2_maxSubSteps = 8;
  // Dynamics
  /// Maximum number of contacts to be handled to solve a TOI impact.
  const b2_maxTOIContacts = 32;
  /// The maximum linear position correction used when solving constraints. This helps to
  /// prevent overshoot.
  const b2_maxLinearCorrection = 0.2 * b2_lengthUnitsPerMeter;
  /// The maximum angular position correction used when solving constraints. This helps to
  /// prevent overshoot.
  const b2_maxAngularCorrection = 8 / 180 * b2_pi;
  /// The maximum linear velocity of a body. This limit is very large and is used
  /// to prevent numerical problems. You shouldn't need to adjust this.
  const b2_maxTranslation = 2 * b2_lengthUnitsPerMeter;
  const b2_maxTranslationSquared = b2_maxTranslation * b2_maxTranslation;
  /// The maximum angular velocity of a body. This limit is very large and is used
  /// to prevent numerical problems. You shouldn't need to adjust this.
  const b2_maxRotation = 0.5 * b2_pi;
  const b2_maxRotationSquared = b2_maxRotation * b2_maxRotation;
  /// This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
  /// that overlap is removed in one time step. However using values close to 1 often lead
  /// to overshoot.
  const b2_baumgarte = 0.2;
  const b2_toiBaumgarte = 0.75;
  // #if B2_ENABLE_PARTICLE
  // Particle
  /// A symbolic constant that stands for particle allocation error.
  const b2_invalidParticleIndex = -1;
  const b2_maxParticleIndex = 0x7FFFFFFF;
  /// The default distance between particles, multiplied by the particle diameter.
  const b2_particleStride = 0.75;
  /// The minimum particle weight that produces pressure.
  const b2_minParticleWeight = 1.0;
  /// The upper limit for particle pressure.
  const b2_maxParticlePressure = 0.25;
  /// The upper limit for force between particles.
  const b2_maxParticleForce = 0.5;
  /// The maximum distance between particles in a triad, multiplied by the particle diameter.
  const b2_maxTriadDistance = 2.0 * b2_lengthUnitsPerMeter;
  const b2_maxTriadDistanceSquared = (b2_maxTriadDistance * b2_maxTriadDistance);
  /// The initial size of particle data buffers.
  const b2_minParticleSystemBufferCapacity = 256;
  /// The time into the future that collisions against barrier particles will be detected.
  const b2_barrierCollisionTime = 2.5;
  // #endif
  // Sleep
  /// The time that a body must be still before it will go to sleep.
  const b2_timeToSleep = 0.5;
  /// A body cannot sleep if its linear velocity is above this tolerance.
  const b2_linearSleepTolerance = 0.01 * b2_lengthUnitsPerMeter;
  /// A body cannot sleep if its angular velocity is above this tolerance.
  const b2_angularSleepTolerance = 2 / 180 * b2_pi;
  // FILE* b2_dumpFile = nullptr;
  // void b2OpenDump(const char* fileName)
  // {
  // 	b2Assert(b2_dumpFile == nullptr);
  // 	b2_dumpFile = fopen(fileName, "w");
  // }
  // void b2Dump(const char* string, ...)
  // {
  // 	if (b2_dumpFile == nullptr)
  // 	{
  // 		return;
  // 	}
  // 	va_list args;
  // 	va_start(args, string);
  // 	vfprintf(b2_dumpFile, string, args);
  // 	va_end(args);
  // }
  // void b2CloseDump()
  // {
  // 	fclose(b2_dumpFile);
  // 	b2_dumpFile = nullptr;
  // }
  /// Version numbering scheme.
  /// See http://en.wikipedia.org/wiki/Software_versioning
  class b2Version {
      constructor(major = 0, minor = 0, revision = 0) {
          this.major = 0; ///< significant changes
          this.minor = 0; ///< incremental changes
          this.revision = 0; ///< bug fixes
          this.major = major;
          this.minor = minor;
          this.revision = revision;
      }
      toString() {
          return this.major + "." + this.minor + "." + this.revision;
      }
  }
  /// Current version.
  const b2_version = new b2Version(2, 4, 1);
  const b2_branch = "master";
  const b2_commit = "9ebbbcd960ad424e03e5de6e66a40764c16f51bc";
  function b2ParseInt(v) {
      return parseInt(v, 10);
  }
  function b2ParseUInt(v) {
      return Math.abs(parseInt(v, 10));
  }
  function b2MakeArray(length, init) {
      const a = new Array(length);
      for (let i = 0; i < length; ++i) {
          a[i] = init(i);
      }
      return a;
  }
  function b2MakeNullArray(length) {
      const a = new Array(length);
      for (let i = 0; i < length; ++i) {
          a[i] = null;
      }
      return a;
  }
  function b2MakeNumberArray(length, init = 0) {
      const a = new Array(length);
      for (let i = 0; i < length; ++i) {
          a[i] = init;
      }
      return a;
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// @file
  /// Settings that can be overriden for your application
  ///
  // Tunable Constants
  /// You can use this to change the length scale used by your game.
  /// For example for inches you could use 39.4.
  // export const b2_lengthUnitsPerMeter: number = 1.0;
  /// The maximum number of vertices on a convex polygon. You cannot increase
  /// this too much because b2BlockAllocator has a maximum object size.
  // export const b2_maxPolygonVertices: number = 8;
  // Memory Allocation
  /// Implement this function to use your own memory allocator.
  function b2Alloc(size) {
      return null;
  }
  /// If you implement b2Alloc, you should also implement this function.
  function b2Free(mem) {
  }
  /// Logging function.
  function b2Log(message, ...args) {
      // console.log(message, ...args);
  }

  /*
  * Copyright (c) 2010 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// This is a growable LIFO stack with an initial capacity of N.
  /// If the stack size exceeds the initial capacity, the heap is used
  /// to increase the size of the stack.
  class b2GrowableStack {
      constructor(N) {
          this.m_stack = [];
          this.m_count = 0;
          this.m_stack = b2MakeArray(N, (index) => null);
          this.m_count = 0;
      }
      Reset() {
          this.m_count = 0;
          return this;
      }
      Push(element) {
          this.m_stack[this.m_count] = element;
          this.m_count++;
      }
      Pop() {
          // DEBUG: b2Assert(this.m_count > 0);
          this.m_count--;
          const element = this.m_stack[this.m_count];
          this.m_stack[this.m_count] = null;
          return element;
      }
      GetCount() {
          return this.m_count;
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  const b2_pi_over_180 = b2_pi / 180;
  const b2_180_over_pi = 180 / b2_pi;
  const b2_two_pi = 2 * b2_pi;
  const b2Abs = Math.abs;
  function b2Min(a, b) { return a < b ? a : b; }
  function b2Max(a, b) { return a > b ? a : b; }
  function b2Clamp(a, lo, hi) {
      return (a < lo) ? (lo) : ((a > hi) ? (hi) : (a));
  }
  function b2Swap(a, b) {
      // DEBUG: b2Assert(false);
      const tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
  }
  /// This function is used to ensure that a floating point number is
  /// not a NaN or infinity.
  const b2IsValid = isFinite;
  function b2Sq(n) {
      return n * n;
  }
  /// This is a approximate yet fast inverse square-root.
  function b2InvSqrt(n) {
      return 1 / Math.sqrt(n);
  }
  const b2Sqrt = Math.sqrt;
  const b2Pow = Math.pow;
  function b2DegToRad(degrees) {
      return degrees * b2_pi_over_180;
  }
  function b2RadToDeg(radians) {
      return radians * b2_180_over_pi;
  }
  const b2Cos = Math.cos;
  const b2Sin = Math.sin;
  const b2Acos = Math.acos;
  const b2Asin = Math.asin;
  const b2Atan2 = Math.atan2;
  function b2NextPowerOfTwo(x) {
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
  }
  function b2IsPowerOfTwo(x) {
      return x > 0 && (x & (x - 1)) === 0;
  }
  function b2Random() {
      return Math.random() * 2 - 1;
  }
  function b2RandomRange(lo, hi) {
      return (hi - lo) * Math.random() + lo;
  }
  /// A 2D column vector.
  class b2Vec2 {
      constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
      }
      Clone() {
          return new b2Vec2(this.x, this.y);
      }
      SetZero() {
          this.x = 0;
          this.y = 0;
          return this;
      }
      Set(x, y) {
          this.x = x;
          this.y = y;
          return this;
      }
      Copy(other) {
          this.x = other.x;
          this.y = other.y;
          return this;
      }
      SelfAdd(v) {
          this.x += v.x;
          this.y += v.y;
          return this;
      }
      SelfAddXY(x, y) {
          this.x += x;
          this.y += y;
          return this;
      }
      SelfSub(v) {
          this.x -= v.x;
          this.y -= v.y;
          return this;
      }
      SelfSubXY(x, y) {
          this.x -= x;
          this.y -= y;
          return this;
      }
      SelfMul(s) {
          this.x *= s;
          this.y *= s;
          return this;
      }
      SelfMulAdd(s, v) {
          this.x += s * v.x;
          this.y += s * v.y;
          return this;
      }
      SelfMulSub(s, v) {
          this.x -= s * v.x;
          this.y -= s * v.y;
          return this;
      }
      Dot(v) {
          return this.x * v.x + this.y * v.y;
      }
      Cross(v) {
          return this.x * v.y - this.y * v.x;
      }
      Length() {
          const x = this.x, y = this.y;
          return Math.sqrt(x * x + y * y);
      }
      LengthSquared() {
          const x = this.x, y = this.y;
          return (x * x + y * y);
      }
      Normalize() {
          const length = this.Length();
          if (length >= b2_epsilon) {
              const inv_length = 1 / length;
              this.x *= inv_length;
              this.y *= inv_length;
          }
          return length;
      }
      SelfNormalize() {
          const length = this.Length();
          if (length >= b2_epsilon) {
              const inv_length = 1 / length;
              this.x *= inv_length;
              this.y *= inv_length;
          }
          return this;
      }
      SelfRotate(radians) {
          const c = Math.cos(radians);
          const s = Math.sin(radians);
          const x = this.x;
          this.x = c * x - s * this.y;
          this.y = s * x + c * this.y;
          return this;
      }
      SelfRotateCosSin(c, s) {
          const x = this.x;
          this.x = c * x - s * this.y;
          this.y = s * x + c * this.y;
          return this;
      }
      IsValid() {
          return isFinite(this.x) && isFinite(this.y);
      }
      SelfCrossVS(s) {
          const x = this.x;
          this.x = s * this.y;
          this.y = -s * x;
          return this;
      }
      SelfCrossSV(s) {
          const x = this.x;
          this.x = -s * this.y;
          this.y = s * x;
          return this;
      }
      SelfMinV(v) {
          this.x = b2Min(this.x, v.x);
          this.y = b2Min(this.y, v.y);
          return this;
      }
      SelfMaxV(v) {
          this.x = b2Max(this.x, v.x);
          this.y = b2Max(this.y, v.y);
          return this;
      }
      SelfAbs() {
          this.x = b2Abs(this.x);
          this.y = b2Abs(this.y);
          return this;
      }
      SelfNeg() {
          this.x = (-this.x);
          this.y = (-this.y);
          return this;
      }
      SelfSkew() {
          const x = this.x;
          this.x = -this.y;
          this.y = x;
          return this;
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2Vec2());
      }
      static AbsV(v, out) {
          out.x = b2Abs(v.x);
          out.y = b2Abs(v.y);
          return out;
      }
      static MinV(a, b, out) {
          out.x = b2Min(a.x, b.x);
          out.y = b2Min(a.y, b.y);
          return out;
      }
      static MaxV(a, b, out) {
          out.x = b2Max(a.x, b.x);
          out.y = b2Max(a.y, b.y);
          return out;
      }
      static ClampV(v, lo, hi, out) {
          out.x = b2Clamp(v.x, lo.x, hi.x);
          out.y = b2Clamp(v.y, lo.y, hi.y);
          return out;
      }
      static RotateV(v, radians, out) {
          const v_x = v.x, v_y = v.y;
          const c = Math.cos(radians);
          const s = Math.sin(radians);
          out.x = c * v_x - s * v_y;
          out.y = s * v_x + c * v_y;
          return out;
      }
      static DotVV(a, b) {
          return a.x * b.x + a.y * b.y;
      }
      static CrossVV(a, b) {
          return a.x * b.y - a.y * b.x;
      }
      static CrossVS(v, s, out) {
          const v_x = v.x;
          out.x = s * v.y;
          out.y = -s * v_x;
          return out;
      }
      static CrossVOne(v, out) {
          const v_x = v.x;
          out.x = v.y;
          out.y = -v_x;
          return out;
      }
      static CrossSV(s, v, out) {
          const v_x = v.x;
          out.x = -s * v.y;
          out.y = s * v_x;
          return out;
      }
      static CrossOneV(v, out) {
          const v_x = v.x;
          out.x = -v.y;
          out.y = v_x;
          return out;
      }
      static AddVV(a, b, out) { out.x = a.x + b.x; out.y = a.y + b.y; return out; }
      static SubVV(a, b, out) { out.x = a.x - b.x; out.y = a.y - b.y; return out; }
      static MulSV(s, v, out) { out.x = v.x * s; out.y = v.y * s; return out; }
      static MulVS(v, s, out) { out.x = v.x * s; out.y = v.y * s; return out; }
      static AddVMulSV(a, s, b, out) { out.x = a.x + (s * b.x); out.y = a.y + (s * b.y); return out; }
      static SubVMulSV(a, s, b, out) { out.x = a.x - (s * b.x); out.y = a.y - (s * b.y); return out; }
      static AddVCrossSV(a, s, v, out) {
          const v_x = v.x;
          out.x = a.x - (s * v.y);
          out.y = a.y + (s * v_x);
          return out;
      }
      static MidVV(a, b, out) { out.x = (a.x + b.x) * 0.5; out.y = (a.y + b.y) * 0.5; return out; }
      static ExtVV(a, b, out) { out.x = (b.x - a.x) * 0.5; out.y = (b.y - a.y) * 0.5; return out; }
      static IsEqualToV(a, b) {
          return a.x === b.x && a.y === b.y;
      }
      static DistanceVV(a, b) {
          const c_x = a.x - b.x;
          const c_y = a.y - b.y;
          return Math.sqrt(c_x * c_x + c_y * c_y);
      }
      static DistanceSquaredVV(a, b) {
          const c_x = a.x - b.x;
          const c_y = a.y - b.y;
          return (c_x * c_x + c_y * c_y);
      }
      static NegV(v, out) { out.x = -v.x; out.y = -v.y; return out; }
  }
  b2Vec2.ZERO = new b2Vec2(0, 0);
  b2Vec2.UNITX = new b2Vec2(1, 0);
  b2Vec2.UNITY = new b2Vec2(0, 1);
  b2Vec2.s_t0 = new b2Vec2();
  b2Vec2.s_t1 = new b2Vec2();
  b2Vec2.s_t2 = new b2Vec2();
  b2Vec2.s_t3 = new b2Vec2();
  const b2Vec2_zero = new b2Vec2(0, 0);
  class b2TypedVec2 {
      constructor(...args) {
          if (args[0] instanceof Float32Array) {
              if (args[0].length !== 2) {
                  throw new Error();
              }
              this.data = args[0];
          }
          else {
              const x = typeof args[0] === "number" ? args[0] : 0;
              const y = typeof args[1] === "number" ? args[1] : 0;
              this.data = new Float32Array([x, y]);
          }
      }
      get x() { return this.data[0]; }
      set x(value) { this.data[0] = value; }
      get y() { return this.data[1]; }
      set y(value) { this.data[1] = value; }
      Clone() {
          return new b2TypedVec2(new Float32Array(this.data));
      }
      SetZero() {
          this.x = 0;
          this.y = 0;
          return this;
      }
      Set(x, y) {
          this.x = x;
          this.y = y;
          return this;
      }
      Copy(other) {
          if (other instanceof b2TypedVec2) {
              this.data.set(other.data);
          }
          else {
              this.x = other.x;
              this.y = other.y;
          }
          return this;
      }
      SelfAdd(v) {
          this.x += v.x;
          this.y += v.y;
          return this;
      }
      SelfAddXY(x, y) {
          this.x += x;
          this.y += y;
          return this;
      }
      SelfSub(v) {
          this.x -= v.x;
          this.y -= v.y;
          return this;
      }
      SelfSubXY(x, y) {
          this.x -= x;
          this.y -= y;
          return this;
      }
      SelfMul(s) {
          this.x *= s;
          this.y *= s;
          return this;
      }
      SelfMulAdd(s, v) {
          this.x += s * v.x;
          this.y += s * v.y;
          return this;
      }
      SelfMulSub(s, v) {
          this.x -= s * v.x;
          this.y -= s * v.y;
          return this;
      }
      Dot(v) {
          return this.x * v.x + this.y * v.y;
      }
      Cross(v) {
          return this.x * v.y - this.y * v.x;
      }
      Length() {
          const x = this.x, y = this.y;
          return Math.sqrt(x * x + y * y);
      }
      LengthSquared() {
          const x = this.x, y = this.y;
          return (x * x + y * y);
      }
      Normalize() {
          const length = this.Length();
          if (length >= b2_epsilon) {
              const inv_length = 1 / length;
              this.x *= inv_length;
              this.y *= inv_length;
          }
          return length;
      }
      SelfNormalize() {
          const length = this.Length();
          if (length >= b2_epsilon) {
              const inv_length = 1 / length;
              this.x *= inv_length;
              this.y *= inv_length;
          }
          return this;
      }
      SelfRotate(radians) {
          const c = Math.cos(radians);
          const s = Math.sin(radians);
          const x = this.x;
          this.x = c * x - s * this.y;
          this.y = s * x + c * this.y;
          return this;
      }
      SelfRotateCosSin(c, s) {
          const x = this.x;
          this.x = c * x - s * this.y;
          this.y = s * x + c * this.y;
          return this;
      }
      IsValid() {
          return isFinite(this.x) && isFinite(this.y);
      }
      SelfCrossVS(s) {
          const x = this.x;
          this.x = s * this.y;
          this.y = -s * x;
          return this;
      }
      SelfCrossSV(s) {
          const x = this.x;
          this.x = -s * this.y;
          this.y = s * x;
          return this;
      }
      SelfMinV(v) {
          this.x = b2Min(this.x, v.x);
          this.y = b2Min(this.y, v.y);
          return this;
      }
      SelfMaxV(v) {
          this.x = b2Max(this.x, v.x);
          this.y = b2Max(this.y, v.y);
          return this;
      }
      SelfAbs() {
          this.x = b2Abs(this.x);
          this.y = b2Abs(this.y);
          return this;
      }
      SelfNeg() {
          this.x = (-this.x);
          this.y = (-this.y);
          return this;
      }
      SelfSkew() {
          const x = this.x;
          this.x = -this.y;
          this.y = x;
          return this;
      }
  }
  /// A 2D column vector with 3 elements.
  class b2Vec3 {
      constructor(...args) {
          if (args[0] instanceof Float32Array) {
              if (args[0].length !== 3) {
                  throw new Error();
              }
              this.data = args[0];
          }
          else {
              const x = typeof args[0] === "number" ? args[0] : 0;
              const y = typeof args[1] === "number" ? args[1] : 0;
              const z = typeof args[2] === "number" ? args[2] : 0;
              this.data = new Float32Array([x, y, z]);
          }
      }
      get x() { return this.data[0]; }
      set x(value) { this.data[0] = value; }
      get y() { return this.data[1]; }
      set y(value) { this.data[1] = value; }
      get z() { return this.data[2]; }
      set z(value) { this.data[2] = value; }
      Clone() {
          return new b2Vec3(this.x, this.y, this.z);
      }
      SetZero() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          return this;
      }
      SetXYZ(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
      }
      Copy(other) {
          this.x = other.x;
          this.y = other.y;
          this.z = other.z;
          return this;
      }
      SelfNeg() {
          this.x = (-this.x);
          this.y = (-this.y);
          this.z = (-this.z);
          return this;
      }
      SelfAdd(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
      }
      SelfAddXYZ(x, y, z) {
          this.x += x;
          this.y += y;
          this.z += z;
          return this;
      }
      SelfSub(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
      }
      SelfSubXYZ(x, y, z) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          return this;
      }
      SelfMul(s) {
          this.x *= s;
          this.y *= s;
          this.z *= s;
          return this;
      }
      static DotV3V3(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
      }
      static CrossV3V3(a, b, out) {
          const a_x = a.x, a_y = a.y, a_z = a.z;
          const b_x = b.x, b_y = b.y, b_z = b.z;
          out.x = a_y * b_z - a_z * b_y;
          out.y = a_z * b_x - a_x * b_z;
          out.z = a_x * b_y - a_y * b_x;
          return out;
      }
  }
  b2Vec3.ZERO = new b2Vec3(0, 0, 0);
  b2Vec3.s_t0 = new b2Vec3();
  /// A 2-by-2 matrix. Stored in column-major order.
  class b2Mat22 {
      constructor() {
          // public readonly data: Float32Array = new Float32Array([ 1, 0, 0, 1 ]);
          // public readonly ex: b2Vec2 = new b2Vec2(this.data.subarray(0, 2));
          // public readonly ey: b2Vec2 = new b2Vec2(this.data.subarray(2, 4));
          this.ex = new b2Vec2(1, 0);
          this.ey = new b2Vec2(0, 1);
      }
      Clone() {
          return new b2Mat22().Copy(this);
      }
      static FromVV(c1, c2) {
          return new b2Mat22().SetVV(c1, c2);
      }
      static FromSSSS(r1c1, r1c2, r2c1, r2c2) {
          return new b2Mat22().SetSSSS(r1c1, r1c2, r2c1, r2c2);
      }
      static FromAngle(radians) {
          return new b2Mat22().SetAngle(radians);
      }
      SetSSSS(r1c1, r1c2, r2c1, r2c2) {
          this.ex.Set(r1c1, r2c1);
          this.ey.Set(r1c2, r2c2);
          return this;
      }
      SetVV(c1, c2) {
          this.ex.Copy(c1);
          this.ey.Copy(c2);
          return this;
      }
      SetAngle(radians) {
          const c = Math.cos(radians);
          const s = Math.sin(radians);
          this.ex.Set(c, s);
          this.ey.Set(-s, c);
          return this;
      }
      Copy(other) {
          this.ex.Copy(other.ex);
          this.ey.Copy(other.ey);
          return this;
      }
      SetIdentity() {
          this.ex.Set(1, 0);
          this.ey.Set(0, 1);
          return this;
      }
      SetZero() {
          this.ex.SetZero();
          this.ey.SetZero();
          return this;
      }
      GetAngle() {
          return Math.atan2(this.ex.y, this.ex.x);
      }
      GetInverse(out) {
          const a = this.ex.x;
          const b = this.ey.x;
          const c = this.ex.y;
          const d = this.ey.y;
          let det = a * d - b * c;
          if (det !== 0) {
              det = 1 / det;
          }
          out.ex.x = det * d;
          out.ey.x = (-det * b);
          out.ex.y = (-det * c);
          out.ey.y = det * a;
          return out;
      }
      Solve(b_x, b_y, out) {
          const a11 = this.ex.x, a12 = this.ey.x;
          const a21 = this.ex.y, a22 = this.ey.y;
          let det = a11 * a22 - a12 * a21;
          if (det !== 0) {
              det = 1 / det;
          }
          out.x = det * (a22 * b_x - a12 * b_y);
          out.y = det * (a11 * b_y - a21 * b_x);
          return out;
      }
      SelfAbs() {
          this.ex.SelfAbs();
          this.ey.SelfAbs();
          return this;
      }
      SelfInv() {
          this.GetInverse(this);
          return this;
      }
      SelfAddM(M) {
          this.ex.SelfAdd(M.ex);
          this.ey.SelfAdd(M.ey);
          return this;
      }
      SelfSubM(M) {
          this.ex.SelfSub(M.ex);
          this.ey.SelfSub(M.ey);
          return this;
      }
      static AbsM(M, out) {
          const M_ex = M.ex, M_ey = M.ey;
          out.ex.x = b2Abs(M_ex.x);
          out.ex.y = b2Abs(M_ex.y);
          out.ey.x = b2Abs(M_ey.x);
          out.ey.y = b2Abs(M_ey.y);
          return out;
      }
      static MulMV(M, v, out) {
          const M_ex = M.ex, M_ey = M.ey;
          const v_x = v.x, v_y = v.y;
          out.x = M_ex.x * v_x + M_ey.x * v_y;
          out.y = M_ex.y * v_x + M_ey.y * v_y;
          return out;
      }
      static MulTMV(M, v, out) {
          const M_ex = M.ex, M_ey = M.ey;
          const v_x = v.x, v_y = v.y;
          out.x = M_ex.x * v_x + M_ex.y * v_y;
          out.y = M_ey.x * v_x + M_ey.y * v_y;
          return out;
      }
      static AddMM(A, B, out) {
          const A_ex = A.ex, A_ey = A.ey;
          const B_ex = B.ex, B_ey = B.ey;
          out.ex.x = A_ex.x + B_ex.x;
          out.ex.y = A_ex.y + B_ex.y;
          out.ey.x = A_ey.x + B_ey.x;
          out.ey.y = A_ey.y + B_ey.y;
          return out;
      }
      static MulMM(A, B, out) {
          const A_ex_x = A.ex.x, A_ex_y = A.ex.y;
          const A_ey_x = A.ey.x, A_ey_y = A.ey.y;
          const B_ex_x = B.ex.x, B_ex_y = B.ex.y;
          const B_ey_x = B.ey.x, B_ey_y = B.ey.y;
          out.ex.x = A_ex_x * B_ex_x + A_ey_x * B_ex_y;
          out.ex.y = A_ex_y * B_ex_x + A_ey_y * B_ex_y;
          out.ey.x = A_ex_x * B_ey_x + A_ey_x * B_ey_y;
          out.ey.y = A_ex_y * B_ey_x + A_ey_y * B_ey_y;
          return out;
      }
      static MulTMM(A, B, out) {
          const A_ex_x = A.ex.x, A_ex_y = A.ex.y;
          const A_ey_x = A.ey.x, A_ey_y = A.ey.y;
          const B_ex_x = B.ex.x, B_ex_y = B.ex.y;
          const B_ey_x = B.ey.x, B_ey_y = B.ey.y;
          out.ex.x = A_ex_x * B_ex_x + A_ex_y * B_ex_y;
          out.ex.y = A_ey_x * B_ex_x + A_ey_y * B_ex_y;
          out.ey.x = A_ex_x * B_ey_x + A_ex_y * B_ey_y;
          out.ey.y = A_ey_x * B_ey_x + A_ey_y * B_ey_y;
          return out;
      }
  }
  b2Mat22.IDENTITY = new b2Mat22();
  /// A 3-by-3 matrix. Stored in column-major order.
  class b2Mat33 {
      constructor() {
          this.data = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
          this.ex = new b2Vec3(this.data.subarray(0, 3));
          this.ey = new b2Vec3(this.data.subarray(3, 6));
          this.ez = new b2Vec3(this.data.subarray(6, 9));
      }
      Clone() {
          return new b2Mat33().Copy(this);
      }
      SetVVV(c1, c2, c3) {
          this.ex.Copy(c1);
          this.ey.Copy(c2);
          this.ez.Copy(c3);
          return this;
      }
      Copy(other) {
          this.ex.Copy(other.ex);
          this.ey.Copy(other.ey);
          this.ez.Copy(other.ez);
          return this;
      }
      SetIdentity() {
          this.ex.SetXYZ(1, 0, 0);
          this.ey.SetXYZ(0, 1, 0);
          this.ez.SetXYZ(0, 0, 1);
          return this;
      }
      SetZero() {
          this.ex.SetZero();
          this.ey.SetZero();
          this.ez.SetZero();
          return this;
      }
      SelfAddM(M) {
          this.ex.SelfAdd(M.ex);
          this.ey.SelfAdd(M.ey);
          this.ez.SelfAdd(M.ez);
          return this;
      }
      Solve33(b_x, b_y, b_z, out) {
          const a11 = this.ex.x, a21 = this.ex.y, a31 = this.ex.z;
          const a12 = this.ey.x, a22 = this.ey.y, a32 = this.ey.z;
          const a13 = this.ez.x, a23 = this.ez.y, a33 = this.ez.z;
          let det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
          if (det !== 0) {
              det = 1 / det;
          }
          out.x = det * (b_x * (a22 * a33 - a32 * a23) + b_y * (a32 * a13 - a12 * a33) + b_z * (a12 * a23 - a22 * a13));
          out.y = det * (a11 * (b_y * a33 - b_z * a23) + a21 * (b_z * a13 - b_x * a33) + a31 * (b_x * a23 - b_y * a13));
          out.z = det * (a11 * (a22 * b_z - a32 * b_y) + a21 * (a32 * b_x - a12 * b_z) + a31 * (a12 * b_y - a22 * b_x));
          return out;
      }
      Solve22(b_x, b_y, out) {
          const a11 = this.ex.x, a12 = this.ey.x;
          const a21 = this.ex.y, a22 = this.ey.y;
          let det = a11 * a22 - a12 * a21;
          if (det !== 0) {
              det = 1 / det;
          }
          out.x = det * (a22 * b_x - a12 * b_y);
          out.y = det * (a11 * b_y - a21 * b_x);
          return out;
      }
      GetInverse22(M) {
          const a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
          let det = a * d - b * c;
          if (det !== 0) {
              det = 1 / det;
          }
          M.ex.x = det * d;
          M.ey.x = -det * b;
          M.ex.z = 0;
          M.ex.y = -det * c;
          M.ey.y = det * a;
          M.ey.z = 0;
          M.ez.x = 0;
          M.ez.y = 0;
          M.ez.z = 0;
      }
      GetSymInverse33(M) {
          let det = b2Vec3.DotV3V3(this.ex, b2Vec3.CrossV3V3(this.ey, this.ez, b2Vec3.s_t0));
          if (det !== 0) {
              det = 1 / det;
          }
          const a11 = this.ex.x, a12 = this.ey.x, a13 = this.ez.x;
          const a22 = this.ey.y, a23 = this.ez.y;
          const a33 = this.ez.z;
          M.ex.x = det * (a22 * a33 - a23 * a23);
          M.ex.y = det * (a13 * a23 - a12 * a33);
          M.ex.z = det * (a12 * a23 - a13 * a22);
          M.ey.x = M.ex.y;
          M.ey.y = det * (a11 * a33 - a13 * a13);
          M.ey.z = det * (a13 * a12 - a11 * a23);
          M.ez.x = M.ex.z;
          M.ez.y = M.ey.z;
          M.ez.z = det * (a11 * a22 - a12 * a12);
      }
      static MulM33V3(A, v, out) {
          const v_x = v.x, v_y = v.y, v_z = v.z;
          out.x = A.ex.x * v_x + A.ey.x * v_y + A.ez.x * v_z;
          out.y = A.ex.y * v_x + A.ey.y * v_y + A.ez.y * v_z;
          out.z = A.ex.z * v_x + A.ey.z * v_y + A.ez.z * v_z;
          return out;
      }
      static MulM33XYZ(A, x, y, z, out) {
          out.x = A.ex.x * x + A.ey.x * y + A.ez.x * z;
          out.y = A.ex.y * x + A.ey.y * y + A.ez.y * z;
          out.z = A.ex.z * x + A.ey.z * y + A.ez.z * z;
          return out;
      }
      static MulM33V2(A, v, out) {
          const v_x = v.x, v_y = v.y;
          out.x = A.ex.x * v_x + A.ey.x * v_y;
          out.y = A.ex.y * v_x + A.ey.y * v_y;
          return out;
      }
      static MulM33XY(A, x, y, out) {
          out.x = A.ex.x * x + A.ey.x * y;
          out.y = A.ex.y * x + A.ey.y * y;
          return out;
      }
  }
  b2Mat33.IDENTITY = new b2Mat33();
  /// Rotation
  class b2Rot {
      constructor(angle = 0) {
          this.s = 0;
          this.c = 1;
          if (angle) {
              this.s = Math.sin(angle);
              this.c = Math.cos(angle);
          }
      }
      Clone() {
          return new b2Rot().Copy(this);
      }
      Copy(other) {
          this.s = other.s;
          this.c = other.c;
          return this;
      }
      SetAngle(angle) {
          this.s = Math.sin(angle);
          this.c = Math.cos(angle);
          return this;
      }
      SetIdentity() {
          this.s = 0;
          this.c = 1;
          return this;
      }
      GetAngle() {
          return Math.atan2(this.s, this.c);
      }
      GetXAxis(out) {
          out.x = this.c;
          out.y = this.s;
          return out;
      }
      GetYAxis(out) {
          out.x = -this.s;
          out.y = this.c;
          return out;
      }
      static MulRR(q, r, out) {
          // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
          // [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
          // s = qs * rc + qc * rs
          // c = qc * rc - qs * rs
          const q_c = q.c, q_s = q.s;
          const r_c = r.c, r_s = r.s;
          out.s = q_s * r_c + q_c * r_s;
          out.c = q_c * r_c - q_s * r_s;
          return out;
      }
      static MulTRR(q, r, out) {
          // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
          // [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
          // s = qc * rs - qs * rc
          // c = qc * rc + qs * rs
          const q_c = q.c, q_s = q.s;
          const r_c = r.c, r_s = r.s;
          out.s = q_c * r_s - q_s * r_c;
          out.c = q_c * r_c + q_s * r_s;
          return out;
      }
      static MulRV(q, v, out) {
          const q_c = q.c, q_s = q.s;
          const v_x = v.x, v_y = v.y;
          out.x = q_c * v_x - q_s * v_y;
          out.y = q_s * v_x + q_c * v_y;
          return out;
      }
      static MulTRV(q, v, out) {
          const q_c = q.c, q_s = q.s;
          const v_x = v.x, v_y = v.y;
          out.x = q_c * v_x + q_s * v_y;
          out.y = -q_s * v_x + q_c * v_y;
          return out;
      }
  }
  b2Rot.IDENTITY = new b2Rot();
  /// A transform contains translation and rotation. It is used to represent
  /// the position and orientation of rigid frames.
  class b2Transform {
      constructor() {
          this.p = new b2Vec2();
          this.q = new b2Rot();
      }
      Clone() {
          return new b2Transform().Copy(this);
      }
      Copy(other) {
          this.p.Copy(other.p);
          this.q.Copy(other.q);
          return this;
      }
      SetIdentity() {
          this.p.SetZero();
          this.q.SetIdentity();
          return this;
      }
      SetPositionRotation(position, q) {
          this.p.Copy(position);
          this.q.Copy(q);
          return this;
      }
      SetPositionAngle(pos, a) {
          this.p.Copy(pos);
          this.q.SetAngle(a);
          return this;
      }
      SetPosition(position) {
          this.p.Copy(position);
          return this;
      }
      SetPositionXY(x, y) {
          this.p.Set(x, y);
          return this;
      }
      SetRotation(rotation) {
          this.q.Copy(rotation);
          return this;
      }
      SetRotationAngle(radians) {
          this.q.SetAngle(radians);
          return this;
      }
      GetPosition() {
          return this.p;
      }
      GetRotation() {
          return this.q;
      }
      GetRotationAngle() {
          return this.q.GetAngle();
      }
      GetAngle() {
          return this.q.GetAngle();
      }
      static MulXV(T, v, out) {
          // float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
          // float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;
          // return b2Vec2(x, y);
          const T_q_c = T.q.c, T_q_s = T.q.s;
          const v_x = v.x, v_y = v.y;
          out.x = (T_q_c * v_x - T_q_s * v_y) + T.p.x;
          out.y = (T_q_s * v_x + T_q_c * v_y) + T.p.y;
          return out;
      }
      static MulTXV(T, v, out) {
          // float32 px = v.x - T.p.x;
          // float32 py = v.y - T.p.y;
          // float32 x = (T.q.c * px + T.q.s * py);
          // float32 y = (-T.q.s * px + T.q.c * py);
          // return b2Vec2(x, y);
          const T_q_c = T.q.c, T_q_s = T.q.s;
          const p_x = v.x - T.p.x;
          const p_y = v.y - T.p.y;
          out.x = (T_q_c * p_x + T_q_s * p_y);
          out.y = (-T_q_s * p_x + T_q_c * p_y);
          return out;
      }
      static MulXX(A, B, out) {
          b2Rot.MulRR(A.q, B.q, out.q);
          b2Vec2.AddVV(b2Rot.MulRV(A.q, B.p, out.p), A.p, out.p);
          return out;
      }
      static MulTXX(A, B, out) {
          b2Rot.MulTRR(A.q, B.q, out.q);
          b2Rot.MulTRV(A.q, b2Vec2.SubVV(B.p, A.p, out.p), out.p);
          return out;
      }
  }
  b2Transform.IDENTITY = new b2Transform();
  /// This describes the motion of a body/shape for TOI computation.
  /// Shapes are defined with respect to the body origin, which may
  /// no coincide with the center of mass. However, to support dynamics
  /// we must interpolate the center of mass position.
  class b2Sweep {
      constructor() {
          this.localCenter = new b2Vec2();
          this.c0 = new b2Vec2();
          this.c = new b2Vec2();
          this.a0 = 0;
          this.a = 0;
          this.alpha0 = 0;
      }
      Clone() {
          return new b2Sweep().Copy(this);
      }
      Copy(other) {
          this.localCenter.Copy(other.localCenter);
          this.c0.Copy(other.c0);
          this.c.Copy(other.c);
          this.a0 = other.a0;
          this.a = other.a;
          this.alpha0 = other.alpha0;
          return this;
      }
      // https://fgiesen.wordpress.com/2012/08/15/linear-interpolation-past-present-and-future/
      GetTransform(xf, beta) {
          xf.p.x = (1.0 - beta) * this.c0.x + beta * this.c.x;
          xf.p.y = (1.0 - beta) * this.c0.y + beta * this.c.y;
          const angle = (1.0 - beta) * this.a0 + beta * this.a;
          xf.q.SetAngle(angle);
          xf.p.SelfSub(b2Rot.MulRV(xf.q, this.localCenter, b2Vec2.s_t0));
          return xf;
      }
      Advance(alpha) {
          // DEBUG: b2Assert(this.alpha0 < 1);
          const beta = (alpha - this.alpha0) / (1 - this.alpha0);
          const one_minus_beta = (1 - beta);
          this.c0.x = one_minus_beta * this.c0.x + beta * this.c.x;
          this.c0.y = one_minus_beta * this.c0.y + beta * this.c.y;
          this.a0 = one_minus_beta * this.a0 + beta * this.a;
          this.alpha0 = alpha;
      }
      Normalize() {
          const d = b2_two_pi * Math.floor(this.a0 / b2_two_pi);
          this.a0 -= d;
          this.a -= d;
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2StackAllocator {
  }

  /*
  * Copyright (c) 2011 Erin Catto http://box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Timer for profiling. This has platform specific code and may
  /// not work on every platform.
  class b2Timer {
      constructor() {
          this.m_start = Date.now();
      }
      /// Reset the timer.
      Reset() {
          this.m_start = Date.now();
          return this;
      }
      /// Get the time since construction or the last reset.
      GetMilliseconds() {
          return Date.now() - this.m_start;
      }
  }
  class b2Counter {
      constructor() {
          this.m_count = 0;
          this.m_min_count = 0;
          this.m_max_count = 0;
      }
      GetCount() {
          return this.m_count;
      }
      GetMinCount() {
          return this.m_min_count;
      }
      GetMaxCount() {
          return this.m_max_count;
      }
      ResetCount() {
          const count = this.m_count;
          this.m_count = 0;
          return count;
      }
      ResetMinCount() {
          this.m_min_count = 0;
      }
      ResetMaxCount() {
          this.m_max_count = 0;
      }
      Increment() {
          this.m_count++;
          if (this.m_max_count < this.m_count) {
              this.m_max_count = this.m_count;
          }
      }
      Decrement() {
          this.m_count--;
          if (this.m_min_count > this.m_count) {
              this.m_min_count = this.m_count;
          }
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// A distance proxy is used by the GJK algorithm.
  /// It encapsulates any shape.
  class b2DistanceProxy {
      constructor() {
          this.m_buffer = b2Vec2.MakeArray(2);
          this.m_vertices = this.m_buffer;
          this.m_count = 0;
          this.m_radius = 0;
      }
      Copy(other) {
          if (other.m_vertices === other.m_buffer) {
              this.m_vertices = this.m_buffer;
              this.m_buffer[0].Copy(other.m_buffer[0]);
              this.m_buffer[1].Copy(other.m_buffer[1]);
          }
          else {
              this.m_vertices = other.m_vertices;
          }
          this.m_count = other.m_count;
          this.m_radius = other.m_radius;
          return this;
      }
      Reset() {
          this.m_vertices = this.m_buffer;
          this.m_count = 0;
          this.m_radius = 0;
          return this;
      }
      SetShape(shape, index) {
          shape.SetupDistanceProxy(this, index);
      }
      SetVerticesRadius(vertices, count, radius) {
          this.m_vertices = vertices;
          this.m_count = count;
          this.m_radius = radius;
      }
      GetSupport(d) {
          let bestIndex = 0;
          let bestValue = b2Vec2.DotVV(this.m_vertices[0], d);
          for (let i = 1; i < this.m_count; ++i) {
              const value = b2Vec2.DotVV(this.m_vertices[i], d);
              if (value > bestValue) {
                  bestIndex = i;
                  bestValue = value;
              }
          }
          return bestIndex;
      }
      GetSupportVertex(d) {
          let bestIndex = 0;
          let bestValue = b2Vec2.DotVV(this.m_vertices[0], d);
          for (let i = 1; i < this.m_count; ++i) {
              const value = b2Vec2.DotVV(this.m_vertices[i], d);
              if (value > bestValue) {
                  bestIndex = i;
                  bestValue = value;
              }
          }
          return this.m_vertices[bestIndex];
      }
      GetVertexCount() {
          return this.m_count;
      }
      GetVertex(index) {
          // DEBUG: b2Assert(0 <= index && index < this.m_count);
          return this.m_vertices[index];
      }
  }
  class b2SimplexCache {
      constructor() {
          this.metric = 0;
          this.count = 0;
          this.indexA = [0, 0, 0];
          this.indexB = [0, 0, 0];
      }
      Reset() {
          this.metric = 0;
          this.count = 0;
          return this;
      }
  }
  class b2DistanceInput {
      constructor() {
          this.proxyA = new b2DistanceProxy();
          this.proxyB = new b2DistanceProxy();
          this.transformA = new b2Transform();
          this.transformB = new b2Transform();
          this.useRadii = false;
      }
      Reset() {
          this.proxyA.Reset();
          this.proxyB.Reset();
          this.transformA.SetIdentity();
          this.transformB.SetIdentity();
          this.useRadii = false;
          return this;
      }
  }
  class b2DistanceOutput {
      constructor() {
          this.pointA = new b2Vec2();
          this.pointB = new b2Vec2();
          this.distance = 0;
          this.iterations = 0; ///< number of GJK iterations used
      }
      Reset() {
          this.pointA.SetZero();
          this.pointB.SetZero();
          this.distance = 0;
          this.iterations = 0;
          return this;
      }
  }
  /// Input parameters for b2ShapeCast
  class b2ShapeCastInput {
      constructor() {
          this.proxyA = new b2DistanceProxy();
          this.proxyB = new b2DistanceProxy();
          this.transformA = new b2Transform();
          this.transformB = new b2Transform();
          this.translationB = new b2Vec2();
      }
  }
  /// Output results for b2ShapeCast
  class b2ShapeCastOutput {
      constructor() {
          this.point = new b2Vec2();
          this.normal = new b2Vec2();
          this.lambda = 0.0;
          this.iterations = 0;
      }
  }
  exports.gjkCalls = 0;
  exports.gjkIters = 0;
  exports.gjkMaxIters = 0;
  function b2_gjk_reset() {
      exports.gjkCalls = 0;
      exports.gjkIters = 0;
      exports.gjkMaxIters = 0;
  }
  class b2SimplexVertex {
      constructor() {
          this.wA = new b2Vec2(); // support point in proxyA
          this.wB = new b2Vec2(); // support point in proxyB
          this.w = new b2Vec2(); // wB - wA
          this.a = 0; // barycentric coordinate for closest point
          this.indexA = 0; // wA index
          this.indexB = 0; // wB index
      }
      Copy(other) {
          this.wA.Copy(other.wA); // support point in proxyA
          this.wB.Copy(other.wB); // support point in proxyB
          this.w.Copy(other.w); // wB - wA
          this.a = other.a; // barycentric coordinate for closest point
          this.indexA = other.indexA; // wA index
          this.indexB = other.indexB; // wB index
          return this;
      }
  }
  class b2Simplex {
      constructor() {
          this.m_v1 = new b2SimplexVertex();
          this.m_v2 = new b2SimplexVertex();
          this.m_v3 = new b2SimplexVertex();
          this.m_vertices = [ /*3*/];
          this.m_count = 0;
          this.m_vertices[0] = this.m_v1;
          this.m_vertices[1] = this.m_v2;
          this.m_vertices[2] = this.m_v3;
      }
      ReadCache(cache, proxyA, transformA, proxyB, transformB) {
          // DEBUG: b2Assert(0 <= cache.count && cache.count <= 3);
          // Copy data from cache.
          this.m_count = cache.count;
          const vertices = this.m_vertices;
          for (let i = 0; i < this.m_count; ++i) {
              const v = vertices[i];
              v.indexA = cache.indexA[i];
              v.indexB = cache.indexB[i];
              const wALocal = proxyA.GetVertex(v.indexA);
              const wBLocal = proxyB.GetVertex(v.indexB);
              b2Transform.MulXV(transformA, wALocal, v.wA);
              b2Transform.MulXV(transformB, wBLocal, v.wB);
              b2Vec2.SubVV(v.wB, v.wA, v.w);
              v.a = 0;
          }
          // Compute the new simplex metric, if it is substantially different than
          // old metric then flush the simplex.
          if (this.m_count > 1) {
              const metric1 = cache.metric;
              const metric2 = this.GetMetric();
              if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < b2_epsilon) {
                  // Reset the simplex.
                  this.m_count = 0;
              }
          }
          // If the cache is empty or invalid ...
          if (this.m_count === 0) {
              const v = vertices[0];
              v.indexA = 0;
              v.indexB = 0;
              const wALocal = proxyA.GetVertex(0);
              const wBLocal = proxyB.GetVertex(0);
              b2Transform.MulXV(transformA, wALocal, v.wA);
              b2Transform.MulXV(transformB, wBLocal, v.wB);
              b2Vec2.SubVV(v.wB, v.wA, v.w);
              v.a = 1;
              this.m_count = 1;
          }
      }
      WriteCache(cache) {
          cache.metric = this.GetMetric();
          cache.count = this.m_count;
          const vertices = this.m_vertices;
          for (let i = 0; i < this.m_count; ++i) {
              cache.indexA[i] = vertices[i].indexA;
              cache.indexB[i] = vertices[i].indexB;
          }
      }
      GetSearchDirection(out) {
          switch (this.m_count) {
              case 1:
                  return b2Vec2.NegV(this.m_v1.w, out);
              case 2: {
                  const e12 = b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, out);
                  const sgn = b2Vec2.CrossVV(e12, b2Vec2.NegV(this.m_v1.w, b2Vec2.s_t0));
                  if (sgn > 0) {
                      // Origin is left of e12.
                      return b2Vec2.CrossOneV(e12, out);
                  }
                  else {
                      // Origin is right of e12.
                      return b2Vec2.CrossVOne(e12, out);
                  }
              }
              default:
                  // DEBUG: b2Assert(false);
                  return out.SetZero();
          }
      }
      GetClosestPoint(out) {
          switch (this.m_count) {
              case 0:
                  // DEBUG: b2Assert(false);
                  return out.SetZero();
              case 1:
                  return out.Copy(this.m_v1.w);
              case 2:
                  return out.Set(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
              case 3:
                  return out.SetZero();
              default:
                  // DEBUG: b2Assert(false);
                  return out.SetZero();
          }
      }
      GetWitnessPoints(pA, pB) {
          switch (this.m_count) {
              case 0:
                  // DEBUG: b2Assert(false);
                  break;
              case 1:
                  pA.Copy(this.m_v1.wA);
                  pB.Copy(this.m_v1.wB);
                  break;
              case 2:
                  pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                  pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                  pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                  pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                  break;
              case 3:
                  pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                  pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                  break;
          }
      }
      GetMetric() {
          switch (this.m_count) {
              case 0:
                  // DEBUG: b2Assert(false);
                  return 0;
              case 1:
                  return 0;
              case 2:
                  return b2Vec2.DistanceVV(this.m_v1.w, this.m_v2.w);
              case 3:
                  return b2Vec2.CrossVV(b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, b2Vec2.s_t0), b2Vec2.SubVV(this.m_v3.w, this.m_v1.w, b2Vec2.s_t1));
              default:
                  // DEBUG: b2Assert(false);
                  return 0;
          }
      }
      Solve2() {
          const w1 = this.m_v1.w;
          const w2 = this.m_v2.w;
          const e12 = b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);
          // w1 region
          const d12_2 = (-b2Vec2.DotVV(w1, e12));
          if (d12_2 <= 0) {
              // a2 <= 0, so we clamp it to 0
              this.m_v1.a = 1;
              this.m_count = 1;
              return;
          }
          // w2 region
          const d12_1 = b2Vec2.DotVV(w2, e12);
          if (d12_1 <= 0) {
              // a1 <= 0, so we clamp it to 0
              this.m_v2.a = 1;
              this.m_count = 1;
              this.m_v1.Copy(this.m_v2);
              return;
          }
          // Must be in e12 region.
          const inv_d12 = 1 / (d12_1 + d12_2);
          this.m_v1.a = d12_1 * inv_d12;
          this.m_v2.a = d12_2 * inv_d12;
          this.m_count = 2;
      }
      Solve3() {
          const w1 = this.m_v1.w;
          const w2 = this.m_v2.w;
          const w3 = this.m_v3.w;
          // Edge12
          // [1      1     ][a1] = [1]
          // [w1.e12 w2.e12][a2] = [0]
          // a3 = 0
          const e12 = b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);
          const w1e12 = b2Vec2.DotVV(w1, e12);
          const w2e12 = b2Vec2.DotVV(w2, e12);
          const d12_1 = w2e12;
          const d12_2 = (-w1e12);
          // Edge13
          // [1      1     ][a1] = [1]
          // [w1.e13 w3.e13][a3] = [0]
          // a2 = 0
          const e13 = b2Vec2.SubVV(w3, w1, b2Simplex.s_e13);
          const w1e13 = b2Vec2.DotVV(w1, e13);
          const w3e13 = b2Vec2.DotVV(w3, e13);
          const d13_1 = w3e13;
          const d13_2 = (-w1e13);
          // Edge23
          // [1      1     ][a2] = [1]
          // [w2.e23 w3.e23][a3] = [0]
          // a1 = 0
          const e23 = b2Vec2.SubVV(w3, w2, b2Simplex.s_e23);
          const w2e23 = b2Vec2.DotVV(w2, e23);
          const w3e23 = b2Vec2.DotVV(w3, e23);
          const d23_1 = w3e23;
          const d23_2 = (-w2e23);
          // Triangle123
          const n123 = b2Vec2.CrossVV(e12, e13);
          const d123_1 = n123 * b2Vec2.CrossVV(w2, w3);
          const d123_2 = n123 * b2Vec2.CrossVV(w3, w1);
          const d123_3 = n123 * b2Vec2.CrossVV(w1, w2);
          // w1 region
          if (d12_2 <= 0 && d13_2 <= 0) {
              this.m_v1.a = 1;
              this.m_count = 1;
              return;
          }
          // e12
          if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
              const inv_d12 = 1 / (d12_1 + d12_2);
              this.m_v1.a = d12_1 * inv_d12;
              this.m_v2.a = d12_2 * inv_d12;
              this.m_count = 2;
              return;
          }
          // e13
          if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
              const inv_d13 = 1 / (d13_1 + d13_2);
              this.m_v1.a = d13_1 * inv_d13;
              this.m_v3.a = d13_2 * inv_d13;
              this.m_count = 2;
              this.m_v2.Copy(this.m_v3);
              return;
          }
          // w2 region
          if (d12_1 <= 0 && d23_2 <= 0) {
              this.m_v2.a = 1;
              this.m_count = 1;
              this.m_v1.Copy(this.m_v2);
              return;
          }
          // w3 region
          if (d13_1 <= 0 && d23_1 <= 0) {
              this.m_v3.a = 1;
              this.m_count = 1;
              this.m_v1.Copy(this.m_v3);
              return;
          }
          // e23
          if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
              const inv_d23 = 1 / (d23_1 + d23_2);
              this.m_v2.a = d23_1 * inv_d23;
              this.m_v3.a = d23_2 * inv_d23;
              this.m_count = 2;
              this.m_v1.Copy(this.m_v3);
              return;
          }
          // Must be in triangle123
          const inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
          this.m_v1.a = d123_1 * inv_d123;
          this.m_v2.a = d123_2 * inv_d123;
          this.m_v3.a = d123_3 * inv_d123;
          this.m_count = 3;
      }
  }
  b2Simplex.s_e12 = new b2Vec2();
  b2Simplex.s_e13 = new b2Vec2();
  b2Simplex.s_e23 = new b2Vec2();
  const b2Distance_s_simplex = new b2Simplex();
  const b2Distance_s_saveA = [0, 0, 0];
  const b2Distance_s_saveB = [0, 0, 0];
  const b2Distance_s_p = new b2Vec2();
  const b2Distance_s_d = new b2Vec2();
  const b2Distance_s_normal = new b2Vec2();
  const b2Distance_s_supportA = new b2Vec2();
  const b2Distance_s_supportB = new b2Vec2();
  function b2Distance(output, cache, input) {
      ++exports.gjkCalls;
      const proxyA = input.proxyA;
      const proxyB = input.proxyB;
      const transformA = input.transformA;
      const transformB = input.transformB;
      // Initialize the simplex.
      const simplex = b2Distance_s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      // Get simplex vertices as an array.
      const vertices = simplex.m_vertices;
      const k_maxIters = 20;
      // These store the vertices of the last simplex so that we
      // can check for duplicates and prevent cycling.
      const saveA = b2Distance_s_saveA;
      const saveB = b2Distance_s_saveB;
      let saveCount = 0;
      // Main iteration loop.
      let iter = 0;
      while (iter < k_maxIters) {
          // Copy simplex so we can identify duplicates.
          saveCount = simplex.m_count;
          for (let i = 0; i < saveCount; ++i) {
              saveA[i] = vertices[i].indexA;
              saveB[i] = vertices[i].indexB;
          }
          switch (simplex.m_count) {
              case 1:
                  break;
              case 2:
                  simplex.Solve2();
                  break;
              case 3:
                  simplex.Solve3();
                  break;
          }
          // If we have 3 points, then the origin is in the corresponding triangle.
          if (simplex.m_count === 3) {
              break;
          }
          // Get search direction.
          const d = simplex.GetSearchDirection(b2Distance_s_d);
          // Ensure the search direction is numerically fit.
          if (d.LengthSquared() < b2_epsilon_sq) {
              // The origin is probably contained by a line segment
              // or triangle. Thus the shapes are overlapped.
              // We can't return zero here even though there may be overlap.
              // In case the simplex is a point, segment, or triangle it is difficult
              // to determine if the origin is contained in the CSO or very close to it.
              break;
          }
          // Compute a tentative new simplex vertex using support points.
          const vertex = vertices[simplex.m_count];
          vertex.indexA = proxyA.GetSupport(b2Rot.MulTRV(transformA.q, b2Vec2.NegV(d, b2Vec2.s_t0), b2Distance_s_supportA));
          b2Transform.MulXV(transformA, proxyA.GetVertex(vertex.indexA), vertex.wA);
          vertex.indexB = proxyB.GetSupport(b2Rot.MulTRV(transformB.q, d, b2Distance_s_supportB));
          b2Transform.MulXV(transformB, proxyB.GetVertex(vertex.indexB), vertex.wB);
          b2Vec2.SubVV(vertex.wB, vertex.wA, vertex.w);
          // Iteration count is equated to the number of support point calls.
          ++iter;
          ++exports.gjkIters;
          // Check for duplicate support points. This is the main termination criteria.
          let duplicate = false;
          for (let i = 0; i < saveCount; ++i) {
              if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {
                  duplicate = true;
                  break;
              }
          }
          // If we found a duplicate support point we must exit to avoid cycling.
          if (duplicate) {
              break;
          }
          // New vertex is ok and needed.
          ++simplex.m_count;
      }
      exports.gjkMaxIters = b2Max(exports.gjkMaxIters, iter);
      // Prepare output.
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Vec2.DistanceVV(output.pointA, output.pointB);
      output.iterations = iter;
      // Cache the simplex.
      simplex.WriteCache(cache);
      // Apply radii if requested.
      if (input.useRadii) {
          const rA = proxyA.m_radius;
          const rB = proxyB.m_radius;
          if (output.distance > (rA + rB) && output.distance > b2_epsilon) {
              // Shapes are still no overlapped.
              // Move the witness points to the outer surface.
              output.distance -= rA + rB;
              const normal = b2Vec2.SubVV(output.pointB, output.pointA, b2Distance_s_normal);
              normal.Normalize();
              output.pointA.SelfMulAdd(rA, normal);
              output.pointB.SelfMulSub(rB, normal);
          }
          else {
              // Shapes are overlapped when radii are considered.
              // Move the witness points to the middle.
              const p = b2Vec2.MidVV(output.pointA, output.pointB, b2Distance_s_p);
              output.pointA.Copy(p);
              output.pointB.Copy(p);
              output.distance = 0;
          }
      }
  }
  /// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.
  // GJK-raycast
  // Algorithm by Gino van den Bergen.
  // "Smooth Mesh Contacts with GJK" in Game Physics Pearls. 2010
  // bool b2ShapeCast(b2ShapeCastOutput* output, const b2ShapeCastInput* input);
  const b2ShapeCast_s_n = new b2Vec2();
  const b2ShapeCast_s_simplex = new b2Simplex();
  const b2ShapeCast_s_wA = new b2Vec2();
  const b2ShapeCast_s_wB = new b2Vec2();
  const b2ShapeCast_s_v = new b2Vec2();
  const b2ShapeCast_s_p = new b2Vec2();
  const b2ShapeCast_s_pointA = new b2Vec2();
  const b2ShapeCast_s_pointB = new b2Vec2();
  function b2ShapeCast(output, input) {
      output.iterations = 0;
      output.lambda = 1.0;
      output.normal.SetZero();
      output.point.SetZero();
      // const b2DistanceProxy* proxyA = &input.proxyA;
      const proxyA = input.proxyA;
      // const b2DistanceProxy* proxyB = &input.proxyB;
      const proxyB = input.proxyB;
      // float32 radiusA = b2Max(proxyA.m_radius, b2_polygonRadius);
      const radiusA = b2Max(proxyA.m_radius, b2_polygonRadius);
      // float32 radiusB = b2Max(proxyB.m_radius, b2_polygonRadius);
      const radiusB = b2Max(proxyB.m_radius, b2_polygonRadius);
      // float32 radius = radiusA + radiusB;
      const radius = radiusA + radiusB;
      // b2Transform xfA = input.transformA;
      const xfA = input.transformA;
      // b2Transform xfB = input.transformB;
      const xfB = input.transformB;
      // b2Vec2 r = input.translationB;
      const r = input.translationB;
      // b2Vec2 n(0.0f, 0.0f);
      const n = b2ShapeCast_s_n.Set(0.0, 0.0);
      // float32 lambda = 0.0f;
      let lambda = 0.0;
      // Initial simplex
      const simplex = b2ShapeCast_s_simplex;
      simplex.m_count = 0;
      // Get simplex vertices as an array.
      // b2SimplexVertex* vertices = &simplex.m_v1;
      const vertices = simplex.m_vertices;
      // Get support point in -r direction
      // int32 indexA = proxyA.GetSupport(b2MulT(xfA.q, -r));
      let indexA = proxyA.GetSupport(b2Rot.MulTRV(xfA.q, b2Vec2.NegV(r, b2Vec2.s_t1), b2Vec2.s_t0));
      // b2Vec2 wA = b2Mul(xfA, proxyA.GetVertex(indexA));
      let wA = b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);
      // int32 indexB = proxyB.GetSupport(b2MulT(xfB.q, r));
      let indexB = proxyB.GetSupport(b2Rot.MulTRV(xfB.q, r, b2Vec2.s_t0));
      // b2Vec2 wB = b2Mul(xfB, proxyB.GetVertex(indexB));
      let wB = b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);
      // b2Vec2 v = wA - wB;
      const v = b2Vec2.SubVV(wA, wB, b2ShapeCast_s_v);
      // Sigma is the target distance between polygons
      // float32 sigma = b2Max(b2_polygonRadius, radius - b2_polygonRadius);
      const sigma = b2Max(b2_polygonRadius, radius - b2_polygonRadius);
      // const float32 tolerance = 0.5f * b2_linearSlop;
      const tolerance = 0.5 * b2_linearSlop;
      // Main iteration loop.
      // const int32 k_maxIters = 20;
      const k_maxIters = 20;
      // int32 iter = 0;
      let iter = 0;
      // while (iter < k_maxIters && v.Length() - sigma > tolerance)
      while (iter < k_maxIters && v.Length() - sigma > tolerance) {
          // DEBUG: b2Assert(simplex.m_count < 3);
          output.iterations += 1;
          // Support in direction -v (A - B)
          // indexA = proxyA.GetSupport(b2MulT(xfA.q, -v));
          indexA = proxyA.GetSupport(b2Rot.MulTRV(xfA.q, b2Vec2.NegV(v, b2Vec2.s_t1), b2Vec2.s_t0));
          // wA = b2Mul(xfA, proxyA.GetVertex(indexA));
          wA = b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);
          // indexB = proxyB.GetSupport(b2MulT(xfB.q, v));
          indexB = proxyB.GetSupport(b2Rot.MulTRV(xfB.q, v, b2Vec2.s_t0));
          // wB = b2Mul(xfB, proxyB.GetVertex(indexB));
          wB = b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);
          // b2Vec2 p = wA - wB;
          const p = b2Vec2.SubVV(wA, wB, b2ShapeCast_s_p);
          // -v is a normal at p
          v.Normalize();
          // Intersect ray with plane
          const vp = b2Vec2.DotVV(v, p);
          const vr = b2Vec2.DotVV(v, r);
          if (vp - sigma > lambda * vr) {
              if (vr <= 0.0) {
                  return false;
              }
              lambda = (vp - sigma) / vr;
              if (lambda > 1.0) {
                  return false;
              }
              // n = -v;
              n.Copy(v).SelfNeg();
              simplex.m_count = 0;
          }
          // Reverse simplex since it works with B - A.
          // Shift by lambda * r because we want the closest point to the current clip point.
          // Note that the support point p is not shifted because we want the plane equation
          // to be formed in unshifted space.
          // b2SimplexVertex* vertex = vertices + simplex.m_count;
          const vertex = vertices[simplex.m_count];
          vertex.indexA = indexB;
          // vertex.wA = wB + lambda * r;
          vertex.wA.Copy(wB).SelfMulAdd(lambda, r);
          vertex.indexB = indexA;
          // vertex.wB = wA;
          vertex.wB.Copy(wA);
          // vertex.w = vertex.wB - vertex.wA;
          vertex.w.Copy(vertex.wB).SelfSub(vertex.wA);
          vertex.a = 1.0;
          simplex.m_count += 1;
          switch (simplex.m_count) {
              case 1:
                  break;
              case 2:
                  simplex.Solve2();
                  break;
              case 3:
                  simplex.Solve3();
                  break;
              // DEBUG: b2Assert(false);
          }
          // If we have 3 points, then the origin is in the corresponding triangle.
          if (simplex.m_count === 3) {
              // Overlap
              return false;
          }
          // Get search direction.
          // v = simplex.GetClosestPoint();
          simplex.GetClosestPoint(v);
          // Iteration count is equated to the number of support point calls.
          ++iter;
      }
      if (iter === 0) {
          // Initial overlap
          return false;
      }
      // Prepare output.
      const pointA = b2ShapeCast_s_pointA;
      const pointB = b2ShapeCast_s_pointB;
      simplex.GetWitnessPoints(pointA, pointB);
      if (v.LengthSquared() > 0.0) {
          // n = -v;
          n.Copy(v).SelfNeg();
          n.Normalize();
      }
      // output.point = pointA + radiusA * n;
      output.normal.Copy(n);
      output.lambda = lambda;
      output.iterations = iter;
      return true;
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  (function (b2ContactFeatureType) {
      b2ContactFeatureType[b2ContactFeatureType["e_vertex"] = 0] = "e_vertex";
      b2ContactFeatureType[b2ContactFeatureType["e_face"] = 1] = "e_face";
  })(exports.ContactFeatureType || (exports.ContactFeatureType = {}));
  /// The features that intersect to form the contact point
  /// This must be 4 bytes or less.
  class b2ContactFeature {
      constructor() {
          this._key = 0;
          this._key_invalid = false;
          this._indexA = 0;
          this._indexB = 0;
          this._typeA = 0;
          this._typeB = 0;
      }
      get key() {
          if (this._key_invalid) {
              this._key_invalid = false;
              this._key = this._indexA | (this._indexB << 8) | (this._typeA << 16) | (this._typeB << 24);
          }
          return this._key;
      }
      set key(value) {
          this._key = value;
          this._key_invalid = false;
          this._indexA = this._key & 0xff;
          this._indexB = (this._key >> 8) & 0xff;
          this._typeA = (this._key >> 16) & 0xff;
          this._typeB = (this._key >> 24) & 0xff;
      }
      get indexA() {
          return this._indexA;
      }
      set indexA(value) {
          this._indexA = value;
          this._key_invalid = true;
      }
      get indexB() {
          return this._indexB;
      }
      set indexB(value) {
          this._indexB = value;
          this._key_invalid = true;
      }
      get typeA() {
          return this._typeA;
      }
      set typeA(value) {
          this._typeA = value;
          this._key_invalid = true;
      }
      get typeB() {
          return this._typeB;
      }
      set typeB(value) {
          this._typeB = value;
          this._key_invalid = true;
      }
  }
  /// Contact ids to facilitate warm starting.
  class b2ContactID {
      constructor() {
          this.cf = new b2ContactFeature();
      }
      Copy(o) {
          this.key = o.key;
          return this;
      }
      Clone() {
          return new b2ContactID().Copy(this);
      }
      get key() {
          return this.cf.key;
      }
      set key(value) {
          this.cf.key = value;
      }
  }
  /// A manifold point is a contact point belonging to a contact
  /// manifold. It holds details related to the geometry and dynamics
  /// of the contact points.
  /// The local point usage depends on the manifold type:
  /// -e_circles: the local center of circleB
  /// -e_faceA: the local center of cirlceB or the clip point of polygonB
  /// -e_faceB: the clip point of polygonA
  /// This structure is stored across time steps, so we keep it small.
  /// Note: the impulses are used for internal caching and may not
  /// provide reliable contact forces, especially for high speed collisions.
  class b2ManifoldPoint {
      constructor() {
          this.localPoint = new b2Vec2(); ///< usage depends on manifold type
          this.normalImpulse = 0; ///< the non-penetration impulse
          this.tangentImpulse = 0; ///< the friction impulse
          this.id = new b2ContactID(); ///< uniquely identifies a contact point between two shapes
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2ManifoldPoint());
      }
      Reset() {
          this.localPoint.SetZero();
          this.normalImpulse = 0;
          this.tangentImpulse = 0;
          this.id.key = 0;
      }
      Copy(o) {
          this.localPoint.Copy(o.localPoint);
          this.normalImpulse = o.normalImpulse;
          this.tangentImpulse = o.tangentImpulse;
          this.id.Copy(o.id);
          return this;
      }
  }
  (function (b2ManifoldType) {
      b2ManifoldType[b2ManifoldType["e_unknown"] = -1] = "e_unknown";
      b2ManifoldType[b2ManifoldType["e_circles"] = 0] = "e_circles";
      b2ManifoldType[b2ManifoldType["e_faceA"] = 1] = "e_faceA";
      b2ManifoldType[b2ManifoldType["e_faceB"] = 2] = "e_faceB";
  })(exports.ManifoldType || (exports.ManifoldType = {}));
  /// A manifold for two touching convex shapes.
  /// Box2D supports multiple types of contact:
  /// - clip point versus plane with radius
  /// - point versus point with radius (circles)
  /// The local point usage depends on the manifold type:
  /// -e_circles: the local center of circleA
  /// -e_faceA: the center of faceA
  /// -e_faceB: the center of faceB
  /// Similarly the local normal usage:
  /// -e_circles: not used
  /// -e_faceA: the normal on polygonA
  /// -e_faceB: the normal on polygonB
  /// We store contacts in this way so that position correction can
  /// account for movement, which is critical for continuous physics.
  /// All contact scenarios must be expressed in one of these types.
  /// This structure is stored across time steps, so we keep it small.
  class b2Manifold {
      constructor() {
          this.points = b2ManifoldPoint.MakeArray(b2_maxManifoldPoints);
          this.localNormal = new b2Vec2();
          this.localPoint = new b2Vec2();
          this.type = exports.ManifoldType.e_unknown;
          this.pointCount = 0;
      }
      Reset() {
          for (let i = 0; i < b2_maxManifoldPoints; ++i) {
              // DEBUG: b2Assert(this.points[i] instanceof b2ManifoldPoint);
              this.points[i].Reset();
          }
          this.localNormal.SetZero();
          this.localPoint.SetZero();
          this.type = exports.ManifoldType.e_unknown;
          this.pointCount = 0;
      }
      Copy(o) {
          this.pointCount = o.pointCount;
          for (let i = 0; i < b2_maxManifoldPoints; ++i) {
              // DEBUG: b2Assert(this.points[i] instanceof b2ManifoldPoint);
              this.points[i].Copy(o.points[i]);
          }
          this.localNormal.Copy(o.localNormal);
          this.localPoint.Copy(o.localPoint);
          this.type = o.type;
          return this;
      }
      Clone() {
          return new b2Manifold().Copy(this);
      }
  }
  class b2WorldManifold {
      constructor() {
          this.normal = new b2Vec2();
          this.points = b2Vec2.MakeArray(b2_maxManifoldPoints);
          this.separations = b2MakeNumberArray(b2_maxManifoldPoints);
      }
      Initialize(manifold, xfA, radiusA, xfB, radiusB) {
          if (manifold.pointCount === 0) {
              return;
          }
          switch (manifold.type) {
              case exports.ManifoldType.e_circles: {
                  this.normal.Set(1, 0);
                  const pointA = b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_pointA);
                  const pointB = b2Transform.MulXV(xfB, manifold.points[0].localPoint, b2WorldManifold.Initialize_s_pointB);
                  if (b2Vec2.DistanceSquaredVV(pointA, pointB) > b2_epsilon_sq) {
                      b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();
                  }
                  const cA = b2Vec2.AddVMulSV(pointA, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);
                  const cB = b2Vec2.SubVMulSV(pointB, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);
                  b2Vec2.MidVV(cA, cB, this.points[0]);
                  this.separations[0] = b2Vec2.DotVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);
                  break;
              }
              case exports.ManifoldType.e_faceA: {
                  b2Rot.MulRV(xfA.q, manifold.localNormal, this.normal);
                  const planePoint = b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);
                  for (let i = 0; i < manifold.pointCount; ++i) {
                      const clipPoint = b2Transform.MulXV(xfB, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);
                      const s = radiusA - b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal);
                      const cA = b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cA);
                      const cB = b2Vec2.SubVMulSV(clipPoint, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);
                      b2Vec2.MidVV(cA, cB, this.points[i]);
                      this.separations[i] = b2Vec2.DotVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);
                  }
                  break;
              }
              case exports.ManifoldType.e_faceB: {
                  b2Rot.MulRV(xfB.q, manifold.localNormal, this.normal);
                  const planePoint = b2Transform.MulXV(xfB, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);
                  for (let i = 0; i < manifold.pointCount; ++i) {
                      const clipPoint = b2Transform.MulXV(xfA, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);
                      const s = radiusB - b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal);
                      const cB = b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cB);
                      const cA = b2Vec2.SubVMulSV(clipPoint, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);
                      b2Vec2.MidVV(cA, cB, this.points[i]);
                      this.separations[i] = b2Vec2.DotVV(b2Vec2.SubVV(cA, cB, b2Vec2.s_t0), this.normal); // b2Dot(cA - cB, normal);
                  }
                  // Ensure normal points from A to B.
                  this.normal.SelfNeg();
                  break;
              }
          }
      }
  }
  b2WorldManifold.Initialize_s_pointA = new b2Vec2();
  b2WorldManifold.Initialize_s_pointB = new b2Vec2();
  b2WorldManifold.Initialize_s_cA = new b2Vec2();
  b2WorldManifold.Initialize_s_cB = new b2Vec2();
  b2WorldManifold.Initialize_s_planePoint = new b2Vec2();
  b2WorldManifold.Initialize_s_clipPoint = new b2Vec2();
  (function (b2PointState) {
      b2PointState[b2PointState["b2_nullState"] = 0] = "b2_nullState";
      b2PointState[b2PointState["b2_addState"] = 1] = "b2_addState";
      b2PointState[b2PointState["b2_persistState"] = 2] = "b2_persistState";
      b2PointState[b2PointState["b2_removeState"] = 3] = "b2_removeState";
  })(exports.PointState || (exports.PointState = {}));
  /// Compute the point states given two manifolds. The states pertain to the transition from manifold1
  /// to manifold2. So state1 is either persist or remove while state2 is either add or persist.
  function b2GetPointStates(state1, state2, manifold1, manifold2) {
      // Detect persists and removes.
      let i;
      for (i = 0; i < manifold1.pointCount; ++i) {
          const id = manifold1.points[i].id;
          const key = id.key;
          state1[i] = exports.PointState.b2_removeState;
          for (let j = 0, jct = manifold2.pointCount; j < jct; ++j) {
              if (manifold2.points[j].id.key === key) {
                  state1[i] = exports.PointState.b2_persistState;
                  break;
              }
          }
      }
      for (; i < b2_maxManifoldPoints; ++i) {
          state1[i] = exports.PointState.b2_nullState;
      }
      // Detect persists and adds.
      for (i = 0; i < manifold2.pointCount; ++i) {
          const id = manifold2.points[i].id;
          const key = id.key;
          state2[i] = exports.PointState.b2_addState;
          for (let j = 0, jct = manifold1.pointCount; j < jct; ++j) {
              if (manifold1.points[j].id.key === key) {
                  state2[i] = exports.PointState.b2_persistState;
                  break;
              }
          }
      }
      for (; i < b2_maxManifoldPoints; ++i) {
          state2[i] = exports.PointState.b2_nullState;
      }
  }
  /// Used for computing contact manifolds.
  class b2ClipVertex {
      constructor() {
          this.v = new b2Vec2();
          this.id = new b2ContactID();
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2ClipVertex());
      }
      Copy(other) {
          this.v.Copy(other.v);
          this.id.Copy(other.id);
          return this;
      }
  }
  /// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
  class b2RayCastInput {
      constructor() {
          this.p1 = new b2Vec2();
          this.p2 = new b2Vec2();
          this.maxFraction = 1;
      }
      Copy(o) {
          this.p1.Copy(o.p1);
          this.p2.Copy(o.p2);
          this.maxFraction = o.maxFraction;
          return this;
      }
  }
  /// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
  /// come from b2RayCastInput.
  class b2RayCastOutput {
      constructor() {
          this.normal = new b2Vec2();
          this.fraction = 0;
      }
      Copy(o) {
          this.normal.Copy(o.normal);
          this.fraction = o.fraction;
          return this;
      }
  }
  /// An axis aligned bounding box.
  class b2AABB {
      constructor() {
          this.lowerBound = new b2Vec2(); ///< the lower vertex
          this.upperBound = new b2Vec2(); ///< the upper vertex
          this.m_cache_center = new b2Vec2(); // access using GetCenter()
          this.m_cache_extent = new b2Vec2(); // access using GetExtents()
      }
      Copy(o) {
          this.lowerBound.Copy(o.lowerBound);
          this.upperBound.Copy(o.upperBound);
          return this;
      }
      /// Verify that the bounds are sorted.
      IsValid() {
          if (!this.lowerBound.IsValid()) {
              return false;
          }
          if (!this.upperBound.IsValid()) {
              return false;
          }
          if (this.upperBound.x < this.lowerBound.x) {
              return false;
          }
          if (this.upperBound.y < this.lowerBound.y) {
              return false;
          }
          return true;
      }
      /// Get the center of the AABB.
      GetCenter() {
          return b2Vec2.MidVV(this.lowerBound, this.upperBound, this.m_cache_center);
      }
      /// Get the extents of the AABB (half-widths).
      GetExtents() {
          return b2Vec2.ExtVV(this.lowerBound, this.upperBound, this.m_cache_extent);
      }
      /// Get the perimeter length
      GetPerimeter() {
          const wx = this.upperBound.x - this.lowerBound.x;
          const wy = this.upperBound.y - this.lowerBound.y;
          return 2 * (wx + wy);
      }
      /// Combine an AABB into this one.
      Combine1(aabb) {
          this.lowerBound.x = b2Min(this.lowerBound.x, aabb.lowerBound.x);
          this.lowerBound.y = b2Min(this.lowerBound.y, aabb.lowerBound.y);
          this.upperBound.x = b2Max(this.upperBound.x, aabb.upperBound.x);
          this.upperBound.y = b2Max(this.upperBound.y, aabb.upperBound.y);
          return this;
      }
      /// Combine two AABBs into this one.
      Combine2(aabb1, aabb2) {
          this.lowerBound.x = b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);
          this.lowerBound.y = b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);
          this.upperBound.x = b2Max(aabb1.upperBound.x, aabb2.upperBound.x);
          this.upperBound.y = b2Max(aabb1.upperBound.y, aabb2.upperBound.y);
          return this;
      }
      static Combine(aabb1, aabb2, out) {
          out.Combine2(aabb1, aabb2);
          return out;
      }
      /// Does this aabb contain the provided AABB.
      Contains(aabb) {
          let result = true;
          result = result && this.lowerBound.x <= aabb.lowerBound.x;
          result = result && this.lowerBound.y <= aabb.lowerBound.y;
          result = result && aabb.upperBound.x <= this.upperBound.x;
          result = result && aabb.upperBound.y <= this.upperBound.y;
          return result;
      }
      // From Real-time Collision Detection, p179.
      RayCast(output, input) {
          let tmin = (-b2_maxFloat);
          let tmax = b2_maxFloat;
          const p_x = input.p1.x;
          const p_y = input.p1.y;
          const d_x = input.p2.x - input.p1.x;
          const d_y = input.p2.y - input.p1.y;
          const absD_x = b2Abs(d_x);
          const absD_y = b2Abs(d_y);
          const normal = output.normal;
          if (absD_x < b2_epsilon) {
              // Parallel.
              if (p_x < this.lowerBound.x || this.upperBound.x < p_x) {
                  return false;
              }
          }
          else {
              const inv_d = 1 / d_x;
              let t1 = (this.lowerBound.x - p_x) * inv_d;
              let t2 = (this.upperBound.x - p_x) * inv_d;
              // Sign of the normal vector.
              let s = (-1);
              if (t1 > t2) {
                  const t3 = t1;
                  t1 = t2;
                  t2 = t3;
                  s = 1;
              }
              // Push the min up
              if (t1 > tmin) {
                  normal.x = s;
                  normal.y = 0;
                  tmin = t1;
              }
              // Pull the max down
              tmax = b2Min(tmax, t2);
              if (tmin > tmax) {
                  return false;
              }
          }
          if (absD_y < b2_epsilon) {
              // Parallel.
              if (p_y < this.lowerBound.y || this.upperBound.y < p_y) {
                  return false;
              }
          }
          else {
              const inv_d = 1 / d_y;
              let t1 = (this.lowerBound.y - p_y) * inv_d;
              let t2 = (this.upperBound.y - p_y) * inv_d;
              // Sign of the normal vector.
              let s = (-1);
              if (t1 > t2) {
                  const t3 = t1;
                  t1 = t2;
                  t2 = t3;
                  s = 1;
              }
              // Push the min up
              if (t1 > tmin) {
                  normal.x = 0;
                  normal.y = s;
                  tmin = t1;
              }
              // Pull the max down
              tmax = b2Min(tmax, t2);
              if (tmin > tmax) {
                  return false;
              }
          }
          // Does the ray start inside the box?
          // Does the ray intersect beyond the max fraction?
          if (tmin < 0 || input.maxFraction < tmin) {
              return false;
          }
          // Intersection.
          output.fraction = tmin;
          return true;
      }
      TestContain(point) {
          if (point.x < this.lowerBound.x || this.upperBound.x < point.x) {
              return false;
          }
          if (point.y < this.lowerBound.y || this.upperBound.y < point.y) {
              return false;
          }
          return true;
      }
      TestOverlap(other) {
          if (this.upperBound.x < other.lowerBound.x) {
              return false;
          }
          if (this.upperBound.y < other.lowerBound.y) {
              return false;
          }
          if (other.upperBound.x < this.lowerBound.x) {
              return false;
          }
          if (other.upperBound.y < this.lowerBound.y) {
              return false;
          }
          return true;
      }
  }
  function b2TestOverlapAABB(a, b) {
      if (a.upperBound.x < b.lowerBound.x) {
          return false;
      }
      if (a.upperBound.y < b.lowerBound.y) {
          return false;
      }
      if (b.upperBound.x < a.lowerBound.x) {
          return false;
      }
      if (b.upperBound.y < a.lowerBound.y) {
          return false;
      }
      return true;
  }
  /// Clipping for contact manifolds.
  function b2ClipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
      // Start with no output points
      let count = 0;
      const vIn0 = vIn[0];
      const vIn1 = vIn[1];
      // Calculate the distance of end points to the line
      const distance0 = b2Vec2.DotVV(normal, vIn0.v) - offset;
      const distance1 = b2Vec2.DotVV(normal, vIn1.v) - offset;
      // If the points are behind the plane
      if (distance0 <= 0) {
          vOut[count++].Copy(vIn0);
      }
      if (distance1 <= 0) {
          vOut[count++].Copy(vIn1);
      }
      // If the points are on different sides of the plane
      if (distance0 * distance1 < 0) {
          // Find intersection point of edge and plane
          const interp = distance0 / (distance0 - distance1);
          const v = vOut[count].v;
          v.x = vIn0.v.x + interp * (vIn1.v.x - vIn0.v.x);
          v.y = vIn0.v.y + interp * (vIn1.v.y - vIn0.v.y);
          // VertexA is hitting edgeB.
          const id = vOut[count].id;
          id.cf.indexA = vertexIndexA;
          id.cf.indexB = vIn0.id.cf.indexB;
          id.cf.typeA = exports.ContactFeatureType.e_vertex;
          id.cf.typeB = exports.ContactFeatureType.e_face;
          ++count;
          // b2Assert(count === 2);
      }
      return count;
  }
  /// Determine if two generic shapes overlap.
  const b2TestOverlapShape_s_input = new b2DistanceInput();
  const b2TestOverlapShape_s_simplexCache = new b2SimplexCache();
  const b2TestOverlapShape_s_output = new b2DistanceOutput();
  function b2TestOverlapShape(shapeA, indexA, shapeB, indexB, xfA, xfB) {
      const input = b2TestOverlapShape_s_input.Reset();
      input.proxyA.SetShape(shapeA, indexA);
      input.proxyB.SetShape(shapeB, indexB);
      input.transformA.Copy(xfA);
      input.transformB.Copy(xfB);
      input.useRadii = true;
      const simplexCache = b2TestOverlapShape_s_simplexCache.Reset();
      simplexCache.count = 0;
      const output = b2TestOverlapShape_s_output.Reset();
      b2Distance(output, simplexCache, input);
      return output.distance < 10 * b2_epsilon;
  }

  /*
  * Copyright (c) 2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  function verify(value) {
      if (value === null) {
          throw new Error();
      }
      return value;
  }
  /// A node in the dynamic tree. The client does not interact with this directly.
  class b2TreeNode {
      constructor(id = 0) {
          this.m_id = 0;
          this.aabb = new b2AABB();
          this._userData = null;
          this.parent = null; // or next
          this.child1 = null;
          this.child2 = null;
          this.height = 0; // leaf = 0, free node = -1
          this.moved = false;
          this.m_id = id;
      }
      get userData() {
          if (this._userData === null) {
              throw new Error();
          }
          return this._userData;
      }
      set userData(value) {
          if (this._userData !== null) {
              throw new Error();
          }
          this._userData = value;
      }
      Reset() {
          this._userData = null;
      }
      IsLeaf() {
          return this.child1 === null;
      }
  }
  class b2DynamicTree {
      constructor() {
          this.m_root = null;
          // b2TreeNode* public m_nodes;
          // int32 public m_nodeCount;
          // int32 public m_nodeCapacity;
          this.m_freeList = null;
          this.m_insertionCount = 0;
          this.m_stack = new b2GrowableStack(256);
      }
      // public GetUserData(node: b2TreeNode<T>): T {
      //   // DEBUG: b2Assert(node !== null);
      //   return node.userData;
      // }
      // public WasMoved(node: b2TreeNode<T>): boolean {
      //   return node.moved;
      // }
      // public ClearMoved(node: b2TreeNode<T>): void {
      //   node.moved = false;
      // }
      // public GetFatAABB(node: b2TreeNode<T>): b2AABB {
      //   // DEBUG: b2Assert(node !== null);
      //   return node.aabb;
      // }
      Query(aabb, callback) {
          const stack = this.m_stack.Reset();
          stack.Push(this.m_root);
          while (stack.GetCount() > 0) {
              const node = stack.Pop();
              if (node === null) {
                  continue;
              }
              if (node.aabb.TestOverlap(aabb)) {
                  if (node.IsLeaf()) {
                      const proceed = callback(node);
                      if (!proceed) {
                          return;
                      }
                  }
                  else {
                      stack.Push(node.child1);
                      stack.Push(node.child2);
                  }
              }
          }
      }
      QueryPoint(point, callback) {
          const stack = this.m_stack.Reset();
          stack.Push(this.m_root);
          while (stack.GetCount() > 0) {
              const node = stack.Pop();
              if (node === null) {
                  continue;
              }
              if (node.aabb.TestContain(point)) {
                  if (node.IsLeaf()) {
                      const proceed = callback(node);
                      if (!proceed) {
                          return;
                      }
                  }
                  else {
                      stack.Push(node.child1);
                      stack.Push(node.child2);
                  }
              }
          }
      }
      RayCast(input, callback) {
          const p1 = input.p1;
          const p2 = input.p2;
          const r = b2Vec2.SubVV(p2, p1, b2DynamicTree.s_r);
          // DEBUG: b2Assert(r.LengthSquared() > 0);
          r.Normalize();
          // v is perpendicular to the segment.
          const v = b2Vec2.CrossOneV(r, b2DynamicTree.s_v);
          const abs_v = b2Vec2.AbsV(v, b2DynamicTree.s_abs_v);
          // Separating axis for segment (Gino, p80).
          // |dot(v, p1 - c)| > dot(|v|, h)
          let maxFraction = input.maxFraction;
          // Build a bounding box for the segment.
          const segmentAABB = b2DynamicTree.s_segmentAABB;
          let t_x = p1.x + maxFraction * (p2.x - p1.x);
          let t_y = p1.y + maxFraction * (p2.y - p1.y);
          segmentAABB.lowerBound.x = b2Min(p1.x, t_x);
          segmentAABB.lowerBound.y = b2Min(p1.y, t_y);
          segmentAABB.upperBound.x = b2Max(p1.x, t_x);
          segmentAABB.upperBound.y = b2Max(p1.y, t_y);
          const stack = this.m_stack.Reset();
          stack.Push(this.m_root);
          while (stack.GetCount() > 0) {
              const node = stack.Pop();
              if (node === null) {
                  continue;
              }
              if (!b2TestOverlapAABB(node.aabb, segmentAABB)) {
                  continue;
              }
              // Separating axis for segment (Gino, p80).
              // |dot(v, p1 - c)| > dot(|v|, h)
              const c = node.aabb.GetCenter();
              const h = node.aabb.GetExtents();
              const separation = b2Abs(b2Vec2.DotVV(v, b2Vec2.SubVV(p1, c, b2Vec2.s_t0))) - b2Vec2.DotVV(abs_v, h);
              if (separation > 0) {
                  continue;
              }
              if (node.IsLeaf()) {
                  const subInput = b2DynamicTree.s_subInput;
                  subInput.p1.Copy(input.p1);
                  subInput.p2.Copy(input.p2);
                  subInput.maxFraction = maxFraction;
                  const value = callback(subInput, node);
                  if (value === 0) {
                      // The client has terminated the ray cast.
                      return;
                  }
                  if (value > 0) {
                      // Update segment bounding box.
                      maxFraction = value;
                      t_x = p1.x + maxFraction * (p2.x - p1.x);
                      t_y = p1.y + maxFraction * (p2.y - p1.y);
                      segmentAABB.lowerBound.x = b2Min(p1.x, t_x);
                      segmentAABB.lowerBound.y = b2Min(p1.y, t_y);
                      segmentAABB.upperBound.x = b2Max(p1.x, t_x);
                      segmentAABB.upperBound.y = b2Max(p1.y, t_y);
                  }
              }
              else {
                  stack.Push(node.child1);
                  stack.Push(node.child2);
              }
          }
      }
      AllocateNode() {
          // Expand the node pool as needed.
          if (this.m_freeList !== null) {
              const node = this.m_freeList;
              this.m_freeList = node.parent; // this.m_freeList = node.next;
              node.parent = null;
              node.child1 = null;
              node.child2 = null;
              node.height = 0;
              node.moved = false;
              return node;
          }
          return new b2TreeNode(b2DynamicTree.s_node_id++);
      }
      FreeNode(node) {
          node.parent = this.m_freeList; // node.next = this.m_freeList;
          node.child1 = null;
          node.child2 = null;
          node.height = -1;
          node.Reset();
          this.m_freeList = node;
      }
      CreateProxy(aabb, userData) {
          const node = this.AllocateNode();
          // Fatten the aabb.
          const r_x = b2_aabbExtension;
          const r_y = b2_aabbExtension;
          node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;
          node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;
          node.aabb.upperBound.x = aabb.upperBound.x + r_x;
          node.aabb.upperBound.y = aabb.upperBound.y + r_y;
          node.userData = userData;
          node.height = 0;
          node.moved = true;
          this.InsertLeaf(node);
          return node;
      }
      DestroyProxy(node) {
          // DEBUG: b2Assert(node.IsLeaf());
          this.RemoveLeaf(node);
          this.FreeNode(node);
      }
      MoveProxy(node, aabb, displacement) {
          // DEBUG: b2Assert(node.IsLeaf());
          // Extend AABB
          const fatAABB = b2DynamicTree.MoveProxy_s_fatAABB;
          const r_x = b2_aabbExtension;
          const r_y = b2_aabbExtension;
          fatAABB.lowerBound.x = aabb.lowerBound.x - r_x;
          fatAABB.lowerBound.y = aabb.lowerBound.y - r_y;
          fatAABB.upperBound.x = aabb.upperBound.x + r_x;
          fatAABB.upperBound.y = aabb.upperBound.y + r_y;
          // Predict AABB movement
          const d_x = b2_aabbMultiplier * displacement.x;
          const d_y = b2_aabbMultiplier * displacement.y;
          if (d_x < 0.0) {
              fatAABB.lowerBound.x += d_x;
          }
          else {
              fatAABB.upperBound.x += d_x;
          }
          if (d_y < 0.0) {
              fatAABB.lowerBound.y += d_y;
          }
          else {
              fatAABB.upperBound.y += d_y;
          }
          const treeAABB = node.aabb; // m_nodes[proxyId].aabb;
          if (treeAABB.Contains(aabb)) {
              // The tree AABB still contains the object, but it might be too large.
              // Perhaps the object was moving fast but has since gone to sleep.
              // The huge AABB is larger than the new fat AABB.
              const hugeAABB = b2DynamicTree.MoveProxy_s_hugeAABB;
              hugeAABB.lowerBound.x = fatAABB.lowerBound.x - 4.0 * r_x;
              hugeAABB.lowerBound.y = fatAABB.lowerBound.y - 4.0 * r_y;
              hugeAABB.upperBound.x = fatAABB.upperBound.x + 4.0 * r_x;
              hugeAABB.upperBound.y = fatAABB.upperBound.y + 4.0 * r_y;
              if (hugeAABB.Contains(treeAABB)) {
                  // The tree AABB contains the object AABB and the tree AABB is
                  // not too large. No tree update needed.
                  return false;
              }
              // Otherwise the tree AABB is huge and needs to be shrunk
          }
          this.RemoveLeaf(node);
          node.aabb.Copy(fatAABB); // m_nodes[proxyId].aabb = fatAABB;
          this.InsertLeaf(node);
          node.moved = true;
          return true;
      }
      InsertLeaf(leaf) {
          ++this.m_insertionCount;
          if (this.m_root === null) {
              this.m_root = leaf;
              this.m_root.parent = null;
              return;
          }
          // Find the best sibling for this node
          const leafAABB = leaf.aabb;
          let sibling = this.m_root;
          while (!sibling.IsLeaf()) {
              const child1 = verify(sibling.child1);
              const child2 = verify(sibling.child2);
              const area = sibling.aabb.GetPerimeter();
              const combinedAABB = b2DynamicTree.s_combinedAABB;
              combinedAABB.Combine2(sibling.aabb, leafAABB);
              const combinedArea = combinedAABB.GetPerimeter();
              // Cost of creating a new parent for this node and the new leaf
              const cost = 2 * combinedArea;
              // Minimum cost of pushing the leaf further down the tree
              const inheritanceCost = 2 * (combinedArea - area);
              // Cost of descending into child1
              let cost1;
              const aabb = b2DynamicTree.s_aabb;
              let oldArea;
              let newArea;
              if (child1.IsLeaf()) {
                  aabb.Combine2(leafAABB, child1.aabb);
                  cost1 = aabb.GetPerimeter() + inheritanceCost;
              }
              else {
                  aabb.Combine2(leafAABB, child1.aabb);
                  oldArea = child1.aabb.GetPerimeter();
                  newArea = aabb.GetPerimeter();
                  cost1 = (newArea - oldArea) + inheritanceCost;
              }
              // Cost of descending into child2
              let cost2;
              if (child2.IsLeaf()) {
                  aabb.Combine2(leafAABB, child2.aabb);
                  cost2 = aabb.GetPerimeter() + inheritanceCost;
              }
              else {
                  aabb.Combine2(leafAABB, child2.aabb);
                  oldArea = child2.aabb.GetPerimeter();
                  newArea = aabb.GetPerimeter();
                  cost2 = newArea - oldArea + inheritanceCost;
              }
              // Descend according to the minimum cost.
              if (cost < cost1 && cost < cost2) {
                  break;
              }
              // Descend
              if (cost1 < cost2) {
                  sibling = child1;
              }
              else {
                  sibling = child2;
              }
          }
          // Create a parent for the siblings.
          const oldParent = sibling.parent;
          const newParent = this.AllocateNode();
          newParent.parent = oldParent;
          newParent.aabb.Combine2(leafAABB, sibling.aabb);
          newParent.height = sibling.height + 1;
          if (oldParent !== null) {
              // The sibling was not the root.
              if (oldParent.child1 === sibling) {
                  oldParent.child1 = newParent;
              }
              else {
                  oldParent.child2 = newParent;
              }
              newParent.child1 = sibling;
              newParent.child2 = leaf;
              sibling.parent = newParent;
              leaf.parent = newParent;
          }
          else {
              // The sibling was the root.
              newParent.child1 = sibling;
              newParent.child2 = leaf;
              sibling.parent = newParent;
              leaf.parent = newParent;
              this.m_root = newParent;
          }
          // Walk back up the tree fixing heights and AABBs
          let node = leaf.parent;
          while (node !== null) {
              node = this.Balance(node);
              const child1 = verify(node.child1);
              const child2 = verify(node.child2);
              node.height = 1 + b2Max(child1.height, child2.height);
              node.aabb.Combine2(child1.aabb, child2.aabb);
              node = node.parent;
          }
          // this.Validate();
      }
      RemoveLeaf(leaf) {
          if (leaf === this.m_root) {
              this.m_root = null;
              return;
          }
          const parent = verify(leaf.parent);
          const grandParent = parent && parent.parent;
          const sibling = verify(parent.child1 === leaf ? parent.child2 : parent.child1);
          if (grandParent !== null) {
              // Destroy parent and connect sibling to grandParent.
              if (grandParent.child1 === parent) {
                  grandParent.child1 = sibling;
              }
              else {
                  grandParent.child2 = sibling;
              }
              sibling.parent = grandParent;
              this.FreeNode(parent);
              // Adjust ancestor bounds.
              let index = grandParent;
              while (index !== null) {
                  index = this.Balance(index);
                  const child1 = verify(index.child1);
                  const child2 = verify(index.child2);
                  index.aabb.Combine2(child1.aabb, child2.aabb);
                  index.height = 1 + b2Max(child1.height, child2.height);
                  index = index.parent;
              }
          }
          else {
              this.m_root = sibling;
              sibling.parent = null;
              this.FreeNode(parent);
          }
          // this.Validate();
      }
      Balance(A) {
          // DEBUG: b2Assert(A !== null);
          if (A.IsLeaf() || A.height < 2) {
              return A;
          }
          const B = verify(A.child1);
          const C = verify(A.child2);
          const balance = C.height - B.height;
          // Rotate C up
          if (balance > 1) {
              const F = verify(C.child1);
              const G = verify(C.child2);
              // Swap A and C
              C.child1 = A;
              C.parent = A.parent;
              A.parent = C;
              // A's old parent should point to C
              if (C.parent !== null) {
                  if (C.parent.child1 === A) {
                      C.parent.child1 = C;
                  }
                  else {
                      // DEBUG: b2Assert(C.parent.child2 === A);
                      C.parent.child2 = C;
                  }
              }
              else {
                  this.m_root = C;
              }
              // Rotate
              if (F.height > G.height) {
                  C.child2 = F;
                  A.child2 = G;
                  G.parent = A;
                  A.aabb.Combine2(B.aabb, G.aabb);
                  C.aabb.Combine2(A.aabb, F.aabb);
                  A.height = 1 + b2Max(B.height, G.height);
                  C.height = 1 + b2Max(A.height, F.height);
              }
              else {
                  C.child2 = G;
                  A.child2 = F;
                  F.parent = A;
                  A.aabb.Combine2(B.aabb, F.aabb);
                  C.aabb.Combine2(A.aabb, G.aabb);
                  A.height = 1 + b2Max(B.height, F.height);
                  C.height = 1 + b2Max(A.height, G.height);
              }
              return C;
          }
          // Rotate B up
          if (balance < -1) {
              const D = verify(B.child1);
              const E = verify(B.child2);
              // Swap A and B
              B.child1 = A;
              B.parent = A.parent;
              A.parent = B;
              // A's old parent should point to B
              if (B.parent !== null) {
                  if (B.parent.child1 === A) {
                      B.parent.child1 = B;
                  }
                  else {
                      // DEBUG: b2Assert(B.parent.child2 === A);
                      B.parent.child2 = B;
                  }
              }
              else {
                  this.m_root = B;
              }
              // Rotate
              if (D.height > E.height) {
                  B.child2 = D;
                  A.child1 = E;
                  E.parent = A;
                  A.aabb.Combine2(C.aabb, E.aabb);
                  B.aabb.Combine2(A.aabb, D.aabb);
                  A.height = 1 + b2Max(C.height, E.height);
                  B.height = 1 + b2Max(A.height, D.height);
              }
              else {
                  B.child2 = E;
                  A.child1 = D;
                  D.parent = A;
                  A.aabb.Combine2(C.aabb, D.aabb);
                  B.aabb.Combine2(A.aabb, E.aabb);
                  A.height = 1 + b2Max(C.height, D.height);
                  B.height = 1 + b2Max(A.height, E.height);
              }
              return B;
          }
          return A;
      }
      GetHeight() {
          if (this.m_root === null) {
              return 0;
          }
          return this.m_root.height;
      }
      static GetAreaNode(node) {
          if (node === null) {
              return 0;
          }
          if (node.IsLeaf()) {
              return 0;
          }
          let area = node.aabb.GetPerimeter();
          area += b2DynamicTree.GetAreaNode(node.child1);
          area += b2DynamicTree.GetAreaNode(node.child2);
          return area;
      }
      GetAreaRatio() {
          if (this.m_root === null) {
              return 0;
          }
          const root = this.m_root;
          const rootArea = root.aabb.GetPerimeter();
          const totalArea = b2DynamicTree.GetAreaNode(this.m_root);
          /*
          float32 totalArea = 0.0;
          for (int32 i = 0; i < m_nodeCapacity; ++i) {
            const b2TreeNode<T>* node = m_nodes + i;
            if (node.height < 0) {
              // Free node in pool
              continue;
            }
      
            totalArea += node.aabb.GetPerimeter();
          }
          */
          return totalArea / rootArea;
      }
      static ComputeHeightNode(node) {
          if (node === null) {
              return 0;
          }
          if (node.IsLeaf()) {
              return 0;
          }
          const height1 = b2DynamicTree.ComputeHeightNode(node.child1);
          const height2 = b2DynamicTree.ComputeHeightNode(node.child2);
          return 1 + b2Max(height1, height2);
      }
      ComputeHeight() {
          const height = b2DynamicTree.ComputeHeightNode(this.m_root);
          return height;
      }
      ValidateStructure(node) {
          if (node === null) {
              return;
          }
          if (node === this.m_root) ;
          if (node.IsLeaf()) {
              // DEBUG: b2Assert(node.child1 === null);
              // DEBUG: b2Assert(node.child2 === null);
              // DEBUG: b2Assert(node.height === 0);
              return;
          }
          const child1 = verify(node.child1);
          const child2 = verify(node.child2);
          // DEBUG: b2Assert(child1.parent === index);
          // DEBUG: b2Assert(child2.parent === index);
          this.ValidateStructure(child1);
          this.ValidateStructure(child2);
      }
      ValidateMetrics(node) {
          if (node === null) {
              return;
          }
          if (node.IsLeaf()) {
              // DEBUG: b2Assert(node.child1 === null);
              // DEBUG: b2Assert(node.child2 === null);
              // DEBUG: b2Assert(node.height === 0);
              return;
          }
          const child1 = verify(node.child1);
          const child2 = verify(node.child2);
          // DEBUG: const height1: number = child1.height;
          // DEBUG: const height2: number = child2.height;
          // DEBUG: const height: number = 1 + b2Max(height1, height2);
          // DEBUG: b2Assert(node.height === height);
          const aabb = b2DynamicTree.s_aabb;
          aabb.Combine2(child1.aabb, child2.aabb);
          // DEBUG: b2Assert(aabb.lowerBound === node.aabb.lowerBound);
          // DEBUG: b2Assert(aabb.upperBound === node.aabb.upperBound);
          this.ValidateMetrics(child1);
          this.ValidateMetrics(child2);
      }
      Validate() {
          // DEBUG: this.ValidateStructure(this.m_root);
          // DEBUG: this.ValidateMetrics(this.m_root);
          // let freeCount: number = 0;
          // let freeIndex: b2TreeNode<T> | null = this.m_freeList;
          // while (freeIndex !== null) {
          //   freeIndex = freeIndex.parent; // freeIndex = freeIndex.next;
          //   ++freeCount;
          // }
          // DEBUG: b2Assert(this.GetHeight() === this.ComputeHeight());
          // b2Assert(this.m_nodeCount + freeCount === this.m_nodeCapacity);
      }
      static GetMaxBalanceNode(node, maxBalance) {
          if (node === null) {
              return maxBalance;
          }
          if (node.height <= 1) {
              return maxBalance;
          }
          // DEBUG: b2Assert(!node.IsLeaf());
          const child1 = verify(node.child1);
          const child2 = verify(node.child2);
          const balance = b2Abs(child2.height - child1.height);
          return b2Max(maxBalance, balance);
      }
      GetMaxBalance() {
          const maxBalance = b2DynamicTree.GetMaxBalanceNode(this.m_root, 0);
          /*
          int32 maxBalance = 0;
          for (int32 i = 0; i < m_nodeCapacity; ++i) {
            const b2TreeNode<T>* node = m_nodes + i;
            if (node.height <= 1) {
              continue;
            }
      
            b2Assert(!node.IsLeaf());
      
            int32 child1 = node.child1;
            int32 child2 = node.child2;
            int32 balance = b2Abs(m_nodes[child2].height - m_nodes[child1].height);
            maxBalance = b2Max(maxBalance, balance);
          }
          */
          return maxBalance;
      }
      RebuildBottomUp() {
          /*
          int32* nodes = (int32*)b2Alloc(m_nodeCount * sizeof(int32));
          int32 count = 0;
      
          // Build array of leaves. Free the rest.
          for (int32 i = 0; i < m_nodeCapacity; ++i) {
            if (m_nodes[i].height < 0) {
              // free node in pool
              continue;
            }
      
            if (m_nodes[i].IsLeaf()) {
              m_nodes[i].parent = b2_nullNode;
              nodes[count] = i;
              ++count;
            } else {
              FreeNode(i);
            }
          }
      
          while (count > 1) {
            float32 minCost = b2_maxFloat;
            int32 iMin = -1, jMin = -1;
            for (int32 i = 0; i < count; ++i) {
              b2AABB aabbi = m_nodes[nodes[i]].aabb;
      
              for (int32 j = i + 1; j < count; ++j) {
                b2AABB aabbj = m_nodes[nodes[j]].aabb;
                b2AABB b;
                b.Combine(aabbi, aabbj);
                float32 cost = b.GetPerimeter();
                if (cost < minCost) {
                  iMin = i;
                  jMin = j;
                  minCost = cost;
                }
              }
            }
      
            int32 index1 = nodes[iMin];
            int32 index2 = nodes[jMin];
            b2TreeNode<T>* child1 = m_nodes + index1;
            b2TreeNode<T>* child2 = m_nodes + index2;
      
            int32 parentIndex = AllocateNode();
            b2TreeNode<T>* parent = m_nodes + parentIndex;
            parent.child1 = index1;
            parent.child2 = index2;
            parent.height = 1 + b2Max(child1.height, child2.height);
            parent.aabb.Combine(child1.aabb, child2.aabb);
            parent.parent = b2_nullNode;
      
            child1.parent = parentIndex;
            child2.parent = parentIndex;
      
            nodes[jMin] = nodes[count-1];
            nodes[iMin] = parentIndex;
            --count;
          }
      
          m_root = nodes[0];
          b2Free(nodes);
          */
          this.Validate();
      }
      static ShiftOriginNode(node, newOrigin) {
          if (node === null) {
              return;
          }
          if (node.height <= 1) {
              return;
          }
          // DEBUG: b2Assert(!node.IsLeaf());
          const child1 = node.child1;
          const child2 = node.child2;
          b2DynamicTree.ShiftOriginNode(child1, newOrigin);
          b2DynamicTree.ShiftOriginNode(child2, newOrigin);
          node.aabb.lowerBound.SelfSub(newOrigin);
          node.aabb.upperBound.SelfSub(newOrigin);
      }
      ShiftOrigin(newOrigin) {
          b2DynamicTree.ShiftOriginNode(this.m_root, newOrigin);
          /*
          // Build array of leaves. Free the rest.
          for (int32 i = 0; i < m_nodeCapacity; ++i) {
            m_nodes[i].aabb.lowerBound -= newOrigin;
            m_nodes[i].aabb.upperBound -= newOrigin;
          }
          */
      }
  }
  b2DynamicTree.s_r = new b2Vec2();
  b2DynamicTree.s_v = new b2Vec2();
  b2DynamicTree.s_abs_v = new b2Vec2();
  b2DynamicTree.s_segmentAABB = new b2AABB();
  b2DynamicTree.s_subInput = new b2RayCastInput();
  b2DynamicTree.s_combinedAABB = new b2AABB();
  b2DynamicTree.s_aabb = new b2AABB();
  b2DynamicTree.s_node_id = 0;
  b2DynamicTree.MoveProxy_s_fatAABB = new b2AABB();
  b2DynamicTree.MoveProxy_s_hugeAABB = new b2AABB();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2Pair {
      constructor(proxyA, proxyB) {
          this.proxyA = proxyA;
          this.proxyB = proxyB;
      }
  }
  /// The broad-phase is used for computing pairs and performing volume queries and ray casts.
  /// This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
  /// It is up to the client to consume the new pairs and to track subsequent overlap.
  class b2BroadPhase {
      constructor() {
          this.m_tree = new b2DynamicTree();
          this.m_proxyCount = 0;
          // public m_moveCapacity: number = 16;
          this.m_moveCount = 0;
          this.m_moveBuffer = [];
          // public m_pairCapacity: number = 16;
          this.m_pairCount = 0;
          this.m_pairBuffer = [];
      }
      // public m_queryProxyId: number = 0;
      /// Create a proxy with an initial AABB. Pairs are not reported until
      /// UpdatePairs is called.
      CreateProxy(aabb, userData) {
          const proxy = this.m_tree.CreateProxy(aabb, userData);
          ++this.m_proxyCount;
          this.BufferMove(proxy);
          return proxy;
      }
      /// Destroy a proxy. It is up to the client to remove any pairs.
      DestroyProxy(proxy) {
          this.UnBufferMove(proxy);
          --this.m_proxyCount;
          this.m_tree.DestroyProxy(proxy);
      }
      /// Call MoveProxy as many times as you like, then when you are done
      /// call UpdatePairs to finalized the proxy pairs (for your time step).
      MoveProxy(proxy, aabb, displacement) {
          const buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
          if (buffer) {
              this.BufferMove(proxy);
          }
      }
      /// Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.
      TouchProxy(proxy) {
          this.BufferMove(proxy);
      }
      /// Get the fat AABB for a proxy.
      // public GetFatAABB(proxy: b2TreeNode<T>): b2AABB {
      //   return this.m_tree.GetFatAABB(proxy);
      // }
      /// Get user data from a proxy. Returns NULL if the id is invalid.
      // public GetUserData(proxy: b2TreeNode<T>): T {
      //   return this.m_tree.GetUserData(proxy);
      // }
      /// Test overlap of fat AABBs.
      // public TestOverlap(proxyA: b2TreeNode<T>, proxyB: b2TreeNode<T>): boolean {
      //   const aabbA: b2AABB = this.m_tree.GetFatAABB(proxyA);
      //   const aabbB: b2AABB = this.m_tree.GetFatAABB(proxyB);
      //   return b2TestOverlapAABB(aabbA, aabbB);
      // }
      /// Get the number of proxies.
      GetProxyCount() {
          return this.m_proxyCount;
      }
      /// Update the pairs. This results in pair callbacks. This can only add pairs.
      UpdatePairs(callback) {
          // Reset pair buffer
          this.m_pairCount = 0;
          // Perform tree queries for all moving proxies.
          for (let i = 0; i < this.m_moveCount; ++i) {
              const queryProxy = this.m_moveBuffer[i];
              if (queryProxy === null) {
                  continue;
              }
              // This is called from b2.DynamicTree::Query when we are gathering pairs.
              // boolean b2BroadPhase::QueryCallback(int32 proxyId);
              // We have to query the tree with the fat AABB so that
              // we don't fail to create a pair that may touch later.
              const fatAABB = queryProxy.aabb; // this.m_tree.GetFatAABB(queryProxy);
              // Query tree, create pairs and add them pair buffer.
              this.m_tree.Query(fatAABB, (proxy) => {
                  // A proxy cannot form a pair with itself.
                  if (proxy.m_id === queryProxy.m_id) {
                      return true;
                  }
                  const moved = proxy.moved; // this.m_tree.WasMoved(proxy);
                  if (moved && proxy.m_id > queryProxy.m_id) {
                      // Both proxies are moving. Avoid duplicate pairs.
                      return true;
                  }
                  // const proxyA = proxy < queryProxy ? proxy : queryProxy;
                  // const proxyB = proxy >= queryProxy ? proxy : queryProxy;
                  let proxyA;
                  let proxyB;
                  if (proxy.m_id < queryProxy.m_id) {
                      proxyA = proxy;
                      proxyB = queryProxy;
                  }
                  else {
                      proxyA = queryProxy;
                      proxyB = proxy;
                  }
                  // Grow the pair buffer as needed.
                  if (this.m_pairCount === this.m_pairBuffer.length) {
                      this.m_pairBuffer[this.m_pairCount] = new b2Pair(proxyA, proxyB);
                  }
                  else {
                      const pair = this.m_pairBuffer[this.m_pairCount];
                      pair.proxyA = proxyA;
                      pair.proxyB = proxyB;
                  }
                  ++this.m_pairCount;
                  return true;
              });
          }
          // Send pairs to caller
          for (let i = 0; i < this.m_pairCount; ++i) {
              const primaryPair = this.m_pairBuffer[i];
              const userDataA = primaryPair.proxyA.userData; // this.m_tree.GetUserData(primaryPair.proxyA);
              const userDataB = primaryPair.proxyB.userData; // this.m_tree.GetUserData(primaryPair.proxyB);
              callback(userDataA, userDataB);
          }
          // Clear move flags
          for (let i = 0; i < this.m_moveCount; ++i) {
              const proxy = this.m_moveBuffer[i];
              if (proxy === null) {
                  continue;
              }
              proxy.moved = false; // this.m_tree.ClearMoved(proxy);
          }
          // Reset move buffer
          this.m_moveCount = 0;
      }
      /// Query an AABB for overlapping proxies. The callback class
      /// is called for each proxy that overlaps the supplied AABB.
      Query(aabb, callback) {
          this.m_tree.Query(aabb, callback);
      }
      QueryPoint(point, callback) {
          this.m_tree.QueryPoint(point, callback);
      }
      /// Ray-cast against the proxies in the tree. This relies on the callback
      /// to perform a exact ray-cast in the case were the proxy contains a shape.
      /// The callback also performs the any collision filtering. This has performance
      /// roughly equal to k * log(n), where k is the number of collisions and n is the
      /// number of proxies in the tree.
      /// @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
      /// @param callback a callback class that is called for each proxy that is hit by the ray.
      RayCast(input, callback) {
          this.m_tree.RayCast(input, callback);
      }
      /// Get the height of the embedded tree.
      GetTreeHeight() {
          return this.m_tree.GetHeight();
      }
      /// Get the balance of the embedded tree.
      GetTreeBalance() {
          return this.m_tree.GetMaxBalance();
      }
      /// Get the quality metric of the embedded tree.
      GetTreeQuality() {
          return this.m_tree.GetAreaRatio();
      }
      /// Shift the world origin. Useful for large worlds.
      /// The shift formula is: position -= newOrigin
      /// @param newOrigin the new origin with respect to the old origin
      ShiftOrigin(newOrigin) {
          this.m_tree.ShiftOrigin(newOrigin);
      }
      BufferMove(proxy) {
          this.m_moveBuffer[this.m_moveCount] = proxy;
          ++this.m_moveCount;
      }
      UnBufferMove(proxy) {
          const i = this.m_moveBuffer.indexOf(proxy);
          this.m_moveBuffer[i] = null;
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// This holds the mass data computed for a shape.
  class b2MassData {
      constructor() {
          /// The mass of the shape, usually in kilograms.
          this.mass = 0;
          /// The position of the shape's centroid relative to the shape's origin.
          this.center = new b2Vec2(0, 0);
          /// The rotational inertia of the shape about the local origin.
          this.I = 0;
      }
  }
  (function (b2ShapeType) {
      b2ShapeType[b2ShapeType["e_unknown"] = -1] = "e_unknown";
      b2ShapeType[b2ShapeType["e_circleShape"] = 0] = "e_circleShape";
      b2ShapeType[b2ShapeType["e_edgeShape"] = 1] = "e_edgeShape";
      b2ShapeType[b2ShapeType["e_polygonShape"] = 2] = "e_polygonShape";
      b2ShapeType[b2ShapeType["e_chainShape"] = 3] = "e_chainShape";
      b2ShapeType[b2ShapeType["e_shapeTypeCount"] = 4] = "e_shapeTypeCount";
  })(exports.ShapeType || (exports.ShapeType = {}));
  /// A shape is used for collision detection. You can create a shape however you like.
  /// Shapes used for simulation in b2World are created automatically when a b2Fixture
  /// is created. Shapes may encapsulate a one or more child shapes.
  class b2Shape {
      constructor(type, radius) {
          this.m_type = exports.ShapeType.e_unknown;
          /// Radius of a shape. For polygonal shapes this must be b2_polygonRadius. There is no support for
          /// making rounded polygons.
          this.m_radius = 0;
          this.m_type = type;
          this.m_radius = radius;
      }
      Copy(other) {
          // DEBUG: b2Assert(this.m_type === other.m_type);
          this.m_radius = other.m_radius;
          return this;
      }
      /// Get the type of this shape. You can use this to down cast to the concrete shape.
      /// @return the shape type.
      GetType() {
          return this.m_type;
      }
  }

  /*
  * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// A line segment (edge) shape. These can be connected in chains or loops
  /// to other edge shapes. Edges created independently are two-sided and do
  /// no provide smooth movement across junctions.
  class b2EdgeShape extends b2Shape {
      constructor() {
          super(exports.ShapeType.e_edgeShape, b2_polygonRadius);
          this.m_vertex1 = new b2Vec2();
          this.m_vertex2 = new b2Vec2();
          this.m_vertex0 = new b2Vec2();
          this.m_vertex3 = new b2Vec2();
          /// Uses m_vertex0 and m_vertex3 to create smooth collision.
          this.m_oneSided = false;
      }
      /// Set this as a part of a sequence. Vertex v0 precedes the edge and vertex v3
      /// follows. These extra vertices are used to provide smooth movement
      /// across junctions. This also makes the collision one-sided. The edge
      /// normal points to the right looking from v1 to v2.
      // void SetOneSided(const b2Vec2& v0, const b2Vec2& v1,const b2Vec2& v2, const b2Vec2& v3);
      SetOneSided(v0, v1, v2, v3) {
          this.m_vertex0.Copy(v0);
          this.m_vertex1.Copy(v1);
          this.m_vertex2.Copy(v2);
          this.m_vertex3.Copy(v3);
          this.m_oneSided = true;
          return this;
      }
      /// Set this as an isolated edge. Collision is two-sided.
      SetTwoSided(v1, v2) {
          this.m_vertex1.Copy(v1);
          this.m_vertex2.Copy(v2);
          this.m_oneSided = false;
          return this;
      }
      /// Implement b2Shape.
      Clone() {
          return new b2EdgeShape().Copy(this);
      }
      Copy(other) {
          super.Copy(other);
          // DEBUG: b2Assert(other instanceof b2EdgeShape);
          this.m_vertex1.Copy(other.m_vertex1);
          this.m_vertex2.Copy(other.m_vertex2);
          this.m_vertex0.Copy(other.m_vertex0);
          this.m_vertex3.Copy(other.m_vertex3);
          this.m_oneSided = other.m_oneSided;
          return this;
      }
      /// @see b2Shape::GetChildCount
      GetChildCount() {
          return 1;
      }
      /// @see b2Shape::TestPoint
      TestPoint(xf, p) {
          return false;
      }
      ComputeDistance(xf, p, normal, childIndex) {
          const v1 = b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeDistance_s_v1);
          const v2 = b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeDistance_s_v2);
          const d = b2Vec2.SubVV(p, v1, b2EdgeShape.ComputeDistance_s_d);
          const s = b2Vec2.SubVV(v2, v1, b2EdgeShape.ComputeDistance_s_s);
          const ds = b2Vec2.DotVV(d, s);
          if (ds > 0) {
              const s2 = b2Vec2.DotVV(s, s);
              if (ds > s2) {
                  b2Vec2.SubVV(p, v2, d);
              }
              else {
                  d.SelfMulSub(ds / s2, s);
              }
          }
          normal.Copy(d);
          return normal.Normalize();
      }
      RayCast(output, input, xf, childIndex) {
          // Put the ray into the edge's frame of reference.
          const p1 = b2Transform.MulTXV(xf, input.p1, b2EdgeShape.RayCast_s_p1);
          const p2 = b2Transform.MulTXV(xf, input.p2, b2EdgeShape.RayCast_s_p2);
          const d = b2Vec2.SubVV(p2, p1, b2EdgeShape.RayCast_s_d);
          const v1 = this.m_vertex1;
          const v2 = this.m_vertex2;
          const e = b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_e);
          // Normal points to the right, looking from v1 at v2
          const normal = output.normal.Set(e.y, -e.x).SelfNormalize();
          // q = p1 + t * d
          // dot(normal, q - v1) = 0
          // dot(normal, p1 - v1) + t * dot(normal, d) = 0
          const numerator = b2Vec2.DotVV(normal, b2Vec2.SubVV(v1, p1, b2Vec2.s_t0));
          if (this.m_oneSided && numerator > 0.0) {
              return false;
          }
          const denominator = b2Vec2.DotVV(normal, d);
          if (denominator === 0) {
              return false;
          }
          const t = numerator / denominator;
          if (t < 0 || input.maxFraction < t) {
              return false;
          }
          const q = b2Vec2.AddVMulSV(p1, t, d, b2EdgeShape.RayCast_s_q);
          // q = v1 + s * r
          // s = dot(q - v1, r) / dot(r, r)
          const r = b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_r);
          const rr = b2Vec2.DotVV(r, r);
          if (rr === 0) {
              return false;
          }
          const s = b2Vec2.DotVV(b2Vec2.SubVV(q, v1, b2Vec2.s_t0), r) / rr;
          if (s < 0 || 1 < s) {
              return false;
          }
          output.fraction = t;
          b2Rot.MulRV(xf.q, output.normal, output.normal);
          if (numerator > 0) {
              output.normal.SelfNeg();
          }
          return true;
      }
      ComputeAABB(aabb, xf, childIndex) {
          const v1 = b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeAABB_s_v1);
          const v2 = b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeAABB_s_v2);
          b2Vec2.MinV(v1, v2, aabb.lowerBound);
          b2Vec2.MaxV(v1, v2, aabb.upperBound);
          const r = this.m_radius;
          aabb.lowerBound.SelfSubXY(r, r);
          aabb.upperBound.SelfAddXY(r, r);
      }
      /// @see b2Shape::ComputeMass
      ComputeMass(massData, density) {
          massData.mass = 0;
          b2Vec2.MidVV(this.m_vertex1, this.m_vertex2, massData.center);
          massData.I = 0;
      }
      SetupDistanceProxy(proxy, index) {
          proxy.m_vertices = proxy.m_buffer;
          proxy.m_vertices[0].Copy(this.m_vertex1);
          proxy.m_vertices[1].Copy(this.m_vertex2);
          proxy.m_count = 2;
          proxy.m_radius = this.m_radius;
      }
      ComputeSubmergedArea(normal, offset, xf, c) {
          c.SetZero();
          return 0;
      }
      Dump(log) {
          log("    const shape: b2EdgeShape = new b2EdgeShape();\n");
          log("    shape.m_radius = %.15f;\n", this.m_radius);
          log("    shape.m_vertex0.Set(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y);
          log("    shape.m_vertex1.Set(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y);
          log("    shape.m_vertex2.Set(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y);
          log("    shape.m_vertex3.Set(%.15f, %.15f);\n", this.m_vertex3.x, this.m_vertex3.y);
          log("    shape.m_oneSided = %s;\n", this.m_oneSided);
      }
  }
  // #if B2_ENABLE_PARTICLE
  /// @see b2Shape::ComputeDistance
  b2EdgeShape.ComputeDistance_s_v1 = new b2Vec2();
  b2EdgeShape.ComputeDistance_s_v2 = new b2Vec2();
  b2EdgeShape.ComputeDistance_s_d = new b2Vec2();
  b2EdgeShape.ComputeDistance_s_s = new b2Vec2();
  // #endif
  /// Implement b2Shape.
  // p = p1 + t * d
  // v = v1 + s * e
  // p1 + t * d = v1 + s * e
  // s * e - t * d = p1 - v1
  b2EdgeShape.RayCast_s_p1 = new b2Vec2();
  b2EdgeShape.RayCast_s_p2 = new b2Vec2();
  b2EdgeShape.RayCast_s_d = new b2Vec2();
  b2EdgeShape.RayCast_s_e = new b2Vec2();
  b2EdgeShape.RayCast_s_q = new b2Vec2();
  b2EdgeShape.RayCast_s_r = new b2Vec2();
  /// @see b2Shape::ComputeAABB
  b2EdgeShape.ComputeAABB_s_v1 = new b2Vec2();
  b2EdgeShape.ComputeAABB_s_v2 = new b2Vec2();

  /*
  * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// A chain shape is a free form sequence of line segments.
  /// The chain has one-sided collision, with the surface normal pointing to the right of the edge.
  /// This provides a counter-clockwise winding like the polygon shape.
  /// Connectivity information is used to create smooth collisions.
  /// @warning the chain will not collide properly if there are self-intersections.
  class b2ChainShape extends b2Shape {
      constructor() {
          super(exports.ShapeType.e_chainShape, b2_polygonRadius);
          this.m_vertices = [];
          this.m_count = 0;
          this.m_prevVertex = new b2Vec2();
          this.m_nextVertex = new b2Vec2();
      }
      CreateLoop(...args) {
          if (typeof args[0][0] === "number") {
              const vertices = args[0];
              if (vertices.length % 2 !== 0) {
                  throw new Error();
              }
              return this._CreateLoop((index) => ({ x: vertices[index * 2], y: vertices[index * 2 + 1] }), vertices.length / 2);
          }
          else {
              const vertices = args[0];
              const count = args[1] || vertices.length;
              return this._CreateLoop((index) => vertices[index], count);
          }
      }
      _CreateLoop(vertices, count) {
          // DEBUG: b2Assert(count >= 3);
          if (count < 3) {
              return this;
          }
          // DEBUG: for (let i: number = 1; i < count; ++i) {
          // DEBUG:   const v1 = vertices[start + i - 1];
          // DEBUG:   const v2 = vertices[start + i];
          // DEBUG:   // If the code crashes here, it means your vertices are too close together.
          // DEBUG:   b2Assert(b2Vec2.DistanceSquaredVV(v1, v2) > b2_linearSlop * b2_linearSlop);
          // DEBUG: }
          this.m_count = count + 1;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          for (let i = 0; i < count; ++i) {
              this.m_vertices[i].Copy(vertices(i));
          }
          this.m_vertices[count].Copy(this.m_vertices[0]);
          this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]);
          this.m_nextVertex.Copy(this.m_vertices[1]);
          return this;
      }
      CreateChain(...args) {
          if (typeof args[0][0] === "number") {
              const vertices = args[0];
              const prevVertex = args[1];
              const nextVertex = args[2];
              if (vertices.length % 2 !== 0) {
                  throw new Error();
              }
              return this._CreateChain((index) => ({ x: vertices[index * 2], y: vertices[index * 2 + 1] }), vertices.length / 2, prevVertex, nextVertex);
          }
          else {
              const vertices = args[0];
              const count = args[1] || vertices.length;
              const prevVertex = args[2];
              const nextVertex = args[3];
              return this._CreateChain((index) => vertices[index], count, prevVertex, nextVertex);
          }
      }
      _CreateChain(vertices, count, prevVertex, nextVertex) {
          // DEBUG: b2Assert(count >= 2);
          // DEBUG: for (let i: number = 1; i < count; ++i) {
          // DEBUG:   const v1 = vertices[start + i - 1];
          // DEBUG:   const v2 = vertices[start + i];
          // DEBUG:   // If the code crashes here, it means your vertices are too close together.
          // DEBUG:   b2Assert(b2Vec2.DistanceSquaredVV(v1, v2) > b2_linearSlop * b2_linearSlop);
          // DEBUG: }
          this.m_count = count;
          this.m_vertices = b2Vec2.MakeArray(count);
          for (let i = 0; i < count; ++i) {
              this.m_vertices[i].Copy(vertices(i));
          }
          this.m_prevVertex.Copy(prevVertex);
          this.m_nextVertex.Copy(nextVertex);
          return this;
      }
      /// Implement b2Shape. Vertices are cloned using b2Alloc.
      Clone() {
          return new b2ChainShape().Copy(this);
      }
      Copy(other) {
          super.Copy(other);
          // DEBUG: b2Assert(other instanceof b2ChainShape);
          this._CreateChain((index) => other.m_vertices[index], other.m_count, other.m_prevVertex, other.m_nextVertex);
          this.m_prevVertex.Copy(other.m_prevVertex);
          this.m_nextVertex.Copy(other.m_nextVertex);
          return this;
      }
      /// @see b2Shape::GetChildCount
      GetChildCount() {
          // edge count = vertex count - 1
          return this.m_count - 1;
      }
      /// Get a child edge.
      GetChildEdge(edge, index) {
          // DEBUG: b2Assert(0 <= index && index < this.m_count - 1);
          edge.m_radius = this.m_radius;
          edge.m_vertex1.Copy(this.m_vertices[index]);
          edge.m_vertex2.Copy(this.m_vertices[index + 1]);
          edge.m_oneSided = true;
          if (index > 0) {
              edge.m_vertex0.Copy(this.m_vertices[index - 1]);
          }
          else {
              edge.m_vertex0.Copy(this.m_prevVertex);
          }
          if (index < this.m_count - 2) {
              edge.m_vertex3.Copy(this.m_vertices[index + 2]);
          }
          else {
              edge.m_vertex3.Copy(this.m_nextVertex);
          }
      }
      /// This always return false.
      /// @see b2Shape::TestPoint
      TestPoint(xf, p) {
          return false;
      }
      ComputeDistance(xf, p, normal, childIndex) {
          const edge = b2ChainShape.ComputeDistance_s_edgeShape;
          this.GetChildEdge(edge, childIndex);
          return edge.ComputeDistance(xf, p, normal, 0);
      }
      RayCast(output, input, xf, childIndex) {
          // DEBUG: b2Assert(childIndex < this.m_count);
          const edgeShape = b2ChainShape.RayCast_s_edgeShape;
          edgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);
          edgeShape.m_vertex2.Copy(this.m_vertices[(childIndex + 1) % this.m_count]);
          return edgeShape.RayCast(output, input, xf, 0);
      }
      ComputeAABB(aabb, xf, childIndex) {
          // DEBUG: b2Assert(childIndex < this.m_count);
          const vertexi1 = this.m_vertices[childIndex];
          const vertexi2 = this.m_vertices[(childIndex + 1) % this.m_count];
          const v1 = b2Transform.MulXV(xf, vertexi1, b2ChainShape.ComputeAABB_s_v1);
          const v2 = b2Transform.MulXV(xf, vertexi2, b2ChainShape.ComputeAABB_s_v2);
          const lower = b2Vec2.MinV(v1, v2, b2ChainShape.ComputeAABB_s_lower);
          const upper = b2Vec2.MaxV(v1, v2, b2ChainShape.ComputeAABB_s_upper);
          aabb.lowerBound.x = lower.x - this.m_radius;
          aabb.lowerBound.y = lower.y - this.m_radius;
          aabb.upperBound.x = upper.x + this.m_radius;
          aabb.upperBound.y = upper.y + this.m_radius;
      }
      /// Chains have zero mass.
      /// @see b2Shape::ComputeMass
      ComputeMass(massData, density) {
          massData.mass = 0;
          massData.center.SetZero();
          massData.I = 0;
      }
      SetupDistanceProxy(proxy, index) {
          // DEBUG: b2Assert(0 <= index && index < this.m_count);
          proxy.m_vertices = proxy.m_buffer;
          proxy.m_vertices[0].Copy(this.m_vertices[index]);
          if (index + 1 < this.m_count) {
              proxy.m_vertices[1].Copy(this.m_vertices[index + 1]);
          }
          else {
              proxy.m_vertices[1].Copy(this.m_vertices[0]);
          }
          proxy.m_count = 2;
          proxy.m_radius = this.m_radius;
      }
      ComputeSubmergedArea(normal, offset, xf, c) {
          c.SetZero();
          return 0;
      }
      Dump(log) {
          log("    const shape: b2ChainShape = new b2ChainShape();\n");
          log("    const vs: b2Vec2[] = [];\n");
          for (let i = 0; i < this.m_count; ++i) {
              log("    vs[%d] = new bVec2(%.15f, %.15f);\n", i, this.m_vertices[i].x, this.m_vertices[i].y);
          }
          log("    shape.CreateChain(vs, %d);\n", this.m_count);
          log("    shape.m_prevVertex.Set(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y);
          log("    shape.m_nextVertex.Set(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y);
      }
  }
  // #if B2_ENABLE_PARTICLE
  /// @see b2Shape::ComputeDistance
  b2ChainShape.ComputeDistance_s_edgeShape = new b2EdgeShape();
  // #endif
  /// Implement b2Shape.
  b2ChainShape.RayCast_s_edgeShape = new b2EdgeShape();
  /// @see b2Shape::ComputeAABB
  b2ChainShape.ComputeAABB_s_v1 = new b2Vec2();
  b2ChainShape.ComputeAABB_s_v2 = new b2Vec2();
  b2ChainShape.ComputeAABB_s_lower = new b2Vec2();
  b2ChainShape.ComputeAABB_s_upper = new b2Vec2();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// A solid circle shape
  class b2CircleShape extends b2Shape {
      constructor(radius = 0) {
          super(exports.ShapeType.e_circleShape, radius);
          this.m_p = new b2Vec2();
      }
      Set(position, radius = this.m_radius) {
          this.m_p.Copy(position);
          this.m_radius = radius;
          return this;
      }
      /// Implement b2Shape.
      Clone() {
          return new b2CircleShape().Copy(this);
      }
      Copy(other) {
          super.Copy(other);
          // DEBUG: b2Assert(other instanceof b2CircleShape);
          this.m_p.Copy(other.m_p);
          return this;
      }
      /// @see b2Shape::GetChildCount
      GetChildCount() {
          return 1;
      }
      TestPoint(transform, p) {
          const center = b2Transform.MulXV(transform, this.m_p, b2CircleShape.TestPoint_s_center);
          const d = b2Vec2.SubVV(p, center, b2CircleShape.TestPoint_s_d);
          return b2Vec2.DotVV(d, d) <= b2Sq(this.m_radius);
      }
      ComputeDistance(xf, p, normal, childIndex) {
          const center = b2Transform.MulXV(xf, this.m_p, b2CircleShape.ComputeDistance_s_center);
          b2Vec2.SubVV(p, center, normal);
          return normal.Normalize() - this.m_radius;
      }
      RayCast(output, input, transform, childIndex) {
          const position = b2Transform.MulXV(transform, this.m_p, b2CircleShape.RayCast_s_position);
          const s = b2Vec2.SubVV(input.p1, position, b2CircleShape.RayCast_s_s);
          const b = b2Vec2.DotVV(s, s) - b2Sq(this.m_radius);
          // Solve quadratic equation.
          const r = b2Vec2.SubVV(input.p2, input.p1, b2CircleShape.RayCast_s_r);
          const c = b2Vec2.DotVV(s, r);
          const rr = b2Vec2.DotVV(r, r);
          const sigma = c * c - rr * b;
          // Check for negative discriminant and short segment.
          if (sigma < 0 || rr < b2_epsilon) {
              return false;
          }
          // Find the point of intersection of the line with the circle.
          let a = (-(c + b2Sqrt(sigma)));
          // Is the intersection point on the segment?
          if (0 <= a && a <= input.maxFraction * rr) {
              a /= rr;
              output.fraction = a;
              b2Vec2.AddVMulSV(s, a, r, output.normal).SelfNormalize();
              return true;
          }
          return false;
      }
      ComputeAABB(aabb, transform, childIndex) {
          const p = b2Transform.MulXV(transform, this.m_p, b2CircleShape.ComputeAABB_s_p);
          aabb.lowerBound.Set(p.x - this.m_radius, p.y - this.m_radius);
          aabb.upperBound.Set(p.x + this.m_radius, p.y + this.m_radius);
      }
      /// @see b2Shape::ComputeMass
      ComputeMass(massData, density) {
          const radius_sq = b2Sq(this.m_radius);
          massData.mass = density * b2_pi * radius_sq;
          massData.center.Copy(this.m_p);
          // inertia about the local origin
          massData.I = massData.mass * (0.5 * radius_sq + b2Vec2.DotVV(this.m_p, this.m_p));
      }
      SetupDistanceProxy(proxy, index) {
          proxy.m_vertices = proxy.m_buffer;
          proxy.m_vertices[0].Copy(this.m_p);
          proxy.m_count = 1;
          proxy.m_radius = this.m_radius;
      }
      ComputeSubmergedArea(normal, offset, xf, c) {
          const p = b2Transform.MulXV(xf, this.m_p, new b2Vec2());
          const l = (-(b2Vec2.DotVV(normal, p) - offset));
          if (l < (-this.m_radius) + b2_epsilon) {
              // Completely dry
              return 0;
          }
          if (l > this.m_radius) {
              // Completely wet
              c.Copy(p);
              return b2_pi * this.m_radius * this.m_radius;
          }
          // Magic
          const r2 = this.m_radius * this.m_radius;
          const l2 = l * l;
          const area = r2 * (b2Asin(l / this.m_radius) + b2_pi / 2) + l * b2Sqrt(r2 - l2);
          const com = (-2 / 3 * b2Pow(r2 - l2, 1.5) / area);
          c.x = p.x + normal.x * com;
          c.y = p.y + normal.y * com;
          return area;
      }
      Dump(log) {
          log("    const shape: b2CircleShape = new b2CircleShape();\n");
          log("    shape.m_radius = %.15f;\n", this.m_radius);
          log("    shape.m_p.Set(%.15f, %.15f);\n", this.m_p.x, this.m_p.y);
      }
  }
  /// Implement b2Shape.
  b2CircleShape.TestPoint_s_center = new b2Vec2();
  b2CircleShape.TestPoint_s_d = new b2Vec2();
  // #if B2_ENABLE_PARTICLE
  /// @see b2Shape::ComputeDistance
  b2CircleShape.ComputeDistance_s_center = new b2Vec2();
  // #endif
  /// Implement b2Shape.
  /// @note because the circle is solid, rays that start inside do not hit because the normal is
  /// not defined.
  // Collision Detection in Interactive 3D Environments by Gino van den Bergen
  // From Section 3.1.2
  // x = s + a * r
  // norm(x) = radius
  b2CircleShape.RayCast_s_position = new b2Vec2();
  b2CircleShape.RayCast_s_s = new b2Vec2();
  b2CircleShape.RayCast_s_r = new b2Vec2();
  /// @see b2Shape::ComputeAABB
  b2CircleShape.ComputeAABB_s_p = new b2Vec2();

  const b2CollideCircles_s_pA = new b2Vec2();
  const b2CollideCircles_s_pB = new b2Vec2();
  function b2CollideCircles(manifold, circleA, xfA, circleB, xfB) {
      manifold.pointCount = 0;
      const pA = b2Transform.MulXV(xfA, circleA.m_p, b2CollideCircles_s_pA);
      const pB = b2Transform.MulXV(xfB, circleB.m_p, b2CollideCircles_s_pB);
      const distSqr = b2Vec2.DistanceSquaredVV(pA, pB);
      const radius = circleA.m_radius + circleB.m_radius;
      if (distSqr > radius * radius) {
          return;
      }
      manifold.type = exports.ManifoldType.e_circles;
      manifold.localPoint.Copy(circleA.m_p);
      manifold.localNormal.SetZero();
      manifold.pointCount = 1;
      manifold.points[0].localPoint.Copy(circleB.m_p);
      manifold.points[0].id.key = 0;
  }
  const b2CollidePolygonAndCircle_s_c = new b2Vec2();
  const b2CollidePolygonAndCircle_s_cLocal = new b2Vec2();
  const b2CollidePolygonAndCircle_s_faceCenter = new b2Vec2();
  function b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB) {
      manifold.pointCount = 0;
      // Compute circle position in the frame of the polygon.
      const c = b2Transform.MulXV(xfB, circleB.m_p, b2CollidePolygonAndCircle_s_c);
      const cLocal = b2Transform.MulTXV(xfA, c, b2CollidePolygonAndCircle_s_cLocal);
      // Find the min separating edge.
      let normalIndex = 0;
      let separation = (-b2_maxFloat);
      const radius = polygonA.m_radius + circleB.m_radius;
      const vertexCount = polygonA.m_count;
      const vertices = polygonA.m_vertices;
      const normals = polygonA.m_normals;
      for (let i = 0; i < vertexCount; ++i) {
          const s = b2Vec2.DotVV(normals[i], b2Vec2.SubVV(cLocal, vertices[i], b2Vec2.s_t0));
          if (s > radius) {
              // Early out.
              return;
          }
          if (s > separation) {
              separation = s;
              normalIndex = i;
          }
      }
      // Vertices that subtend the incident face.
      const vertIndex1 = normalIndex;
      const vertIndex2 = (vertIndex1 + 1) % vertexCount;
      const v1 = vertices[vertIndex1];
      const v2 = vertices[vertIndex2];
      // If the center is inside the polygon ...
      if (separation < b2_epsilon) {
          manifold.pointCount = 1;
          manifold.type = exports.ManifoldType.e_faceA;
          manifold.localNormal.Copy(normals[normalIndex]);
          b2Vec2.MidVV(v1, v2, manifold.localPoint);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
          return;
      }
      // Compute barycentric coordinates
      const u1 = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, v1, b2Vec2.s_t0), b2Vec2.SubVV(v2, v1, b2Vec2.s_t1));
      const u2 = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, v2, b2Vec2.s_t0), b2Vec2.SubVV(v1, v2, b2Vec2.s_t1));
      if (u1 <= 0) {
          if (b2Vec2.DistanceSquaredVV(cLocal, v1) > radius * radius) {
              return;
          }
          manifold.pointCount = 1;
          manifold.type = exports.ManifoldType.e_faceA;
          b2Vec2.SubVV(cLocal, v1, manifold.localNormal).SelfNormalize();
          manifold.localPoint.Copy(v1);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
      }
      else if (u2 <= 0) {
          if (b2Vec2.DistanceSquaredVV(cLocal, v2) > radius * radius) {
              return;
          }
          manifold.pointCount = 1;
          manifold.type = exports.ManifoldType.e_faceA;
          b2Vec2.SubVV(cLocal, v2, manifold.localNormal).SelfNormalize();
          manifold.localPoint.Copy(v2);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
      }
      else {
          const faceCenter = b2Vec2.MidVV(v1, v2, b2CollidePolygonAndCircle_s_faceCenter);
          const separation = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, faceCenter, b2Vec2.s_t1), normals[vertIndex1]);
          if (separation > radius) {
              return;
          }
          manifold.pointCount = 1;
          manifold.type = exports.ManifoldType.e_faceA;
          manifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();
          manifold.localPoint.Copy(faceCenter);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
      }
  }

  // DEBUG: import { b2Assert } from "../common/b2_settings.js";
  const b2CollideEdgeAndCircle_s_Q = new b2Vec2();
  const b2CollideEdgeAndCircle_s_e = new b2Vec2();
  const b2CollideEdgeAndCircle_s_d = new b2Vec2();
  const b2CollideEdgeAndCircle_s_e1 = new b2Vec2();
  const b2CollideEdgeAndCircle_s_e2 = new b2Vec2();
  const b2CollideEdgeAndCircle_s_P = new b2Vec2();
  const b2CollideEdgeAndCircle_s_n = new b2Vec2();
  const b2CollideEdgeAndCircle_s_id = new b2ContactID();
  function b2CollideEdgeAndCircle(manifold, edgeA, xfA, circleB, xfB) {
      manifold.pointCount = 0;
      // Compute circle in frame of edge
      const Q = b2Transform.MulTXV(xfA, b2Transform.MulXV(xfB, circleB.m_p, b2Vec2.s_t0), b2CollideEdgeAndCircle_s_Q);
      const A = edgeA.m_vertex1;
      const B = edgeA.m_vertex2;
      const e = b2Vec2.SubVV(B, A, b2CollideEdgeAndCircle_s_e);
      // Normal points to the right for a CCW winding
      // b2Vec2 n(e.y, -e.x);
      // const n: b2Vec2 = b2CollideEdgeAndCircle_s_n.Set(-e.y, e.x);
      const n = b2CollideEdgeAndCircle_s_n.Set(e.y, -e.x);
      // float offset = b2Dot(n, Q - A);
      const offset = b2Vec2.DotVV(n, b2Vec2.SubVV(Q, A, b2Vec2.s_t0));
      const oneSided = edgeA.m_oneSided;
      if (oneSided && offset < 0.0) {
          return;
      }
      // Barycentric coordinates
      const u = b2Vec2.DotVV(e, b2Vec2.SubVV(B, Q, b2Vec2.s_t0));
      const v = b2Vec2.DotVV(e, b2Vec2.SubVV(Q, A, b2Vec2.s_t0));
      const radius = edgeA.m_radius + circleB.m_radius;
      // const cf: b2ContactFeature = new b2ContactFeature();
      const id = b2CollideEdgeAndCircle_s_id;
      id.cf.indexB = 0;
      id.cf.typeB = exports.ContactFeatureType.e_vertex;
      // Region A
      if (v <= 0) {
          const P = A;
          const d = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);
          const dd = b2Vec2.DotVV(d, d);
          if (dd > radius * radius) {
              return;
          }
          // Is there an edge connected to A?
          if (edgeA.m_oneSided) {
              const A1 = edgeA.m_vertex0;
              const B1 = A;
              const e1 = b2Vec2.SubVV(B1, A1, b2CollideEdgeAndCircle_s_e1);
              const u1 = b2Vec2.DotVV(e1, b2Vec2.SubVV(B1, Q, b2Vec2.s_t0));
              // Is the circle in Region AB of the previous edge?
              if (u1 > 0) {
                  return;
              }
          }
          id.cf.indexA = 0;
          id.cf.typeA = exports.ContactFeatureType.e_vertex;
          manifold.pointCount = 1;
          manifold.type = exports.ManifoldType.e_circles;
          manifold.localNormal.SetZero();
          manifold.localPoint.Copy(P);
          manifold.points[0].id.Copy(id);
          // manifold.points[0].id.key = 0;
          // manifold.points[0].id.cf = cf;
          manifold.points[0].localPoint.Copy(circleB.m_p);
          return;
      }
      // Region B
      if (u <= 0) {
          const P = B;
          const d = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);
          const dd = b2Vec2.DotVV(d, d);
          if (dd > radius * radius) {
              return;
          }
          // Is there an edge connected to B?
          if (edgeA.m_oneSided) {
              const B2 = edgeA.m_vertex3;
              const A2 = B;
              const e2 = b2Vec2.SubVV(B2, A2, b2CollideEdgeAndCircle_s_e2);
              const v2 = b2Vec2.DotVV(e2, b2Vec2.SubVV(Q, A2, b2Vec2.s_t0));
              // Is the circle in Region AB of the next edge?
              if (v2 > 0) {
                  return;
              }
          }
          id.cf.indexA = 1;
          id.cf.typeA = exports.ContactFeatureType.e_vertex;
          manifold.pointCount = 1;
          manifold.type = exports.ManifoldType.e_circles;
          manifold.localNormal.SetZero();
          manifold.localPoint.Copy(P);
          manifold.points[0].id.Copy(id);
          // manifold.points[0].id.key = 0;
          // manifold.points[0].id.cf = cf;
          manifold.points[0].localPoint.Copy(circleB.m_p);
          return;
      }
      // Region AB
      const den = b2Vec2.DotVV(e, e);
      // DEBUG: b2Assert(den > 0);
      const P = b2CollideEdgeAndCircle_s_P;
      P.x = (1 / den) * (u * A.x + v * B.x);
      P.y = (1 / den) * (u * A.y + v * B.y);
      const d = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);
      const dd = b2Vec2.DotVV(d, d);
      if (dd > radius * radius) {
          return;
      }
      if (offset < 0) {
          n.Set(-n.x, -n.y);
      }
      n.Normalize();
      id.cf.indexA = 0;
      id.cf.typeA = exports.ContactFeatureType.e_face;
      manifold.pointCount = 1;
      manifold.type = exports.ManifoldType.e_faceA;
      manifold.localNormal.Copy(n);
      manifold.localPoint.Copy(A);
      manifold.points[0].id.Copy(id);
      // manifold.points[0].id.key = 0;
      // manifold.points[0].id.cf = cf;
      manifold.points[0].localPoint.Copy(circleB.m_p);
  }
  var b2EPAxisType;
  (function (b2EPAxisType) {
      b2EPAxisType[b2EPAxisType["e_unknown"] = 0] = "e_unknown";
      b2EPAxisType[b2EPAxisType["e_edgeA"] = 1] = "e_edgeA";
      b2EPAxisType[b2EPAxisType["e_edgeB"] = 2] = "e_edgeB";
  })(b2EPAxisType || (b2EPAxisType = {}));
  class b2EPAxis {
      constructor() {
          this.normal = new b2Vec2();
          this.type = b2EPAxisType.e_unknown;
          this.index = 0;
          this.separation = 0;
      }
  }
  class b2TempPolygon {
      constructor() {
          this.vertices = [];
          this.normals = [];
          this.count = 0;
      }
  }
  class b2ReferenceFace {
      constructor() {
          this.i1 = 0;
          this.i2 = 0;
          this.v1 = new b2Vec2();
          this.v2 = new b2Vec2();
          this.normal = new b2Vec2();
          this.sideNormal1 = new b2Vec2();
          this.sideOffset1 = 0;
          this.sideNormal2 = new b2Vec2();
          this.sideOffset2 = 0;
      }
  }
  // static b2EPAxis b2ComputeEdgeSeparation(const b2TempPolygon& polygonB, const b2Vec2& v1, const b2Vec2& normal1)
  const b2ComputeEdgeSeparation_s_axis = new b2EPAxis();
  const b2ComputeEdgeSeparation_s_axes = [new b2Vec2(), new b2Vec2()];
  function b2ComputeEdgeSeparation(polygonB, v1, normal1) {
      // b2EPAxis axis;
      const axis = b2ComputeEdgeSeparation_s_axis;
      axis.type = b2EPAxisType.e_edgeA;
      axis.index = -1;
      axis.separation = -Number.MAX_VALUE; // -FLT_MAX;
      axis.normal.SetZero();
      // b2Vec2 axes[2] = { normal1, -normal1 };
      const axes = b2ComputeEdgeSeparation_s_axes;
      axes[0].Copy(normal1);
      axes[1].Copy(normal1).SelfNeg();
      // Find axis with least overlap (min-max problem)
      for (let j = 0; j < 2; ++j) {
          let sj = Number.MAX_VALUE; // FLT_MAX;
          // Find deepest polygon vertex along axis j
          for (let i = 0; i < polygonB.count; ++i) {
              // float si = b2Dot(axes[j], polygonB.vertices[i] - v1);
              const si = b2Vec2.DotVV(axes[j], b2Vec2.SubVV(polygonB.vertices[i], v1, b2Vec2.s_t0));
              if (si < sj) {
                  sj = si;
              }
          }
          if (sj > axis.separation) {
              axis.index = j;
              axis.separation = sj;
              axis.normal.Copy(axes[j]);
          }
      }
      return axis;
  }
  // static b2EPAxis b2ComputePolygonSeparation(const b2TempPolygon& polygonB, const b2Vec2& v1, const b2Vec2& v2)
  const b2ComputePolygonSeparation_s_axis = new b2EPAxis();
  const b2ComputePolygonSeparation_s_n = new b2Vec2();
  function b2ComputePolygonSeparation(polygonB, v1, v2) {
      const axis = b2ComputePolygonSeparation_s_axis;
      axis.type = b2EPAxisType.e_unknown;
      axis.index = -1;
      axis.separation = -Number.MAX_VALUE; // -FLT_MAX;
      axis.normal.SetZero();
      for (let i = 0; i < polygonB.count; ++i) {
          // b2Vec2 n = -polygonB.normals[i];
          const n = b2Vec2.NegV(polygonB.normals[i], b2ComputePolygonSeparation_s_n);
          // float s1 = b2Dot(n, polygonB.vertices[i] - v1);
          const s1 = b2Vec2.DotVV(n, b2Vec2.SubVV(polygonB.vertices[i], v1, b2Vec2.s_t0));
          // float s2 = b2Dot(n, polygonB.vertices[i] - v2);
          const s2 = b2Vec2.DotVV(n, b2Vec2.SubVV(polygonB.vertices[i], v2, b2Vec2.s_t0));
          // float s = b2Min(s1, s2);
          const s = b2Min(s1, s2);
          if (s > axis.separation) {
              axis.type = b2EPAxisType.e_edgeB;
              axis.index = i;
              axis.separation = s;
              axis.normal.Copy(n);
          }
      }
      return axis;
  }
  const b2CollideEdgeAndPolygon_s_xf = new b2Transform();
  const b2CollideEdgeAndPolygon_s_centroidB = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_edge1 = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_normal1 = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_edge0 = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_normal0 = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_edge2 = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_normal2 = new b2Vec2();
  const b2CollideEdgeAndPolygon_s_tempPolygonB = new b2TempPolygon();
  const b2CollideEdgeAndPolygon_s_ref = new b2ReferenceFace();
  const b2CollideEdgeAndPolygon_s_clipPoints = [new b2ClipVertex(), new b2ClipVertex()];
  const b2CollideEdgeAndPolygon_s_clipPoints1 = [new b2ClipVertex(), new b2ClipVertex()];
  const b2CollideEdgeAndPolygon_s_clipPoints2 = [new b2ClipVertex(), new b2ClipVertex()];
  function b2CollideEdgeAndPolygon(manifold, edgeA, xfA, polygonB, xfB) {
      manifold.pointCount = 0;
      // b2Transform xf = b2MulT(xfA, xfB);
      const xf = b2Transform.MulTXX(xfA, xfB, b2CollideEdgeAndPolygon_s_xf);
      // b2Vec2 centroidB = b2Mul(xf, polygonB.m_centroid);
      const centroidB = b2Transform.MulXV(xf, polygonB.m_centroid, b2CollideEdgeAndPolygon_s_centroidB);
      // b2Vec2 v1 = edgeA.m_vertex1;
      const v1 = edgeA.m_vertex1;
      // b2Vec2 v2 = edgeA.m_vertex2;
      const v2 = edgeA.m_vertex2;
      // b2Vec2 edge1 = v2 - v1;
      const edge1 = b2Vec2.SubVV(v2, v1, b2CollideEdgeAndPolygon_s_edge1);
      edge1.Normalize();
      // Normal points to the right for a CCW winding
      // b2Vec2 normal1(edge1.y, -edge1.x);
      const normal1 = b2CollideEdgeAndPolygon_s_normal1.Set(edge1.y, -edge1.x);
      // float offset1 = b2Dot(normal1, centroidB - v1);
      const offset1 = b2Vec2.DotVV(normal1, b2Vec2.SubVV(centroidB, v1, b2Vec2.s_t0));
      const oneSided = edgeA.m_oneSided;
      if (oneSided && offset1 < 0.0) {
          return;
      }
      // Get polygonB in frameA
      // b2TempPolygon tempPolygonB;
      const tempPolygonB = b2CollideEdgeAndPolygon_s_tempPolygonB;
      tempPolygonB.count = polygonB.m_count;
      for (let i = 0; i < polygonB.m_count; ++i) {
          if (tempPolygonB.vertices.length <= i) {
              tempPolygonB.vertices.push(new b2Vec2());
          }
          if (tempPolygonB.normals.length <= i) {
              tempPolygonB.normals.push(new b2Vec2());
          }
          // tempPolygonB.vertices[i] = b2Mul(xf, polygonB.m_vertices[i]);
          b2Transform.MulXV(xf, polygonB.m_vertices[i], tempPolygonB.vertices[i]);
          // tempPolygonB.normals[i] = b2Mul(xf.q, polygonB.m_normals[i]);
          b2Rot.MulRV(xf.q, polygonB.m_normals[i], tempPolygonB.normals[i]);
      }
      const radius = polygonB.m_radius + edgeA.m_radius;
      // b2EPAxis edgeAxis = b2ComputeEdgeSeparation(tempPolygonB, v1, normal1);
      const edgeAxis = b2ComputeEdgeSeparation(tempPolygonB, v1, normal1);
      if (edgeAxis.separation > radius) {
          return;
      }
      // b2EPAxis polygonAxis = b2ComputePolygonSeparation(tedge0.y, -edge0.xempPolygonB, v1, v2);
      const polygonAxis = b2ComputePolygonSeparation(tempPolygonB, v1, v2);
      if (polygonAxis.separation > radius) {
          return;
      }
      // Use hysteresis for jitter reduction.
      const k_relativeTol = 0.98;
      const k_absoluteTol = 0.001;
      // b2EPAxis primaryAxis;
      let primaryAxis;
      if (polygonAxis.separation - radius > k_relativeTol * (edgeAxis.separation - radius) + k_absoluteTol) {
          primaryAxis = polygonAxis;
      }
      else {
          primaryAxis = edgeAxis;
      }
      if (oneSided) {
          // Smooth collision
          // See https://box2d.org/posts/2020/06/ghost-collisions/
          // b2Vec2 edge0 = v1 - edgeA.m_vertex0;
          const edge0 = b2Vec2.SubVV(v1, edgeA.m_vertex0, b2CollideEdgeAndPolygon_s_edge0);
          edge0.Normalize();
          // b2Vec2 normal0(edge0.y, -edge0.x);
          const normal0 = b2CollideEdgeAndPolygon_s_normal0.Set(edge0.y, -edge0.x);
          const convex1 = b2Vec2.CrossVV(edge0, edge1) >= 0.0;
          // b2Vec2 edge2 = edgeA.m_vertex3 - v2;
          const edge2 = b2Vec2.SubVV(edgeA.m_vertex3, v2, b2CollideEdgeAndPolygon_s_edge2);
          edge2.Normalize();
          // b2Vec2 normal2(edge2.y, -edge2.x);
          const normal2 = b2CollideEdgeAndPolygon_s_normal2.Set(edge2.y, -edge2.x);
          const convex2 = b2Vec2.CrossVV(edge1, edge2) >= 0.0;
          const sinTol = 0.1;
          const side1 = b2Vec2.DotVV(primaryAxis.normal, edge1) <= 0.0;
          // Check Gauss Map
          if (side1) {
              if (convex1) {
                  if (b2Vec2.CrossVV(primaryAxis.normal, normal0) > sinTol) {
                      // Skip region
                      return;
                  }
                  // Admit region
              }
              else {
                  // Snap region
                  primaryAxis = edgeAxis;
              }
          }
          else {
              if (convex2) {
                  if (b2Vec2.CrossVV(normal2, primaryAxis.normal) > sinTol) {
                      // Skip region
                      return;
                  }
                  // Admit region
              }
              else {
                  // Snap region
                  primaryAxis = edgeAxis;
              }
          }
      }
      // b2ClipVertex clipPoints[2];
      const clipPoints = b2CollideEdgeAndPolygon_s_clipPoints;
      // b2ReferenceFace ref;
      const ref = b2CollideEdgeAndPolygon_s_ref;
      if (primaryAxis.type === b2EPAxisType.e_edgeA) {
          manifold.type = exports.ManifoldType.e_faceA;
          // Search for the polygon normal that is most anti-parallel to the edge normal.
          let bestIndex = 0;
          let bestValue = b2Vec2.DotVV(primaryAxis.normal, tempPolygonB.normals[0]);
          for (let i = 1; i < tempPolygonB.count; ++i) {
              const value = b2Vec2.DotVV(primaryAxis.normal, tempPolygonB.normals[i]);
              if (value < bestValue) {
                  bestValue = value;
                  bestIndex = i;
              }
          }
          const i1 = bestIndex;
          const i2 = i1 + 1 < tempPolygonB.count ? i1 + 1 : 0;
          clipPoints[0].v.Copy(tempPolygonB.vertices[i1]);
          clipPoints[0].id.cf.indexA = 0;
          clipPoints[0].id.cf.indexB = i1;
          clipPoints[0].id.cf.typeA = exports.ContactFeatureType.e_face;
          clipPoints[0].id.cf.typeB = exports.ContactFeatureType.e_vertex;
          clipPoints[1].v.Copy(tempPolygonB.vertices[i2]);
          clipPoints[1].id.cf.indexA = 0;
          clipPoints[1].id.cf.indexB = i2;
          clipPoints[1].id.cf.typeA = exports.ContactFeatureType.e_face;
          clipPoints[1].id.cf.typeB = exports.ContactFeatureType.e_vertex;
          ref.i1 = 0;
          ref.i2 = 1;
          ref.v1.Copy(v1);
          ref.v2.Copy(v2);
          ref.normal.Copy(primaryAxis.normal);
          ref.sideNormal1.Copy(edge1).SelfNeg(); // ref.sideNormal1 = -edge1;
          ref.sideNormal2.Copy(edge1);
      }
      else {
          manifold.type = exports.ManifoldType.e_faceB;
          clipPoints[0].v.Copy(v2);
          clipPoints[0].id.cf.indexA = 1;
          clipPoints[0].id.cf.indexB = primaryAxis.index;
          clipPoints[0].id.cf.typeA = exports.ContactFeatureType.e_vertex;
          clipPoints[0].id.cf.typeB = exports.ContactFeatureType.e_face;
          clipPoints[1].v.Copy(v1);
          clipPoints[1].id.cf.indexA = 0;
          clipPoints[1].id.cf.indexB = primaryAxis.index;
          clipPoints[1].id.cf.typeA = exports.ContactFeatureType.e_vertex;
          clipPoints[1].id.cf.typeB = exports.ContactFeatureType.e_face;
          ref.i1 = primaryAxis.index;
          ref.i2 = ref.i1 + 1 < tempPolygonB.count ? ref.i1 + 1 : 0;
          ref.v1.Copy(tempPolygonB.vertices[ref.i1]);
          ref.v2.Copy(tempPolygonB.vertices[ref.i2]);
          ref.normal.Copy(tempPolygonB.normals[ref.i1]);
          // CCW winding
          ref.sideNormal1.Set(ref.normal.y, -ref.normal.x);
          ref.sideNormal2.Copy(ref.sideNormal1).SelfNeg(); // ref.sideNormal2 = -ref.sideNormal1;
      }
      ref.sideOffset1 = b2Vec2.DotVV(ref.sideNormal1, ref.v1);
      ref.sideOffset2 = b2Vec2.DotVV(ref.sideNormal2, ref.v2);
      // Clip incident edge against reference face side planes
      // b2ClipVertex clipPoints1[2];
      const clipPoints1 = b2CollideEdgeAndPolygon_s_clipPoints1; // [new b2ClipVertex(), new b2ClipVertex()];
      // b2ClipVertex clipPoints2[2];
      const clipPoints2 = b2CollideEdgeAndPolygon_s_clipPoints2; // [new b2ClipVertex(), new b2ClipVertex()];
      // int32 np;
      let np;
      // Clip to side 1
      np = b2ClipSegmentToLine(clipPoints1, clipPoints, ref.sideNormal1, ref.sideOffset1, ref.i1);
      if (np < b2_maxManifoldPoints) {
          return;
      }
      // Clip to side 2
      np = b2ClipSegmentToLine(clipPoints2, clipPoints1, ref.sideNormal2, ref.sideOffset2, ref.i2);
      if (np < b2_maxManifoldPoints) {
          return;
      }
      // Now clipPoints2 contains the clipped points.
      if (primaryAxis.type === b2EPAxisType.e_edgeA) {
          manifold.localNormal.Copy(ref.normal);
          manifold.localPoint.Copy(ref.v1);
      }
      else {
          manifold.localNormal.Copy(polygonB.m_normals[ref.i1]);
          manifold.localPoint.Copy(polygonB.m_vertices[ref.i1]);
      }
      let pointCount = 0;
      for (let i = 0; i < b2_maxManifoldPoints; ++i) {
          const separation = b2Vec2.DotVV(ref.normal, b2Vec2.SubVV(clipPoints2[i].v, ref.v1, b2Vec2.s_t0));
          if (separation <= radius) {
              const cp = manifold.points[pointCount];
              if (primaryAxis.type === b2EPAxisType.e_edgeA) {
                  b2Transform.MulTXV(xf, clipPoints2[i].v, cp.localPoint); // cp.localPoint = b2MulT(xf, clipPoints2[i].v);
                  cp.id.Copy(clipPoints2[i].id);
              }
              else {
                  cp.localPoint.Copy(clipPoints2[i].v);
                  cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
                  cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
                  cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
                  cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
              }
              ++pointCount;
          }
      }
      manifold.pointCount = pointCount;
  }

  // MIT License
  // Find the max separation between poly1 and poly2 using edge normals from poly1.
  const b2FindMaxSeparation_s_xf = new b2Transform();
  const b2FindMaxSeparation_s_n = new b2Vec2();
  const b2FindMaxSeparation_s_v1 = new b2Vec2();
  function b2FindMaxSeparation(edgeIndex, poly1, xf1, poly2, xf2) {
      const count1 = poly1.m_count;
      const count2 = poly2.m_count;
      const n1s = poly1.m_normals;
      const v1s = poly1.m_vertices;
      const v2s = poly2.m_vertices;
      const xf = b2Transform.MulTXX(xf2, xf1, b2FindMaxSeparation_s_xf);
      let bestIndex = 0;
      let maxSeparation = -b2_maxFloat;
      for (let i = 0; i < count1; ++i) {
          // Get poly1 normal in frame2.
          const n = b2Rot.MulRV(xf.q, n1s[i], b2FindMaxSeparation_s_n);
          const v1 = b2Transform.MulXV(xf, v1s[i], b2FindMaxSeparation_s_v1);
          // Find deepest point for normal i.
          let si = b2_maxFloat;
          for (let j = 0; j < count2; ++j) {
              const sij = b2Vec2.DotVV(n, b2Vec2.SubVV(v2s[j], v1, b2Vec2.s_t0));
              if (sij < si) {
                  si = sij;
              }
          }
          if (si > maxSeparation) {
              maxSeparation = si;
              bestIndex = i;
          }
      }
      edgeIndex[0] = bestIndex;
      return maxSeparation;
  }
  const b2FindIncidentEdge_s_normal1 = new b2Vec2();
  function b2FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
      const normals1 = poly1.m_normals;
      const count2 = poly2.m_count;
      const vertices2 = poly2.m_vertices;
      const normals2 = poly2.m_normals;
      // DEBUG: b2Assert(0 <= edge1 && edge1 < poly1.m_count);
      // Get the normal of the reference edge in poly2's frame.
      const normal1 = b2Rot.MulTRV(xf2.q, b2Rot.MulRV(xf1.q, normals1[edge1], b2Vec2.s_t0), b2FindIncidentEdge_s_normal1);
      // Find the incident edge on poly2.
      let index = 0;
      let minDot = b2_maxFloat;
      for (let i = 0; i < count2; ++i) {
          const dot = b2Vec2.DotVV(normal1, normals2[i]);
          if (dot < minDot) {
              minDot = dot;
              index = i;
          }
      }
      // Build the clip vertices for the incident edge.
      const i1 = index;
      const i2 = i1 + 1 < count2 ? i1 + 1 : 0;
      const c0 = c[0];
      b2Transform.MulXV(xf2, vertices2[i1], c0.v);
      const cf0 = c0.id.cf;
      cf0.indexA = edge1;
      cf0.indexB = i1;
      cf0.typeA = exports.ContactFeatureType.e_face;
      cf0.typeB = exports.ContactFeatureType.e_vertex;
      const c1 = c[1];
      b2Transform.MulXV(xf2, vertices2[i2], c1.v);
      const cf1 = c1.id.cf;
      cf1.indexA = edge1;
      cf1.indexB = i2;
      cf1.typeA = exports.ContactFeatureType.e_face;
      cf1.typeB = exports.ContactFeatureType.e_vertex;
  }
  // Find edge normal of max separation on A - return if separating axis is found
  // Find edge normal of max separation on B - return if separation axis is found
  // Choose reference edge as min(minA, minB)
  // Find incident edge
  // Clip
  // The normal points from 1 to 2
  const b2CollidePolygons_s_incidentEdge = [new b2ClipVertex(), new b2ClipVertex()];
  const b2CollidePolygons_s_clipPoints1 = [new b2ClipVertex(), new b2ClipVertex()];
  const b2CollidePolygons_s_clipPoints2 = [new b2ClipVertex(), new b2ClipVertex()];
  const b2CollidePolygons_s_edgeA = [0];
  const b2CollidePolygons_s_edgeB = [0];
  const b2CollidePolygons_s_localTangent = new b2Vec2();
  const b2CollidePolygons_s_localNormal = new b2Vec2();
  const b2CollidePolygons_s_planePoint = new b2Vec2();
  const b2CollidePolygons_s_normal = new b2Vec2();
  const b2CollidePolygons_s_tangent = new b2Vec2();
  const b2CollidePolygons_s_ntangent = new b2Vec2();
  const b2CollidePolygons_s_v11 = new b2Vec2();
  const b2CollidePolygons_s_v12 = new b2Vec2();
  function b2CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
      manifold.pointCount = 0;
      const totalRadius = polyA.m_radius + polyB.m_radius;
      const edgeA = b2CollidePolygons_s_edgeA;
      edgeA[0] = 0;
      const separationA = b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);
      if (separationA > totalRadius) {
          return;
      }
      const edgeB = b2CollidePolygons_s_edgeB;
      edgeB[0] = 0;
      const separationB = b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);
      if (separationB > totalRadius) {
          return;
      }
      let poly1; // reference polygon
      let poly2; // incident polygon
      let xf1, xf2;
      let edge1 = 0; // reference edge
      let flip = 0;
      const k_tol = 0.1 * b2_linearSlop;
      if (separationB > separationA + k_tol) {
          poly1 = polyB;
          poly2 = polyA;
          xf1 = xfB;
          xf2 = xfA;
          edge1 = edgeB[0];
          manifold.type = exports.ManifoldType.e_faceB;
          flip = 1;
      }
      else {
          poly1 = polyA;
          poly2 = polyB;
          xf1 = xfA;
          xf2 = xfB;
          edge1 = edgeA[0];
          manifold.type = exports.ManifoldType.e_faceA;
          flip = 0;
      }
      const incidentEdge = b2CollidePolygons_s_incidentEdge;
      b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      const count1 = poly1.m_count;
      const vertices1 = poly1.m_vertices;
      const iv1 = edge1;
      const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
      const local_v11 = vertices1[iv1];
      const local_v12 = vertices1[iv2];
      const localTangent = b2Vec2.SubVV(local_v12, local_v11, b2CollidePolygons_s_localTangent);
      localTangent.Normalize();
      const localNormal = b2Vec2.CrossVOne(localTangent, b2CollidePolygons_s_localNormal);
      const planePoint = b2Vec2.MidVV(local_v11, local_v12, b2CollidePolygons_s_planePoint);
      const tangent = b2Rot.MulRV(xf1.q, localTangent, b2CollidePolygons_s_tangent);
      const normal = b2Vec2.CrossVOne(tangent, b2CollidePolygons_s_normal);
      const v11 = b2Transform.MulXV(xf1, local_v11, b2CollidePolygons_s_v11);
      const v12 = b2Transform.MulXV(xf1, local_v12, b2CollidePolygons_s_v12);
      // Face offset.
      const frontOffset = b2Vec2.DotVV(normal, v11);
      // Side offsets, extended by polytope skin thickness.
      const sideOffset1 = -b2Vec2.DotVV(tangent, v11) + totalRadius;
      const sideOffset2 = b2Vec2.DotVV(tangent, v12) + totalRadius;
      // Clip incident edge against extruded edge1 side edges.
      const clipPoints1 = b2CollidePolygons_s_clipPoints1;
      const clipPoints2 = b2CollidePolygons_s_clipPoints2;
      let np;
      // Clip to box side 1
      const ntangent = b2Vec2.NegV(tangent, b2CollidePolygons_s_ntangent);
      np = b2ClipSegmentToLine(clipPoints1, incidentEdge, ntangent, sideOffset1, iv1);
      if (np < 2) {
          return;
      }
      // Clip to negative box side 1
      np = b2ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);
      if (np < 2) {
          return;
      }
      // Now clipPoints2 contains the clipped points.
      manifold.localNormal.Copy(localNormal);
      manifold.localPoint.Copy(planePoint);
      let pointCount = 0;
      for (let i = 0; i < b2_maxManifoldPoints; ++i) {
          const cv = clipPoints2[i];
          const separation = b2Vec2.DotVV(normal, cv.v) - frontOffset;
          if (separation <= totalRadius) {
              const cp = manifold.points[pointCount];
              b2Transform.MulTXV(xf2, cv.v, cp.localPoint);
              cp.id.Copy(cv.id);
              if (flip) {
                  // Swap features
                  const cf = cp.id.cf;
                  cp.id.cf.indexA = cf.indexB;
                  cp.id.cf.indexB = cf.indexA;
                  cp.id.cf.typeA = cf.typeB;
                  cp.id.cf.typeB = cf.typeA;
              }
              ++pointCount;
          }
      }
      manifold.pointCount = pointCount;
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// A solid convex polygon. It is assumed that the interior of the polygon is to
  /// the left of each edge.
  /// In most cases you should not need many vertices for a convex polygon.
  class b2PolygonShape extends b2Shape {
      constructor() {
          super(exports.ShapeType.e_polygonShape, b2_polygonRadius);
          this.m_centroid = new b2Vec2(0, 0);
          this.m_vertices = [];
          this.m_normals = [];
          this.m_count = 0;
      }
      /// Implement b2Shape.
      Clone() {
          return new b2PolygonShape().Copy(this);
      }
      Copy(other) {
          super.Copy(other);
          // DEBUG: b2Assert(other instanceof b2PolygonShape);
          this.m_centroid.Copy(other.m_centroid);
          this.m_count = other.m_count;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          this.m_normals = b2Vec2.MakeArray(this.m_count);
          for (let i = 0; i < this.m_count; ++i) {
              this.m_vertices[i].Copy(other.m_vertices[i]);
              this.m_normals[i].Copy(other.m_normals[i]);
          }
          return this;
      }
      /// @see b2Shape::GetChildCount
      GetChildCount() {
          return 1;
      }
      Set(...args) {
          if (typeof args[0][0] === "number") {
              const vertices = args[0];
              if (vertices.length % 2 !== 0) {
                  throw new Error();
              }
              return this._Set((index) => ({ x: vertices[index * 2], y: vertices[index * 2 + 1] }), vertices.length / 2);
          }
          else {
              const vertices = args[0];
              const count = args[1] || vertices.length;
              return this._Set((index) => vertices[index], count);
          }
      }
      _Set(vertices, count) {
          // DEBUG: b2Assert(3 <= count);
          if (count < 3) {
              return this.SetAsBox(1, 1);
          }
          let n = count;
          // Perform welding and copy vertices into local buffer.
          const ps = [];
          for (let i = 0; i < n; ++i) {
              const /*b2Vec2*/ v = vertices(i);
              let /*bool*/ unique = true;
              for (let /*int32*/ j = 0; j < ps.length; ++j) {
                  if (b2Vec2.DistanceSquaredVV(v, ps[j]) < ((0.5 * b2_linearSlop) * (0.5 * b2_linearSlop))) {
                      unique = false;
                      break;
                  }
              }
              if (unique) {
                  ps.push(v);
              }
          }
          n = ps.length;
          if (n < 3) {
              // Polygon is degenerate.
              // DEBUG: b2Assert(false);
              return this.SetAsBox(1.0, 1.0);
          }
          // Create the convex hull using the Gift wrapping algorithm
          // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
          // Find the right most point on the hull
          let i0 = 0;
          let x0 = ps[0].x;
          for (let i = 1; i < n; ++i) {
              const x = ps[i].x;
              if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {
                  i0 = i;
                  x0 = x;
              }
          }
          const hull = [];
          let m = 0;
          let ih = i0;
          for (;;) {
              hull[m] = ih;
              let ie = 0;
              for (let j = 1; j < n; ++j) {
                  if (ie === ih) {
                      ie = j;
                      continue;
                  }
                  const r = b2Vec2.SubVV(ps[ie], ps[hull[m]], b2PolygonShape.Set_s_r);
                  const v = b2Vec2.SubVV(ps[j], ps[hull[m]], b2PolygonShape.Set_s_v);
                  const c = b2Vec2.CrossVV(r, v);
                  if (c < 0) {
                      ie = j;
                  }
                  // Collinearity check
                  if (c === 0 && v.LengthSquared() > r.LengthSquared()) {
                      ie = j;
                  }
              }
              ++m;
              ih = ie;
              if (ie === i0) {
                  break;
              }
          }
          this.m_count = m;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          this.m_normals = b2Vec2.MakeArray(this.m_count);
          // Copy vertices.
          for (let i = 0; i < m; ++i) {
              this.m_vertices[i].Copy(ps[hull[i]]);
          }
          // Compute normals. Ensure the edges have non-zero length.
          for (let i = 0; i < m; ++i) {
              const vertexi1 = this.m_vertices[i];
              const vertexi2 = this.m_vertices[(i + 1) % m];
              const edge = b2Vec2.SubVV(vertexi2, vertexi1, b2Vec2.s_t0); // edge uses s_t0
              // DEBUG: b2Assert(edge.LengthSquared() > b2_epsilon_sq);
              b2Vec2.CrossVOne(edge, this.m_normals[i]).SelfNormalize();
          }
          // Compute the polygon centroid.
          b2PolygonShape.ComputeCentroid(this.m_vertices, m, this.m_centroid);
          return this;
      }
      /// Build vertices to represent an axis-aligned box or an oriented box.
      /// @param hx the half-width.
      /// @param hy the half-height.
      /// @param center the center of the box in local coordinates.
      /// @param angle the rotation of the box in local coordinates.
      SetAsBox(hx, hy, center, angle = 0) {
          this.m_count = 4;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          this.m_normals = b2Vec2.MakeArray(this.m_count);
          this.m_vertices[0].Set((-hx), (-hy));
          this.m_vertices[1].Set(hx, (-hy));
          this.m_vertices[2].Set(hx, hy);
          this.m_vertices[3].Set((-hx), hy);
          this.m_normals[0].Set(0, (-1));
          this.m_normals[1].Set(1, 0);
          this.m_normals[2].Set(0, 1);
          this.m_normals[3].Set((-1), 0);
          this.m_centroid.SetZero();
          if (center) {
              this.m_centroid.Copy(center);
              const xf = new b2Transform();
              xf.SetPosition(center);
              xf.SetRotationAngle(angle);
              // Transform vertices and normals.
              for (let i = 0; i < this.m_count; ++i) {
                  b2Transform.MulXV(xf, this.m_vertices[i], this.m_vertices[i]);
                  b2Rot.MulRV(xf.q, this.m_normals[i], this.m_normals[i]);
              }
          }
          return this;
      }
      TestPoint(xf, p) {
          const pLocal = b2Transform.MulTXV(xf, p, b2PolygonShape.TestPoint_s_pLocal);
          for (let i = 0; i < this.m_count; ++i) {
              const dot = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Vec2.s_t0));
              if (dot > 0) {
                  return false;
              }
          }
          return true;
      }
      ComputeDistance(xf, p, normal, childIndex) {
          const pLocal = b2Transform.MulTXV(xf, p, b2PolygonShape.ComputeDistance_s_pLocal);
          let maxDistance = -b2_maxFloat;
          const normalForMaxDistance = b2PolygonShape.ComputeDistance_s_normalForMaxDistance.Copy(pLocal);
          for (let i = 0; i < this.m_count; ++i) {
              const dot = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Vec2.s_t0));
              if (dot > maxDistance) {
                  maxDistance = dot;
                  normalForMaxDistance.Copy(this.m_normals[i]);
              }
          }
          if (maxDistance > 0) {
              const minDistance = b2PolygonShape.ComputeDistance_s_minDistance.Copy(normalForMaxDistance);
              let minDistance2 = maxDistance * maxDistance;
              for (let i = 0; i < this.m_count; ++i) {
                  const distance = b2Vec2.SubVV(pLocal, this.m_vertices[i], b2PolygonShape.ComputeDistance_s_distance);
                  const distance2 = distance.LengthSquared();
                  if (minDistance2 > distance2) {
                      minDistance.Copy(distance);
                      minDistance2 = distance2;
                  }
              }
              b2Rot.MulRV(xf.q, minDistance, normal);
              normal.Normalize();
              return Math.sqrt(minDistance2);
          }
          else {
              b2Rot.MulRV(xf.q, normalForMaxDistance, normal);
              return maxDistance;
          }
      }
      RayCast(output, input, xf, childIndex) {
          // Put the ray into the polygon's frame of reference.
          const p1 = b2Transform.MulTXV(xf, input.p1, b2PolygonShape.RayCast_s_p1);
          const p2 = b2Transform.MulTXV(xf, input.p2, b2PolygonShape.RayCast_s_p2);
          const d = b2Vec2.SubVV(p2, p1, b2PolygonShape.RayCast_s_d);
          let lower = 0, upper = input.maxFraction;
          let index = -1;
          for (let i = 0; i < this.m_count; ++i) {
              // p = p1 + a * d
              // dot(normal, p - v) = 0
              // dot(normal, p1 - v) + a * dot(normal, d) = 0
              const numerator = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(this.m_vertices[i], p1, b2Vec2.s_t0));
              const denominator = b2Vec2.DotVV(this.m_normals[i], d);
              if (denominator === 0) {
                  if (numerator < 0) {
                      return false;
                  }
              }
              else {
                  // Note: we want this predicate without division:
                  // lower < numerator / denominator, where denominator < 0
                  // Since denominator < 0, we have to flip the inequality:
                  // lower < numerator / denominator <==> denominator * lower > numerator.
                  if (denominator < 0 && numerator < lower * denominator) {
                      // Increase lower.
                      // The segment enters this half-space.
                      lower = numerator / denominator;
                      index = i;
                  }
                  else if (denominator > 0 && numerator < upper * denominator) {
                      // Decrease upper.
                      // The segment exits this half-space.
                      upper = numerator / denominator;
                  }
              }
              // The use of epsilon here causes the assert on lower to trip
              // in some cases. Apparently the use of epsilon was to make edge
              // shapes work, but now those are handled separately.
              // if (upper < lower - b2_epsilon)
              if (upper < lower) {
                  return false;
              }
          }
          // DEBUG: b2Assert(0 <= lower && lower <= input.maxFraction);
          if (index >= 0) {
              output.fraction = lower;
              b2Rot.MulRV(xf.q, this.m_normals[index], output.normal);
              return true;
          }
          return false;
      }
      ComputeAABB(aabb, xf, childIndex) {
          const lower = b2Transform.MulXV(xf, this.m_vertices[0], aabb.lowerBound);
          const upper = aabb.upperBound.Copy(lower);
          for (let i = 0; i < this.m_count; ++i) {
              const v = b2Transform.MulXV(xf, this.m_vertices[i], b2PolygonShape.ComputeAABB_s_v);
              b2Vec2.MinV(v, lower, lower);
              b2Vec2.MaxV(v, upper, upper);
          }
          const r = this.m_radius;
          lower.SelfSubXY(r, r);
          upper.SelfAddXY(r, r);
      }
      ComputeMass(massData, density) {
          // Polygon mass, centroid, and inertia.
          // Let rho be the polygon density in mass per unit area.
          // Then:
          // mass = rho * int(dA)
          // centroid.x = (1/mass) * rho * int(x * dA)
          // centroid.y = (1/mass) * rho * int(y * dA)
          // I = rho * int((x*x + y*y) * dA)
          //
          // We can compute these integrals by summing all the integrals
          // for each triangle of the polygon. To evaluate the integral
          // for a single triangle, we make a change of variables to
          // the (u,v) coordinates of the triangle:
          // x = x0 + e1x * u + e2x * v
          // y = y0 + e1y * u + e2y * v
          // where 0 <= u && 0 <= v && u + v <= 1.
          //
          // We integrate u from [0,1-v] and then v from [0,1].
          // We also need to use the Jacobian of the transformation:
          // D = cross(e1, e2)
          //
          // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
          //
          // The rest of the derivation is handled by computer algebra.
          // DEBUG: b2Assert(this.m_count >= 3);
          const center = b2PolygonShape.ComputeMass_s_center.SetZero();
          let area = 0;
          let I = 0;
          // Get a reference point for forming triangles.
          // Use the first vertex to reduce round-off errors.
          const s = b2PolygonShape.ComputeMass_s_s.Copy(this.m_vertices[0]);
          const k_inv3 = 1 / 3;
          for (let i = 0; i < this.m_count; ++i) {
              // Triangle vertices.
              const e1 = b2Vec2.SubVV(this.m_vertices[i], s, b2PolygonShape.ComputeMass_s_e1);
              const e2 = b2Vec2.SubVV(this.m_vertices[(i + 1) % this.m_count], s, b2PolygonShape.ComputeMass_s_e2);
              const D = b2Vec2.CrossVV(e1, e2);
              const triangleArea = 0.5 * D;
              area += triangleArea;
              // Area weighted centroid
              center.SelfAdd(b2Vec2.MulSV(triangleArea * k_inv3, b2Vec2.AddVV(e1, e2, b2Vec2.s_t0), b2Vec2.s_t1));
              const ex1 = e1.x;
              const ey1 = e1.y;
              const ex2 = e2.x;
              const ey2 = e2.y;
              const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
              const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
              I += (0.25 * k_inv3 * D) * (intx2 + inty2);
          }
          // Total mass
          massData.mass = density * area;
          // Center of mass
          // DEBUG: b2Assert(area > b2_epsilon);
          center.SelfMul(1 / area);
          b2Vec2.AddVV(center, s, massData.center);
          // Inertia tensor relative to the local origin (point s).
          massData.I = density * I;
          // Shift to center of mass then to original body origin.
          massData.I += massData.mass * (b2Vec2.DotVV(massData.center, massData.center) - b2Vec2.DotVV(center, center));
      }
      Validate() {
          for (let i = 0; i < this.m_count; ++i) {
              const i1 = i;
              const i2 = (i + 1) % this.m_count;
              const p = this.m_vertices[i1];
              const e = b2Vec2.SubVV(this.m_vertices[i2], p, b2PolygonShape.Validate_s_e);
              for (let j = 0; j < this.m_count; ++j) {
                  if (j === i1 || j === i2) {
                      continue;
                  }
                  const v = b2Vec2.SubVV(this.m_vertices[j], p, b2PolygonShape.Validate_s_v);
                  const c = b2Vec2.CrossVV(e, v);
                  if (c < 0) {
                      return false;
                  }
              }
          }
          return true;
      }
      SetupDistanceProxy(proxy, index) {
          proxy.m_vertices = this.m_vertices;
          proxy.m_count = this.m_count;
          proxy.m_radius = this.m_radius;
      }
      ComputeSubmergedArea(normal, offset, xf, c) {
          // Transform plane into shape co-ordinates
          const normalL = b2Rot.MulTRV(xf.q, normal, b2PolygonShape.ComputeSubmergedArea_s_normalL);
          const offsetL = offset - b2Vec2.DotVV(normal, xf.p);
          const depths = [];
          let diveCount = 0;
          let intoIndex = -1;
          let outoIndex = -1;
          let lastSubmerged = false;
          for (let i = 0; i < this.m_count; ++i) {
              depths[i] = b2Vec2.DotVV(normalL, this.m_vertices[i]) - offsetL;
              const isSubmerged = depths[i] < (-b2_epsilon);
              if (i > 0) {
                  if (isSubmerged) {
                      if (!lastSubmerged) {
                          intoIndex = i - 1;
                          diveCount++;
                      }
                  }
                  else {
                      if (lastSubmerged) {
                          outoIndex = i - 1;
                          diveCount++;
                      }
                  }
              }
              lastSubmerged = isSubmerged;
          }
          switch (diveCount) {
              case 0:
                  if (lastSubmerged) {
                      // Completely submerged
                      const md = b2PolygonShape.ComputeSubmergedArea_s_md;
                      this.ComputeMass(md, 1);
                      b2Transform.MulXV(xf, md.center, c);
                      return md.mass;
                  }
                  else {
                      // Completely dry
                      return 0;
                  }
              case 1:
                  if (intoIndex === (-1)) {
                      intoIndex = this.m_count - 1;
                  }
                  else {
                      outoIndex = this.m_count - 1;
                  }
                  break;
          }
          const intoIndex2 = ((intoIndex + 1) % this.m_count);
          const outoIndex2 = ((outoIndex + 1) % this.m_count);
          const intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
          const outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
          const intoVec = b2PolygonShape.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
          const outoVec = b2PolygonShape.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
          // Initialize accumulator
          let area = 0;
          const center = b2PolygonShape.ComputeSubmergedArea_s_center.SetZero();
          let p2 = this.m_vertices[intoIndex2];
          let p3;
          // An awkward loop from intoIndex2+1 to outIndex2
          let i = intoIndex2;
          while (i !== outoIndex2) {
              i = (i + 1) % this.m_count;
              if (i === outoIndex2) {
                  p3 = outoVec;
              }
              else {
                  p3 = this.m_vertices[i];
              }
              const triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
              area += triangleArea;
              // Area weighted centroid
              center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
              center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
              p2 = p3;
          }
          // Normalize and transform centroid
          center.SelfMul(1 / area);
          b2Transform.MulXV(xf, center, c);
          return area;
      }
      Dump(log) {
          log("    const shape: b2PolygonShape = new b2PolygonShape();\n");
          log("    const vs: b2Vec2[] = [];\n");
          for (let i = 0; i < this.m_count; ++i) {
              log("    vs[%d] = new b2Vec2(%.15f, %.15f);\n", i, this.m_vertices[i].x, this.m_vertices[i].y);
          }
          log("    shape.Set(vs, %d);\n", this.m_count);
      }
      static ComputeCentroid(vs, count, out) {
          // DEBUG: b2Assert(count >= 3);
          const c = out;
          c.SetZero();
          let area = 0;
          // Get a reference point for forming triangles.
          // Use the first vertex to reduce round-off errors.
          const s = b2PolygonShape.ComputeCentroid_s_s.Copy(vs[0]);
          const inv3 = 1 / 3;
          for (let i = 0; i < count; ++i) {
              // Triangle vertices.
              const p1 = b2Vec2.SubVV(vs[0], s, b2PolygonShape.ComputeCentroid_s_p1);
              const p2 = b2Vec2.SubVV(vs[i], s, b2PolygonShape.ComputeCentroid_s_p2);
              const p3 = b2Vec2.SubVV(vs[(i + 1) % count], s, b2PolygonShape.ComputeCentroid_s_p3);
              const e1 = b2Vec2.SubVV(p2, p1, b2PolygonShape.ComputeCentroid_s_e1);
              const e2 = b2Vec2.SubVV(p3, p1, b2PolygonShape.ComputeCentroid_s_e2);
              const D = b2Vec2.CrossVV(e1, e2);
              const triangleArea = 0.5 * D;
              area += triangleArea;
              // Area weighted centroid
              c.x += triangleArea * inv3 * (p1.x + p2.x + p3.x);
              c.y += triangleArea * inv3 * (p1.y + p2.y + p3.y);
          }
          // Centroid
          // DEBUG: b2Assert(area > b2_epsilon);
          // c = (1.0f / area) * c + s;
          c.x = (1 / area) * c.x + s.x;
          c.y = (1 / area) * c.y + s.y;
          return c;
      }
  }
  /// Create a convex hull from the given array of points.
  /// @warning the points may be re-ordered, even if they form a convex polygon
  /// @warning collinear points are handled but not removed. Collinear points
  /// may lead to poor stacking behavior.
  b2PolygonShape.Set_s_r = new b2Vec2();
  b2PolygonShape.Set_s_v = new b2Vec2();
  /// @see b2Shape::TestPoint
  b2PolygonShape.TestPoint_s_pLocal = new b2Vec2();
  // #if B2_ENABLE_PARTICLE
  /// @see b2Shape::ComputeDistance
  b2PolygonShape.ComputeDistance_s_pLocal = new b2Vec2();
  b2PolygonShape.ComputeDistance_s_normalForMaxDistance = new b2Vec2();
  b2PolygonShape.ComputeDistance_s_minDistance = new b2Vec2();
  b2PolygonShape.ComputeDistance_s_distance = new b2Vec2();
  // #endif
  /// Implement b2Shape.
  /// @note because the polygon is solid, rays that start inside do not hit because the normal is
  /// not defined.
  b2PolygonShape.RayCast_s_p1 = new b2Vec2();
  b2PolygonShape.RayCast_s_p2 = new b2Vec2();
  b2PolygonShape.RayCast_s_d = new b2Vec2();
  /// @see b2Shape::ComputeAABB
  b2PolygonShape.ComputeAABB_s_v = new b2Vec2();
  /// @see b2Shape::ComputeMass
  b2PolygonShape.ComputeMass_s_center = new b2Vec2();
  b2PolygonShape.ComputeMass_s_s = new b2Vec2();
  b2PolygonShape.ComputeMass_s_e1 = new b2Vec2();
  b2PolygonShape.ComputeMass_s_e2 = new b2Vec2();
  b2PolygonShape.Validate_s_e = new b2Vec2();
  b2PolygonShape.Validate_s_v = new b2Vec2();
  b2PolygonShape.ComputeSubmergedArea_s_normalL = new b2Vec2();
  b2PolygonShape.ComputeSubmergedArea_s_md = new b2MassData();
  b2PolygonShape.ComputeSubmergedArea_s_intoVec = new b2Vec2();
  b2PolygonShape.ComputeSubmergedArea_s_outoVec = new b2Vec2();
  b2PolygonShape.ComputeSubmergedArea_s_center = new b2Vec2();
  b2PolygonShape.ComputeCentroid_s_s = new b2Vec2();
  b2PolygonShape.ComputeCentroid_s_p1 = new b2Vec2();
  b2PolygonShape.ComputeCentroid_s_p2 = new b2Vec2();
  b2PolygonShape.ComputeCentroid_s_p3 = new b2Vec2();
  b2PolygonShape.ComputeCentroid_s_e1 = new b2Vec2();
  b2PolygonShape.ComputeCentroid_s_e2 = new b2Vec2();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  exports.toiTime = 0;
  exports.toiMaxTime = 0;
  exports.toiCalls = 0;
  exports.toiIters = 0;
  exports.toiMaxIters = 0;
  exports.toiRootIters = 0;
  exports.toiMaxRootIters = 0;
  function b2_toi_reset() {
      exports.toiTime = 0;
      exports.toiMaxTime = 0;
      exports.toiCalls = 0;
      exports.toiIters = 0;
      exports.toiMaxIters = 0;
      exports.toiRootIters = 0;
      exports.toiMaxRootIters = 0;
  }
  const b2TimeOfImpact_s_xfA = new b2Transform();
  const b2TimeOfImpact_s_xfB = new b2Transform();
  const b2TimeOfImpact_s_pointA = new b2Vec2();
  const b2TimeOfImpact_s_pointB = new b2Vec2();
  const b2TimeOfImpact_s_normal = new b2Vec2();
  const b2TimeOfImpact_s_axisA = new b2Vec2();
  const b2TimeOfImpact_s_axisB = new b2Vec2();
  /// Input parameters for b2TimeOfImpact
  class b2TOIInput {
      constructor() {
          this.proxyA = new b2DistanceProxy();
          this.proxyB = new b2DistanceProxy();
          this.sweepA = new b2Sweep();
          this.sweepB = new b2Sweep();
          this.tMax = 0; // defines sweep interval [0, tMax]
      }
  }
  (function (b2TOIOutputState) {
      b2TOIOutputState[b2TOIOutputState["e_unknown"] = 0] = "e_unknown";
      b2TOIOutputState[b2TOIOutputState["e_failed"] = 1] = "e_failed";
      b2TOIOutputState[b2TOIOutputState["e_overlapped"] = 2] = "e_overlapped";
      b2TOIOutputState[b2TOIOutputState["e_touching"] = 3] = "e_touching";
      b2TOIOutputState[b2TOIOutputState["e_separated"] = 4] = "e_separated";
  })(exports.TOIOutputState || (exports.TOIOutputState = {}));
  class b2TOIOutput {
      constructor() {
          this.state = exports.TOIOutputState.e_unknown;
          this.t = 0;
      }
  }
  (function (b2SeparationFunctionType) {
      b2SeparationFunctionType[b2SeparationFunctionType["e_unknown"] = -1] = "e_unknown";
      b2SeparationFunctionType[b2SeparationFunctionType["e_points"] = 0] = "e_points";
      b2SeparationFunctionType[b2SeparationFunctionType["e_faceA"] = 1] = "e_faceA";
      b2SeparationFunctionType[b2SeparationFunctionType["e_faceB"] = 2] = "e_faceB";
  })(exports.SeparationFunctionType || (exports.SeparationFunctionType = {}));
  class b2SeparationFunction {
      constructor() {
          this.m_sweepA = new b2Sweep();
          this.m_sweepB = new b2Sweep();
          this.m_type = exports.SeparationFunctionType.e_unknown;
          this.m_localPoint = new b2Vec2();
          this.m_axis = new b2Vec2();
      }
      Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1) {
          this.m_proxyA = proxyA;
          this.m_proxyB = proxyB;
          const count = cache.count;
          // DEBUG: b2Assert(0 < count && count < 3);
          this.m_sweepA.Copy(sweepA);
          this.m_sweepB.Copy(sweepB);
          const xfA = b2TimeOfImpact_s_xfA;
          const xfB = b2TimeOfImpact_s_xfB;
          this.m_sweepA.GetTransform(xfA, t1);
          this.m_sweepB.GetTransform(xfB, t1);
          if (count === 1) {
              this.m_type = exports.SeparationFunctionType.e_points;
              const localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
              const localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
              const pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
              const pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
              b2Vec2.SubVV(pointB, pointA, this.m_axis);
              const s = this.m_axis.Normalize();
              // #if B2_ENABLE_PARTICLE
              this.m_localPoint.SetZero();
              // #endif
              return s;
          }
          else if (cache.indexA[0] === cache.indexA[1]) {
              // Two points on B and one on A.
              this.m_type = exports.SeparationFunctionType.e_faceB;
              const localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
              const localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
              b2Vec2.CrossVOne(b2Vec2.SubVV(localPointB2, localPointB1, b2Vec2.s_t0), this.m_axis).SelfNormalize();
              const normal = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);
              b2Vec2.MidVV(localPointB1, localPointB2, this.m_localPoint);
              const pointB = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);
              const localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
              const pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
              let s = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);
              if (s < 0) {
                  this.m_axis.SelfNeg();
                  s = -s;
              }
              return s;
          }
          else {
              // Two points on A and one or two points on B.
              this.m_type = exports.SeparationFunctionType.e_faceA;
              const localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
              const localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
              b2Vec2.CrossVOne(b2Vec2.SubVV(localPointA2, localPointA1, b2Vec2.s_t0), this.m_axis).SelfNormalize();
              const normal = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);
              b2Vec2.MidVV(localPointA1, localPointA2, this.m_localPoint);
              const pointA = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);
              const localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
              const pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
              let s = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);
              if (s < 0) {
                  this.m_axis.SelfNeg();
                  s = -s;
              }
              return s;
          }
      }
      FindMinSeparation(indexA, indexB, t) {
          const xfA = b2TimeOfImpact_s_xfA;
          const xfB = b2TimeOfImpact_s_xfB;
          this.m_sweepA.GetTransform(xfA, t);
          this.m_sweepB.GetTransform(xfB, t);
          switch (this.m_type) {
              case exports.SeparationFunctionType.e_points: {
                  const axisA = b2Rot.MulTRV(xfA.q, this.m_axis, b2TimeOfImpact_s_axisA);
                  const axisB = b2Rot.MulTRV(xfB.q, b2Vec2.NegV(this.m_axis, b2Vec2.s_t0), b2TimeOfImpact_s_axisB);
                  indexA[0] = this.m_proxyA.GetSupport(axisA);
                  indexB[0] = this.m_proxyB.GetSupport(axisB);
                  const localPointA = this.m_proxyA.GetVertex(indexA[0]);
                  const localPointB = this.m_proxyB.GetVertex(indexB[0]);
                  const pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
                  const pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
                  const separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.m_axis);
                  return separation;
              }
              case exports.SeparationFunctionType.e_faceA: {
                  const normal = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);
                  const pointA = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);
                  const axisB = b2Rot.MulTRV(xfB.q, b2Vec2.NegV(normal, b2Vec2.s_t0), b2TimeOfImpact_s_axisB);
                  indexA[0] = -1;
                  indexB[0] = this.m_proxyB.GetSupport(axisB);
                  const localPointB = this.m_proxyB.GetVertex(indexB[0]);
                  const pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
                  const separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);
                  return separation;
              }
              case exports.SeparationFunctionType.e_faceB: {
                  const normal = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);
                  const pointB = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);
                  const axisA = b2Rot.MulTRV(xfA.q, b2Vec2.NegV(normal, b2Vec2.s_t0), b2TimeOfImpact_s_axisA);
                  indexB[0] = -1;
                  indexA[0] = this.m_proxyA.GetSupport(axisA);
                  const localPointA = this.m_proxyA.GetVertex(indexA[0]);
                  const pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
                  const separation = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);
                  return separation;
              }
              default:
                  // DEBUG: b2Assert(false);
                  indexA[0] = -1;
                  indexB[0] = -1;
                  return 0;
          }
      }
      Evaluate(indexA, indexB, t) {
          const xfA = b2TimeOfImpact_s_xfA;
          const xfB = b2TimeOfImpact_s_xfB;
          this.m_sweepA.GetTransform(xfA, t);
          this.m_sweepB.GetTransform(xfB, t);
          switch (this.m_type) {
              case exports.SeparationFunctionType.e_points: {
                  const localPointA = this.m_proxyA.GetVertex(indexA);
                  const localPointB = this.m_proxyB.GetVertex(indexB);
                  const pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
                  const pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
                  const separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.m_axis);
                  return separation;
              }
              case exports.SeparationFunctionType.e_faceA: {
                  const normal = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);
                  const pointA = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);
                  const localPointB = this.m_proxyB.GetVertex(indexB);
                  const pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
                  const separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);
                  return separation;
              }
              case exports.SeparationFunctionType.e_faceB: {
                  const normal = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);
                  const pointB = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);
                  const localPointA = this.m_proxyA.GetVertex(indexA);
                  const pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
                  const separation = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);
                  return separation;
              }
              default:
                  // DEBUG: b2Assert(false);
                  return 0;
          }
      }
  }
  const b2TimeOfImpact_s_timer = new b2Timer();
  const b2TimeOfImpact_s_cache = new b2SimplexCache();
  const b2TimeOfImpact_s_distanceInput = new b2DistanceInput();
  const b2TimeOfImpact_s_distanceOutput = new b2DistanceOutput();
  const b2TimeOfImpact_s_fcn = new b2SeparationFunction();
  const b2TimeOfImpact_s_indexA = [0];
  const b2TimeOfImpact_s_indexB = [0];
  const b2TimeOfImpact_s_sweepA = new b2Sweep();
  const b2TimeOfImpact_s_sweepB = new b2Sweep();
  function b2TimeOfImpact(output, input) {
      const timer = b2TimeOfImpact_s_timer.Reset();
      ++exports.toiCalls;
      output.state = exports.TOIOutputState.e_unknown;
      output.t = input.tMax;
      const proxyA = input.proxyA;
      const proxyB = input.proxyB;
      const maxVertices = b2Max(b2_maxPolygonVertices, b2Max(proxyA.m_count, proxyB.m_count));
      const sweepA = b2TimeOfImpact_s_sweepA.Copy(input.sweepA);
      const sweepB = b2TimeOfImpact_s_sweepB.Copy(input.sweepB);
      // Large rotations can make the root finder fail, so we normalize the
      // sweep angles.
      sweepA.Normalize();
      sweepB.Normalize();
      const tMax = input.tMax;
      const totalRadius = proxyA.m_radius + proxyB.m_radius;
      const target = b2Max(b2_linearSlop, totalRadius - 3 * b2_linearSlop);
      const tolerance = 0.25 * b2_linearSlop;
      // DEBUG: b2Assert(target > tolerance);
      let t1 = 0;
      const k_maxIterations = 20; // TODO_ERIN b2Settings
      let iter = 0;
      // Prepare input for distance query.
      const cache = b2TimeOfImpact_s_cache;
      cache.count = 0;
      const distanceInput = b2TimeOfImpact_s_distanceInput;
      distanceInput.proxyA.Copy(input.proxyA);
      distanceInput.proxyB.Copy(input.proxyB);
      distanceInput.useRadii = false;
      // The outer loop progressively attempts to compute new separating axes.
      // This loop terminates when an axis is repeated (no progress is made).
      for (;;) {
          const xfA = b2TimeOfImpact_s_xfA;
          const xfB = b2TimeOfImpact_s_xfB;
          sweepA.GetTransform(xfA, t1);
          sweepB.GetTransform(xfB, t1);
          // Get the distance between shapes. We can also use the results
          // to get a separating axis.
          distanceInput.transformA.Copy(xfA);
          distanceInput.transformB.Copy(xfB);
          const distanceOutput = b2TimeOfImpact_s_distanceOutput;
          b2Distance(distanceOutput, cache, distanceInput);
          // If the shapes are overlapped, we give up on continuous collision.
          if (distanceOutput.distance <= 0) {
              // Failure!
              output.state = exports.TOIOutputState.e_overlapped;
              output.t = 0;
              break;
          }
          if (distanceOutput.distance < target + tolerance) {
              // Victory!
              output.state = exports.TOIOutputState.e_touching;
              output.t = t1;
              break;
          }
          // Initialize the separating axis.
          const fcn = b2TimeOfImpact_s_fcn;
          fcn.Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
          /*
          #if 0
              // Dump the curve seen by the root finder {
                const int32 N = 100;
                float32 dx = 1.0f / N;
                float32 xs[N+1];
                float32 fs[N+1];
          
                float32 x = 0.0f;
          
                for (int32 i = 0; i <= N; ++i) {
                  sweepA.GetTransform(&xfA, x);
                  sweepB.GetTransform(&xfB, x);
                  float32 f = fcn.Evaluate(xfA, xfB) - target;
          
                  printf("%g %g\n", x, f);
          
                  xs[i] = x;
                  fs[i] = f;
          
                  x += dx;
                }
              }
          #endif
          */
          // Compute the TOI on the separating axis. We do this by successively
          // resolving the deepest point. This loop is bounded by the number of vertices.
          let done = false;
          let t2 = tMax;
          let pushBackIter = 0;
          for (;;) {
              // Find the deepest point at t2. Store the witness point indices.
              const indexA = b2TimeOfImpact_s_indexA;
              const indexB = b2TimeOfImpact_s_indexB;
              let s2 = fcn.FindMinSeparation(indexA, indexB, t2);
              // Is the final configuration separated?
              if (s2 > (target + tolerance)) {
                  // Victory!
                  output.state = exports.TOIOutputState.e_separated;
                  output.t = tMax;
                  done = true;
                  break;
              }
              // Has the separation reached tolerance?
              if (s2 > (target - tolerance)) {
                  // Advance the sweeps
                  t1 = t2;
                  break;
              }
              // Compute the initial separation of the witness points.
              let s1 = fcn.Evaluate(indexA[0], indexB[0], t1);
              // Check for initial overlap. This might happen if the root finder
              // runs out of iterations.
              if (s1 < (target - tolerance)) {
                  output.state = exports.TOIOutputState.e_failed;
                  output.t = t1;
                  done = true;
                  break;
              }
              // Check for touching
              if (s1 <= (target + tolerance)) {
                  // Victory! t1 should hold the TOI (could be 0.0).
                  output.state = exports.TOIOutputState.e_touching;
                  output.t = t1;
                  done = true;
                  break;
              }
              // Compute 1D root of: f(x) - target = 0
              let rootIterCount = 0;
              let a1 = t1;
              let a2 = t2;
              for (;;) {
                  // Use a mix of the secant rule and bisection.
                  let t = 0;
                  if (rootIterCount & 1) {
                      // Secant rule to improve convergence.
                      t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
                  }
                  else {
                      // Bisection to guarantee progress.
                      t = 0.5 * (a1 + a2);
                  }
                  ++rootIterCount;
                  ++exports.toiRootIters;
                  const s = fcn.Evaluate(indexA[0], indexB[0], t);
                  if (b2Abs(s - target) < tolerance) {
                      // t2 holds a tentative value for t1
                      t2 = t;
                      break;
                  }
                  // Ensure we continue to bracket the root.
                  if (s > target) {
                      a1 = t;
                      s1 = s;
                  }
                  else {
                      a2 = t;
                      s2 = s;
                  }
                  if (rootIterCount === 50) {
                      break;
                  }
              }
              exports.toiMaxRootIters = b2Max(exports.toiMaxRootIters, rootIterCount);
              ++pushBackIter;
              if (pushBackIter === maxVertices) {
                  break;
              }
          }
          ++iter;
          ++exports.toiIters;
          if (done) {
              break;
          }
          if (iter === k_maxIterations) {
              // Root finder got stuck. Semi-victory.
              output.state = exports.TOIOutputState.e_failed;
              output.t = t1;
              break;
          }
      }
      exports.toiMaxIters = b2Max(exports.toiMaxIters, iter);
      const time = timer.GetMilliseconds();
      exports.toiMaxTime = b2Max(exports.toiMaxTime, time);
      exports.toiTime += time;
  }

  /*
  * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  (function (b2JointType) {
      b2JointType[b2JointType["e_unknownJoint"] = 0] = "e_unknownJoint";
      b2JointType[b2JointType["e_revoluteJoint"] = 1] = "e_revoluteJoint";
      b2JointType[b2JointType["e_prismaticJoint"] = 2] = "e_prismaticJoint";
      b2JointType[b2JointType["e_distanceJoint"] = 3] = "e_distanceJoint";
      b2JointType[b2JointType["e_pulleyJoint"] = 4] = "e_pulleyJoint";
      b2JointType[b2JointType["e_mouseJoint"] = 5] = "e_mouseJoint";
      b2JointType[b2JointType["e_gearJoint"] = 6] = "e_gearJoint";
      b2JointType[b2JointType["e_wheelJoint"] = 7] = "e_wheelJoint";
      b2JointType[b2JointType["e_weldJoint"] = 8] = "e_weldJoint";
      b2JointType[b2JointType["e_frictionJoint"] = 9] = "e_frictionJoint";
      b2JointType[b2JointType["e_ropeJoint"] = 10] = "e_ropeJoint";
      b2JointType[b2JointType["e_motorJoint"] = 11] = "e_motorJoint";
      b2JointType[b2JointType["e_areaJoint"] = 12] = "e_areaJoint";
  })(exports.JointType || (exports.JointType = {}));
  class b2Jacobian {
      constructor() {
          this.linear = new b2Vec2();
          this.angularA = 0;
          this.angularB = 0;
      }
      SetZero() {
          this.linear.SetZero();
          this.angularA = 0;
          this.angularB = 0;
          return this;
      }
      Set(x, a1, a2) {
          this.linear.Copy(x);
          this.angularA = a1;
          this.angularB = a2;
          return this;
      }
  }
  /// A joint edge is used to connect bodies and joints together
  /// in a joint graph where each body is a node and each joint
  /// is an edge. A joint edge belongs to a doubly linked list
  /// maintained in each attached body. Each joint has two joint
  /// nodes, one for each attached body.
  class b2JointEdge {
      constructor(joint) {
          this._other = null; ///< provides quick access to the other body attached.
          this.prev = null; ///< the previous joint edge in the body's joint list
          this.next = null; ///< the next joint edge in the body's joint list
          this.joint = joint;
      }
      get other() {
          if (this._other === null) {
              throw new Error();
          }
          return this._other;
      }
      set other(value) {
          if (this._other !== null) {
              throw new Error();
          }
          this._other = value;
      }
      Reset() {
          this._other = null;
          this.prev = null;
          this.next = null;
      }
  }
  /// Joint definitions are used to construct joints.
  class b2JointDef {
      constructor(type) {
          /// The joint type is set automatically for concrete joint types.
          this.type = exports.JointType.e_unknownJoint;
          /// Use this to attach application specific data to your joints.
          this.userData = null;
          /// Set this flag to true if the attached bodies should collide.
          this.collideConnected = false;
          this.type = type;
      }
  }
  /// Utility to compute linear stiffness values from frequency and damping ratio
  // void b2LinearStiffness(float& stiffness, float& damping,
  // 	float frequencyHertz, float dampingRatio,
  // 	const b2Body* bodyA, const b2Body* bodyB);
  function b2LinearStiffness(def, frequencyHertz, dampingRatio, bodyA, bodyB) {
      const massA = bodyA.GetMass();
      const massB = bodyB.GetMass();
      let mass;
      if (massA > 0.0 && massB > 0.0) {
          mass = massA * massB / (massA + massB);
      }
      else if (massA > 0.0) {
          mass = massA;
      }
      else {
          mass = massB;
      }
      const omega = 2.0 * b2_pi * frequencyHertz;
      def.stiffness = mass * omega * omega;
      def.damping = 2.0 * mass * dampingRatio * omega;
  }
  /// Utility to compute rotational stiffness values frequency and damping ratio
  // void b2AngularStiffness(float& stiffness, float& damping,
  // 	float frequencyHertz, float dampingRatio,
  // 	const b2Body* bodyA, const b2Body* bodyB);
  function b2AngularStiffness(def, frequencyHertz, dampingRatio, bodyA, bodyB) {
      const IA = bodyA.GetInertia();
      const IB = bodyB.GetInertia();
      let I;
      if (IA > 0.0 && IB > 0.0) {
          I = IA * IB / (IA + IB);
      }
      else if (IA > 0.0) {
          I = IA;
      }
      else {
          I = IB;
      }
      const omega = 2.0 * b2_pi * frequencyHertz;
      def.stiffness = I * omega * omega;
      def.damping = 2.0 * I * dampingRatio * omega;
  }
  /// The base joint class. Joints are used to constraint two bodies together in
  /// various fashions. Some joints also feature limits and motors.
  class b2Joint {
      constructor(def) {
          // DEBUG: b2Assert(def.bodyA !== def.bodyB);
          this.m_type = exports.JointType.e_unknownJoint;
          this.m_prev = null;
          this.m_next = null;
          this.m_edgeA = new b2JointEdge(this);
          this.m_edgeB = new b2JointEdge(this);
          this.m_index = 0;
          this.m_islandFlag = false;
          this.m_collideConnected = false;
          this.m_userData = null;
          this.m_type = def.type;
          this.m_edgeA.other = def.bodyB;
          this.m_edgeB.other = def.bodyA;
          this.m_bodyA = def.bodyA;
          this.m_bodyB = def.bodyB;
          this.m_collideConnected = b2Maybe(def.collideConnected, false);
          this.m_userData = b2Maybe(def.userData, null);
      }
      /// Get the type of the concrete joint.
      GetType() {
          return this.m_type;
      }
      /// Get the first body attached to this joint.
      GetBodyA() {
          return this.m_bodyA;
      }
      /// Get the second body attached to this joint.
      GetBodyB() {
          return this.m_bodyB;
      }
      /// Get the next joint the world joint list.
      GetNext() {
          return this.m_next;
      }
      /// Get the user data pointer.
      GetUserData() {
          return this.m_userData;
      }
      /// Set the user data pointer.
      SetUserData(data) {
          this.m_userData = data;
      }
      /// Short-cut function to determine if either body is inactive.
      IsEnabled() {
          return this.m_bodyA.IsEnabled() && this.m_bodyB.IsEnabled();
      }
      /// Get collide connected.
      /// Note: modifying the collide connect flag won't work correctly because
      /// the flag is only checked when fixture AABBs begin to overlap.
      GetCollideConnected() {
          return this.m_collideConnected;
      }
      /// Dump this joint to the log file.
      Dump(log) {
          log("// Dump is not supported for this joint type.\n");
      }
      /// Shift the origin for any points stored in world coordinates.
      ShiftOrigin(newOrigin) { }
      Draw(draw) {
          const xf1 = this.m_bodyA.GetTransform();
          const xf2 = this.m_bodyB.GetTransform();
          const x1 = xf1.p;
          const x2 = xf2.p;
          const p1 = this.GetAnchorA(b2Joint.Draw_s_p1);
          const p2 = this.GetAnchorB(b2Joint.Draw_s_p2);
          const color = b2Joint.Draw_s_color.SetRGB(0.5, 0.8, 0.8);
          switch (this.m_type) {
              case exports.JointType.e_distanceJoint:
                  draw.DrawSegment(p1, p2, color);
                  break;
              case exports.JointType.e_pulleyJoint:
                  {
                      const pulley = this;
                      const s1 = pulley.GetGroundAnchorA();
                      const s2 = pulley.GetGroundAnchorB();
                      draw.DrawSegment(s1, p1, color);
                      draw.DrawSegment(s2, p2, color);
                      draw.DrawSegment(s1, s2, color);
                  }
                  break;
              case exports.JointType.e_mouseJoint:
                  {
                      const c = b2Joint.Draw_s_c;
                      c.Set(0.0, 1.0, 0.0);
                      draw.DrawPoint(p1, 4.0, c);
                      draw.DrawPoint(p2, 4.0, c);
                      c.Set(0.8, 0.8, 0.8);
                      draw.DrawSegment(p1, p2, c);
                  }
                  break;
              default:
                  draw.DrawSegment(x1, p1, color);
                  draw.DrawSegment(p1, p2, color);
                  draw.DrawSegment(x2, p2, color);
          }
      }
  }
  /// Debug draw this joint
  b2Joint.Draw_s_p1 = new b2Vec2();
  b2Joint.Draw_s_p2 = new b2Vec2();
  b2Joint.Draw_s_color = new b2Color(0.5, 0.8, 0.8);
  b2Joint.Draw_s_c = new b2Color();

  /*
  * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Distance joint definition. This requires defining an
  /// anchor point on both bodies and the non-zero length of the
  /// distance joint. The definition uses local anchor points
  /// so that the initial configuration can violate the constraint
  /// slightly. This helps when saving and loading a game.
  /// @warning Do not use a zero or short length.
  class b2DistanceJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_distanceJoint);
          this.localAnchorA = new b2Vec2();
          this.localAnchorB = new b2Vec2();
          this.length = 1;
          this.minLength = 0;
          this.maxLength = b2_maxFloat; // FLT_MAX;
          this.stiffness = 0;
          this.damping = 0;
      }
      Initialize(b1, b2, anchor1, anchor2) {
          this.bodyA = b1;
          this.bodyB = b2;
          this.bodyA.GetLocalPoint(anchor1, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor2, this.localAnchorB);
          this.length = b2Max(b2Vec2.DistanceVV(anchor1, anchor2), b2_linearSlop);
          this.minLength = this.length;
          this.maxLength = this.length;
      }
  }
  class b2DistanceJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_stiffness = 0;
          this.m_damping = 0;
          this.m_bias = 0;
          this.m_length = 0;
          this.m_minLength = 0;
          this.m_maxLength = 0;
          // Solver shared
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_gamma = 0;
          this.m_impulse = 0;
          this.m_lowerImpulse = 0;
          this.m_upperImpulse = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_u = new b2Vec2();
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_currentLength = 0;
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_softMass = 0;
          this.m_mass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          this.m_length = b2Max(b2Maybe(def.length, this.GetCurrentLength()), b2_linearSlop);
          this.m_minLength = b2Max(b2Maybe(def.minLength, this.m_length), b2_linearSlop);
          this.m_maxLength = b2Max(b2Maybe(def.maxLength, this.m_length), this.m_minLength);
          this.m_stiffness = b2Maybe(def.stiffness, 0);
          this.m_damping = b2Maybe(def.damping, 0);
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          // b2Vec2 F = inv_dt * (m_impulse + m_lowerImpulse - m_upperImpulse) * m_u;
          out.x = inv_dt * (this.m_impulse + this.m_lowerImpulse - this.m_upperImpulse) * this.m_u.x;
          out.y = inv_dt * (this.m_impulse + this.m_lowerImpulse - this.m_upperImpulse) * this.m_u.y;
          return out;
      }
      GetReactionTorque(inv_dt) {
          return 0;
      }
      GetLocalAnchorA() { return this.m_localAnchorA; }
      GetLocalAnchorB() { return this.m_localAnchorB; }
      SetLength(length) {
          this.m_impulse = 0;
          this.m_length = b2Max(b2_linearSlop, length);
          return this.m_length;
      }
      GetLength() {
          return this.m_length;
      }
      SetMinLength(minLength) {
          this.m_lowerImpulse = 0;
          this.m_minLength = b2Clamp(minLength, b2_linearSlop, this.m_maxLength);
          return this.m_minLength;
      }
      SetMaxLength(maxLength) {
          this.m_upperImpulse = 0;
          this.m_maxLength = b2Max(maxLength, this.m_minLength);
          return this.m_maxLength;
      }
      GetCurrentLength() {
          const pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, new b2Vec2());
          const pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, new b2Vec2());
          return b2Vec2.DistanceVV(pA, pB);
      }
      SetStiffness(stiffness) {
          this.m_stiffness = stiffness;
      }
      GetStiffness() {
          return this.m_stiffness;
      }
      SetDamping(damping) {
          this.m_damping = damping;
      }
      GetDamping() {
          return this.m_damping;
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.length = %.15f;\n", this.m_length);
          log("  jd.minLength = %.15f;\n", this.m_minLength);
          log("  jd.maxLength = %.15f;\n", this.m_maxLength);
          log("  jd.stiffness = %.15f;\n", this.m_stiffness);
          log("  jd.damping = %.15f;\n", this.m_damping);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const cA = data.positions[this.m_indexA].c;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const cB = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // m_u = cB + m_rB - cA - m_rA;
          this.m_u.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x;
          this.m_u.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y;
          // Handle singularity.
          this.m_currentLength = this.m_u.Length();
          if (this.m_currentLength > b2_linearSlop) {
              this.m_u.SelfMul(1 / this.m_currentLength);
          }
          else {
              this.m_u.SetZero();
              this.m_mass = 0;
              this.m_impulse = 0;
              this.m_lowerImpulse = 0;
              this.m_upperImpulse = 0;
          }
          // float32 crAu = b2Cross(m_rA, m_u);
          const crAu = b2Vec2.CrossVV(this.m_rA, this.m_u);
          // float32 crBu = b2Cross(m_rB, m_u);
          const crBu = b2Vec2.CrossVV(this.m_rB, this.m_u);
          // float32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;
          let invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
          this.m_mass = invMass !== 0 ? 1 / invMass : 0;
          if (this.m_stiffness > 0 && this.m_minLength < this.m_maxLength) {
              // soft
              const C = this.m_currentLength - this.m_length;
              const d = this.m_damping;
              const k = this.m_stiffness;
              // magic formulas
              const h = data.step.dt;
              // gamma = 1 / (h * (d + h * k))
              // the extra factor of h in the denominator is since the lambda is an impulse, not a force
              this.m_gamma = h * (d + h * k);
              this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;
              this.m_bias = C * h * k * this.m_gamma;
              invMass += this.m_gamma;
              this.m_softMass = invMass !== 0 ? 1 / invMass : 0;
          }
          else {
              // rigid
              this.m_gamma = 0;
              this.m_bias = 0;
              this.m_softMass = this.m_mass;
          }
          if (data.step.warmStarting) {
              // Scale the impulse to support a variable time step.
              this.m_impulse *= data.step.dtRatio;
              this.m_lowerImpulse *= data.step.dtRatio;
              this.m_upperImpulse *= data.step.dtRatio;
              const P = b2Vec2.MulSV(this.m_impulse + this.m_lowerImpulse - this.m_upperImpulse, this.m_u, b2DistanceJoint.InitVelocityConstraints_s_P);
              vA.SelfMulSub(this.m_invMassA, P);
              wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
              vB.SelfMulAdd(this.m_invMassB, P);
              wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
          }
          else {
              this.m_impulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          if (this.m_minLength < this.m_maxLength) {
              if (this.m_stiffness > 0) {
                  // Cdot = dot(u, v + cross(w, r))
                  const vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);
                  const vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);
                  const Cdot = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpB, vpA, b2Vec2.s_t0));
                  const impulse = -this.m_softMass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
                  this.m_impulse += impulse;
                  const P = b2Vec2.MulSV(impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);
                  vA.SelfMulSub(this.m_invMassA, P);
                  wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
                  vB.SelfMulAdd(this.m_invMassB, P);
                  wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
              }
              // lower
              {
                  const C = this.m_currentLength - this.m_minLength;
                  const bias = b2Max(0, C) * data.step.inv_dt;
                  const vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);
                  const vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);
                  const Cdot = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpB, vpA, b2Vec2.s_t0));
                  let impulse = -this.m_mass * (Cdot + bias);
                  const oldImpulse = this.m_lowerImpulse;
                  this.m_lowerImpulse = b2Max(0, this.m_lowerImpulse + impulse);
                  impulse = this.m_lowerImpulse - oldImpulse;
                  const P = b2Vec2.MulSV(impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);
                  vA.SelfMulSub(this.m_invMassA, P);
                  wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
                  vB.SelfMulAdd(this.m_invMassB, P);
                  wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
              }
              // upper
              {
                  const C = this.m_maxLength - this.m_currentLength;
                  const bias = b2Max(0, C) * data.step.inv_dt;
                  const vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);
                  const vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);
                  const Cdot = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpA, vpB, b2Vec2.s_t0));
                  let impulse = -this.m_mass * (Cdot + bias);
                  const oldImpulse = this.m_upperImpulse;
                  this.m_upperImpulse = b2Max(0, this.m_upperImpulse + impulse);
                  impulse = this.m_upperImpulse - oldImpulse;
                  const P = b2Vec2.MulSV(-impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);
                  vA.SelfMulSub(this.m_invMassA, P);
                  wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
                  vB.SelfMulAdd(this.m_invMassB, P);
                  wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
              }
          }
          else {
              // Equal limits
              // Cdot = dot(u, v + cross(w, r))
              const vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);
              const vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);
              const Cdot = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpB, vpA, b2Vec2.s_t0));
              const impulse = -this.m_mass * Cdot;
              this.m_impulse += impulse;
              const P = b2Vec2.MulSV(impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);
              vA.SelfMulSub(this.m_invMassA, P);
              wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
              vB.SelfMulAdd(this.m_invMassB, P);
              wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA); // use m_rA
          // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB); // use m_rB
          // b2Vec2 u = cB + rB - cA - rA;
          const u = this.m_u; // use m_u
          u.x = cB.x + rB.x - cA.x - rA.x;
          u.y = cB.y + rB.y - cA.y - rA.y;
          const length = this.m_u.Normalize();
          let C;
          if (this.m_minLength == this.m_maxLength) {
              C = length - this.m_minLength;
          }
          else if (length < this.m_minLength) {
              C = length - this.m_minLength;
          }
          else if (this.m_maxLength < length) {
              C = length - this.m_maxLength;
          }
          else {
              return true;
          }
          const impulse = -this.m_mass * C;
          const P = b2Vec2.MulSV(impulse, u, b2DistanceJoint.SolvePositionConstraints_s_P);
          cA.SelfMulSub(this.m_invMassA, P);
          aA -= this.m_invIA * b2Vec2.CrossVV(rA, P);
          cB.SelfMulAdd(this.m_invMassB, P);
          aB += this.m_invIB * b2Vec2.CrossVV(rB, P);
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          return b2Abs(C) < b2_linearSlop;
      }
      Draw(draw) {
          const xfA = this.m_bodyA.GetTransform();
          const xfB = this.m_bodyB.GetTransform();
          const pA = b2Transform.MulXV(xfA, this.m_localAnchorA, b2DistanceJoint.Draw_s_pA);
          const pB = b2Transform.MulXV(xfB, this.m_localAnchorB, b2DistanceJoint.Draw_s_pB);
          const axis = b2Vec2.SubVV(pB, pA, b2DistanceJoint.Draw_s_axis);
          axis.Normalize();
          const c1 = b2DistanceJoint.Draw_s_c1; // b2Color c1(0.7f, 0.7f, 0.7f);
          const c2 = b2DistanceJoint.Draw_s_c2; // b2Color c2(0.3f, 0.9f, 0.3f);
          const c3 = b2DistanceJoint.Draw_s_c3; // b2Color c3(0.9f, 0.3f, 0.3f);
          const c4 = b2DistanceJoint.Draw_s_c4; // b2Color c4(0.4f, 0.4f, 0.4f);
          draw.DrawSegment(pA, pB, c4);
          // b2Vec2 pRest = pA + this.m_length * axis;
          const pRest = b2Vec2.AddVMulSV(pA, this.m_length, axis, b2DistanceJoint.Draw_s_pRest);
          draw.DrawPoint(pRest, 8.0, c1);
          if (this.m_minLength != this.m_maxLength) {
              if (this.m_minLength > b2_linearSlop) {
                  // b2Vec2 pMin = pA + this.m_minLength * axis;
                  const pMin = b2Vec2.AddVMulSV(pA, this.m_minLength, axis, b2DistanceJoint.Draw_s_pMin);
                  draw.DrawPoint(pMin, 4.0, c2);
              }
              if (this.m_maxLength < b2_maxFloat) {
                  // b2Vec2 pMax = pA + this.m_maxLength * axis;
                  const pMax = b2Vec2.AddVMulSV(pA, this.m_maxLength, axis, b2DistanceJoint.Draw_s_pMax);
                  draw.DrawPoint(pMax, 4.0, c3);
              }
          }
      }
  }
  b2DistanceJoint.InitVelocityConstraints_s_P = new b2Vec2();
  b2DistanceJoint.SolveVelocityConstraints_s_vpA = new b2Vec2();
  b2DistanceJoint.SolveVelocityConstraints_s_vpB = new b2Vec2();
  b2DistanceJoint.SolveVelocityConstraints_s_P = new b2Vec2();
  b2DistanceJoint.SolvePositionConstraints_s_P = new b2Vec2();
  b2DistanceJoint.Draw_s_pA = new b2Vec2();
  b2DistanceJoint.Draw_s_pB = new b2Vec2();
  b2DistanceJoint.Draw_s_axis = new b2Vec2();
  b2DistanceJoint.Draw_s_c1 = new b2Color(0.7, 0.7, 0.7);
  b2DistanceJoint.Draw_s_c2 = new b2Color(0.3, 0.9, 0.3);
  b2DistanceJoint.Draw_s_c3 = new b2Color(0.9, 0.3, 0.3);
  b2DistanceJoint.Draw_s_c4 = new b2Color(0.4, 0.4, 0.4);
  b2DistanceJoint.Draw_s_pRest = new b2Vec2();
  b2DistanceJoint.Draw_s_pMin = new b2Vec2();
  b2DistanceJoint.Draw_s_pMax = new b2Vec2();

  // DEBUG: import { b2Assert } from "../common/b2_settings.js";
  class b2AreaJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_areaJoint);
          this.bodies = [];
          this.stiffness = 0;
          this.damping = 0;
      }
      AddBody(body) {
          this.bodies.push(body);
          if (this.bodies.length === 1) {
              this.bodyA = body;
          }
          else if (this.bodies.length === 2) {
              this.bodyB = body;
          }
      }
  }
  class b2AreaJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_stiffness = 0;
          this.m_damping = 0;
          // Solver shared
          this.m_impulse = 0;
          this.m_targetArea = 0;
          this.m_delta = new b2Vec2();
          // DEBUG: b2Assert(def.bodies.length >= 3, "You cannot create an area joint with less than three bodies.");
          this.m_bodies = def.bodies;
          this.m_stiffness = b2Maybe(def.stiffness, 0);
          this.m_damping = b2Maybe(def.damping, 0);
          this.m_targetLengths = b2MakeNumberArray(def.bodies.length);
          this.m_normals = b2Vec2.MakeArray(def.bodies.length);
          this.m_joints = []; // b2MakeNullArray(def.bodies.length);
          this.m_deltas = b2Vec2.MakeArray(def.bodies.length);
          const djd = new b2DistanceJointDef();
          djd.stiffness = this.m_stiffness;
          djd.damping = this.m_damping;
          this.m_targetArea = 0;
          for (let i = 0; i < this.m_bodies.length; ++i) {
              const body = this.m_bodies[i];
              const next = this.m_bodies[(i + 1) % this.m_bodies.length];
              const body_c = body.GetWorldCenter();
              const next_c = next.GetWorldCenter();
              this.m_targetLengths[i] = b2Vec2.DistanceVV(body_c, next_c);
              this.m_targetArea += b2Vec2.CrossVV(body_c, next_c);
              djd.Initialize(body, next, body_c, next_c);
              this.m_joints[i] = body.GetWorld().CreateJoint(djd);
          }
          this.m_targetArea *= 0.5;
      }
      GetAnchorA(out) {
          return out;
      }
      GetAnchorB(out) {
          return out;
      }
      GetReactionForce(inv_dt, out) {
          return out;
      }
      GetReactionTorque(inv_dt) {
          return 0;
      }
      SetStiffness(stiffness) {
          this.m_stiffness = stiffness;
          for (let i = 0; i < this.m_joints.length; ++i) {
              this.m_joints[i].SetStiffness(stiffness);
          }
      }
      GetStiffness() {
          return this.m_stiffness;
      }
      SetDamping(damping) {
          this.m_damping = damping;
          for (let i = 0; i < this.m_joints.length; ++i) {
              this.m_joints[i].SetDamping(damping);
          }
      }
      GetDamping() {
          return this.m_damping;
      }
      Dump(log) {
          log("Area joint dumping is not supported.\n");
      }
      InitVelocityConstraints(data) {
          for (let i = 0; i < this.m_bodies.length; ++i) {
              const prev = this.m_bodies[(i + this.m_bodies.length - 1) % this.m_bodies.length];
              const next = this.m_bodies[(i + 1) % this.m_bodies.length];
              const prev_c = data.positions[prev.m_islandIndex].c;
              const next_c = data.positions[next.m_islandIndex].c;
              const delta = this.m_deltas[i];
              b2Vec2.SubVV(next_c, prev_c, delta);
          }
          if (data.step.warmStarting) {
              this.m_impulse *= data.step.dtRatio;
              for (let i = 0; i < this.m_bodies.length; ++i) {
                  const body = this.m_bodies[i];
                  const body_v = data.velocities[body.m_islandIndex].v;
                  const delta = this.m_deltas[i];
                  body_v.x += body.m_invMass * delta.y * 0.5 * this.m_impulse;
                  body_v.y += body.m_invMass * -delta.x * 0.5 * this.m_impulse;
              }
          }
          else {
              this.m_impulse = 0;
          }
      }
      SolveVelocityConstraints(data) {
          let dotMassSum = 0;
          let crossMassSum = 0;
          for (let i = 0; i < this.m_bodies.length; ++i) {
              const body = this.m_bodies[i];
              const body_v = data.velocities[body.m_islandIndex].v;
              const delta = this.m_deltas[i];
              dotMassSum += delta.LengthSquared() / body.GetMass();
              crossMassSum += b2Vec2.CrossVV(body_v, delta);
          }
          const lambda = -2 * crossMassSum / dotMassSum;
          // lambda = b2Clamp(lambda, -b2_maxLinearCorrection, b2_maxLinearCorrection);
          this.m_impulse += lambda;
          for (let i = 0; i < this.m_bodies.length; ++i) {
              const body = this.m_bodies[i];
              const body_v = data.velocities[body.m_islandIndex].v;
              const delta = this.m_deltas[i];
              body_v.x += body.m_invMass * delta.y * 0.5 * lambda;
              body_v.y += body.m_invMass * -delta.x * 0.5 * lambda;
          }
      }
      SolvePositionConstraints(data) {
          let perimeter = 0;
          let area = 0;
          for (let i = 0; i < this.m_bodies.length; ++i) {
              const body = this.m_bodies[i];
              const next = this.m_bodies[(i + 1) % this.m_bodies.length];
              const body_c = data.positions[body.m_islandIndex].c;
              const next_c = data.positions[next.m_islandIndex].c;
              const delta = b2Vec2.SubVV(next_c, body_c, this.m_delta);
              let dist = delta.Length();
              if (dist < b2_epsilon) {
                  dist = 1;
              }
              this.m_normals[i].x = delta.y / dist;
              this.m_normals[i].y = -delta.x / dist;
              perimeter += dist;
              area += b2Vec2.CrossVV(body_c, next_c);
          }
          area *= 0.5;
          const deltaArea = this.m_targetArea - area;
          const toExtrude = 0.5 * deltaArea / perimeter;
          let done = true;
          for (let i = 0; i < this.m_bodies.length; ++i) {
              const body = this.m_bodies[i];
              const body_c = data.positions[body.m_islandIndex].c;
              const next_i = (i + 1) % this.m_bodies.length;
              const delta = b2Vec2.AddVV(this.m_normals[i], this.m_normals[next_i], this.m_delta);
              delta.SelfMul(toExtrude);
              const norm_sq = delta.LengthSquared();
              if (norm_sq > b2Sq(b2_maxLinearCorrection)) {
                  delta.SelfMul(b2_maxLinearCorrection / b2Sqrt(norm_sq));
              }
              if (norm_sq > b2Sq(b2_linearSlop)) {
                  done = false;
              }
              body_c.x += delta.x;
              body_c.y += delta.y;
          }
          return done;
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// This holds contact filtering data.
  class b2Filter {
      constructor() {
          /// The collision category bits. Normally you would just set one bit.
          this.categoryBits = 0x0001;
          /// The collision mask bits. This states the categories that this
          /// shape would accept for collision.
          this.maskBits = 0xFFFF;
          /// Collision groups allow a certain group of objects to never collide (negative)
          /// or always collide (positive). Zero means no collision group. Non-zero group
          /// filtering always wins against the mask bits.
          this.groupIndex = 0;
      }
      Clone() {
          return new b2Filter().Copy(this);
      }
      Copy(other) {
          // DEBUG: b2Assert(this !== other);
          this.categoryBits = other.categoryBits;
          this.maskBits = other.maskBits;
          this.groupIndex = other.groupIndex || 0;
          return this;
      }
  }
  b2Filter.DEFAULT = new b2Filter();
  /// A fixture definition is used to create a fixture. This class defines an
  /// abstract fixture definition. You can reuse fixture definitions safely.
  class b2FixtureDef {
      constructor() {
          /// Use this to store application specific fixture data.
          this.userData = null;
          /// The friction coefficient, usually in the range [0,1].
          this.friction = 0.2;
          /// The restitution (elasticity) usually in the range [0,1].
          this.restitution = 0;
          /// Restitution velocity threshold, usually in m/s. Collisions above this
          /// speed have restitution applied (will bounce).
          this.restitutionThreshold = 1.0 * b2_lengthUnitsPerMeter;
          /// The density, usually in kg/m^2.
          this.density = 0;
          /// A sensor shape collects contact information but never generates a collision
          /// response.
          this.isSensor = false;
          /// Contact filtering data.
          this.filter = new b2Filter();
      }
  }
  /// This proxy is used internally to connect fixtures to the broad-phase.
  class b2FixtureProxy {
      constructor(fixture, childIndex) {
          this.aabb = new b2AABB();
          this.childIndex = 0;
          this.fixture = fixture;
          this.childIndex = childIndex;
          this.fixture.m_shape.ComputeAABB(this.aabb, this.fixture.m_body.GetTransform(), childIndex);
          this.treeNode = this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb, this);
      }
      Reset() {
          this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode);
      }
      Touch() {
          this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode);
      }
      Synchronize(transform1, transform2) {
          if (transform1 === transform2) {
              this.fixture.m_shape.ComputeAABB(this.aabb, transform1, this.childIndex);
              this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode, this.aabb, b2Vec2.ZERO);
          }
          else {
              // Compute an AABB that covers the swept shape (may miss some rotation effect).
              const aabb1 = b2FixtureProxy.Synchronize_s_aabb1;
              const aabb2 = b2FixtureProxy.Synchronize_s_aabb2;
              this.fixture.m_shape.ComputeAABB(aabb1, transform1, this.childIndex);
              this.fixture.m_shape.ComputeAABB(aabb2, transform2, this.childIndex);
              this.aabb.Combine2(aabb1, aabb2);
              const displacement = b2FixtureProxy.Synchronize_s_displacement;
              displacement.Copy(aabb2.GetCenter()).SelfSub(aabb1.GetCenter());
              this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode, this.aabb, displacement);
          }
      }
  }
  b2FixtureProxy.Synchronize_s_aabb1 = new b2AABB();
  b2FixtureProxy.Synchronize_s_aabb2 = new b2AABB();
  b2FixtureProxy.Synchronize_s_displacement = new b2Vec2();
  /// A fixture is used to attach a shape to a body for collision detection. A fixture
  /// inherits its transform from its parent. Fixtures hold additional non-geometric data
  /// such as friction, collision filters, etc.
  /// Fixtures are created via b2Body::CreateFixture.
  /// @warning you cannot reuse fixtures.
  class b2Fixture {
      constructor(body, def) {
          this.m_density = 0;
          this.m_next = null;
          this.m_friction = 0;
          this.m_restitution = 0;
          this.m_restitutionThreshold = 1.0 * b2_lengthUnitsPerMeter;
          this.m_proxies = [];
          this.m_filter = new b2Filter();
          this.m_isSensor = false;
          this.m_userData = null;
          this.m_body = body;
          this.m_shape = def.shape.Clone();
          this.m_userData = b2Maybe(def.userData, null);
          this.m_friction = b2Maybe(def.friction, 0.2);
          this.m_restitution = b2Maybe(def.restitution, 0);
          this.m_restitutionThreshold = b2Maybe(def.restitutionThreshold, 0);
          this.m_filter.Copy(b2Maybe(def.filter, b2Filter.DEFAULT));
          this.m_isSensor = b2Maybe(def.isSensor, false);
          this.m_density = b2Maybe(def.density, 0);
      }
      get m_proxyCount() { return this.m_proxies.length; }
      Reset() {
          // The proxies must be destroyed before calling this.
          // DEBUG: b2Assert(this.m_proxyCount === 0);
      }
      /// Get the type of the child shape. You can use this to down cast to the concrete shape.
      /// @return the shape type.
      GetType() {
          return this.m_shape.GetType();
      }
      /// Get the child shape. You can modify the child shape, however you should not change the
      /// number of vertices because this will crash some collision caching mechanisms.
      /// Manipulating the shape may lead to non-physical behavior.
      GetShape() {
          return this.m_shape;
      }
      /// Set if this fixture is a sensor.
      SetSensor(sensor) {
          if (sensor !== this.m_isSensor) {
              this.m_body.SetAwake(true);
              this.m_isSensor = sensor;
          }
      }
      /// Is this fixture a sensor (non-solid)?
      /// @return the true if the shape is a sensor.
      IsSensor() {
          return this.m_isSensor;
      }
      /// Set the contact filtering data. This will not update contacts until the next time
      /// step when either parent body is active and awake.
      /// This automatically calls Refilter.
      SetFilterData(filter) {
          this.m_filter.Copy(filter);
          this.Refilter();
      }
      /// Get the contact filtering data.
      GetFilterData() {
          return this.m_filter;
      }
      /// Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide.
      Refilter() {
          // Flag associated contacts for filtering.
          let edge = this.m_body.GetContactList();
          while (edge) {
              const contact = edge.contact;
              const fixtureA = contact.GetFixtureA();
              const fixtureB = contact.GetFixtureB();
              if (fixtureA === this || fixtureB === this) {
                  contact.FlagForFiltering();
              }
              edge = edge.next;
          }
          // Touch each proxy so that new pairs may be created
          this.TouchProxies();
      }
      /// Get the parent body of this fixture. This is NULL if the fixture is not attached.
      /// @return the parent body.
      GetBody() {
          return this.m_body;
      }
      /// Get the next fixture in the parent body's fixture list.
      /// @return the next shape.
      GetNext() {
          return this.m_next;
      }
      /// Get the user data that was assigned in the fixture definition. Use this to
      /// store your application specific data.
      GetUserData() {
          return this.m_userData;
      }
      /// Set the user data. Use this to store your application specific data.
      SetUserData(data) {
          this.m_userData = data;
      }
      /// Test a point for containment in this fixture.
      /// @param p a point in world coordinates.
      TestPoint(p) {
          return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
      }
      // #if B2_ENABLE_PARTICLE
      ComputeDistance(p, normal, childIndex) {
          return this.m_shape.ComputeDistance(this.m_body.GetTransform(), p, normal, childIndex);
      }
      // #endif
      /// Cast a ray against this shape.
      /// @param output the ray-cast results.
      /// @param input the ray-cast input parameters.
      RayCast(output, input, childIndex) {
          return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);
      }
      /// Get the mass data for this fixture. The mass data is based on the density and
      /// the shape. The rotational inertia is about the shape's origin. This operation
      /// may be expensive.
      GetMassData(massData = new b2MassData()) {
          this.m_shape.ComputeMass(massData, this.m_density);
          return massData;
      }
      /// Set the density of this fixture. This will _not_ automatically adjust the mass
      /// of the body. You must call b2Body::ResetMassData to update the body's mass.
      SetDensity(density) {
          this.m_density = density;
      }
      /// Get the density of this fixture.
      GetDensity() {
          return this.m_density;
      }
      /// Get the coefficient of friction.
      GetFriction() {
          return this.m_friction;
      }
      /// Set the coefficient of friction. This will _not_ change the friction of
      /// existing contacts.
      SetFriction(friction) {
          this.m_friction = friction;
      }
      /// Get the coefficient of restitution.
      GetRestitution() {
          return this.m_restitution;
      }
      /// Set the coefficient of restitution. This will _not_ change the restitution of
      /// existing contacts.
      SetRestitution(restitution) {
          this.m_restitution = restitution;
      }
      /// Get the restitution velocity threshold.
      GetRestitutionThreshold() {
          return this.m_restitutionThreshold;
      }
      /// Set the restitution threshold. This will _not_ change the restitution threshold of
      /// existing contacts.
      SetRestitutionThreshold(threshold) {
          this.m_restitutionThreshold = threshold;
      }
      /// Get the fixture's AABB. This AABB may be enlarge and/or stale.
      /// If you need a more accurate AABB, compute it using the shape and
      /// the body transform.
      GetAABB(childIndex) {
          // DEBUG: b2Assert(0 <= childIndex && childIndex < this.m_proxyCount);
          return this.m_proxies[childIndex].aabb;
      }
      /// Dump this fixture to the log file.
      Dump(log, bodyIndex) {
          log("    const fd: b2FixtureDef = new b2FixtureDef();\n");
          log("    fd.friction = %.15f;\n", this.m_friction);
          log("    fd.restitution = %.15f;\n", this.m_restitution);
          log("    fd.restitutionThreshold = %.15f;\n", this.m_restitutionThreshold);
          log("    fd.density = %.15f;\n", this.m_density);
          log("    fd.isSensor = %s;\n", (this.m_isSensor) ? ("true") : ("false"));
          log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits);
          log("    fd.filter.maskBits = %d;\n", this.m_filter.maskBits);
          log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex);
          this.m_shape.Dump(log);
          log("\n");
          log("    fd.shape = shape;\n");
          log("\n");
          log("    bodies[%d].CreateFixture(fd);\n", bodyIndex);
      }
      // These support body activation/deactivation.
      CreateProxies() {
          if (this.m_proxies.length !== 0) {
              throw new Error();
          }
          // Create proxies in the broad-phase.
          for (let i = 0; i < this.m_shape.GetChildCount(); ++i) {
              this.m_proxies[i] = new b2FixtureProxy(this, i);
          }
      }
      DestroyProxies() {
          // Destroy proxies in the broad-phase.
          for (const proxy of this.m_proxies) {
              proxy.Reset();
          }
          this.m_proxies.length = 0;
      }
      TouchProxies() {
          for (const proxy of this.m_proxies) {
              proxy.Touch();
          }
      }
      SynchronizeProxies(transform1, transform2) {
          for (const proxy of this.m_proxies) {
              proxy.Synchronize(transform1, transform2);
          }
      }
  }

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  (function (b2BodyType) {
      b2BodyType[b2BodyType["b2_unknown"] = -1] = "b2_unknown";
      b2BodyType[b2BodyType["b2_staticBody"] = 0] = "b2_staticBody";
      b2BodyType[b2BodyType["b2_kinematicBody"] = 1] = "b2_kinematicBody";
      b2BodyType[b2BodyType["b2_dynamicBody"] = 2] = "b2_dynamicBody";
      // TODO_ERIN
      // b2_bulletBody = 3
  })(exports.BodyType || (exports.BodyType = {}));
  /// A body definition holds all the data needed to construct a rigid body.
  /// You can safely re-use body definitions. Shapes are added to a body after construction.
  class b2BodyDef {
      constructor() {
          /// The body type: static, kinematic, or dynamic.
          /// Note: if a dynamic body would have zero mass, the mass is set to one.
          this.type = exports.BodyType.b2_staticBody;
          /// The world position of the body. Avoid creating bodies at the origin
          /// since this can lead to many overlapping shapes.
          this.position = new b2Vec2(0, 0);
          /// The world angle of the body in radians.
          this.angle = 0;
          /// The linear velocity of the body's origin in world co-ordinates.
          this.linearVelocity = new b2Vec2(0, 0);
          /// The angular velocity of the body.
          this.angularVelocity = 0;
          /// Linear damping is use to reduce the linear velocity. The damping parameter
          /// can be larger than 1.0f but the damping effect becomes sensitive to the
          /// time step when the damping parameter is large.
          this.linearDamping = 0;
          /// Angular damping is use to reduce the angular velocity. The damping parameter
          /// can be larger than 1.0f but the damping effect becomes sensitive to the
          /// time step when the damping parameter is large.
          this.angularDamping = 0;
          /// Set this flag to false if this body should never fall asleep. Note that
          /// this increases CPU usage.
          this.allowSleep = true;
          /// Is this body initially awake or sleeping?
          this.awake = true;
          /// Should this body be prevented from rotating? Useful for characters.
          this.fixedRotation = false;
          /// Is this a fast moving body that should be prevented from tunneling through
          /// other moving bodies? Note that all bodies are prevented from tunneling through
          /// kinematic and static bodies. This setting is only considered on dynamic bodies.
          /// @warning You should use this flag sparingly since it increases processing time.
          this.bullet = false;
          /// Does this body start out enabled?
          this.enabled = true;
          /// Use this to store application specific body data.
          this.userData = null;
          /// Scale the gravity applied to this body.
          this.gravityScale = 1;
      }
  }
  /// A rigid body. These are created via b2World::CreateBody.
  class b2Body {
      // #endif
      constructor(bd, world) {
          this.m_type = exports.BodyType.b2_staticBody;
          this.m_islandFlag = false;
          this.m_awakeFlag = false;
          this.m_autoSleepFlag = false;
          this.m_bulletFlag = false;
          this.m_fixedRotationFlag = false;
          this.m_enabledFlag = false;
          this.m_toiFlag = false;
          this.m_islandIndex = 0;
          this.m_xf = new b2Transform(); // the body origin transform
          // #if B2_ENABLE_PARTICLE
          this.m_xf0 = new b2Transform();
          // #endif
          this.m_sweep = new b2Sweep(); // the swept motion for CCD
          this.m_linearVelocity = new b2Vec2();
          this.m_angularVelocity = 0;
          this.m_force = new b2Vec2();
          this.m_torque = 0;
          this.m_prev = null;
          this.m_next = null;
          this.m_fixtureList = null;
          this.m_fixtureCount = 0;
          this.m_jointList = null;
          this.m_contactList = null;
          this.m_mass = 1;
          this.m_invMass = 1;
          // Rotational inertia about the center of mass.
          this.m_I = 0;
          this.m_invI = 0;
          this.m_linearDamping = 0;
          this.m_angularDamping = 0;
          this.m_gravityScale = 1;
          this.m_sleepTime = 0;
          this.m_userData = null;
          // #if B2_ENABLE_CONTROLLER
          this.m_controllerList = null;
          this.m_controllerCount = 0;
          this.m_bulletFlag = b2Maybe(bd.bullet, false);
          this.m_fixedRotationFlag = b2Maybe(bd.fixedRotation, false);
          this.m_autoSleepFlag = b2Maybe(bd.allowSleep, true);
          // this.m_awakeFlag = b2Maybe(bd.awake, true);
          if (b2Maybe(bd.awake, false) && b2Maybe(bd.type, exports.BodyType.b2_staticBody) !== exports.BodyType.b2_staticBody) {
              this.m_awakeFlag = true;
          }
          this.m_enabledFlag = b2Maybe(bd.enabled, true);
          this.m_world = world;
          this.m_xf.p.Copy(b2Maybe(bd.position, b2Vec2.ZERO));
          // DEBUG: b2Assert(this.m_xf.p.IsValid());
          this.m_xf.q.SetAngle(b2Maybe(bd.angle, 0));
          // DEBUG: b2Assert(b2IsValid(this.m_xf.q.GetAngle()));
          // #if B2_ENABLE_PARTICLE
          this.m_xf0.Copy(this.m_xf);
          // #endif
          this.m_sweep.localCenter.SetZero();
          this.m_sweep.c0.Copy(this.m_xf.p);
          this.m_sweep.c.Copy(this.m_xf.p);
          this.m_sweep.a0 = this.m_sweep.a = this.m_xf.q.GetAngle();
          this.m_sweep.alpha0 = 0;
          this.m_linearVelocity.Copy(b2Maybe(bd.linearVelocity, b2Vec2.ZERO));
          // DEBUG: b2Assert(this.m_linearVelocity.IsValid());
          this.m_angularVelocity = b2Maybe(bd.angularVelocity, 0);
          // DEBUG: b2Assert(b2IsValid(this.m_angularVelocity));
          this.m_linearDamping = b2Maybe(bd.linearDamping, 0);
          this.m_angularDamping = b2Maybe(bd.angularDamping, 0);
          this.m_gravityScale = b2Maybe(bd.gravityScale, 1);
          // DEBUG: b2Assert(b2IsValid(this.m_gravityScale) && this.m_gravityScale >= 0);
          // DEBUG: b2Assert(b2IsValid(this.m_angularDamping) && this.m_angularDamping >= 0);
          // DEBUG: b2Assert(b2IsValid(this.m_linearDamping) && this.m_linearDamping >= 0);
          this.m_force.SetZero();
          this.m_torque = 0;
          this.m_sleepTime = 0;
          this.m_type = b2Maybe(bd.type, exports.BodyType.b2_staticBody);
          this.m_mass = 0;
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_userData = bd.userData;
          this.m_fixtureList = null;
          this.m_fixtureCount = 0;
          // #if B2_ENABLE_CONTROLLER
          this.m_controllerList = null;
          this.m_controllerCount = 0;
          // #endif
      }
      CreateFixture(a, b = 0) {
          if (a instanceof b2Shape) {
              return this.CreateFixtureShapeDensity(a, b);
          }
          else {
              return this.CreateFixtureDef(a);
          }
      }
      /// Creates a fixture and attach it to this body. Use this function if you need
      /// to set some fixture parameters, like friction. Otherwise you can create the
      /// fixture directly from a shape.
      /// If the density is non-zero, this function automatically updates the mass of the body.
      /// Contacts are not created until the next time step.
      /// @param def the fixture definition.
      /// @warning This function is locked during callbacks.
      CreateFixtureDef(def) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          const fixture = new b2Fixture(this, def);
          if (this.m_enabledFlag) {
              fixture.CreateProxies();
          }
          fixture.m_next = this.m_fixtureList;
          this.m_fixtureList = fixture;
          ++this.m_fixtureCount;
          // fixture.m_body = this;
          // Adjust mass properties if needed.
          if (fixture.m_density > 0) {
              this.ResetMassData();
          }
          // Let the world know we have a new fixture. This will cause new contacts
          // to be created at the beginning of the next time step.
          this.m_world.m_newContacts = true;
          return fixture;
      }
      CreateFixtureShapeDensity(shape, density = 0) {
          const def = b2Body.CreateFixtureShapeDensity_s_def;
          def.shape = shape;
          def.density = density;
          return this.CreateFixtureDef(def);
      }
      /// Destroy a fixture. This removes the fixture from the broad-phase and
      /// destroys all contacts associated with this fixture. This will
      /// automatically adjust the mass of the body if the body is dynamic and the
      /// fixture has positive density.
      /// All fixtures attached to a body are implicitly destroyed when the body is destroyed.
      /// @param fixture the fixture to be removed.
      /// @warning This function is locked during callbacks.
      DestroyFixture(fixture) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          // DEBUG: b2Assert(fixture.m_body === this);
          // Remove the fixture from this body's singly linked list.
          // DEBUG: b2Assert(this.m_fixtureCount > 0);
          let node = this.m_fixtureList;
          let ppF = null;
          // DEBUG: let found: boolean = false;
          while (node !== null) {
              if (node === fixture) {
                  if (ppF) {
                      ppF.m_next = fixture.m_next;
                  }
                  else {
                      this.m_fixtureList = fixture.m_next;
                  }
                  // DEBUG: found = true;
                  break;
              }
              ppF = node;
              node = node.m_next;
          }
          // You tried to remove a shape that is not attached to this body.
          // DEBUG: b2Assert(found);
          // Destroy any contacts associated with the fixture.
          let edge = this.m_contactList;
          while (edge) {
              const c = edge.contact;
              edge = edge.next;
              const fixtureA = c.GetFixtureA();
              const fixtureB = c.GetFixtureB();
              if (fixture === fixtureA || fixture === fixtureB) {
                  // This destroys the contact and removes it from
                  // this body's contact list.
                  this.m_world.m_contactManager.Destroy(c);
              }
          }
          if (this.m_enabledFlag) {
              fixture.DestroyProxies();
          }
          // fixture.m_body = null;
          fixture.m_next = null;
          fixture.Reset();
          --this.m_fixtureCount;
          // Reset the mass data.
          this.ResetMassData();
      }
      /// Set the position of the body's origin and rotation.
      /// This breaks any contacts and wakes the other bodies.
      /// Manipulating a body's transform may cause non-physical behavior.
      /// @param position the world position of the body's local origin.
      /// @param angle the world rotation in radians.
      SetTransformVec(position, angle) {
          this.SetTransformXY(position.x, position.y, angle);
      }
      SetTransformXY(x, y, angle) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          this.m_xf.q.SetAngle(angle);
          this.m_xf.p.Set(x, y);
          // #if B2_ENABLE_PARTICLE
          this.m_xf0.Copy(this.m_xf);
          // #endif
          b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
          this.m_sweep.a = angle;
          this.m_sweep.c0.Copy(this.m_sweep.c);
          this.m_sweep.a0 = angle;
          for (let f = this.m_fixtureList; f; f = f.m_next) {
              f.SynchronizeProxies(this.m_xf, this.m_xf);
          }
          // Check for new contacts the next step
          this.m_world.m_newContacts = true;
      }
      SetTransform(xf) {
          this.SetTransformVec(xf.p, xf.GetAngle());
      }
      /// Get the body transform for the body's origin.
      /// @return the world transform of the body's origin.
      GetTransform() {
          return this.m_xf;
      }
      /// Get the world body origin position.
      /// @return the world position of the body's origin.
      GetPosition() {
          return this.m_xf.p;
      }
      SetPosition(position) {
          this.SetTransformVec(position, this.GetAngle());
      }
      SetPositionXY(x, y) {
          this.SetTransformXY(x, y, this.GetAngle());
      }
      /// Get the angle in radians.
      /// @return the current world rotation angle in radians.
      GetAngle() {
          return this.m_sweep.a;
      }
      SetAngle(angle) {
          this.SetTransformVec(this.GetPosition(), angle);
      }
      /// Get the world position of the center of mass.
      GetWorldCenter() {
          return this.m_sweep.c;
      }
      /// Get the local position of the center of mass.
      GetLocalCenter() {
          return this.m_sweep.localCenter;
      }
      /// Set the linear velocity of the center of mass.
      /// @param v the new linear velocity of the center of mass.
      SetLinearVelocity(v) {
          if (this.m_type === exports.BodyType.b2_staticBody) {
              return;
          }
          if (b2Vec2.DotVV(v, v) > 0) {
              this.SetAwake(true);
          }
          this.m_linearVelocity.Copy(v);
      }
      /// Get the linear velocity of the center of mass.
      /// @return the linear velocity of the center of mass.
      GetLinearVelocity() {
          return this.m_linearVelocity;
      }
      /// Set the angular velocity.
      /// @param omega the new angular velocity in radians/second.
      SetAngularVelocity(w) {
          if (this.m_type === exports.BodyType.b2_staticBody) {
              return;
          }
          if (w * w > 0) {
              this.SetAwake(true);
          }
          this.m_angularVelocity = w;
      }
      /// Get the angular velocity.
      /// @return the angular velocity in radians/second.
      GetAngularVelocity() {
          return this.m_angularVelocity;
      }
      GetDefinition(bd) {
          bd.type = this.GetType();
          bd.allowSleep = this.m_autoSleepFlag;
          bd.angle = this.GetAngle();
          bd.angularDamping = this.m_angularDamping;
          bd.gravityScale = this.m_gravityScale;
          bd.angularVelocity = this.m_angularVelocity;
          bd.fixedRotation = this.m_fixedRotationFlag;
          bd.bullet = this.m_bulletFlag;
          bd.awake = this.m_awakeFlag;
          bd.linearDamping = this.m_linearDamping;
          bd.linearVelocity.Copy(this.GetLinearVelocity());
          bd.position.Copy(this.GetPosition());
          bd.userData = this.GetUserData();
          return bd;
      }
      /// Apply a force at a world point. If the force is not
      /// applied at the center of mass, it will generate a torque and
      /// affect the angular velocity. This wakes up the body.
      /// @param force the world force vector, usually in Newtons (N).
      /// @param point the world position of the point of application.
      /// @param wake also wake up the body
      ApplyForce(force, point, wake = true) {
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          if (wake && !this.m_awakeFlag) {
              this.SetAwake(true);
          }
          // Don't accumulate a force if the body is sleeping.
          if (this.m_awakeFlag) {
              this.m_force.x += force.x;
              this.m_force.y += force.y;
              this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
          }
      }
      /// Apply a force to the center of mass. This wakes up the body.
      /// @param force the world force vector, usually in Newtons (N).
      /// @param wake also wake up the body
      ApplyForceToCenter(force, wake = true) {
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          if (wake && !this.m_awakeFlag) {
              this.SetAwake(true);
          }
          // Don't accumulate a force if the body is sleeping.
          if (this.m_awakeFlag) {
              this.m_force.x += force.x;
              this.m_force.y += force.y;
          }
      }
      /// Apply a torque. This affects the angular velocity
      /// without affecting the linear velocity of the center of mass.
      /// @param torque about the z-axis (out of the screen), usually in N-m.
      /// @param wake also wake up the body
      ApplyTorque(torque, wake = true) {
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          if (wake && !this.m_awakeFlag) {
              this.SetAwake(true);
          }
          // Don't accumulate a force if the body is sleeping.
          if (this.m_awakeFlag) {
              this.m_torque += torque;
          }
      }
      /// Apply an impulse at a point. This immediately modifies the velocity.
      /// It also modifies the angular velocity if the point of application
      /// is not at the center of mass. This wakes up the body.
      /// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
      /// @param point the world position of the point of application.
      /// @param wake also wake up the body
      ApplyLinearImpulse(impulse, point, wake = true) {
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          if (wake && !this.m_awakeFlag) {
              this.SetAwake(true);
          }
          // Don't accumulate a force if the body is sleeping.
          if (this.m_awakeFlag) {
              this.m_linearVelocity.x += this.m_invMass * impulse.x;
              this.m_linearVelocity.y += this.m_invMass * impulse.y;
              this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
          }
      }
      /// Apply an impulse at the center of gravity. This immediately modifies the velocity.
      /// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
      /// @param wake also wake up the body
      ApplyLinearImpulseToCenter(impulse, wake = true) {
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          if (wake && !this.m_awakeFlag) {
              this.SetAwake(true);
          }
          // Don't accumulate a force if the body is sleeping.
          if (this.m_awakeFlag) {
              this.m_linearVelocity.x += this.m_invMass * impulse.x;
              this.m_linearVelocity.y += this.m_invMass * impulse.y;
          }
      }
      /// Apply an angular impulse.
      /// @param impulse the angular impulse in units of kg*m*m/s
      /// @param wake also wake up the body
      ApplyAngularImpulse(impulse, wake = true) {
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          if (wake && !this.m_awakeFlag) {
              this.SetAwake(true);
          }
          // Don't accumulate a force if the body is sleeping.
          if (this.m_awakeFlag) {
              this.m_angularVelocity += this.m_invI * impulse;
          }
      }
      /// Get the total mass of the body.
      /// @return the mass, usually in kilograms (kg).
      GetMass() {
          return this.m_mass;
      }
      /// Get the rotational inertia of the body about the local origin.
      /// @return the rotational inertia, usually in kg-m^2.
      GetInertia() {
          return this.m_I + this.m_mass * b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
      }
      /// Get the mass data of the body.
      /// @return a struct containing the mass, inertia and center of the body.
      GetMassData(data) {
          data.mass = this.m_mass;
          data.I = this.m_I + this.m_mass * b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
          data.center.Copy(this.m_sweep.localCenter);
          return data;
      }
      SetMassData(massData) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          if (this.m_type !== exports.BodyType.b2_dynamicBody) {
              return;
          }
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_mass = massData.mass;
          if (this.m_mass <= 0) {
              this.m_mass = 1;
          }
          this.m_invMass = 1 / this.m_mass;
          if (massData.I > 0 && !this.m_fixedRotationFlag) {
              this.m_I = massData.I - this.m_mass * b2Vec2.DotVV(massData.center, massData.center);
              // DEBUG: b2Assert(this.m_I > 0);
              this.m_invI = 1 / this.m_I;
          }
          // Move center of mass.
          const oldCenter = b2Body.SetMassData_s_oldCenter.Copy(this.m_sweep.c);
          this.m_sweep.localCenter.Copy(massData.center);
          b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
          this.m_sweep.c0.Copy(this.m_sweep.c);
          // Update center of mass velocity.
          b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Vec2.s_t0), this.m_linearVelocity);
      }
      ResetMassData() {
          // Compute mass data from shapes. Each shape has its own density.
          this.m_mass = 0;
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_sweep.localCenter.SetZero();
          // Static and kinematic bodies have zero mass.
          if (this.m_type === exports.BodyType.b2_staticBody || this.m_type === exports.BodyType.b2_kinematicBody) {
              this.m_sweep.c0.Copy(this.m_xf.p);
              this.m_sweep.c.Copy(this.m_xf.p);
              this.m_sweep.a0 = this.m_sweep.a;
              return;
          }
          // DEBUG: b2Assert(this.m_type === b2BodyType.b2_dynamicBody);
          // Accumulate mass over all fixtures.
          const localCenter = b2Body.ResetMassData_s_localCenter.SetZero();
          for (let f = this.m_fixtureList; f; f = f.m_next) {
              if (f.m_density === 0) {
                  continue;
              }
              const massData = f.GetMassData(b2Body.ResetMassData_s_massData);
              this.m_mass += massData.mass;
              localCenter.x += massData.center.x * massData.mass;
              localCenter.y += massData.center.y * massData.mass;
              this.m_I += massData.I;
          }
          // Compute center of mass.
          if (this.m_mass > 0) {
              this.m_invMass = 1 / this.m_mass;
              localCenter.x *= this.m_invMass;
              localCenter.y *= this.m_invMass;
          }
          if (this.m_I > 0 && !this.m_fixedRotationFlag) {
              // Center the inertia about the center of mass.
              this.m_I -= this.m_mass * b2Vec2.DotVV(localCenter, localCenter);
              // DEBUG: b2Assert(this.m_I > 0);
              this.m_invI = 1 / this.m_I;
          }
          else {
              this.m_I = 0;
              this.m_invI = 0;
          }
          // Move center of mass.
          const oldCenter = b2Body.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);
          this.m_sweep.localCenter.Copy(localCenter);
          b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
          this.m_sweep.c0.Copy(this.m_sweep.c);
          // Update center of mass velocity.
          b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Vec2.s_t0), this.m_linearVelocity);
      }
      /// Get the world coordinates of a point given the local coordinates.
      /// @param localPoint a point on the body measured relative the the body's origin.
      /// @return the same point expressed in world coordinates.
      GetWorldPoint(localPoint, out) {
          return b2Transform.MulXV(this.m_xf, localPoint, out);
      }
      /// Get the world coordinates of a vector given the local coordinates.
      /// @param localVector a vector fixed in the body.
      /// @return the same vector expressed in world coordinates.
      GetWorldVector(localVector, out) {
          return b2Rot.MulRV(this.m_xf.q, localVector, out);
      }
      /// Gets a local point relative to the body's origin given a world point.
      /// @param a point in world coordinates.
      /// @return the corresponding local point relative to the body's origin.
      GetLocalPoint(worldPoint, out) {
          return b2Transform.MulTXV(this.m_xf, worldPoint, out);
      }
      /// Gets a local vector given a world vector.
      /// @param a vector in world coordinates.
      /// @return the corresponding local vector.
      GetLocalVector(worldVector, out) {
          return b2Rot.MulTRV(this.m_xf.q, worldVector, out);
      }
      /// Get the world linear velocity of a world point attached to this body.
      /// @param a point in world coordinates.
      /// @return the world velocity of a point.
      GetLinearVelocityFromWorldPoint(worldPoint, out) {
          return b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(worldPoint, this.m_sweep.c, b2Vec2.s_t0), out);
      }
      /// Get the world velocity of a local point.
      /// @param a point in local coordinates.
      /// @return the world velocity of a point.
      GetLinearVelocityFromLocalPoint(localPoint, out) {
          return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint, out), out);
      }
      /// Get the linear damping of the body.
      GetLinearDamping() {
          return this.m_linearDamping;
      }
      /// Set the linear damping of the body.
      SetLinearDamping(linearDamping) {
          this.m_linearDamping = linearDamping;
      }
      /// Get the angular damping of the body.
      GetAngularDamping() {
          return this.m_angularDamping;
      }
      /// Set the angular damping of the body.
      SetAngularDamping(angularDamping) {
          this.m_angularDamping = angularDamping;
      }
      /// Get the gravity scale of the body.
      GetGravityScale() {
          return this.m_gravityScale;
      }
      /// Set the gravity scale of the body.
      SetGravityScale(scale) {
          this.m_gravityScale = scale;
      }
      /// Set the type of this body. This may alter the mass and velocity.
      SetType(type) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          if (this.m_type === type) {
              return;
          }
          this.m_type = type;
          this.ResetMassData();
          if (this.m_type === exports.BodyType.b2_staticBody) {
              this.m_linearVelocity.SetZero();
              this.m_angularVelocity = 0;
              this.m_sweep.a0 = this.m_sweep.a;
              this.m_sweep.c0.Copy(this.m_sweep.c);
              this.m_awakeFlag = false;
              this.SynchronizeFixtures();
          }
          this.SetAwake(true);
          this.m_force.SetZero();
          this.m_torque = 0;
          // Delete the attached contacts.
          let ce = this.m_contactList;
          while (ce) {
              const ce0 = ce;
              ce = ce.next;
              this.m_world.m_contactManager.Destroy(ce0.contact);
          }
          this.m_contactList = null;
          // Touch the proxies so that new contacts will be created (when appropriate)
          for (let f = this.m_fixtureList; f; f = f.m_next) {
              f.TouchProxies();
          }
      }
      /// Get the type of this body.
      GetType() {
          return this.m_type;
      }
      /// Should this body be treated like a bullet for continuous collision detection?
      SetBullet(flag) {
          this.m_bulletFlag = flag;
      }
      /// Is this body treated like a bullet for continuous collision detection?
      IsBullet() {
          return this.m_bulletFlag;
      }
      /// You can disable sleeping on this body. If you disable sleeping, the
      /// body will be woken.
      SetSleepingAllowed(flag) {
          this.m_autoSleepFlag = flag;
          if (!flag) {
              this.SetAwake(true);
          }
      }
      /// Is this body allowed to sleep
      IsSleepingAllowed() {
          return this.m_autoSleepFlag;
      }
      /// Set the sleep state of the body. A sleeping body has very
      /// low CPU cost.
      /// @param flag set to true to wake the body, false to put it to sleep.
      SetAwake(flag) {
          if (this.m_type === exports.BodyType.b2_staticBody) {
              return;
          }
          if (flag) {
              this.m_awakeFlag = true;
              this.m_sleepTime = 0;
          }
          else {
              this.m_awakeFlag = false;
              this.m_sleepTime = 0;
              this.m_linearVelocity.SetZero();
              this.m_angularVelocity = 0;
              this.m_force.SetZero();
              this.m_torque = 0;
          }
      }
      /// Get the sleeping state of this body.
      /// @return true if the body is sleeping.
      IsAwake() {
          return this.m_awakeFlag;
      }
      /// Allow a body to be disabled. A disabled body is not simulated and cannot
      /// be collided with or woken up.
      /// If you pass a flag of true, all fixtures will be added to the broad-phase.
      /// If you pass a flag of false, all fixtures will be removed from the
      /// broad-phase and all contacts will be destroyed.
      /// Fixtures and joints are otherwise unaffected. You may continue
      /// to create/destroy fixtures and joints on disabled bodies.
      /// Fixtures on a disabled body are implicitly disabled and will
      /// not participate in collisions, ray-casts, or queries.
      /// Joints connected to a disabled body are implicitly disabled.
      /// An diabled body is still owned by a b2World object and remains
      /// in the body list.
      SetEnabled(flag) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          if (flag === this.IsEnabled()) {
              return;
          }
          this.m_enabledFlag = flag;
          if (flag) {
              // Create all proxies.
              for (let f = this.m_fixtureList; f; f = f.m_next) {
                  f.CreateProxies();
              }
              // Contacts are created at the beginning of the next
              this.m_world.m_newContacts = true;
          }
          else {
              // Destroy all proxies.
              for (let f = this.m_fixtureList; f; f = f.m_next) {
                  f.DestroyProxies();
              }
              // Destroy the attached contacts.
              let ce = this.m_contactList;
              while (ce) {
                  const ce0 = ce;
                  ce = ce.next;
                  this.m_world.m_contactManager.Destroy(ce0.contact);
              }
              this.m_contactList = null;
          }
      }
      /// Get the active state of the body.
      IsEnabled() {
          return this.m_enabledFlag;
      }
      /// Set this body to have fixed rotation. This causes the mass
      /// to be reset.
      SetFixedRotation(flag) {
          if (this.m_fixedRotationFlag === flag) {
              return;
          }
          this.m_fixedRotationFlag = flag;
          this.m_angularVelocity = 0;
          this.ResetMassData();
      }
      /// Does this body have fixed rotation?
      IsFixedRotation() {
          return this.m_fixedRotationFlag;
      }
      /// Get the list of all fixtures attached to this body.
      GetFixtureList() {
          return this.m_fixtureList;
      }
      /// Get the list of all joints attached to this body.
      GetJointList() {
          return this.m_jointList;
      }
      /// Get the list of all contacts attached to this body.
      /// @warning this list changes during the time step and you may
      /// miss some collisions if you don't use b2ContactListener.
      GetContactList() {
          return this.m_contactList;
      }
      /// Get the next body in the world's body list.
      GetNext() {
          return this.m_next;
      }
      /// Get the user data pointer that was provided in the body definition.
      GetUserData() {
          return this.m_userData;
      }
      /// Set the user data. Use this to store your application specific data.
      SetUserData(data) {
          this.m_userData = data;
      }
      /// Get the parent world of this body.
      GetWorld() {
          return this.m_world;
      }
      /// Dump this body to a file
      Dump(log) {
          const bodyIndex = this.m_islandIndex;
          log("{\n");
          log("  const bd: b2BodyDef = new b2BodyDef();\n");
          let type_str = "";
          switch (this.m_type) {
              case exports.BodyType.b2_staticBody:
                  type_str = "b2BodyType.b2_staticBody";
                  break;
              case exports.BodyType.b2_kinematicBody:
                  type_str = "b2BodyType.b2_kinematicBody";
                  break;
              case exports.BodyType.b2_dynamicBody:
                  type_str = "b2BodyType.b2_dynamicBody";
                  break;
          }
          log("  bd.type = %s;\n", type_str);
          log("  bd.position.Set(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y);
          log("  bd.angle = %.15f;\n", this.m_sweep.a);
          log("  bd.linearVelocity.Set(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y);
          log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity);
          log("  bd.linearDamping = %.15f;\n", this.m_linearDamping);
          log("  bd.angularDamping = %.15f;\n", this.m_angularDamping);
          log("  bd.allowSleep = %s;\n", (this.m_autoSleepFlag) ? ("true") : ("false"));
          log("  bd.awake = %s;\n", (this.m_awakeFlag) ? ("true") : ("false"));
          log("  bd.fixedRotation = %s;\n", (this.m_fixedRotationFlag) ? ("true") : ("false"));
          log("  bd.bullet = %s;\n", (this.m_bulletFlag) ? ("true") : ("false"));
          log("  bd.active = %s;\n", (this.m_enabledFlag) ? ("true") : ("false"));
          log("  bd.gravityScale = %.15f;\n", this.m_gravityScale);
          log("\n");
          log("  bodies[%d] = this.m_world.CreateBody(bd);\n", this.m_islandIndex);
          log("\n");
          for (let f = this.m_fixtureList; f; f = f.m_next) {
              log("  {\n");
              f.Dump(log, bodyIndex);
              log("  }\n");
          }
          log("}\n");
      }
      SynchronizeFixtures() {
          if (this.m_awakeFlag) {
              const xf1 = b2Body.SynchronizeFixtures_s_xf1;
              xf1.q.SetAngle(this.m_sweep.a0);
              b2Rot.MulRV(xf1.q, this.m_sweep.localCenter, xf1.p);
              b2Vec2.SubVV(this.m_sweep.c0, xf1.p, xf1.p);
              for (let f = this.m_fixtureList; f; f = f.m_next) {
                  f.SynchronizeProxies(xf1, this.m_xf);
              }
          }
          else {
              for (let f = this.m_fixtureList; f; f = f.m_next) {
                  f.SynchronizeProxies(this.m_xf, this.m_xf);
              }
          }
      }
      SynchronizeTransform() {
          this.m_xf.q.SetAngle(this.m_sweep.a);
          b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
          b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
      }
      // This is used to prevent connected bodies from colliding.
      // It may lie, depending on the collideConnected flag.
      ShouldCollide(other) {
          // At least one body should be dynamic or kinematic.
          if (this.m_type === exports.BodyType.b2_staticBody && other.m_type === exports.BodyType.b2_staticBody) {
              return false;
          }
          return this.ShouldCollideConnected(other);
      }
      ShouldCollideConnected(other) {
          // Does a joint prevent collision?
          for (let jn = this.m_jointList; jn; jn = jn.next) {
              if (jn.other === other) {
                  if (!jn.joint.m_collideConnected) {
                      return false;
                  }
              }
          }
          return true;
      }
      Advance(alpha) {
          // Advance to the new safe time. This doesn't sync the broad-phase.
          this.m_sweep.Advance(alpha);
          this.m_sweep.c.Copy(this.m_sweep.c0);
          this.m_sweep.a = this.m_sweep.a0;
          this.m_xf.q.SetAngle(this.m_sweep.a);
          b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
          b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
      }
      // #if B2_ENABLE_CONTROLLER
      GetControllerList() {
          return this.m_controllerList;
      }
      GetControllerCount() {
          return this.m_controllerCount;
      }
  }
  /// Creates a fixture from a shape and attach it to this body.
  /// This is a convenience function. Use b2FixtureDef if you need to set parameters
  /// like friction, restitution, user data, or filtering.
  /// If the density is non-zero, this function automatically updates the mass of the body.
  /// @param shape the shape to be cloned.
  /// @param density the shape density (set to zero for static bodies).
  /// @warning This function is locked during callbacks.
  b2Body.CreateFixtureShapeDensity_s_def = new b2FixtureDef();
  /// Set the mass properties to override the mass properties of the fixtures.
  /// Note that this changes the center of mass position.
  /// Note that creating or destroying fixtures can also alter the mass.
  /// This function has no effect if the body isn't dynamic.
  /// @param massData the mass properties.
  b2Body.SetMassData_s_oldCenter = new b2Vec2();
  /// This resets the mass properties to the sum of the mass properties of the fixtures.
  /// This normally does not need to be called unless you called SetMassData to override
  /// the mass and you later want to reset the mass.
  b2Body.ResetMassData_s_localCenter = new b2Vec2();
  b2Body.ResetMassData_s_oldCenter = new b2Vec2();
  b2Body.ResetMassData_s_massData = new b2MassData();
  b2Body.SynchronizeFixtures_s_xf1 = new b2Transform();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Friction mixing law. The idea is to allow either fixture to drive the friction to zero.
  /// For example, anything slides on ice.
  function b2MixFriction(friction1, friction2) {
      return b2Sqrt(friction1 * friction2);
  }
  /// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.
  /// For example, a superball bounces on anything.
  function b2MixRestitution(restitution1, restitution2) {
      return restitution1 > restitution2 ? restitution1 : restitution2;
  }
  /// Restitution mixing law. This picks the lowest value.
  function b2MixRestitutionThreshold(threshold1, threshold2) {
      return threshold1 < threshold2 ? threshold1 : threshold2;
  }
  class b2ContactEdge {
      constructor(contact) {
          this._other = null; ///< provides quick access to the other body attached.
          this.prev = null; ///< the previous contact edge in the body's contact list
          this.next = null; ///< the next contact edge in the body's contact list
          this.contact = contact;
      }
      get other() {
          if (this._other === null) {
              throw new Error();
          }
          return this._other;
      }
      set other(value) {
          if (this._other !== null) {
              throw new Error();
          }
          this._other = value;
      }
      Reset() {
          this._other = null;
          this.prev = null;
          this.next = null;
      }
  }
  class b2Contact {
      constructor() {
          this.m_islandFlag = false; /// Used when crawling contact graph when forming islands.
          this.m_touchingFlag = false; /// Set when the shapes are touching.
          this.m_enabledFlag = false; /// This contact can be disabled (by user)
          this.m_filterFlag = false; /// This contact needs filtering because a fixture filter was changed.
          this.m_bulletHitFlag = false; /// This bullet contact had a TOI event
          this.m_toiFlag = false; /// This contact has a valid TOI in m_toi
          this.m_prev = null;
          this.m_next = null;
          this.m_nodeA = new b2ContactEdge(this);
          this.m_nodeB = new b2ContactEdge(this);
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_manifold = new b2Manifold(); // TODO: readonly
          this.m_toiCount = 0;
          this.m_toi = 0;
          this.m_friction = 0;
          this.m_restitution = 0;
          this.m_restitutionThreshold = 0;
          this.m_tangentSpeed = 0;
          this.m_oldManifold = new b2Manifold(); // TODO: readonly
      }
      GetManifold() {
          return this.m_manifold;
      }
      GetWorldManifold(worldManifold) {
          const bodyA = this.m_fixtureA.GetBody();
          const bodyB = this.m_fixtureB.GetBody();
          const shapeA = this.GetShapeA();
          const shapeB = this.GetShapeB();
          worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
      }
      IsTouching() {
          return this.m_touchingFlag;
      }
      SetEnabled(flag) {
          this.m_enabledFlag = flag;
      }
      IsEnabled() {
          return this.m_enabledFlag;
      }
      GetNext() {
          return this.m_next;
      }
      GetFixtureA() {
          return this.m_fixtureA;
      }
      GetChildIndexA() {
          return this.m_indexA;
      }
      GetShapeA() {
          return this.m_fixtureA.GetShape();
      }
      GetFixtureB() {
          return this.m_fixtureB;
      }
      GetChildIndexB() {
          return this.m_indexB;
      }
      GetShapeB() {
          return this.m_fixtureB.GetShape();
      }
      FlagForFiltering() {
          this.m_filterFlag = true;
      }
      SetFriction(friction) {
          this.m_friction = friction;
      }
      GetFriction() {
          return this.m_friction;
      }
      ResetFriction() {
          this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
      }
      SetRestitution(restitution) {
          this.m_restitution = restitution;
      }
      GetRestitution() {
          return this.m_restitution;
      }
      ResetRestitution() {
          this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
      }
      /// Override the default restitution velocity threshold mixture. You can call this in b2ContactListener::PreSolve.
      /// The value persists until you set or reset.
      SetRestitutionThreshold(threshold) {
          this.m_restitutionThreshold = threshold;
      }
      /// Get the restitution threshold.
      GetRestitutionThreshold() {
          return this.m_restitutionThreshold;
      }
      /// Reset the restitution threshold to the default value.
      ResetRestitutionThreshold() {
          this.m_restitutionThreshold = b2MixRestitutionThreshold(this.m_fixtureA.m_restitutionThreshold, this.m_fixtureB.m_restitutionThreshold);
      }
      SetTangentSpeed(speed) {
          this.m_tangentSpeed = speed;
      }
      GetTangentSpeed() {
          return this.m_tangentSpeed;
      }
      Reset(fixtureA, indexA, fixtureB, indexB) {
          this.m_islandFlag = false;
          this.m_touchingFlag = false;
          this.m_enabledFlag = true;
          this.m_filterFlag = false;
          this.m_bulletHitFlag = false;
          this.m_toiFlag = false;
          this.m_fixtureA = fixtureA;
          this.m_fixtureB = fixtureB;
          this.m_indexA = indexA;
          this.m_indexB = indexB;
          this.m_manifold.pointCount = 0;
          this.m_prev = null;
          this.m_next = null;
          this.m_nodeA.Reset();
          this.m_nodeB.Reset();
          this.m_toiCount = 0;
          this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
          this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
          this.m_restitutionThreshold = b2MixRestitutionThreshold(this.m_fixtureA.m_restitutionThreshold, this.m_fixtureB.m_restitutionThreshold);
      }
      Update(listener) {
          const tManifold = this.m_oldManifold;
          this.m_oldManifold = this.m_manifold;
          this.m_manifold = tManifold;
          // Re-enable this contact.
          this.m_enabledFlag = true;
          let touching = false;
          const wasTouching = this.m_touchingFlag;
          const sensorA = this.m_fixtureA.IsSensor();
          const sensorB = this.m_fixtureB.IsSensor();
          const sensor = sensorA || sensorB;
          const bodyA = this.m_fixtureA.GetBody();
          const bodyB = this.m_fixtureB.GetBody();
          const xfA = bodyA.GetTransform();
          const xfB = bodyB.GetTransform();
          // Is this contact a sensor?
          if (sensor) {
              const shapeA = this.GetShapeA();
              const shapeB = this.GetShapeB();
              touching = b2TestOverlapShape(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
              // Sensors don't generate manifolds.
              this.m_manifold.pointCount = 0;
          }
          else {
              this.Evaluate(this.m_manifold, xfA, xfB);
              touching = this.m_manifold.pointCount > 0;
              // Match old contact ids to new contact ids and copy the
              // stored impulses to warm start the solver.
              for (let i = 0; i < this.m_manifold.pointCount; ++i) {
                  const mp2 = this.m_manifold.points[i];
                  mp2.normalImpulse = 0;
                  mp2.tangentImpulse = 0;
                  const id2 = mp2.id;
                  for (let j = 0; j < this.m_oldManifold.pointCount; ++j) {
                      const mp1 = this.m_oldManifold.points[j];
                      if (mp1.id.key === id2.key) {
                          mp2.normalImpulse = mp1.normalImpulse;
                          mp2.tangentImpulse = mp1.tangentImpulse;
                          break;
                      }
                  }
              }
              if (touching !== wasTouching) {
                  bodyA.SetAwake(true);
                  bodyB.SetAwake(true);
              }
          }
          this.m_touchingFlag = touching;
          if (!wasTouching && touching && listener) {
              listener.BeginContact(this);
          }
          if (wasTouching && !touching && listener) {
              listener.EndContact(this);
          }
          if (!sensor && touching && listener) {
              listener.PreSolve(this, this.m_oldManifold);
          }
      }
      ComputeTOI(sweepA, sweepB) {
          const input = b2Contact.ComputeTOI_s_input;
          input.proxyA.SetShape(this.GetShapeA(), this.m_indexA);
          input.proxyB.SetShape(this.GetShapeB(), this.m_indexB);
          input.sweepA.Copy(sweepA);
          input.sweepB.Copy(sweepB);
          input.tMax = b2_linearSlop;
          const output = b2Contact.ComputeTOI_s_output;
          b2TimeOfImpact(output, input);
          return output.t;
      }
  }
  b2Contact.ComputeTOI_s_input = new b2TOIInput();
  b2Contact.ComputeTOI_s_output = new b2TOIOutput();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2ChainAndCircleContact extends b2Contact {
      static Create() {
          return new b2ChainAndCircleContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          const edge = b2ChainAndCircleContact.Evaluate_s_edge;
          this.GetShapeA().GetChildEdge(edge, this.m_indexA);
          b2CollideEdgeAndCircle(manifold, edge, xfA, this.GetShapeB(), xfB);
      }
  }
  b2ChainAndCircleContact.Evaluate_s_edge = new b2EdgeShape();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2ChainAndPolygonContact extends b2Contact {
      static Create() {
          return new b2ChainAndPolygonContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          const edge = b2ChainAndPolygonContact.Evaluate_s_edge;
          this.GetShapeA().GetChildEdge(edge, this.m_indexA);
          b2CollideEdgeAndPolygon(manifold, edge, xfA, this.GetShapeB(), xfB);
      }
  }
  b2ChainAndPolygonContact.Evaluate_s_edge = new b2EdgeShape();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2CircleContact extends b2Contact {
      static Create() {
          return new b2CircleContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          b2CollideCircles(manifold, this.GetShapeA(), xfA, this.GetShapeB(), xfB);
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2PolygonContact extends b2Contact {
      static Create() {
          return new b2PolygonContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          b2CollidePolygons(manifold, this.GetShapeA(), xfA, this.GetShapeB(), xfB);
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2PolygonAndCircleContact extends b2Contact {
      static Create() {
          return new b2PolygonAndCircleContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          b2CollidePolygonAndCircle(manifold, this.GetShapeA(), xfA, this.GetShapeB(), xfB);
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2EdgeAndCircleContact extends b2Contact {
      static Create() {
          return new b2EdgeAndCircleContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          b2CollideEdgeAndCircle(manifold, this.GetShapeA(), xfA, this.GetShapeB(), xfB);
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2EdgeAndPolygonContact extends b2Contact {
      static Create() {
          return new b2EdgeAndPolygonContact();
      }
      static Destroy(contact) {
      }
      Evaluate(manifold, xfA, xfB) {
          b2CollideEdgeAndPolygon(manifold, this.GetShapeA(), xfA, this.GetShapeB(), xfB);
      }
  }

  // DEBUG: import { b2Assert } from "../common/b2_settings.js";
  class b2ContactRegister {
      constructor() {
          this.pool = [];
          this.createFcn = null;
          this.destroyFcn = null;
          this.primary = false;
      }
  }
  class b2ContactFactory {
      constructor() {
          this.m_registers = [];
          this.InitializeRegisters();
      }
      AddType(createFcn, destroyFcn, typeA, typeB) {
          const pool = [];
          function poolCreateFcn() {
              return pool.pop() || createFcn();
          }
          function poolDestroyFcn(contact) {
              pool.push(contact);
          }
          this.m_registers[typeA][typeB].pool = pool;
          this.m_registers[typeA][typeB].createFcn = poolCreateFcn; // createFcn;
          this.m_registers[typeA][typeB].destroyFcn = poolDestroyFcn; // destroyFcn;
          this.m_registers[typeA][typeB].primary = true;
          if (typeA !== typeB) {
              this.m_registers[typeB][typeA].pool = pool;
              this.m_registers[typeB][typeA].createFcn = poolCreateFcn; // createFcn;
              this.m_registers[typeB][typeA].destroyFcn = poolDestroyFcn; // destroyFcn;
              this.m_registers[typeB][typeA].primary = false;
          }
      }
      InitializeRegisters() {
          for (let i = 0; i < exports.ShapeType.e_shapeTypeCount; i++) {
              this.m_registers[i] = [];
              for (let j = 0; j < exports.ShapeType.e_shapeTypeCount; j++) {
                  this.m_registers[i][j] = new b2ContactRegister();
              }
          }
          this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, exports.ShapeType.e_circleShape, exports.ShapeType.e_circleShape);
          this.AddType(b2PolygonAndCircleContact.Create, b2PolygonAndCircleContact.Destroy, exports.ShapeType.e_polygonShape, exports.ShapeType.e_circleShape);
          this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, exports.ShapeType.e_polygonShape, exports.ShapeType.e_polygonShape);
          this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, exports.ShapeType.e_edgeShape, exports.ShapeType.e_circleShape);
          this.AddType(b2EdgeAndPolygonContact.Create, b2EdgeAndPolygonContact.Destroy, exports.ShapeType.e_edgeShape, exports.ShapeType.e_polygonShape);
          this.AddType(b2ChainAndCircleContact.Create, b2ChainAndCircleContact.Destroy, exports.ShapeType.e_chainShape, exports.ShapeType.e_circleShape);
          this.AddType(b2ChainAndPolygonContact.Create, b2ChainAndPolygonContact.Destroy, exports.ShapeType.e_chainShape, exports.ShapeType.e_polygonShape);
      }
      Create(fixtureA, indexA, fixtureB, indexB) {
          const typeA = fixtureA.GetType();
          const typeB = fixtureB.GetType();
          // DEBUG: b2Assert(0 <= typeA && typeA < b2ShapeType.e_shapeTypeCount);
          // DEBUG: b2Assert(0 <= typeB && typeB < b2ShapeType.e_shapeTypeCount);
          const reg = this.m_registers[typeA][typeB];
          if (reg.createFcn) {
              const c = reg.createFcn();
              if (reg.primary) {
                  c.Reset(fixtureA, indexA, fixtureB, indexB);
              }
              else {
                  c.Reset(fixtureB, indexB, fixtureA, indexA);
              }
              return c;
          }
          else {
              return null;
          }
      }
      Destroy(contact) {
          const typeA = contact.m_fixtureA.GetType();
          const typeB = contact.m_fixtureB.GetType();
          // DEBUG: b2Assert(0 <= typeA && typeB < b2ShapeType.e_shapeTypeCount);
          // DEBUG: b2Assert(0 <= typeA && typeB < b2ShapeType.e_shapeTypeCount);
          const reg = this.m_registers[typeA][typeB];
          if (reg.destroyFcn) {
              reg.destroyFcn(contact);
          }
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  // #endif
  /// Joints and fixtures are destroyed when their associated
  /// body is destroyed. Implement this listener so that you
  /// may nullify references to these joints and shapes.
  class b2DestructionListener {
      /// Called when any joint is about to be destroyed due
      /// to the destruction of one of its attached bodies.
      SayGoodbyeJoint(joint) { }
      /// Called when any fixture is about to be destroyed due
      /// to the destruction of its parent body.
      SayGoodbyeFixture(fixture) { }
      // #if B2_ENABLE_PARTICLE
      /// Called when any particle group is about to be destroyed.
      SayGoodbyeParticleGroup(group) { }
      /// Called when a particle is about to be destroyed.
      /// The index can be used in conjunction with
      /// b2ParticleSystem::GetUserDataBuffer() or
      /// b2ParticleSystem::GetParticleHandleFromIndex() to determine which
      /// particle has been destroyed.
      SayGoodbyeParticle(system, index) { }
  }
  /// Implement this class to provide collision filtering. In other words, you can implement
  /// this class if you want finer control over contact creation.
  class b2ContactFilter {
      /// Return true if contact calculations should be performed between these two shapes.
      /// @warning for performance reasons this is only called when the AABBs begin to overlap.
      ShouldCollide(fixtureA, fixtureB) {
          const bodyA = fixtureA.GetBody();
          const bodyB = fixtureB.GetBody();
          // At least one body should be dynamic or kinematic.
          if (bodyB.GetType() === exports.BodyType.b2_staticBody && bodyA.GetType() === exports.BodyType.b2_staticBody) {
              return false;
          }
          // Does a joint prevent collision?
          if (!bodyB.ShouldCollideConnected(bodyA)) {
              return false;
          }
          const filter1 = fixtureA.GetFilterData();
          const filter2 = fixtureB.GetFilterData();
          if (filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0) {
              return (filter1.groupIndex > 0);
          }
          const collide = (((filter1.maskBits & filter2.categoryBits) !== 0) && ((filter1.categoryBits & filter2.maskBits) !== 0));
          return collide;
      }
      // #if B2_ENABLE_PARTICLE
      ShouldCollideFixtureParticle(fixture, system, index) {
          return true;
      }
      ShouldCollideParticleParticle(system, indexA, indexB) {
          return true;
      }
  }
  // #endif
  b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
  /// Contact impulses for reporting. Impulses are used instead of forces because
  /// sub-step forces may approach infinity for rigid body collisions. These
  /// match up one-to-one with the contact points in b2Manifold.
  class b2ContactImpulse {
      constructor() {
          this.normalImpulses = b2MakeNumberArray(b2_maxManifoldPoints);
          this.tangentImpulses = b2MakeNumberArray(b2_maxManifoldPoints);
          this.count = 0;
      }
  }
  /// Implement this class to get contact information. You can use these results for
  /// things like sounds and game logic. You can also get contact results by
  /// traversing the contact lists after the time step. However, you might miss
  /// some contacts because continuous physics leads to sub-stepping.
  /// Additionally you may receive multiple callbacks for the same contact in a
  /// single time step.
  /// You should strive to make your callbacks efficient because there may be
  /// many callbacks per time step.
  /// @warning You cannot create/destroy Box2D entities inside these callbacks.
  class b2ContactListener {
      /// Called when two fixtures begin to touch.
      BeginContact(contact) { }
      /// Called when two fixtures cease to touch.
      EndContact(contact) { }
      // #if B2_ENABLE_PARTICLE
      BeginContactFixtureParticle(system, contact) { }
      EndContactFixtureParticle(system, contact) { }
      BeginContactParticleParticle(system, contact) { }
      EndContactParticleParticle(system, contact) { }
      // #endif
      /// This is called after a contact is updated. This allows you to inspect a
      /// contact before it goes to the solver. If you are careful, you can modify the
      /// contact manifold (e.g. disable contact).
      /// A copy of the old manifold is provided so that you can detect changes.
      /// Note: this is called only for awake bodies.
      /// Note: this is called even when the number of contact points is zero.
      /// Note: this is not called for sensors.
      /// Note: if you set the number of contact points to zero, you will not
      /// get an EndContact callback. However, you may get a BeginContact callback
      /// the next step.
      PreSolve(contact, oldManifold) { }
      /// This lets you inspect a contact after the solver is finished. This is useful
      /// for inspecting impulses.
      /// Note: the contact manifold does not include time of impact impulses, which can be
      /// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
      /// in a separate data structure.
      /// Note: this is only called for contacts that are touching, solid, and awake.
      PostSolve(contact, impulse) { }
  }
  b2ContactListener.b2_defaultListener = new b2ContactListener();
  /// Callback class for AABB queries.
  /// See b2World::Query
  class b2QueryCallback {
      /// Called for each fixture found in the query AABB.
      /// @return false to terminate the query.
      ReportFixture(fixture) {
          return true;
      }
      // #if B2_ENABLE_PARTICLE
      ReportParticle(system, index) {
          return false;
      }
      ShouldQueryParticleSystem(system) {
          return true;
      }
  }
  /// Callback class for ray casts.
  /// See b2World::RayCast
  class b2RayCastCallback {
      /// Called for each fixture found in the query. You control how the ray cast
      /// proceeds by returning a float:
      /// return -1: ignore this fixture and continue
      /// return 0: terminate the ray cast
      /// return fraction: clip the ray to this point
      /// return 1: don't clip the ray and continue
      /// @param fixture the fixture hit by the ray
      /// @param point the point of initial intersection
      /// @param normal the normal vector at the point of intersection
      /// @return -1 to filter, 0 to terminate, fraction to clip the ray for
      /// closest hit, 1 to continue
      ReportFixture(fixture, point, normal, fraction) {
          return fraction;
      }
      // #if B2_ENABLE_PARTICLE
      ReportParticle(system, index, point, normal, fraction) {
          return 0;
      }
      ShouldQueryParticleSystem(system) {
          return true;
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  // Delegate of b2World.
  class b2ContactManager {
      constructor() {
          this.m_broadPhase = new b2BroadPhase();
          this.m_contactList = null;
          this.m_contactCount = 0;
          this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
          this.m_contactListener = b2ContactListener.b2_defaultListener;
          this.m_contactFactory = new b2ContactFactory();
      }
      // Broad-phase callback.
      AddPair(proxyA, proxyB) {
          // DEBUG: b2Assert(proxyA instanceof b2FixtureProxy);
          // DEBUG: b2Assert(proxyB instanceof b2FixtureProxy);
          let fixtureA = proxyA.fixture;
          let fixtureB = proxyB.fixture;
          let indexA = proxyA.childIndex;
          let indexB = proxyB.childIndex;
          let bodyA = fixtureA.GetBody();
          let bodyB = fixtureB.GetBody();
          // Are the fixtures on the same body?
          if (bodyA === bodyB) {
              return;
          }
          // TODO_ERIN use a hash table to remove a potential bottleneck when both
          // bodies have a lot of contacts.
          // Does a contact already exist?
          let edge = bodyB.GetContactList();
          while (edge) {
              if (edge.other === bodyA) {
                  const fA = edge.contact.GetFixtureA();
                  const fB = edge.contact.GetFixtureB();
                  const iA = edge.contact.GetChildIndexA();
                  const iB = edge.contact.GetChildIndexB();
                  if (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB) {
                      // A contact already exists.
                      return;
                  }
                  if (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA) {
                      // A contact already exists.
                      return;
                  }
              }
              edge = edge.next;
          }
          // Check user filtering.
          if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {
              return;
          }
          // Call the factory.
          const c = this.m_contactFactory.Create(fixtureA, indexA, fixtureB, indexB);
          if (c === null) {
              return;
          }
          // Contact creation may swap fixtures.
          fixtureA = c.GetFixtureA();
          fixtureB = c.GetFixtureB();
          indexA = c.GetChildIndexA();
          indexB = c.GetChildIndexB();
          bodyA = fixtureA.m_body;
          bodyB = fixtureB.m_body;
          // Insert into the world.
          c.m_prev = null;
          c.m_next = this.m_contactList;
          if (this.m_contactList !== null) {
              this.m_contactList.m_prev = c;
          }
          this.m_contactList = c;
          // Connect to island graph.
          // Connect to body A
          c.m_nodeA.other = bodyB;
          c.m_nodeA.prev = null;
          c.m_nodeA.next = bodyA.m_contactList;
          if (bodyA.m_contactList !== null) {
              bodyA.m_contactList.prev = c.m_nodeA;
          }
          bodyA.m_contactList = c.m_nodeA;
          // Connect to body B
          c.m_nodeB.other = bodyA;
          c.m_nodeB.prev = null;
          c.m_nodeB.next = bodyB.m_contactList;
          if (bodyB.m_contactList !== null) {
              bodyB.m_contactList.prev = c.m_nodeB;
          }
          bodyB.m_contactList = c.m_nodeB;
          ++this.m_contactCount;
      }
      FindNewContacts() {
          this.m_broadPhase.UpdatePairs((proxyA, proxyB) => {
              this.AddPair(proxyA, proxyB);
          });
      }
      Destroy(c) {
          const fixtureA = c.GetFixtureA();
          const fixtureB = c.GetFixtureB();
          const bodyA = fixtureA.GetBody();
          const bodyB = fixtureB.GetBody();
          if (this.m_contactListener && c.IsTouching()) {
              this.m_contactListener.EndContact(c);
          }
          // Remove from the world.
          if (c.m_prev) {
              c.m_prev.m_next = c.m_next;
          }
          if (c.m_next) {
              c.m_next.m_prev = c.m_prev;
          }
          if (c === this.m_contactList) {
              this.m_contactList = c.m_next;
          }
          // Remove from body 1
          if (c.m_nodeA.prev) {
              c.m_nodeA.prev.next = c.m_nodeA.next;
          }
          if (c.m_nodeA.next) {
              c.m_nodeA.next.prev = c.m_nodeA.prev;
          }
          if (c.m_nodeA === bodyA.m_contactList) {
              bodyA.m_contactList = c.m_nodeA.next;
          }
          // Remove from body 2
          if (c.m_nodeB.prev) {
              c.m_nodeB.prev.next = c.m_nodeB.next;
          }
          if (c.m_nodeB.next) {
              c.m_nodeB.next.prev = c.m_nodeB.prev;
          }
          if (c.m_nodeB === bodyB.m_contactList) {
              bodyB.m_contactList = c.m_nodeB.next;
          }
          // moved this from b2ContactFactory:Destroy
          if (c.m_manifold.pointCount > 0 &&
              !fixtureA.IsSensor() &&
              !fixtureB.IsSensor()) {
              fixtureA.GetBody().SetAwake(true);
              fixtureB.GetBody().SetAwake(true);
          }
          // Call the factory.
          this.m_contactFactory.Destroy(c);
          --this.m_contactCount;
      }
      // This is the top level collision call for the time step. Here
      // all the narrow phase collision is processed for the world
      // contact list.
      Collide() {
          // Update awake contacts.
          let c = this.m_contactList;
          while (c) {
              const fixtureA = c.GetFixtureA();
              const fixtureB = c.GetFixtureB();
              const indexA = c.GetChildIndexA();
              const indexB = c.GetChildIndexB();
              const bodyA = fixtureA.GetBody();
              const bodyB = fixtureB.GetBody();
              // Is this contact flagged for filtering?
              if (c.m_filterFlag) {
                  // Check user filtering.
                  if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {
                      const cNuke = c;
                      c = cNuke.m_next;
                      this.Destroy(cNuke);
                      continue;
                  }
                  // Clear the filtering flag.
                  c.m_filterFlag = false;
              }
              const activeA = bodyA.IsAwake() && bodyA.m_type !== exports.BodyType.b2_staticBody;
              const activeB = bodyB.IsAwake() && bodyB.m_type !== exports.BodyType.b2_staticBody;
              // At least one body must be awake and it must be dynamic or kinematic.
              if (!activeA && !activeB) {
                  c = c.m_next;
                  continue;
              }
              const treeNodeA = fixtureA.m_proxies[indexA].treeNode;
              const treeNodeB = fixtureB.m_proxies[indexB].treeNode;
              const overlap = b2TestOverlapAABB(treeNodeA.aabb, treeNodeB.aabb);
              // Here we destroy contacts that cease to overlap in the broad-phase.
              if (!overlap) {
                  const cNuke = c;
                  c = cNuke.m_next;
                  this.Destroy(cNuke);
                  continue;
              }
              // The contact persists.
              c.Update(this.m_contactListener);
              c = c.m_next;
          }
      }
  }

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Profiling data. Times are in milliseconds.
  class b2Profile {
      constructor() {
          this.step = 0;
          this.collide = 0;
          this.solve = 0;
          this.solveInit = 0;
          this.solveVelocity = 0;
          this.solvePosition = 0;
          this.broadphase = 0;
          this.solveTOI = 0;
      }
      Reset() {
          this.step = 0;
          this.collide = 0;
          this.solve = 0;
          this.solveInit = 0;
          this.solveVelocity = 0;
          this.solvePosition = 0;
          this.broadphase = 0;
          this.solveTOI = 0;
          return this;
      }
  }
  /// This is an internal structure.
  class b2TimeStep {
      constructor() {
          this.dt = 0; // time step
          this.inv_dt = 0; // inverse time step (0 if dt == 0).
          this.dtRatio = 0; // dt * inv_dt0
          this.velocityIterations = 0;
          this.positionIterations = 0;
          // #if B2_ENABLE_PARTICLE
          this.particleIterations = 0;
          // #endif
          this.warmStarting = false;
      }
      Copy(step) {
          this.dt = step.dt;
          this.inv_dt = step.inv_dt;
          this.dtRatio = step.dtRatio;
          this.positionIterations = step.positionIterations;
          this.velocityIterations = step.velocityIterations;
          // #if B2_ENABLE_PARTICLE
          this.particleIterations = step.particleIterations;
          // #endif
          this.warmStarting = step.warmStarting;
          return this;
      }
  }
  class b2Position {
      constructor() {
          this.c = new b2Vec2();
          this.a = 0;
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2Position());
      }
  }
  class b2Velocity {
      constructor() {
          this.v = new b2Vec2();
          this.w = 0;
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2Velocity());
      }
  }
  class b2SolverData {
      constructor() {
          this.step = new b2TimeStep();
      }
  }

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  // Solver debugging is normally disabled because the block solver sometimes has to deal with a poorly conditioned effective mass matrix.
  // #define B2_DEBUG_SOLVER 0
  exports.blockSolve = false;
  function get_g_blockSolve() { return exports.blockSolve; }
  function set_g_blockSolve(value) { exports.blockSolve = value; }
  class b2VelocityConstraintPoint {
      constructor() {
          this.rA = new b2Vec2();
          this.rB = new b2Vec2();
          this.normalImpulse = 0;
          this.tangentImpulse = 0;
          this.normalMass = 0;
          this.tangentMass = 0;
          this.velocityBias = 0;
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2VelocityConstraintPoint());
      }
  }
  class b2ContactVelocityConstraint {
      constructor() {
          this.points = b2VelocityConstraintPoint.MakeArray(b2_maxManifoldPoints);
          this.normal = new b2Vec2();
          this.tangent = new b2Vec2();
          this.normalMass = new b2Mat22();
          this.K = new b2Mat22();
          this.indexA = 0;
          this.indexB = 0;
          this.invMassA = 0;
          this.invMassB = 0;
          this.invIA = 0;
          this.invIB = 0;
          this.friction = 0;
          this.restitution = 0;
          this.threshold = 0;
          this.tangentSpeed = 0;
          this.pointCount = 0;
          this.contactIndex = 0;
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2ContactVelocityConstraint());
      }
  }
  class b2ContactPositionConstraint {
      constructor() {
          this.localPoints = b2Vec2.MakeArray(b2_maxManifoldPoints);
          this.localNormal = new b2Vec2();
          this.localPoint = new b2Vec2();
          this.indexA = 0;
          this.indexB = 0;
          this.invMassA = 0;
          this.invMassB = 0;
          this.localCenterA = new b2Vec2();
          this.localCenterB = new b2Vec2();
          this.invIA = 0;
          this.invIB = 0;
          this.type = exports.ManifoldType.e_unknown;
          this.radiusA = 0;
          this.radiusB = 0;
          this.pointCount = 0;
      }
      static MakeArray(length) {
          return b2MakeArray(length, (i) => new b2ContactPositionConstraint());
      }
  }
  class b2ContactSolverDef {
      constructor() {
          this.step = new b2TimeStep();
          this.count = 0;
      }
  }
  class b2PositionSolverManifold {
      constructor() {
          this.normal = new b2Vec2();
          this.point = new b2Vec2();
          this.separation = 0;
      }
      Initialize(pc, xfA, xfB, index) {
          const pointA = b2PositionSolverManifold.Initialize_s_pointA;
          const pointB = b2PositionSolverManifold.Initialize_s_pointB;
          const planePoint = b2PositionSolverManifold.Initialize_s_planePoint;
          const clipPoint = b2PositionSolverManifold.Initialize_s_clipPoint;
          // DEBUG: b2Assert(pc.pointCount > 0);
          switch (pc.type) {
              case exports.ManifoldType.e_circles: {
                  // b2Vec2 pointA = b2Mul(xfA, pc->localPoint);
                  b2Transform.MulXV(xfA, pc.localPoint, pointA);
                  // b2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);
                  b2Transform.MulXV(xfB, pc.localPoints[0], pointB);
                  // normal = pointB - pointA;
                  // normal.Normalize();
                  b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();
                  // point = 0.5f * (pointA + pointB);
                  b2Vec2.MidVV(pointA, pointB, this.point);
                  // separation = b2Dot(pointB - pointA, normal) - pc->radius;
                  this.separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
                  break;
              }
              case exports.ManifoldType.e_faceA: {
                  // normal = b2Mul(xfA.q, pc->localNormal);
                  b2Rot.MulRV(xfA.q, pc.localNormal, this.normal);
                  // b2Vec2 planePoint = b2Mul(xfA, pc->localPoint);
                  b2Transform.MulXV(xfA, pc.localPoint, planePoint);
                  // b2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);
                  b2Transform.MulXV(xfB, pc.localPoints[index], clipPoint);
                  // separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;
                  this.separation = b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
                  // point = clipPoint;
                  this.point.Copy(clipPoint);
                  break;
              }
              case exports.ManifoldType.e_faceB: {
                  // normal = b2Mul(xfB.q, pc->localNormal);
                  b2Rot.MulRV(xfB.q, pc.localNormal, this.normal);
                  // b2Vec2 planePoint = b2Mul(xfB, pc->localPoint);
                  b2Transform.MulXV(xfB, pc.localPoint, planePoint);
                  // b2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);
                  b2Transform.MulXV(xfA, pc.localPoints[index], clipPoint);
                  // separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;
                  this.separation = b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
                  // point = clipPoint;
                  this.point.Copy(clipPoint);
                  // Ensure normal points from A to B
                  // normal = -normal;
                  this.normal.SelfNeg();
                  break;
              }
          }
      }
  }
  b2PositionSolverManifold.Initialize_s_pointA = new b2Vec2();
  b2PositionSolverManifold.Initialize_s_pointB = new b2Vec2();
  b2PositionSolverManifold.Initialize_s_planePoint = new b2Vec2();
  b2PositionSolverManifold.Initialize_s_clipPoint = new b2Vec2();
  class b2ContactSolver {
      constructor() {
          this.m_step = new b2TimeStep();
          this.m_positionConstraints = b2ContactPositionConstraint.MakeArray(1024); // TODO: b2Settings
          this.m_velocityConstraints = b2ContactVelocityConstraint.MakeArray(1024); // TODO: b2Settings
          this.m_count = 0;
      }
      Initialize(def) {
          this.m_step.Copy(def.step);
          this.m_count = def.count;
          // TODO:
          if (this.m_positionConstraints.length < this.m_count) {
              const new_length = b2Max(this.m_positionConstraints.length * 2, this.m_count);
              while (this.m_positionConstraints.length < new_length) {
                  this.m_positionConstraints[this.m_positionConstraints.length] = new b2ContactPositionConstraint();
              }
          }
          // TODO:
          if (this.m_velocityConstraints.length < this.m_count) {
              const new_length = b2Max(this.m_velocityConstraints.length * 2, this.m_count);
              while (this.m_velocityConstraints.length < new_length) {
                  this.m_velocityConstraints[this.m_velocityConstraints.length] = new b2ContactVelocityConstraint();
              }
          }
          this.m_positions = def.positions;
          this.m_velocities = def.velocities;
          this.m_contacts = def.contacts;
          // Initialize position independent portions of the constraints.
          for (let i = 0; i < this.m_count; ++i) {
              const contact = this.m_contacts[i];
              const fixtureA = contact.m_fixtureA;
              const fixtureB = contact.m_fixtureB;
              const shapeA = fixtureA.GetShape();
              const shapeB = fixtureB.GetShape();
              const radiusA = shapeA.m_radius;
              const radiusB = shapeB.m_radius;
              const bodyA = fixtureA.GetBody();
              const bodyB = fixtureB.GetBody();
              const manifold = contact.GetManifold();
              const pointCount = manifold.pointCount;
              // DEBUG: b2Assert(pointCount > 0);
              const vc = this.m_velocityConstraints[i];
              vc.friction = contact.m_friction;
              vc.restitution = contact.m_restitution;
              vc.threshold = contact.m_restitutionThreshold;
              vc.tangentSpeed = contact.m_tangentSpeed;
              vc.indexA = bodyA.m_islandIndex;
              vc.indexB = bodyB.m_islandIndex;
              vc.invMassA = bodyA.m_invMass;
              vc.invMassB = bodyB.m_invMass;
              vc.invIA = bodyA.m_invI;
              vc.invIB = bodyB.m_invI;
              vc.contactIndex = i;
              vc.pointCount = pointCount;
              vc.K.SetZero();
              vc.normalMass.SetZero();
              const pc = this.m_positionConstraints[i];
              pc.indexA = bodyA.m_islandIndex;
              pc.indexB = bodyB.m_islandIndex;
              pc.invMassA = bodyA.m_invMass;
              pc.invMassB = bodyB.m_invMass;
              pc.localCenterA.Copy(bodyA.m_sweep.localCenter);
              pc.localCenterB.Copy(bodyB.m_sweep.localCenter);
              pc.invIA = bodyA.m_invI;
              pc.invIB = bodyB.m_invI;
              pc.localNormal.Copy(manifold.localNormal);
              pc.localPoint.Copy(manifold.localPoint);
              pc.pointCount = pointCount;
              pc.radiusA = radiusA;
              pc.radiusB = radiusB;
              pc.type = manifold.type;
              for (let j = 0; j < pointCount; ++j) {
                  const cp = manifold.points[j];
                  const vcp = vc.points[j];
                  if (this.m_step.warmStarting) {
                      vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;
                      vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;
                  }
                  else {
                      vcp.normalImpulse = 0;
                      vcp.tangentImpulse = 0;
                  }
                  vcp.rA.SetZero();
                  vcp.rB.SetZero();
                  vcp.normalMass = 0;
                  vcp.tangentMass = 0;
                  vcp.velocityBias = 0;
                  pc.localPoints[j].Copy(cp.localPoint);
              }
          }
          return this;
      }
      InitializeVelocityConstraints() {
          const xfA = b2ContactSolver.InitializeVelocityConstraints_s_xfA;
          const xfB = b2ContactSolver.InitializeVelocityConstraints_s_xfB;
          const worldManifold = b2ContactSolver.InitializeVelocityConstraints_s_worldManifold;
          const k_maxConditionNumber = 1000;
          for (let i = 0; i < this.m_count; ++i) {
              const vc = this.m_velocityConstraints[i];
              const pc = this.m_positionConstraints[i];
              const radiusA = pc.radiusA;
              const radiusB = pc.radiusB;
              const manifold = this.m_contacts[vc.contactIndex].GetManifold();
              const indexA = vc.indexA;
              const indexB = vc.indexB;
              const mA = vc.invMassA;
              const mB = vc.invMassB;
              const iA = vc.invIA;
              const iB = vc.invIB;
              const localCenterA = pc.localCenterA;
              const localCenterB = pc.localCenterB;
              const cA = this.m_positions[indexA].c;
              const aA = this.m_positions[indexA].a;
              const vA = this.m_velocities[indexA].v;
              const wA = this.m_velocities[indexA].w;
              const cB = this.m_positions[indexB].c;
              const aB = this.m_positions[indexB].a;
              const vB = this.m_velocities[indexB].v;
              const wB = this.m_velocities[indexB].w;
              // DEBUG: b2Assert(manifold.pointCount > 0);
              xfA.q.SetAngle(aA);
              xfB.q.SetAngle(aB);
              b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);
              b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);
              worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);
              vc.normal.Copy(worldManifold.normal);
              b2Vec2.CrossVOne(vc.normal, vc.tangent); // compute from normal
              const pointCount = vc.pointCount;
              for (let j = 0; j < pointCount; ++j) {
                  const vcp = vc.points[j];
                  // vcp->rA = worldManifold.points[j] - cA;
                  b2Vec2.SubVV(worldManifold.points[j], cA, vcp.rA);
                  // vcp->rB = worldManifold.points[j] - cB;
                  b2Vec2.SubVV(worldManifold.points[j], cB, vcp.rB);
                  const rnA = b2Vec2.CrossVV(vcp.rA, vc.normal);
                  const rnB = b2Vec2.CrossVV(vcp.rB, vc.normal);
                  const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                  vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
                  // b2Vec2 tangent = b2Cross(vc->normal, 1.0f);
                  const tangent = vc.tangent; // precomputed from normal
                  const rtA = b2Vec2.CrossVV(vcp.rA, tangent);
                  const rtB = b2Vec2.CrossVV(vcp.rB, tangent);
                  const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                  vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
                  // Setup a velocity bias for restitution.
                  vcp.velocityBias = 0;
                  // float32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));
                  const vRel = b2Vec2.DotVV(vc.normal, b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1), b2Vec2.s_t0));
                  if (vRel < -vc.threshold) {
                      vcp.velocityBias += (-vc.restitution * vRel);
                  }
              }
              // If we have two points, then prepare the block solver.
              if (vc.pointCount === 2 && exports.blockSolve) {
                  const vcp1 = vc.points[0];
                  const vcp2 = vc.points[1];
                  const rn1A = b2Vec2.CrossVV(vcp1.rA, vc.normal);
                  const rn1B = b2Vec2.CrossVV(vcp1.rB, vc.normal);
                  const rn2A = b2Vec2.CrossVV(vcp2.rA, vc.normal);
                  const rn2B = b2Vec2.CrossVV(vcp2.rB, vc.normal);
                  const k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                  const k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                  const k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                  // Ensure a reasonable condition number.
                  // float32 k_maxConditionNumber = 1000.0f;
                  if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                      // K is safe to invert.
                      vc.K.ex.Set(k11, k12);
                      vc.K.ey.Set(k12, k22);
                      vc.K.GetInverse(vc.normalMass);
                  }
                  else {
                      // The constraints are redundant, just use one.
                      // TODO_ERIN use deepest?
                      vc.pointCount = 1;
                  }
              }
          }
      }
      WarmStart() {
          const P = b2ContactSolver.WarmStart_s_P;
          // Warm start.
          for (let i = 0; i < this.m_count; ++i) {
              const vc = this.m_velocityConstraints[i];
              const indexA = vc.indexA;
              const indexB = vc.indexB;
              const mA = vc.invMassA;
              const iA = vc.invIA;
              const mB = vc.invMassB;
              const iB = vc.invIB;
              const pointCount = vc.pointCount;
              const vA = this.m_velocities[indexA].v;
              let wA = this.m_velocities[indexA].w;
              const vB = this.m_velocities[indexB].v;
              let wB = this.m_velocities[indexB].w;
              const normal = vc.normal;
              // b2Vec2 tangent = b2Cross(normal, 1.0f);
              const tangent = vc.tangent; // precomputed from normal
              for (let j = 0; j < pointCount; ++j) {
                  const vcp = vc.points[j];
                  // b2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;
                  b2Vec2.AddVV(b2Vec2.MulSV(vcp.normalImpulse, normal, b2Vec2.s_t0), b2Vec2.MulSV(vcp.tangentImpulse, tangent, b2Vec2.s_t1), P);
                  // wA -= iA * b2Cross(vcp->rA, P);
                  wA -= iA * b2Vec2.CrossVV(vcp.rA, P);
                  // vA -= mA * P;
                  vA.SelfMulSub(mA, P);
                  // wB += iB * b2Cross(vcp->rB, P);
                  wB += iB * b2Vec2.CrossVV(vcp.rB, P);
                  // vB += mB * P;
                  vB.SelfMulAdd(mB, P);
              }
              // this.m_velocities[indexA].v = vA;
              this.m_velocities[indexA].w = wA;
              // this.m_velocities[indexB].v = vB;
              this.m_velocities[indexB].w = wB;
          }
      }
      SolveVelocityConstraints() {
          const dv = b2ContactSolver.SolveVelocityConstraints_s_dv;
          const dv1 = b2ContactSolver.SolveVelocityConstraints_s_dv1;
          const dv2 = b2ContactSolver.SolveVelocityConstraints_s_dv2;
          const P = b2ContactSolver.SolveVelocityConstraints_s_P;
          const a = b2ContactSolver.SolveVelocityConstraints_s_a;
          const b = b2ContactSolver.SolveVelocityConstraints_s_b;
          const x = b2ContactSolver.SolveVelocityConstraints_s_x;
          const d = b2ContactSolver.SolveVelocityConstraints_s_d;
          const P1 = b2ContactSolver.SolveVelocityConstraints_s_P1;
          const P2 = b2ContactSolver.SolveVelocityConstraints_s_P2;
          const P1P2 = b2ContactSolver.SolveVelocityConstraints_s_P1P2;
          for (let i = 0; i < this.m_count; ++i) {
              const vc = this.m_velocityConstraints[i];
              const indexA = vc.indexA;
              const indexB = vc.indexB;
              const mA = vc.invMassA;
              const iA = vc.invIA;
              const mB = vc.invMassB;
              const iB = vc.invIB;
              const pointCount = vc.pointCount;
              const vA = this.m_velocities[indexA].v;
              let wA = this.m_velocities[indexA].w;
              const vB = this.m_velocities[indexB].v;
              let wB = this.m_velocities[indexB].w;
              // b2Vec2 normal = vc->normal;
              const normal = vc.normal;
              // b2Vec2 tangent = b2Cross(normal, 1.0f);
              const tangent = vc.tangent; // precomputed from normal
              const friction = vc.friction;
              // DEBUG: b2Assert(pointCount === 1 || pointCount === 2);
              // Solve tangent constraints first because non-penetration is more important
              // than friction.
              for (let j = 0; j < pointCount; ++j) {
                  const vcp = vc.points[j];
                  // Relative velocity at contact
                  // b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
                  b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1), dv);
                  // Compute tangent force
                  // float32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;
                  const vt = b2Vec2.DotVV(dv, tangent) - vc.tangentSpeed;
                  let lambda = vcp.tangentMass * (-vt);
                  // b2Clamp the accumulated force
                  const maxFriction = friction * vcp.normalImpulse;
                  const newImpulse = b2Clamp(vcp.tangentImpulse + lambda, (-maxFriction), maxFriction);
                  lambda = newImpulse - vcp.tangentImpulse;
                  vcp.tangentImpulse = newImpulse;
                  // Apply contact impulse
                  // b2Vec2 P = lambda * tangent;
                  b2Vec2.MulSV(lambda, tangent, P);
                  // vA -= mA * P;
                  vA.SelfMulSub(mA, P);
                  // wA -= iA * b2Cross(vcp->rA, P);
                  wA -= iA * b2Vec2.CrossVV(vcp.rA, P);
                  // vB += mB * P;
                  vB.SelfMulAdd(mB, P);
                  // wB += iB * b2Cross(vcp->rB, P);
                  wB += iB * b2Vec2.CrossVV(vcp.rB, P);
              }
              // Solve normal constraints
              if (vc.pointCount === 1 || exports.blockSolve === false) {
                  for (let j = 0; j < pointCount; ++j) {
                      const vcp = vc.points[j];
                      // Relative velocity at contact
                      // b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
                      b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1), dv);
                      // Compute normal impulse
                      // float32 vn = b2Dot(dv, normal);
                      const vn = b2Vec2.DotVV(dv, normal);
                      let lambda = (-vcp.normalMass * (vn - vcp.velocityBias));
                      // b2Clamp the accumulated impulse
                      // float32 newImpulse = b2Max(vcp->normalImpulse + lambda, 0.0f);
                      const newImpulse = b2Max(vcp.normalImpulse + lambda, 0);
                      lambda = newImpulse - vcp.normalImpulse;
                      vcp.normalImpulse = newImpulse;
                      // Apply contact impulse
                      // b2Vec2 P = lambda * normal;
                      b2Vec2.MulSV(lambda, normal, P);
                      // vA -= mA * P;
                      vA.SelfMulSub(mA, P);
                      // wA -= iA * b2Cross(vcp->rA, P);
                      wA -= iA * b2Vec2.CrossVV(vcp.rA, P);
                      // vB += mB * P;
                      vB.SelfMulAdd(mB, P);
                      // wB += iB * b2Cross(vcp->rB, P);
                      wB += iB * b2Vec2.CrossVV(vcp.rB, P);
                  }
              }
              else {
                  // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).
                  // Build the mini LCP for this contact patch
                  //
                  // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2
                  //
                  // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
                  // b = vn0 - velocityBias
                  //
                  // The system is solved using the "Total enumeration method" (s. Murty). The complementary constraint vn_i * x_i
                  // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases
                  // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be tested. The first valid
                  // solution that satisfies the problem is chosen.
                  //
                  // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires
                  // that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).
                  //
                  // Substitute:
                  //
                  // x = a + d
                  //
                  // a := old total impulse
                  // x := new total impulse
                  // d := incremental impulse
                  //
                  // For the current iteration we extend the formula for the incremental impulse
                  // to compute the new total impulse:
                  //
                  // vn = A * d + b
                  //    = A * (x - a) + b
                  //    = A * x + b - A * a
                  //    = A * x + b'
                  // b' = b - A * a;
                  const cp1 = vc.points[0];
                  const cp2 = vc.points[1];
                  // b2Vec2 a(cp1->normalImpulse, cp2->normalImpulse);
                  a.Set(cp1.normalImpulse, cp2.normalImpulse);
                  // DEBUG: b2Assert(a.x >= 0 && a.y >= 0);
                  // Relative velocity at contact
                  // b2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
                  b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, cp1.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, cp1.rA, b2Vec2.s_t1), dv1);
                  // b2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
                  b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, cp2.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, cp2.rA, b2Vec2.s_t1), dv2);
                  // Compute normal velocity
                  // float32 vn1 = b2Dot(dv1, normal);
                  let vn1 = b2Vec2.DotVV(dv1, normal);
                  // float32 vn2 = b2Dot(dv2, normal);
                  let vn2 = b2Vec2.DotVV(dv2, normal);
                  // b2Vec2 b;
                  b.x = vn1 - cp1.velocityBias;
                  b.y = vn2 - cp2.velocityBias;
                  // Compute b'
                  // b -= b2Mul(vc->K, a);
                  b.SelfSub(b2Mat22.MulMV(vc.K, a, b2Vec2.s_t0));
                  /*
                  #if B2_DEBUG_SOLVER === 1
                  const k_errorTol: number = 0.001;
                  #endif
                  */
                  for (;;) {
                      //
                      // Case 1: vn = 0
                      //
                      // 0 = A * x + b'
                      //
                      // Solve for x:
                      //
                      // x = - inv(A) * b'
                      //
                      // b2Vec2 x = - b2Mul(vc->normalMass, b);
                      b2Mat22.MulMV(vc.normalMass, b, x).SelfNeg();
                      if (x.x >= 0 && x.y >= 0) {
                          // Get the incremental impulse
                          // b2Vec2 d = x - a;
                          b2Vec2.SubVV(x, a, d);
                          // Apply incremental impulse
                          // b2Vec2 P1 = d.x * normal;
                          b2Vec2.MulSV(d.x, normal, P1);
                          // b2Vec2 P2 = d.y * normal;
                          b2Vec2.MulSV(d.y, normal, P2);
                          b2Vec2.AddVV(P1, P2, P1P2);
                          // vA -= mA * (P1 + P2);
                          vA.SelfMulSub(mA, P1P2);
                          // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
                          wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                          // vB += mB * (P1 + P2);
                          vB.SelfMulAdd(mB, P1P2);
                          // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
                          wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                          // Accumulate
                          cp1.normalImpulse = x.x;
                          cp2.normalImpulse = x.y;
                          /*
                          #if B2_DEBUG_SOLVER === 1
                          // Postconditions
                          dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
                          dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
              
                          // Compute normal velocity
                          vn1 = b2Dot(dv1, normal);
                          vn2 = b2Dot(dv2, normal);
              
                          b2Assert(b2Abs(vn1 - cp1->velocityBias) < k_errorTol);
                          b2Assert(b2Abs(vn2 - cp2->velocityBias) < k_errorTol);
                          #endif
                          */
                          break;
                      }
                      //
                      // Case 2: vn1 = 0 and x2 = 0
                      //
                      //   0 = a11 * x1 + a12 * 0 + b1'
                      // vn2 = a21 * x1 + a22 * 0 + b2'
                      //
                      x.x = (-cp1.normalMass * b.x);
                      x.y = 0;
                      vn1 = 0;
                      vn2 = vc.K.ex.y * x.x + b.y;
                      if (x.x >= 0 && vn2 >= 0) {
                          // Get the incremental impulse
                          // b2Vec2 d = x - a;
                          b2Vec2.SubVV(x, a, d);
                          // Apply incremental impulse
                          // b2Vec2 P1 = d.x * normal;
                          b2Vec2.MulSV(d.x, normal, P1);
                          // b2Vec2 P2 = d.y * normal;
                          b2Vec2.MulSV(d.y, normal, P2);
                          b2Vec2.AddVV(P1, P2, P1P2);
                          // vA -= mA * (P1 + P2);
                          vA.SelfMulSub(mA, P1P2);
                          // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
                          wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                          // vB += mB * (P1 + P2);
                          vB.SelfMulAdd(mB, P1P2);
                          // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
                          wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                          // Accumulate
                          cp1.normalImpulse = x.x;
                          cp2.normalImpulse = x.y;
                          /*
                          #if B2_DEBUG_SOLVER === 1
                          // Postconditions
                          dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
              
                          // Compute normal velocity
                          vn1 = b2Dot(dv1, normal);
              
                          b2Assert(b2Abs(vn1 - cp1->velocityBias) < k_errorTol);
                          #endif
                          */
                          break;
                      }
                      //
                      // Case 3: vn2 = 0 and x1 = 0
                      //
                      // vn1 = a11 * 0 + a12 * x2 + b1'
                      //   0 = a21 * 0 + a22 * x2 + b2'
                      //
                      x.x = 0;
                      x.y = (-cp2.normalMass * b.y);
                      vn1 = vc.K.ey.x * x.y + b.x;
                      vn2 = 0;
                      if (x.y >= 0 && vn1 >= 0) {
                          // Resubstitute for the incremental impulse
                          // b2Vec2 d = x - a;
                          b2Vec2.SubVV(x, a, d);
                          // Apply incremental impulse
                          // b2Vec2 P1 = d.x * normal;
                          b2Vec2.MulSV(d.x, normal, P1);
                          // b2Vec2 P2 = d.y * normal;
                          b2Vec2.MulSV(d.y, normal, P2);
                          b2Vec2.AddVV(P1, P2, P1P2);
                          // vA -= mA * (P1 + P2);
                          vA.SelfMulSub(mA, P1P2);
                          // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
                          wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                          // vB += mB * (P1 + P2);
                          vB.SelfMulAdd(mB, P1P2);
                          // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
                          wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                          // Accumulate
                          cp1.normalImpulse = x.x;
                          cp2.normalImpulse = x.y;
                          /*
                          #if B2_DEBUG_SOLVER === 1
                          // Postconditions
                          dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
              
                          // Compute normal velocity
                          vn2 = b2Dot(dv2, normal);
              
                          b2Assert(b2Abs(vn2 - cp2->velocityBias) < k_errorTol);
                          #endif
                          */
                          break;
                      }
                      //
                      // Case 4: x1 = 0 and x2 = 0
                      //
                      // vn1 = b1
                      // vn2 = b2;
                      x.x = 0;
                      x.y = 0;
                      vn1 = b.x;
                      vn2 = b.y;
                      if (vn1 >= 0 && vn2 >= 0) {
                          // Resubstitute for the incremental impulse
                          // b2Vec2 d = x - a;
                          b2Vec2.SubVV(x, a, d);
                          // Apply incremental impulse
                          // b2Vec2 P1 = d.x * normal;
                          b2Vec2.MulSV(d.x, normal, P1);
                          // b2Vec2 P2 = d.y * normal;
                          b2Vec2.MulSV(d.y, normal, P2);
                          b2Vec2.AddVV(P1, P2, P1P2);
                          // vA -= mA * (P1 + P2);
                          vA.SelfMulSub(mA, P1P2);
                          // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
                          wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                          // vB += mB * (P1 + P2);
                          vB.SelfMulAdd(mB, P1P2);
                          // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
                          wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                          // Accumulate
                          cp1.normalImpulse = x.x;
                          cp2.normalImpulse = x.y;
                          break;
                      }
                      // No solution, give up. This is hit sometimes, but it doesn't seem to matter.
                      break;
                  }
              }
              // this.m_velocities[indexA].v = vA;
              this.m_velocities[indexA].w = wA;
              // this.m_velocities[indexB].v = vB;
              this.m_velocities[indexB].w = wB;
          }
      }
      StoreImpulses() {
          for (let i = 0; i < this.m_count; ++i) {
              const vc = this.m_velocityConstraints[i];
              const manifold = this.m_contacts[vc.contactIndex].GetManifold();
              for (let j = 0; j < vc.pointCount; ++j) {
                  manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
                  manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
              }
          }
      }
      SolvePositionConstraints() {
          const xfA = b2ContactSolver.SolvePositionConstraints_s_xfA;
          const xfB = b2ContactSolver.SolvePositionConstraints_s_xfB;
          const psm = b2ContactSolver.SolvePositionConstraints_s_psm;
          const rA = b2ContactSolver.SolvePositionConstraints_s_rA;
          const rB = b2ContactSolver.SolvePositionConstraints_s_rB;
          const P = b2ContactSolver.SolvePositionConstraints_s_P;
          let minSeparation = 0;
          for (let i = 0; i < this.m_count; ++i) {
              const pc = this.m_positionConstraints[i];
              const indexA = pc.indexA;
              const indexB = pc.indexB;
              const localCenterA = pc.localCenterA;
              const mA = pc.invMassA;
              const iA = pc.invIA;
              const localCenterB = pc.localCenterB;
              const mB = pc.invMassB;
              const iB = pc.invIB;
              const pointCount = pc.pointCount;
              const cA = this.m_positions[indexA].c;
              let aA = this.m_positions[indexA].a;
              const cB = this.m_positions[indexB].c;
              let aB = this.m_positions[indexB].a;
              // Solve normal constraints
              for (let j = 0; j < pointCount; ++j) {
                  xfA.q.SetAngle(aA);
                  xfB.q.SetAngle(aB);
                  b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);
                  b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);
                  psm.Initialize(pc, xfA, xfB, j);
                  const normal = psm.normal;
                  const point = psm.point;
                  const separation = psm.separation;
                  // b2Vec2 rA = point - cA;
                  b2Vec2.SubVV(point, cA, rA);
                  // b2Vec2 rB = point - cB;
                  b2Vec2.SubVV(point, cB, rB);
                  // Track max constraint error.
                  minSeparation = b2Min(minSeparation, separation);
                  // Prevent large corrections and allow slop.
                  const C = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), (-b2_maxLinearCorrection), 0);
                  // Compute the effective mass.
                  // float32 rnA = b2Cross(rA, normal);
                  const rnA = b2Vec2.CrossVV(rA, normal);
                  // float32 rnB = b2Cross(rB, normal);
                  const rnB = b2Vec2.CrossVV(rB, normal);
                  // float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                  const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                  // Compute normal impulse
                  const impulse = K > 0 ? -C / K : 0;
                  // b2Vec2 P = impulse * normal;
                  b2Vec2.MulSV(impulse, normal, P);
                  // cA -= mA * P;
                  cA.SelfMulSub(mA, P);
                  // aA -= iA * b2Cross(rA, P);
                  aA -= iA * b2Vec2.CrossVV(rA, P);
                  // cB += mB * P;
                  cB.SelfMulAdd(mB, P);
                  // aB += iB * b2Cross(rB, P);
                  aB += iB * b2Vec2.CrossVV(rB, P);
              }
              // this.m_positions[indexA].c = cA;
              this.m_positions[indexA].a = aA;
              // this.m_positions[indexB].c = cB;
              this.m_positions[indexB].a = aB;
          }
          // We can't expect minSpeparation >= -b2_linearSlop because we don't
          // push the separation above -b2_linearSlop.
          return minSeparation > (-3 * b2_linearSlop);
      }
      SolveTOIPositionConstraints(toiIndexA, toiIndexB) {
          const xfA = b2ContactSolver.SolveTOIPositionConstraints_s_xfA;
          const xfB = b2ContactSolver.SolveTOIPositionConstraints_s_xfB;
          const psm = b2ContactSolver.SolveTOIPositionConstraints_s_psm;
          const rA = b2ContactSolver.SolveTOIPositionConstraints_s_rA;
          const rB = b2ContactSolver.SolveTOIPositionConstraints_s_rB;
          const P = b2ContactSolver.SolveTOIPositionConstraints_s_P;
          let minSeparation = 0;
          for (let i = 0; i < this.m_count; ++i) {
              const pc = this.m_positionConstraints[i];
              const indexA = pc.indexA;
              const indexB = pc.indexB;
              const localCenterA = pc.localCenterA;
              const localCenterB = pc.localCenterB;
              const pointCount = pc.pointCount;
              let mA = 0;
              let iA = 0;
              if (indexA === toiIndexA || indexA === toiIndexB) {
                  mA = pc.invMassA;
                  iA = pc.invIA;
              }
              let mB = 0;
              let iB = 0;
              if (indexB === toiIndexA || indexB === toiIndexB) {
                  mB = pc.invMassB;
                  iB = pc.invIB;
              }
              const cA = this.m_positions[indexA].c;
              let aA = this.m_positions[indexA].a;
              const cB = this.m_positions[indexB].c;
              let aB = this.m_positions[indexB].a;
              // Solve normal constraints
              for (let j = 0; j < pointCount; ++j) {
                  xfA.q.SetAngle(aA);
                  xfB.q.SetAngle(aB);
                  b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);
                  b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);
                  psm.Initialize(pc, xfA, xfB, j);
                  const normal = psm.normal;
                  const point = psm.point;
                  const separation = psm.separation;
                  // b2Vec2 rA = point - cA;
                  b2Vec2.SubVV(point, cA, rA);
                  // b2Vec2 rB = point - cB;
                  b2Vec2.SubVV(point, cB, rB);
                  // Track max constraint error.
                  minSeparation = b2Min(minSeparation, separation);
                  // Prevent large corrections and allow slop.
                  const C = b2Clamp(b2_toiBaumgarte * (separation + b2_linearSlop), (-b2_maxLinearCorrection), 0);
                  // Compute the effective mass.
                  // float32 rnA = b2Cross(rA, normal);
                  const rnA = b2Vec2.CrossVV(rA, normal);
                  // float32 rnB = b2Cross(rB, normal);
                  const rnB = b2Vec2.CrossVV(rB, normal);
                  // float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                  const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                  // Compute normal impulse
                  const impulse = K > 0 ? -C / K : 0;
                  // b2Vec2 P = impulse * normal;
                  b2Vec2.MulSV(impulse, normal, P);
                  // cA -= mA * P;
                  cA.SelfMulSub(mA, P);
                  // aA -= iA * b2Cross(rA, P);
                  aA -= iA * b2Vec2.CrossVV(rA, P);
                  // cB += mB * P;
                  cB.SelfMulAdd(mB, P);
                  // aB += iB * b2Cross(rB, P);
                  aB += iB * b2Vec2.CrossVV(rB, P);
              }
              // this.m_positions[indexA].c = cA;
              this.m_positions[indexA].a = aA;
              // this.m_positions[indexB].c = cB;
              this.m_positions[indexB].a = aB;
          }
          // We can't expect minSpeparation >= -b2_linearSlop because we don't
          // push the separation above -b2_linearSlop.
          return minSeparation >= -1.5 * b2_linearSlop;
      }
  }
  b2ContactSolver.InitializeVelocityConstraints_s_xfA = new b2Transform();
  b2ContactSolver.InitializeVelocityConstraints_s_xfB = new b2Transform();
  b2ContactSolver.InitializeVelocityConstraints_s_worldManifold = new b2WorldManifold();
  b2ContactSolver.WarmStart_s_P = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_dv = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_dv1 = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_dv2 = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_P = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_a = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_b = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_x = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_d = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_P1 = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_P2 = new b2Vec2();
  b2ContactSolver.SolveVelocityConstraints_s_P1P2 = new b2Vec2();
  b2ContactSolver.SolvePositionConstraints_s_xfA = new b2Transform();
  b2ContactSolver.SolvePositionConstraints_s_xfB = new b2Transform();
  b2ContactSolver.SolvePositionConstraints_s_psm = new b2PositionSolverManifold();
  b2ContactSolver.SolvePositionConstraints_s_rA = new b2Vec2();
  b2ContactSolver.SolvePositionConstraints_s_rB = new b2Vec2();
  b2ContactSolver.SolvePositionConstraints_s_P = new b2Vec2();
  b2ContactSolver.SolveTOIPositionConstraints_s_xfA = new b2Transform();
  b2ContactSolver.SolveTOIPositionConstraints_s_xfB = new b2Transform();
  b2ContactSolver.SolveTOIPositionConstraints_s_psm = new b2PositionSolverManifold();
  b2ContactSolver.SolveTOIPositionConstraints_s_rA = new b2Vec2();
  b2ContactSolver.SolveTOIPositionConstraints_s_rB = new b2Vec2();
  b2ContactSolver.SolveTOIPositionConstraints_s_P = new b2Vec2();

  /*
  * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Friction joint definition.
  class b2FrictionJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_frictionJoint);
          this.localAnchorA = new b2Vec2();
          this.localAnchorB = new b2Vec2();
          this.maxForce = 0;
          this.maxTorque = 0;
      }
      Initialize(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
      }
  }
  class b2FrictionJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          // Solver shared
          this.m_linearImpulse = new b2Vec2();
          this.m_angularImpulse = 0;
          this.m_maxForce = 0;
          this.m_maxTorque = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_linearMass = new b2Mat22();
          this.m_angularMass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_K = new b2Mat22();
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          this.m_linearImpulse.SetZero();
          this.m_maxForce = b2Maybe(def.maxForce, 0);
          this.m_maxTorque = b2Maybe(def.maxTorque, 0);
          this.m_linearMass.SetZero();
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          // const cA: b2Vec2 = data.positions[this.m_indexA].c;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          // const cB: b2Vec2 = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // Compute the effective mass matrix.
          // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // J = [-I -r1_skew I r2_skew]
          //     [ 0       -1 0       1]
          // r_skew = [-ry; rx]
          // Matlab
          // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
          //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
          //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const K = this.m_K; // new b2Mat22();
          K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
          K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
          K.GetInverse(this.m_linearMass);
          this.m_angularMass = iA + iB;
          if (this.m_angularMass > 0) {
              this.m_angularMass = 1 / this.m_angularMass;
          }
          if (data.step.warmStarting) {
              // Scale impulses to support a variable time step.
              // m_linearImpulse *= data.step.dtRatio;
              this.m_linearImpulse.SelfMul(data.step.dtRatio);
              this.m_angularImpulse *= data.step.dtRatio;
              // const P: b2Vec2(m_linearImpulse.x, m_linearImpulse.y);
              const P = this.m_linearImpulse;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              // wA -= iA * (b2Cross(m_rA, P) + m_angularImpulse);
              wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + this.m_angularImpulse);
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              // wB += iB * (b2Cross(m_rB, P) + m_angularImpulse);
              wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + this.m_angularImpulse);
          }
          else {
              this.m_linearImpulse.SetZero();
              this.m_angularImpulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const h = data.step.dt;
          // Solve angular friction
          {
              const Cdot = wB - wA;
              let impulse = (-this.m_angularMass * Cdot);
              const oldImpulse = this.m_angularImpulse;
              const maxImpulse = h * this.m_maxTorque;
              this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
              impulse = this.m_angularImpulse - oldImpulse;
              wA -= iA * impulse;
              wB += iB * impulse;
          }
          // Solve linear friction
          {
              // b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
              const Cdot_v2 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2FrictionJoint.SolveVelocityConstraints_s_Cdot_v2);
              // b2Vec2 impulse = -b2Mul(m_linearMass, Cdot);
              const impulseV = b2Mat22.MulMV(this.m_linearMass, Cdot_v2, b2FrictionJoint.SolveVelocityConstraints_s_impulseV).SelfNeg();
              // b2Vec2 oldImpulse = m_linearImpulse;
              const oldImpulseV = b2FrictionJoint.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);
              // m_linearImpulse += impulse;
              this.m_linearImpulse.SelfAdd(impulseV);
              const maxImpulse = h * this.m_maxForce;
              if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                  this.m_linearImpulse.Normalize();
                  this.m_linearImpulse.SelfMul(maxImpulse);
              }
              // impulse = m_linearImpulse - oldImpulse;
              b2Vec2.SubVV(this.m_linearImpulse, oldImpulseV, impulseV);
              // vA -= mA * impulse;
              vA.SelfMulSub(mA, impulseV);
              // wA -= iA * b2Cross(m_rA, impulse);
              wA -= iA * b2Vec2.CrossVV(this.m_rA, impulseV);
              // vB += mB * impulse;
              vB.SelfMulAdd(mB, impulseV);
              // wB += iB * b2Cross(m_rB, impulse);
              wB += iB * b2Vec2.CrossVV(this.m_rB, impulseV);
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          return true;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          out.x = inv_dt * this.m_linearImpulse.x;
          out.y = inv_dt * this.m_linearImpulse.y;
          return out;
      }
      GetReactionTorque(inv_dt) {
          return inv_dt * this.m_angularImpulse;
      }
      GetLocalAnchorA() { return this.m_localAnchorA; }
      GetLocalAnchorB() { return this.m_localAnchorB; }
      SetMaxForce(force) {
          this.m_maxForce = force;
      }
      GetMaxForce() {
          return this.m_maxForce;
      }
      SetMaxTorque(torque) {
          this.m_maxTorque = torque;
      }
      GetMaxTorque() {
          return this.m_maxTorque;
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.maxForce = %.15f;\n", this.m_maxForce);
          log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
  }
  b2FrictionJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();
  b2FrictionJoint.SolveVelocityConstraints_s_impulseV = new b2Vec2();
  b2FrictionJoint.SolveVelocityConstraints_s_oldImpulseV = new b2Vec2();

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Gear joint definition. This definition requires two existing
  /// revolute or prismatic joints (any combination will work).
  class b2GearJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_gearJoint);
          this.ratio = 1;
      }
  }
  class b2GearJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_typeA = exports.JointType.e_unknownJoint;
          this.m_typeB = exports.JointType.e_unknownJoint;
          // Solver shared
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_localAnchorC = new b2Vec2();
          this.m_localAnchorD = new b2Vec2();
          this.m_localAxisC = new b2Vec2();
          this.m_localAxisD = new b2Vec2();
          this.m_referenceAngleA = 0;
          this.m_referenceAngleB = 0;
          this.m_constant = 0;
          this.m_ratio = 0;
          this.m_impulse = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_indexC = 0;
          this.m_indexD = 0;
          this.m_lcA = new b2Vec2();
          this.m_lcB = new b2Vec2();
          this.m_lcC = new b2Vec2();
          this.m_lcD = new b2Vec2();
          this.m_mA = 0;
          this.m_mB = 0;
          this.m_mC = 0;
          this.m_mD = 0;
          this.m_iA = 0;
          this.m_iB = 0;
          this.m_iC = 0;
          this.m_iD = 0;
          this.m_JvAC = new b2Vec2();
          this.m_JvBD = new b2Vec2();
          this.m_JwA = 0;
          this.m_JwB = 0;
          this.m_JwC = 0;
          this.m_JwD = 0;
          this.m_mass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_qC = new b2Rot();
          this.m_qD = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_lalcC = new b2Vec2();
          this.m_lalcD = new b2Vec2();
          this.m_joint1 = def.joint1;
          this.m_joint2 = def.joint2;
          this.m_typeA = this.m_joint1.GetType();
          this.m_typeB = this.m_joint2.GetType();
          // DEBUG: b2Assert(this.m_typeA === b2JointType.e_revoluteJoint || this.m_typeA === b2JointType.e_prismaticJoint);
          // DEBUG: b2Assert(this.m_typeB === b2JointType.e_revoluteJoint || this.m_typeB === b2JointType.e_prismaticJoint);
          let coordinateA, coordinateB;
          // TODO_ERIN there might be some problem with the joint edges in b2Joint.
          this.m_bodyC = this.m_joint1.GetBodyA();
          this.m_bodyA = this.m_joint1.GetBodyB();
          // Body B on joint1 must be dynamic
          // b2Assert(this.m_bodyA.m_type === b2_dynamicBody);
          // Get geometry of joint1
          const xfA = this.m_bodyA.m_xf;
          const aA = this.m_bodyA.m_sweep.a;
          const xfC = this.m_bodyC.m_xf;
          const aC = this.m_bodyC.m_sweep.a;
          if (this.m_typeA === exports.JointType.e_revoluteJoint) {
              const revolute = def.joint1;
              this.m_localAnchorC.Copy(revolute.m_localAnchorA);
              this.m_localAnchorA.Copy(revolute.m_localAnchorB);
              this.m_referenceAngleA = revolute.m_referenceAngle;
              this.m_localAxisC.SetZero();
              coordinateA = aA - aC - this.m_referenceAngleA;
          }
          else {
              const prismatic = def.joint1;
              this.m_localAnchorC.Copy(prismatic.m_localAnchorA);
              this.m_localAnchorA.Copy(prismatic.m_localAnchorB);
              this.m_referenceAngleA = prismatic.m_referenceAngle;
              this.m_localAxisC.Copy(prismatic.m_localXAxisA);
              // b2Vec2 pC = m_localAnchorC;
              const pC = this.m_localAnchorC;
              // b2Vec2 pA = b2MulT(xfC.q, b2Mul(xfA.q, m_localAnchorA) + (xfA.p - xfC.p));
              const pA = b2Rot.MulTRV(xfC.q, b2Vec2.AddVV(b2Rot.MulRV(xfA.q, this.m_localAnchorA, b2Vec2.s_t0), b2Vec2.SubVV(xfA.p, xfC.p, b2Vec2.s_t1), b2Vec2.s_t0), b2Vec2.s_t0); // pA uses s_t0
              // coordinateA = b2Dot(pA - pC, m_localAxisC);
              coordinateA = b2Vec2.DotVV(b2Vec2.SubVV(pA, pC, b2Vec2.s_t0), this.m_localAxisC);
          }
          this.m_bodyD = this.m_joint2.GetBodyA();
          this.m_bodyB = this.m_joint2.GetBodyB();
          // Body B on joint2 must be dynamic
          // b2Assert(this.m_bodyB.m_type === b2_dynamicBody);
          // Get geometry of joint2
          const xfB = this.m_bodyB.m_xf;
          const aB = this.m_bodyB.m_sweep.a;
          const xfD = this.m_bodyD.m_xf;
          const aD = this.m_bodyD.m_sweep.a;
          if (this.m_typeB === exports.JointType.e_revoluteJoint) {
              const revolute = def.joint2;
              this.m_localAnchorD.Copy(revolute.m_localAnchorA);
              this.m_localAnchorB.Copy(revolute.m_localAnchorB);
              this.m_referenceAngleB = revolute.m_referenceAngle;
              this.m_localAxisD.SetZero();
              coordinateB = aB - aD - this.m_referenceAngleB;
          }
          else {
              const prismatic = def.joint2;
              this.m_localAnchorD.Copy(prismatic.m_localAnchorA);
              this.m_localAnchorB.Copy(prismatic.m_localAnchorB);
              this.m_referenceAngleB = prismatic.m_referenceAngle;
              this.m_localAxisD.Copy(prismatic.m_localXAxisA);
              // b2Vec2 pD = m_localAnchorD;
              const pD = this.m_localAnchorD;
              // b2Vec2 pB = b2MulT(xfD.q, b2Mul(xfB.q, m_localAnchorB) + (xfB.p - xfD.p));
              const pB = b2Rot.MulTRV(xfD.q, b2Vec2.AddVV(b2Rot.MulRV(xfB.q, this.m_localAnchorB, b2Vec2.s_t0), b2Vec2.SubVV(xfB.p, xfD.p, b2Vec2.s_t1), b2Vec2.s_t0), b2Vec2.s_t0); // pB uses s_t0
              // coordinateB = b2Dot(pB - pD, m_localAxisD);
              coordinateB = b2Vec2.DotVV(b2Vec2.SubVV(pB, pD, b2Vec2.s_t0), this.m_localAxisD);
          }
          this.m_ratio = b2Maybe(def.ratio, 1);
          this.m_constant = coordinateA + this.m_ratio * coordinateB;
          this.m_impulse = 0;
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_indexC = this.m_bodyC.m_islandIndex;
          this.m_indexD = this.m_bodyD.m_islandIndex;
          this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);
          this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);
          this.m_mA = this.m_bodyA.m_invMass;
          this.m_mB = this.m_bodyB.m_invMass;
          this.m_mC = this.m_bodyC.m_invMass;
          this.m_mD = this.m_bodyD.m_invMass;
          this.m_iA = this.m_bodyA.m_invI;
          this.m_iB = this.m_bodyB.m_invI;
          this.m_iC = this.m_bodyC.m_invI;
          this.m_iD = this.m_bodyD.m_invI;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const aC = data.positions[this.m_indexC].a;
          const vC = data.velocities[this.m_indexC].v;
          let wC = data.velocities[this.m_indexC].w;
          const aD = data.positions[this.m_indexD].a;
          const vD = data.velocities[this.m_indexD].v;
          let wD = data.velocities[this.m_indexD].w;
          // b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB), qC = this.m_qC.SetAngle(aC), qD = this.m_qD.SetAngle(aD);
          this.m_mass = 0;
          if (this.m_typeA === exports.JointType.e_revoluteJoint) {
              this.m_JvAC.SetZero();
              this.m_JwA = 1;
              this.m_JwC = 1;
              this.m_mass += this.m_iA + this.m_iC;
          }
          else {
              // b2Vec2 u = b2Mul(qC, m_localAxisC);
              const u = b2Rot.MulRV(qC, this.m_localAxisC, b2GearJoint.InitVelocityConstraints_s_u);
              // b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
              b2Vec2.SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC);
              const rC = b2Rot.MulRV(qC, this.m_lalcC, b2GearJoint.InitVelocityConstraints_s_rC);
              // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
              b2Vec2.SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA);
              const rA = b2Rot.MulRV(qA, this.m_lalcA, b2GearJoint.InitVelocityConstraints_s_rA);
              // m_JvAC = u;
              this.m_JvAC.Copy(u);
              // m_JwC = b2Cross(rC, u);
              this.m_JwC = b2Vec2.CrossVV(rC, u);
              // m_JwA = b2Cross(rA, u);
              this.m_JwA = b2Vec2.CrossVV(rA, u);
              this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
          }
          if (this.m_typeB === exports.JointType.e_revoluteJoint) {
              this.m_JvBD.SetZero();
              this.m_JwB = this.m_ratio;
              this.m_JwD = this.m_ratio;
              this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
          }
          else {
              // b2Vec2 u = b2Mul(qD, m_localAxisD);
              const u = b2Rot.MulRV(qD, this.m_localAxisD, b2GearJoint.InitVelocityConstraints_s_u);
              // b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
              b2Vec2.SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD);
              const rD = b2Rot.MulRV(qD, this.m_lalcD, b2GearJoint.InitVelocityConstraints_s_rD);
              // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
              b2Vec2.SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB);
              const rB = b2Rot.MulRV(qB, this.m_lalcB, b2GearJoint.InitVelocityConstraints_s_rB);
              // m_JvBD = m_ratio * u;
              b2Vec2.MulSV(this.m_ratio, u, this.m_JvBD);
              // m_JwD = m_ratio * b2Cross(rD, u);
              this.m_JwD = this.m_ratio * b2Vec2.CrossVV(rD, u);
              // m_JwB = m_ratio * b2Cross(rB, u);
              this.m_JwB = this.m_ratio * b2Vec2.CrossVV(rB, u);
              this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
          }
          // Compute effective mass.
          this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
          if (data.step.warmStarting) {
              // vA += (m_mA * m_impulse) * m_JvAC;
              vA.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC);
              wA += this.m_iA * this.m_impulse * this.m_JwA;
              // vB += (m_mB * m_impulse) * m_JvBD;
              vB.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD);
              wB += this.m_iB * this.m_impulse * this.m_JwB;
              // vC -= (m_mC * m_impulse) * m_JvAC;
              vC.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC);
              wC -= this.m_iC * this.m_impulse * this.m_JwC;
              // vD -= (m_mD * m_impulse) * m_JvBD;
              vD.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD);
              wD -= this.m_iD * this.m_impulse * this.m_JwD;
          }
          else {
              this.m_impulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
          // data.velocities[this.m_indexC].v = vC;
          data.velocities[this.m_indexC].w = wC;
          // data.velocities[this.m_indexD].v = vD;
          data.velocities[this.m_indexD].w = wD;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const vC = data.velocities[this.m_indexC].v;
          let wC = data.velocities[this.m_indexC].w;
          const vD = data.velocities[this.m_indexD].v;
          let wD = data.velocities[this.m_indexD].w;
          // float32 Cdot = b2Dot(m_JvAC, vA - vC) + b2Dot(m_JvBD, vB - vD);
          let Cdot = b2Vec2.DotVV(this.m_JvAC, b2Vec2.SubVV(vA, vC, b2Vec2.s_t0)) +
              b2Vec2.DotVV(this.m_JvBD, b2Vec2.SubVV(vB, vD, b2Vec2.s_t0));
          Cdot += (this.m_JwA * wA - this.m_JwC * wC) + (this.m_JwB * wB - this.m_JwD * wD);
          const impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          // vA += (m_mA * impulse) * m_JvAC;
          vA.SelfMulAdd((this.m_mA * impulse), this.m_JvAC);
          wA += this.m_iA * impulse * this.m_JwA;
          // vB += (m_mB * impulse) * m_JvBD;
          vB.SelfMulAdd((this.m_mB * impulse), this.m_JvBD);
          wB += this.m_iB * impulse * this.m_JwB;
          // vC -= (m_mC * impulse) * m_JvAC;
          vC.SelfMulSub((this.m_mC * impulse), this.m_JvAC);
          wC -= this.m_iC * impulse * this.m_JwC;
          // vD -= (m_mD * impulse) * m_JvBD;
          vD.SelfMulSub((this.m_mD * impulse), this.m_JvBD);
          wD -= this.m_iD * impulse * this.m_JwD;
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
          // data.velocities[this.m_indexC].v = vC;
          data.velocities[this.m_indexC].w = wC;
          // data.velocities[this.m_indexD].v = vD;
          data.velocities[this.m_indexD].w = wD;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          const cC = data.positions[this.m_indexC].c;
          let aC = data.positions[this.m_indexC].a;
          const cD = data.positions[this.m_indexD].c;
          let aD = data.positions[this.m_indexD].a;
          // b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB), qC = this.m_qC.SetAngle(aC), qD = this.m_qD.SetAngle(aD);
          const linearError = 0;
          let coordinateA, coordinateB;
          const JvAC = this.m_JvAC, JvBD = this.m_JvBD;
          let JwA, JwB, JwC, JwD;
          let mass = 0;
          if (this.m_typeA === exports.JointType.e_revoluteJoint) {
              JvAC.SetZero();
              JwA = 1;
              JwC = 1;
              mass += this.m_iA + this.m_iC;
              coordinateA = aA - aC - this.m_referenceAngleA;
          }
          else {
              // b2Vec2 u = b2Mul(qC, m_localAxisC);
              const u = b2Rot.MulRV(qC, this.m_localAxisC, b2GearJoint.SolvePositionConstraints_s_u);
              // b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
              const rC = b2Rot.MulRV(qC, this.m_lalcC, b2GearJoint.SolvePositionConstraints_s_rC);
              // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
              const rA = b2Rot.MulRV(qA, this.m_lalcA, b2GearJoint.SolvePositionConstraints_s_rA);
              // JvAC = u;
              JvAC.Copy(u);
              // JwC = b2Cross(rC, u);
              JwC = b2Vec2.CrossVV(rC, u);
              // JwA = b2Cross(rA, u);
              JwA = b2Vec2.CrossVV(rA, u);
              mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
              // b2Vec2 pC = m_localAnchorC - m_lcC;
              const pC = this.m_lalcC;
              // b2Vec2 pA = b2MulT(qC, rA + (cA - cC));
              const pA = b2Rot.MulTRV(qC, b2Vec2.AddVV(rA, b2Vec2.SubVV(cA, cC, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.s_t0); // pA uses s_t0
              // coordinateA = b2Dot(pA - pC, m_localAxisC);
              coordinateA = b2Vec2.DotVV(b2Vec2.SubVV(pA, pC, b2Vec2.s_t0), this.m_localAxisC);
          }
          if (this.m_typeB === exports.JointType.e_revoluteJoint) {
              JvBD.SetZero();
              JwB = this.m_ratio;
              JwD = this.m_ratio;
              mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
              coordinateB = aB - aD - this.m_referenceAngleB;
          }
          else {
              // b2Vec2 u = b2Mul(qD, m_localAxisD);
              const u = b2Rot.MulRV(qD, this.m_localAxisD, b2GearJoint.SolvePositionConstraints_s_u);
              // b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
              const rD = b2Rot.MulRV(qD, this.m_lalcD, b2GearJoint.SolvePositionConstraints_s_rD);
              // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
              const rB = b2Rot.MulRV(qB, this.m_lalcB, b2GearJoint.SolvePositionConstraints_s_rB);
              // JvBD = m_ratio * u;
              b2Vec2.MulSV(this.m_ratio, u, JvBD);
              // JwD = m_ratio * b2Cross(rD, u);
              JwD = this.m_ratio * b2Vec2.CrossVV(rD, u);
              // JwB = m_ratio * b2Cross(rB, u);
              JwB = this.m_ratio * b2Vec2.CrossVV(rB, u);
              mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
              // b2Vec2 pD = m_localAnchorD - m_lcD;
              const pD = this.m_lalcD;
              // b2Vec2 pB = b2MulT(qD, rB + (cB - cD));
              const pB = b2Rot.MulTRV(qD, b2Vec2.AddVV(rB, b2Vec2.SubVV(cB, cD, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.s_t0); // pB uses s_t0
              // coordinateB = b2Dot(pB - pD, m_localAxisD);
              coordinateB = b2Vec2.DotVV(b2Vec2.SubVV(pB, pD, b2Vec2.s_t0), this.m_localAxisD);
          }
          const C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant;
          let impulse = 0;
          if (mass > 0) {
              impulse = -C / mass;
          }
          // cA += m_mA * impulse * JvAC;
          cA.SelfMulAdd(this.m_mA * impulse, JvAC);
          aA += this.m_iA * impulse * JwA;
          // cB += m_mB * impulse * JvBD;
          cB.SelfMulAdd(this.m_mB * impulse, JvBD);
          aB += this.m_iB * impulse * JwB;
          // cC -= m_mC * impulse * JvAC;
          cC.SelfMulSub(this.m_mC * impulse, JvAC);
          aC -= this.m_iC * impulse * JwC;
          // cD -= m_mD * impulse * JvBD;
          cD.SelfMulSub(this.m_mD * impulse, JvBD);
          aD -= this.m_iD * impulse * JwD;
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          // data.positions[this.m_indexC].c = cC;
          data.positions[this.m_indexC].a = aC;
          // data.positions[this.m_indexD].c = cD;
          data.positions[this.m_indexD].a = aD;
          // TODO_ERIN not implemented
          return linearError < b2_linearSlop;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          // b2Vec2 P = m_impulse * m_JvAC;
          // return inv_dt * P;
          return b2Vec2.MulSV(inv_dt * this.m_impulse, this.m_JvAC, out);
      }
      GetReactionTorque(inv_dt) {
          // float32 L = m_impulse * m_JwA;
          // return inv_dt * L;
          return inv_dt * this.m_impulse * this.m_JwA;
      }
      GetJoint1() { return this.m_joint1; }
      GetJoint2() { return this.m_joint2; }
      GetRatio() {
          return this.m_ratio;
      }
      SetRatio(ratio) {
          // DEBUG: b2Assert(b2IsValid(ratio));
          this.m_ratio = ratio;
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          const index1 = this.m_joint1.m_index;
          const index2 = this.m_joint2.m_index;
          log("  const jd: b2GearJointDef = new b2GearJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.joint1 = joints[%d];\n", index1);
          log("  jd.joint2 = joints[%d];\n", index2);
          log("  jd.ratio = %.15f;\n", this.m_ratio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
  }
  b2GearJoint.InitVelocityConstraints_s_u = new b2Vec2();
  b2GearJoint.InitVelocityConstraints_s_rA = new b2Vec2();
  b2GearJoint.InitVelocityConstraints_s_rB = new b2Vec2();
  b2GearJoint.InitVelocityConstraints_s_rC = new b2Vec2();
  b2GearJoint.InitVelocityConstraints_s_rD = new b2Vec2();
  b2GearJoint.SolvePositionConstraints_s_u = new b2Vec2();
  b2GearJoint.SolvePositionConstraints_s_rA = new b2Vec2();
  b2GearJoint.SolvePositionConstraints_s_rB = new b2Vec2();
  b2GearJoint.SolvePositionConstraints_s_rC = new b2Vec2();
  b2GearJoint.SolvePositionConstraints_s_rD = new b2Vec2();

  /*
  * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /*
  Position Correction Notes
  =========================
  I tried the several algorithms for position correction of the 2D revolute joint.
  I looked at these systems:
  - simple pendulum (1m diameter sphere on massless 5m stick) with initial angular velocity of 100 rad/s.
  - suspension bridge with 30 1m long planks of length 1m.
  - multi-link chain with 30 1m long links.

  Here are the algorithms:

  Baumgarte - A fraction of the position error is added to the velocity error. There is no
  separate position solver.

  Pseudo Velocities - After the velocity solver and position integration,
  the position error, Jacobian, and effective mass are recomputed. Then
  the velocity constraints are solved with pseudo velocities and a fraction
  of the position error is added to the pseudo velocity error. The pseudo
  velocities are initialized to zero and there is no warm-starting. After
  the position solver, the pseudo velocities are added to the positions.
  This is also called the First Order World method or the Position LCP method.

  Modified Nonlinear Gauss-Seidel (NGS) - Like Pseudo Velocities except the
  position error is re-computed for each constraint and the positions are updated
  after the constraint is solved. The radius vectors (aka Jacobians) are
  re-computed too (otherwise the algorithm has horrible instability). The pseudo
  velocity states are not needed because they are effectively zero at the beginning
  of each iteration. Since we have the current position error, we allow the
  iterations to terminate early if the error becomes smaller than b2_linearSlop.

  Full NGS or just NGS - Like Modified NGS except the effective mass are re-computed
  each time a constraint is solved.

  Here are the results:
  Baumgarte - this is the cheapest algorithm but it has some stability problems,
  especially with the bridge. The chain links separate easily close to the root
  and they jitter as they struggle to pull together. This is one of the most common
  methods in the field. The big drawback is that the position correction artificially
  affects the momentum, thus leading to instabilities and false bounce. I used a
  bias factor of 0.2. A larger bias factor makes the bridge less stable, a smaller
  factor makes joints and contacts more spongy.

  Pseudo Velocities - the is more stable than the Baumgarte method. The bridge is
  stable. However, joints still separate with large angular velocities. Drag the
  simple pendulum in a circle quickly and the joint will separate. The chain separates
  easily and does not recover. I used a bias factor of 0.2. A larger value lead to
  the bridge collapsing when a heavy cube drops on it.

  Modified NGS - this algorithm is better in some ways than Baumgarte and Pseudo
  Velocities, but in other ways it is worse. The bridge and chain are much more
  stable, but the simple pendulum goes unstable at high angular velocities.

  Full NGS - stable in all tests. The joints display good stiffness. The bridge
  still sags, but this is better than infinite forces.

  Recommendations
  Pseudo Velocities are not really worthwhile because the bridge and chain cannot
  recover from joint separation. In other cases the benefit over Baumgarte is small.

  Modified NGS is not a robust method for the revolute joint due to the violent
  instability seen in the simple pendulum. Perhaps it is viable with other constraint
  types, especially scalar constraints where the effective mass is a scalar.

  This leaves Baumgarte and Full NGS. Baumgarte has small, but manageable instabilities
  and is very fast. I don't think we can escape Baumgarte, especially in highly
  demanding cases where high constraint fidelity is not needed.

  Full NGS is robust and easy on the eyes. I recommend this as an option for
  higher fidelity simulation and certainly for suspension bridges and long chains.
  Full NGS might be a good choice for ragdolls, especially motorized ragdolls where
  joint separation can be problematic. The number of NGS iterations can be reduced
  for better performance without harming robustness much.

  Each joint in a can be handled differently in the position solver. So I recommend
  a system where the user can select the algorithm on a per joint basis. I would
  probably default to the slower Full NGS and let the user select the faster
  Baumgarte method in performance critical scenarios.
  */
  /*
  Cache Performance

  The Box2D solvers are dominated by cache misses. Data structures are designed
  to increase the number of cache hits. Much of misses are due to random access
  to body data. The constraint structures are iterated over linearly, which leads
  to few cache misses.

  The bodies are not accessed during iteration. Instead read only data, such as
  the mass values are stored with the constraints. The mutable data are the constraint
  impulses and the bodies velocities/positions. The impulses are held inside the
  constraint structures. The body velocities/positions are held in compact, temporary
  arrays to increase the number of cache hits. Linear and angular velocity are
  stored in a single array since multiple arrays lead to multiple misses.
  */
  /*
  2D Rotation

  R = [cos(theta) -sin(theta)]
      [sin(theta) cos(theta) ]

  thetaDot = omega

  Let q1 = cos(theta), q2 = sin(theta).
  R = [q1 -q2]
      [q2  q1]

  q1Dot = -thetaDot * q2
  q2Dot = thetaDot * q1

  q1_new = q1_old - dt * w * q2
  q2_new = q2_old + dt * w * q1
  then normalize.

  This might be faster than computing sin+cos.
  However, we can compute sin+cos of the same angle fast.
  */
  class b2Island {
      constructor() {
          this.m_bodies = [ /*1024*/]; // TODO: b2Settings
          this.m_contacts = [ /*1024*/]; // TODO: b2Settings
          this.m_joints = [ /*1024*/]; // TODO: b2Settings
          this.m_positions = b2Position.MakeArray(1024); // TODO: b2Settings
          this.m_velocities = b2Velocity.MakeArray(1024); // TODO: b2Settings
          this.m_bodyCount = 0;
          this.m_jointCount = 0;
          this.m_contactCount = 0;
          this.m_bodyCapacity = 0;
          this.m_contactCapacity = 0;
          this.m_jointCapacity = 0;
      }
      Initialize(bodyCapacity, contactCapacity, jointCapacity, listener) {
          this.m_bodyCapacity = bodyCapacity;
          this.m_contactCapacity = contactCapacity;
          this.m_jointCapacity = jointCapacity;
          this.m_bodyCount = 0;
          this.m_contactCount = 0;
          this.m_jointCount = 0;
          this.m_listener = listener;
          // TODO:
          // while (this.m_bodies.length < bodyCapacity) {
          //   this.m_bodies[this.m_bodies.length] = null;
          // }
          // TODO:
          // while (this.m_contacts.length < contactCapacity) {
          //   this.m_contacts[this.m_contacts.length] = null;
          // }
          // TODO:
          // while (this.m_joints.length < jointCapacity) {
          //   this.m_joints[this.m_joints.length] = null;
          // }
          // TODO:
          if (this.m_positions.length < bodyCapacity) {
              const new_length = b2Max(this.m_positions.length * 2, bodyCapacity);
              while (this.m_positions.length < new_length) {
                  this.m_positions[this.m_positions.length] = new b2Position();
              }
          }
          // TODO:
          if (this.m_velocities.length < bodyCapacity) {
              const new_length = b2Max(this.m_velocities.length * 2, bodyCapacity);
              while (this.m_velocities.length < new_length) {
                  this.m_velocities[this.m_velocities.length] = new b2Velocity();
              }
          }
      }
      Clear() {
          this.m_bodyCount = 0;
          this.m_contactCount = 0;
          this.m_jointCount = 0;
      }
      AddBody(body) {
          // DEBUG: b2Assert(this.m_bodyCount < this.m_bodyCapacity);
          body.m_islandIndex = this.m_bodyCount;
          this.m_bodies[this.m_bodyCount++] = body;
      }
      AddContact(contact) {
          // DEBUG: b2Assert(this.m_contactCount < this.m_contactCapacity);
          this.m_contacts[this.m_contactCount++] = contact;
      }
      AddJoint(joint) {
          // DEBUG: b2Assert(this.m_jointCount < this.m_jointCapacity);
          this.m_joints[this.m_jointCount++] = joint;
      }
      Solve(profile, step, gravity, allowSleep) {
          const timer = b2Island.s_timer.Reset();
          const h = step.dt;
          // Integrate velocities and apply damping. Initialize the body state.
          for (let i = 0; i < this.m_bodyCount; ++i) {
              const b = this.m_bodies[i];
              // const c: b2Vec2 =
              this.m_positions[i].c.Copy(b.m_sweep.c);
              const a = b.m_sweep.a;
              const v = this.m_velocities[i].v.Copy(b.m_linearVelocity);
              let w = b.m_angularVelocity;
              // Store positions for continuous collision.
              b.m_sweep.c0.Copy(b.m_sweep.c);
              b.m_sweep.a0 = b.m_sweep.a;
              if (b.m_type === exports.BodyType.b2_dynamicBody) {
                  // Integrate velocities.
                  // v += h * b->m_invMass * (b->m_gravityScale * b->m_mass * gravity + b->m_force);
                  v.x += h * b.m_invMass * (b.m_gravityScale * b.m_mass * gravity.x + b.m_force.x);
                  v.y += h * b.m_invMass * (b.m_gravityScale * b.m_mass * gravity.y + b.m_force.y);
                  w += h * b.m_invI * b.m_torque;
                  // Apply damping.
                  // ODE: dv/dt + c * v = 0
                  // Solution: v(t) = v0 * exp(-c * t)
                  // Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
                  // v2 = exp(-c * dt) * v1
                  // Pade approximation:
                  // v2 = v1 * 1 / (1 + c * dt)
                  v.SelfMul(1.0 / (1.0 + h * b.m_linearDamping));
                  w *= 1.0 / (1.0 + h * b.m_angularDamping);
              }
              // this.m_positions[i].c = c;
              this.m_positions[i].a = a;
              // this.m_velocities[i].v = v;
              this.m_velocities[i].w = w;
          }
          timer.Reset();
          // Solver data
          const solverData = b2Island.s_solverData;
          solverData.step.Copy(step);
          solverData.positions = this.m_positions;
          solverData.velocities = this.m_velocities;
          // Initialize velocity constraints.
          const contactSolverDef = b2Island.s_contactSolverDef;
          contactSolverDef.step.Copy(step);
          contactSolverDef.contacts = this.m_contacts;
          contactSolverDef.count = this.m_contactCount;
          contactSolverDef.positions = this.m_positions;
          contactSolverDef.velocities = this.m_velocities;
          const contactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);
          contactSolver.InitializeVelocityConstraints();
          if (step.warmStarting) {
              contactSolver.WarmStart();
          }
          for (let i = 0; i < this.m_jointCount; ++i) {
              this.m_joints[i].InitVelocityConstraints(solverData);
          }
          profile.solveInit = timer.GetMilliseconds();
          // Solve velocity constraints.
          timer.Reset();
          for (let i = 0; i < step.velocityIterations; ++i) {
              for (let j = 0; j < this.m_jointCount; ++j) {
                  this.m_joints[j].SolveVelocityConstraints(solverData);
              }
              contactSolver.SolveVelocityConstraints();
          }
          // Store impulses for warm starting
          contactSolver.StoreImpulses();
          profile.solveVelocity = timer.GetMilliseconds();
          // Integrate positions.
          for (let i = 0; i < this.m_bodyCount; ++i) {
              const c = this.m_positions[i].c;
              let a = this.m_positions[i].a;
              const v = this.m_velocities[i].v;
              let w = this.m_velocities[i].w;
              // Check for large velocities
              const translation = b2Vec2.MulSV(h, v, b2Island.s_translation);
              if (b2Vec2.DotVV(translation, translation) > b2_maxTranslationSquared) {
                  const ratio = b2_maxTranslation / translation.Length();
                  v.SelfMul(ratio);
              }
              const rotation = h * w;
              if (rotation * rotation > b2_maxRotationSquared) {
                  const ratio = b2_maxRotation / b2Abs(rotation);
                  w *= ratio;
              }
              // Integrate
              c.x += h * v.x;
              c.y += h * v.y;
              a += h * w;
              // this.m_positions[i].c = c;
              this.m_positions[i].a = a;
              // this.m_velocities[i].v = v;
              this.m_velocities[i].w = w;
          }
          // Solve position constraints
          timer.Reset();
          let positionSolved = false;
          for (let i = 0; i < step.positionIterations; ++i) {
              const contactsOkay = contactSolver.SolvePositionConstraints();
              let jointsOkay = true;
              for (let j = 0; j < this.m_jointCount; ++j) {
                  const jointOkay = this.m_joints[j].SolvePositionConstraints(solverData);
                  jointsOkay = jointsOkay && jointOkay;
              }
              if (contactsOkay && jointsOkay) {
                  // Exit early if the position errors are small.
                  positionSolved = true;
                  break;
              }
          }
          // Copy state buffers back to the bodies
          for (let i = 0; i < this.m_bodyCount; ++i) {
              const body = this.m_bodies[i];
              body.m_sweep.c.Copy(this.m_positions[i].c);
              body.m_sweep.a = this.m_positions[i].a;
              body.m_linearVelocity.Copy(this.m_velocities[i].v);
              body.m_angularVelocity = this.m_velocities[i].w;
              body.SynchronizeTransform();
          }
          profile.solvePosition = timer.GetMilliseconds();
          this.Report(contactSolver.m_velocityConstraints);
          if (allowSleep) {
              let minSleepTime = b2_maxFloat;
              const linTolSqr = b2_linearSleepTolerance * b2_linearSleepTolerance;
              const angTolSqr = b2_angularSleepTolerance * b2_angularSleepTolerance;
              for (let i = 0; i < this.m_bodyCount; ++i) {
                  const b = this.m_bodies[i];
                  if (b.GetType() === exports.BodyType.b2_staticBody) {
                      continue;
                  }
                  if (!b.m_autoSleepFlag ||
                      b.m_angularVelocity * b.m_angularVelocity > angTolSqr ||
                      b2Vec2.DotVV(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                      b.m_sleepTime = 0;
                      minSleepTime = 0;
                  }
                  else {
                      b.m_sleepTime += h;
                      minSleepTime = b2Min(minSleepTime, b.m_sleepTime);
                  }
              }
              if (minSleepTime >= b2_timeToSleep && positionSolved) {
                  for (let i = 0; i < this.m_bodyCount; ++i) {
                      const b = this.m_bodies[i];
                      b.SetAwake(false);
                  }
              }
          }
      }
      SolveTOI(subStep, toiIndexA, toiIndexB) {
          // DEBUG: b2Assert(toiIndexA < this.m_bodyCount);
          // DEBUG: b2Assert(toiIndexB < this.m_bodyCount);
          // Initialize the body state.
          for (let i = 0; i < this.m_bodyCount; ++i) {
              const b = this.m_bodies[i];
              this.m_positions[i].c.Copy(b.m_sweep.c);
              this.m_positions[i].a = b.m_sweep.a;
              this.m_velocities[i].v.Copy(b.m_linearVelocity);
              this.m_velocities[i].w = b.m_angularVelocity;
          }
          const contactSolverDef = b2Island.s_contactSolverDef;
          contactSolverDef.contacts = this.m_contacts;
          contactSolverDef.count = this.m_contactCount;
          contactSolverDef.step.Copy(subStep);
          contactSolverDef.positions = this.m_positions;
          contactSolverDef.velocities = this.m_velocities;
          const contactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);
          // Solve position constraints.
          for (let i = 0; i < subStep.positionIterations; ++i) {
              const contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
              if (contactsOkay) {
                  break;
              }
          }
          /*
          #if 0
            // Is the new position really safe?
            for (int32 i = 0; i < this.m_contactCount; ++i) {
              b2Contact* c = this.m_contacts[i];
              b2Fixture* fA = c.GetFixtureA();
              b2Fixture* fB = c.GetFixtureB();
        
              b2Body* bA = fA.GetBody();
              b2Body* bB = fB.GetBody();
        
              int32 indexA = c.GetChildIndexA();
              int32 indexB = c.GetChildIndexB();
        
              b2DistanceInput input;
              input.proxyA.Set(fA.GetShape(), indexA);
              input.proxyB.Set(fB.GetShape(), indexB);
              input.transformA = bA.GetTransform();
              input.transformB = bB.GetTransform();
              input.useRadii = false;
        
              b2DistanceOutput output;
              b2SimplexCache cache;
              cache.count = 0;
              b2Distance(&output, &cache, &input);
        
              if (output.distance === 0 || cache.count === 3) {
                cache.count += 0;
              }
            }
          #endif
          */
          // Leap of faith to new safe state.
          this.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);
          this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;
          this.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);
          this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;
          // No warm starting is needed for TOI events because warm
          // starting impulses were applied in the discrete solver.
          contactSolver.InitializeVelocityConstraints();
          // Solve velocity constraints.
          for (let i = 0; i < subStep.velocityIterations; ++i) {
              contactSolver.SolveVelocityConstraints();
          }
          // Don't store the TOI contact forces for warm starting
          // because they can be quite large.
          const h = subStep.dt;
          // Integrate positions
          for (let i = 0; i < this.m_bodyCount; ++i) {
              const c = this.m_positions[i].c;
              let a = this.m_positions[i].a;
              const v = this.m_velocities[i].v;
              let w = this.m_velocities[i].w;
              // Check for large velocities
              const translation = b2Vec2.MulSV(h, v, b2Island.s_translation);
              if (b2Vec2.DotVV(translation, translation) > b2_maxTranslationSquared) {
                  const ratio = b2_maxTranslation / translation.Length();
                  v.SelfMul(ratio);
              }
              const rotation = h * w;
              if (rotation * rotation > b2_maxRotationSquared) {
                  const ratio = b2_maxRotation / b2Abs(rotation);
                  w *= ratio;
              }
              // Integrate
              c.SelfMulAdd(h, v);
              a += h * w;
              // this.m_positions[i].c = c;
              this.m_positions[i].a = a;
              // this.m_velocities[i].v = v;
              this.m_velocities[i].w = w;
              // Sync bodies
              const body = this.m_bodies[i];
              body.m_sweep.c.Copy(c);
              body.m_sweep.a = a;
              body.m_linearVelocity.Copy(v);
              body.m_angularVelocity = w;
              body.SynchronizeTransform();
          }
          this.Report(contactSolver.m_velocityConstraints);
      }
      Report(constraints) {
          if (this.m_listener === null) {
              return;
          }
          for (let i = 0; i < this.m_contactCount; ++i) {
              const c = this.m_contacts[i];
              if (!c) {
                  continue;
              }
              const vc = constraints[i];
              const impulse = b2Island.s_impulse;
              impulse.count = vc.pointCount;
              for (let j = 0; j < vc.pointCount; ++j) {
                  impulse.normalImpulses[j] = vc.points[j].normalImpulse;
                  impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
              }
              this.m_listener.PostSolve(c, impulse);
          }
      }
  }
  b2Island.s_timer = new b2Timer();
  b2Island.s_solverData = new b2SolverData();
  b2Island.s_contactSolverDef = new b2ContactSolverDef();
  b2Island.s_contactSolver = new b2ContactSolver();
  b2Island.s_translation = new b2Vec2();
  b2Island.s_impulse = new b2ContactImpulse();

  /*
  * Copyright (c) 2006-2012 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  class b2MotorJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_motorJoint);
          this.linearOffset = new b2Vec2(0, 0);
          this.angularOffset = 0;
          this.maxForce = 1;
          this.maxTorque = 1;
          this.correctionFactor = 0.3;
      }
      Initialize(bA, bB) {
          this.bodyA = bA;
          this.bodyB = bB;
          // b2Vec2 xB = bodyB->GetPosition();
          // linearOffset = bodyA->GetLocalPoint(xB);
          this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
          const angleA = this.bodyA.GetAngle();
          const angleB = this.bodyB.GetAngle();
          this.angularOffset = angleB - angleA;
      }
  }
  class b2MotorJoint extends b2Joint {
      constructor(def) {
          super(def);
          // Solver shared
          this.m_linearOffset = new b2Vec2();
          this.m_angularOffset = 0;
          this.m_linearImpulse = new b2Vec2();
          this.m_angularImpulse = 0;
          this.m_maxForce = 0;
          this.m_maxTorque = 0;
          this.m_correctionFactor = 0.3;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_linearError = new b2Vec2();
          this.m_angularError = 0;
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_linearMass = new b2Mat22();
          this.m_angularMass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_K = new b2Mat22();
          this.m_linearOffset.Copy(b2Maybe(def.linearOffset, b2Vec2.ZERO));
          this.m_linearImpulse.SetZero();
          this.m_maxForce = b2Maybe(def.maxForce, 0);
          this.m_maxTorque = b2Maybe(def.maxTorque, 0);
          this.m_correctionFactor = b2Maybe(def.correctionFactor, 0.3);
      }
      GetAnchorA(out) {
          const pos = this.m_bodyA.GetPosition();
          out.x = pos.x;
          out.y = pos.y;
          return out;
      }
      GetAnchorB(out) {
          const pos = this.m_bodyB.GetPosition();
          out.x = pos.x;
          out.y = pos.y;
          return out;
      }
      GetReactionForce(inv_dt, out) {
          // return inv_dt * m_linearImpulse;
          return b2Vec2.MulSV(inv_dt, this.m_linearImpulse, out);
      }
      GetReactionTorque(inv_dt) {
          return inv_dt * this.m_angularImpulse;
      }
      SetLinearOffset(linearOffset) {
          if (!b2Vec2.IsEqualToV(linearOffset, this.m_linearOffset)) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_linearOffset.Copy(linearOffset);
          }
      }
      GetLinearOffset() {
          return this.m_linearOffset;
      }
      SetAngularOffset(angularOffset) {
          if (angularOffset !== this.m_angularOffset) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_angularOffset = angularOffset;
          }
      }
      GetAngularOffset() {
          return this.m_angularOffset;
      }
      SetMaxForce(force) {
          // DEBUG: b2Assert(b2IsValid(force) && force >= 0);
          this.m_maxForce = force;
      }
      GetMaxForce() {
          return this.m_maxForce;
      }
      SetMaxTorque(torque) {
          // DEBUG: b2Assert(b2IsValid(torque) && torque >= 0);
          this.m_maxTorque = torque;
      }
      GetMaxTorque() {
          return this.m_maxTorque;
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const cA = data.positions[this.m_indexA].c;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const cB = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // Compute the effective mass matrix.
          // this.m_rA = b2Mul(qA, m_linearOffset - this.m_localCenterA);
          const rA = b2Rot.MulRV(qA, b2Vec2.SubVV(this.m_linearOffset, this.m_localCenterA, b2Vec2.s_t0), this.m_rA);
          // this.m_rB = b2Mul(qB, -this.m_localCenterB);
          const rB = b2Rot.MulRV(qB, b2Vec2.NegV(this.m_localCenterB, b2Vec2.s_t0), this.m_rB);
          // J = [-I -r1_skew I r2_skew]
          // r_skew = [-ry; rx]
          // Matlab
          // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
          //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
          //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          // Upper 2 by 2 of K for point to point
          const K = this.m_K;
          K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
          K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
          // this.m_linearMass = K.GetInverse();
          K.GetInverse(this.m_linearMass);
          this.m_angularMass = iA + iB;
          if (this.m_angularMass > 0) {
              this.m_angularMass = 1 / this.m_angularMass;
          }
          // this.m_linearError = cB + rB - cA - rA;
          b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), this.m_linearError);
          this.m_angularError = aB - aA - this.m_angularOffset;
          if (data.step.warmStarting) {
              // Scale impulses to support a variable time step.
              // this.m_linearImpulse *= data.step.dtRatio;
              this.m_linearImpulse.SelfMul(data.step.dtRatio);
              this.m_angularImpulse *= data.step.dtRatio;
              // b2Vec2 P(this.m_linearImpulse.x, this.m_linearImpulse.y);
              const P = this.m_linearImpulse;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * (b2Vec2.CrossVV(rA, P) + this.m_angularImpulse);
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * (b2Vec2.CrossVV(rB, P) + this.m_angularImpulse);
          }
          else {
              this.m_linearImpulse.SetZero();
              this.m_angularImpulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA; // vA is a reference
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB; // vB is a reference
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const h = data.step.dt;
          const inv_h = data.step.inv_dt;
          // Solve angular friction
          {
              const Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
              let impulse = -this.m_angularMass * Cdot;
              const oldImpulse = this.m_angularImpulse;
              const maxImpulse = h * this.m_maxTorque;
              this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
              impulse = this.m_angularImpulse - oldImpulse;
              wA -= iA * impulse;
              wB += iB * impulse;
          }
          // Solve linear friction
          {
              const rA = this.m_rA;
              const rB = this.m_rB;
              // b2Vec2 Cdot = vB + b2Vec2.CrossSV(wB, rB) - vA - b2Vec2.CrossSV(wA, rA) + inv_h * this.m_correctionFactor * this.m_linearError;
              const Cdot_v2 = b2Vec2.AddVV(b2Vec2.SubVV(b2Vec2.AddVV(vB, b2Vec2.CrossSV(wB, rB, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.AddVV(vA, b2Vec2.CrossSV(wA, rA, b2Vec2.s_t1), b2Vec2.s_t1), b2Vec2.s_t2), b2Vec2.MulSV(inv_h * this.m_correctionFactor, this.m_linearError, b2Vec2.s_t3), b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2);
              // b2Vec2 impulse = -b2Mul(this.m_linearMass, Cdot);
              const impulse_v2 = b2Mat22.MulMV(this.m_linearMass, Cdot_v2, b2MotorJoint.SolveVelocityConstraints_s_impulse_v2).SelfNeg();
              // b2Vec2 oldImpulse = this.m_linearImpulse;
              const oldImpulse_v2 = b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);
              // this.m_linearImpulse += impulse;
              this.m_linearImpulse.SelfAdd(impulse_v2);
              const maxImpulse = h * this.m_maxForce;
              if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                  this.m_linearImpulse.Normalize();
                  // this.m_linearImpulse *= maxImpulse;
                  this.m_linearImpulse.SelfMul(maxImpulse);
              }
              // impulse = this.m_linearImpulse - oldImpulse;
              b2Vec2.SubVV(this.m_linearImpulse, oldImpulse_v2, impulse_v2);
              // vA -= mA * impulse;
              vA.SelfMulSub(mA, impulse_v2);
              // wA -= iA * b2Vec2.CrossVV(rA, impulse);
              wA -= iA * b2Vec2.CrossVV(rA, impulse_v2);
              // vB += mB * impulse;
              vB.SelfMulAdd(mB, impulse_v2);
              // wB += iB * b2Vec2.CrossVV(rB, impulse);
              wB += iB * b2Vec2.CrossVV(rB, impulse_v2);
          }
          // data.velocities[this.m_indexA].v = vA; // vA is a reference
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB; // vB is a reference
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          return true;
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2MotorJointDef = new b2MotorJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.linearOffset.Set(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y);
          log("  jd.angularOffset = %.15f;\n", this.m_angularOffset);
          log("  jd.maxForce = %.15f;\n", this.m_maxForce);
          log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
          log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
  }
  b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();
  b2MotorJoint.SolveVelocityConstraints_s_impulse_v2 = new b2Vec2();
  b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2 = new b2Vec2();

  /*
  * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Mouse joint definition. This requires a world target point,
  /// tuning parameters, and the time step.
  class b2MouseJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_mouseJoint);
          this.target = new b2Vec2();
          this.maxForce = 0;
          this.stiffness = 5;
          this.damping = 0.7;
      }
  }
  class b2MouseJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_localAnchorB = new b2Vec2();
          this.m_targetA = new b2Vec2();
          this.m_stiffness = 0;
          this.m_damping = 0;
          this.m_beta = 0;
          // Solver shared
          this.m_impulse = new b2Vec2();
          this.m_maxForce = 0;
          this.m_gamma = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_rB = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassB = 0;
          this.m_invIB = 0;
          this.m_mass = new b2Mat22();
          this.m_C = new b2Vec2();
          this.m_qB = new b2Rot();
          this.m_lalcB = new b2Vec2();
          this.m_K = new b2Mat22();
          this.m_targetA.Copy(b2Maybe(def.target, b2Vec2.ZERO));
          // DEBUG: b2Assert(this.m_targetA.IsValid());
          b2Transform.MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB);
          this.m_maxForce = b2Maybe(def.maxForce, 0);
          // DEBUG: b2Assert(b2IsValid(this.m_maxForce) && this.m_maxForce >= 0);
          this.m_impulse.SetZero();
          this.m_stiffness = b2Maybe(def.stiffness, 0);
          // DEBUG: b2Assert(b2IsValid(this.m_stiffness) && this.m_stiffness >= 0);
          this.m_damping = b2Maybe(def.damping, 0);
          // DEBUG: b2Assert(b2IsValid(this.m_damping) && this.m_damping >= 0);
          this.m_beta = 0;
          this.m_gamma = 0;
      }
      SetTarget(target) {
          if (!this.m_bodyB.IsAwake()) {
              this.m_bodyB.SetAwake(true);
          }
          this.m_targetA.Copy(target);
      }
      GetTarget() {
          return this.m_targetA;
      }
      SetMaxForce(maxForce) {
          this.m_maxForce = maxForce;
      }
      GetMaxForce() {
          return this.m_maxForce;
      }
      SetStiffness(stiffness) {
          this.m_stiffness = stiffness;
      }
      GetStiffness() {
          return this.m_stiffness;
      }
      SetDamping(damping) {
          this.m_damping = damping;
      }
      GetDamping() {
          return this.m_damping;
      }
      InitVelocityConstraints(data) {
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIB = this.m_bodyB.m_invI;
          const cB = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const qB = this.m_qB.SetAngle(aB);
          const mass = this.m_bodyB.GetMass();
          // Frequency
          const omega = 2 * b2_pi * this.m_stiffness;
          // Damping coefficient
          const d = 2 * mass * this.m_damping * omega;
          // Spring stiffness
          const k = mass * (omega * omega);
          // magic formulas
          // gamma has units of inverse mass.
          // beta has units of inverse time.
          const h = data.step.dt;
          this.m_gamma = h * (d + h * k);
          if (this.m_gamma !== 0) {
              this.m_gamma = 1 / this.m_gamma;
          }
          this.m_beta = h * k * this.m_gamma;
          // Compute the effective mass matrix.
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
          //      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
          //        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
          const K = this.m_K;
          K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
          K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
          K.GetInverse(this.m_mass);
          // m_C = cB + m_rB - m_targetA;
          this.m_C.x = cB.x + this.m_rB.x - this.m_targetA.x;
          this.m_C.y = cB.y + this.m_rB.y - this.m_targetA.y;
          // m_C *= m_beta;
          this.m_C.SelfMul(this.m_beta);
          // Cheat with some damping
          wB *= 0.98;
          if (data.step.warmStarting) {
              this.m_impulse.SelfMul(data.step.dtRatio);
              // vB += m_invMassB * m_impulse;
              vB.x += this.m_invMassB * this.m_impulse.x;
              vB.y += this.m_invMassB * this.m_impulse.y;
              wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, this.m_impulse);
          }
          else {
              this.m_impulse.SetZero();
          }
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // Cdot = v + cross(w, r)
          // b2Vec2 Cdot = vB + b2Cross(wB, m_rB);
          const Cdot = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2MouseJoint.SolveVelocityConstraints_s_Cdot);
          //  b2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_C + m_gamma * m_impulse));
          const impulse = b2Mat22.MulMV(this.m_mass, b2Vec2.AddVV(Cdot, b2Vec2.AddVV(this.m_C, b2Vec2.MulSV(this.m_gamma, this.m_impulse, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.s_t0).SelfNeg(), b2MouseJoint.SolveVelocityConstraints_s_impulse);
          // b2Vec2 oldImpulse = m_impulse;
          const oldImpulse = b2MouseJoint.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);
          // m_impulse += impulse;
          this.m_impulse.SelfAdd(impulse);
          const maxImpulse = data.step.dt * this.m_maxForce;
          if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
              this.m_impulse.SelfMul(maxImpulse / this.m_impulse.Length());
          }
          // impulse = m_impulse - oldImpulse;
          b2Vec2.SubVV(this.m_impulse, oldImpulse, impulse);
          // vB += m_invMassB * impulse;
          vB.SelfMulAdd(this.m_invMassB, impulse);
          wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, impulse);
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          return true;
      }
      GetAnchorA(out) {
          out.x = this.m_targetA.x;
          out.y = this.m_targetA.y;
          return out;
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          return b2Vec2.MulSV(inv_dt, this.m_impulse, out);
      }
      GetReactionTorque(inv_dt) {
          return 0;
      }
      Dump(log) {
          log("Mouse joint dumping is not supported.\n");
      }
      ShiftOrigin(newOrigin) {
          this.m_targetA.SelfSub(newOrigin);
      }
  }
  b2MouseJoint.SolveVelocityConstraints_s_Cdot = new b2Vec2();
  b2MouseJoint.SolveVelocityConstraints_s_impulse = new b2Vec2();
  b2MouseJoint.SolveVelocityConstraints_s_oldImpulse = new b2Vec2();

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Prismatic joint definition. This requires defining a line of
  /// motion using an axis and an anchor point. The definition uses local
  /// anchor points and a local axis so that the initial configuration
  /// can violate the constraint slightly. The joint translation is zero
  /// when the local anchor points coincide in world space. Using local
  /// anchors and a local axis helps when saving and loading a game.
  class b2PrismaticJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_prismaticJoint);
          this.localAnchorA = new b2Vec2();
          this.localAnchorB = new b2Vec2();
          this.localAxisA = new b2Vec2(1, 0);
          this.referenceAngle = 0;
          this.enableLimit = false;
          this.lowerTranslation = 0;
          this.upperTranslation = 0;
          this.enableMotor = false;
          this.maxMotorForce = 0;
          this.motorSpeed = 0;
      }
      Initialize(bA, bB, anchor, axis) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.bodyA.GetLocalVector(axis, this.localAxisA);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }
  }
  // Linear constraint (point-to-line)
  // d = p2 - p1 = x2 + r2 - x1 - r1
  // C = dot(perp, d)
  // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 - cross(w1, r1))
  //      = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) + dot(cross(r2, perp), v2)
  // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]
  //
  // Angular constraint
  // C = a2 - a1 + a_initial
  // Cdot = w2 - w1
  // J = [0 0 -1 0 0 1]
  //
  // K = J * invM * JT
  //
  // J = [-a -s1 a s2]
  //     [0  -1  0  1]
  // a = perp
  // s1 = cross(d + r1, a) = cross(p2 - x1, a)
  // s2 = cross(r2, a) = cross(p2 - x2, a)
  // Motor/Limit linear constraint
  // C = dot(ax1, d)
  // Cdot = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) + dot(cross(r2, ax1), v2)
  // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]
  // Predictive limit is applied even when the limit is not active.
  // Prevents a constraint speed that can lead to a constraint error in one time step.
  // Want C2 = C1 + h * Cdot >= 0
  // Or:
  // Cdot + C1/h >= 0
  // I do not apply a negative constraint error because that is handled in position correction.
  // So:
  // Cdot + max(C1, 0)/h >= 0
  // Block Solver
  // We develop a block solver that includes the angular and linear constraints. This makes the limit stiffer.
  //
  // The Jacobian has 2 rows:
  // J = [-uT -s1 uT s2] // linear
  //     [0   -1   0  1] // angular
  //
  // u = perp
  // s1 = cross(d + r1, u), s2 = cross(r2, u)
  // a1 = cross(d + r1, v), a2 = cross(r2, v)
  class b2PrismaticJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_localXAxisA = new b2Vec2();
          this.m_localYAxisA = new b2Vec2();
          this.m_referenceAngle = 0;
          this.m_impulse = new b2Vec2(0, 0);
          this.m_motorImpulse = 0;
          this.m_lowerImpulse = 0;
          this.m_upperImpulse = 0;
          this.m_lowerTranslation = 0;
          this.m_upperTranslation = 0;
          this.m_maxMotorForce = 0;
          this.m_motorSpeed = 0;
          this.m_enableLimit = false;
          this.m_enableMotor = false;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_axis = new b2Vec2(0, 0);
          this.m_perp = new b2Vec2(0, 0);
          this.m_s1 = 0;
          this.m_s2 = 0;
          this.m_a1 = 0;
          this.m_a2 = 0;
          this.m_K = new b2Mat22();
          this.m_K3 = new b2Mat33();
          this.m_K2 = new b2Mat22();
          this.m_translation = 0;
          this.m_axialMass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          this.m_localXAxisA.Copy(b2Maybe(def.localAxisA, new b2Vec2(1, 0))).SelfNormalize();
          b2Vec2.CrossOneV(this.m_localXAxisA, this.m_localYAxisA);
          this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);
          this.m_lowerTranslation = b2Maybe(def.lowerTranslation, 0);
          this.m_upperTranslation = b2Maybe(def.upperTranslation, 0);
          // b2Assert(this.m_lowerTranslation <= this.m_upperTranslation);
          this.m_maxMotorForce = b2Maybe(def.maxMotorForce, 0);
          this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);
          this.m_enableLimit = b2Maybe(def.enableLimit, false);
          this.m_enableMotor = b2Maybe(def.enableMotor, false);
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const cA = data.positions[this.m_indexA].c;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const cB = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // Compute the effective masses.
          // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // b2Vec2 d = (cB - cA) + rB - rA;
          const d = b2Vec2.AddVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), b2Vec2.SubVV(rB, rA, b2Vec2.s_t1), b2PrismaticJoint.InitVelocityConstraints_s_d);
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          // Compute motor Jacobian and effective mass.
          {
              // m_axis = b2Mul(qA, m_localXAxisA);
              b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);
              // m_a1 = b2Cross(d + rA, m_axis);
              this.m_a1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_axis);
              // m_a2 = b2Cross(rB, m_axis);
              this.m_a2 = b2Vec2.CrossVV(rB, this.m_axis);
              this.m_axialMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
              if (this.m_axialMass > 0) {
                  this.m_axialMass = 1 / this.m_axialMass;
              }
          }
          // Prismatic constraint.
          {
              // m_perp = b2Mul(qA, m_localYAxisA);
              b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);
              // m_s1 = b2Cross(d + rA, m_perp);
              this.m_s1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_perp);
              // m_s2 = b2Cross(rB, m_perp);
              this.m_s2 = b2Vec2.CrossVV(rB, this.m_perp);
              // float32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;
              this.m_K.ex.x = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
              // float32 k12 = iA * m_s1 + iB * m_s2;
              this.m_K.ex.y = iA * this.m_s1 + iB * this.m_s2;
              this.m_K.ey.x = this.m_K.ex.y;
              // float32 k22 = iA + iB;
              this.m_K.ey.y = iA + iB;
              if (this.m_K.ey.y === 0) {
                  // For bodies with fixed rotation.
                  this.m_K.ey.y = 1;
              }
              // m_K.ex.Set(k11, k12);
              // m_K.ey.Set(k12, k22);
          }
          // Compute motor and limit terms.
          if (this.m_enableLimit) {
              this.m_translation = b2Vec2.DotVV(this.m_axis, d);
          }
          else {
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
          if (!this.m_enableMotor) {
              this.m_motorImpulse = 0;
          }
          if (data.step.warmStarting) {
              // Account for variable time step.
              // m_impulse *= data.step.dtRatio;
              this.m_impulse.SelfMul(data.step.dtRatio);
              this.m_motorImpulse *= data.step.dtRatio;
              this.m_lowerImpulse *= data.step.dtRatio;
              this.m_upperImpulse *= data.step.dtRatio;
              const axialImpulse = this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse;
              // b2Vec2 P = m_impulse.x * m_perp + axialImpulse * m_axis;
              const P = b2Vec2.AddVV(b2Vec2.MulSV(this.m_impulse.x, this.m_perp, b2Vec2.s_t0), b2Vec2.MulSV(axialImpulse, this.m_axis, b2Vec2.s_t1), b2PrismaticJoint.InitVelocityConstraints_s_P);
              // float LA = m_impulse.x * m_s1 + m_impulse.y + axialImpulse * m_a1;
              const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + axialImpulse * this.m_a1;
              // float LB = m_impulse.x * m_s2 + m_impulse.y + axialImpulse * m_a2;
              const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + axialImpulse * this.m_a2;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * LA;
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * LB;
          }
          else {
              this.m_impulse.SetZero();
              this.m_motorImpulse = 0.0;
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          // Solve linear motor constraint.
          if (this.m_enableMotor) {
              // float32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
              const Cdot = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;
              let impulse = this.m_axialMass * (this.m_motorSpeed - Cdot);
              const oldImpulse = this.m_motorImpulse;
              const maxImpulse = data.step.dt * this.m_maxMotorForce;
              this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
              impulse = this.m_motorImpulse - oldImpulse;
              // b2Vec2 P = impulse * m_axis;
              const P = b2Vec2.MulSV(impulse, this.m_axis, b2PrismaticJoint.SolveVelocityConstraints_s_P);
              const LA = impulse * this.m_a1;
              const LB = impulse * this.m_a2;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * LA;
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * LB;
          }
          if (this.m_enableLimit) {
              // Lower limit
              {
                  const C = this.m_translation - this.m_lowerTranslation;
                  const Cdot = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;
                  let impulse = -this.m_axialMass * (Cdot + b2Max(C, 0.0) * data.step.inv_dt);
                  const oldImpulse = this.m_lowerImpulse;
                  this.m_lowerImpulse = b2Max(this.m_lowerImpulse + impulse, 0.0);
                  impulse = this.m_lowerImpulse - oldImpulse;
                  // b2Vec2 P = impulse * this.m_axis;
                  const P = b2Vec2.MulSV(impulse, this.m_axis, b2PrismaticJoint.SolveVelocityConstraints_s_P);
                  const LA = impulse * this.m_a1;
                  const LB = impulse * this.m_a2;
                  // vA -= mA * P;
                  vA.SelfMulSub(mA, P);
                  wA -= iA * LA;
                  // vB += mB * P;
                  vB.SelfMulAdd(mB, P);
                  wB += iB * LB;
              }
              // Upper limit
              // Note: signs are flipped to keep C positive when the constraint is satisfied.
              // This also keeps the impulse positive when the limit is active.
              {
                  const C = this.m_upperTranslation - this.m_translation;
                  const Cdot = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vA, vB, b2Vec2.s_t0)) + this.m_a1 * wA - this.m_a2 * wB;
                  let impulse = -this.m_axialMass * (Cdot + b2Max(C, 0.0) * data.step.inv_dt);
                  const oldImpulse = this.m_upperImpulse;
                  this.m_upperImpulse = b2Max(this.m_upperImpulse + impulse, 0.0);
                  impulse = this.m_upperImpulse - oldImpulse;
                  // b2Vec2 P = impulse * this.m_axis;
                  const P = b2Vec2.MulSV(impulse, this.m_axis, b2PrismaticJoint.SolveVelocityConstraints_s_P);
                  const LA = impulse * this.m_a1;
                  const LB = impulse * this.m_a2;
                  // vA += mA * P;
                  vA.SelfMulAdd(mA, P);
                  wA += iA * LA;
                  // vB -= mB * P;
                  vB.SelfMulSub(mB, P);
                  wB -= iB * LB;
              }
          }
          // Solve the prismatic constraint in block form.
          {
              // b2Vec2 Cdot;
              // Cdot.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;
              const Cdot_x = b2Vec2.DotVV(this.m_perp, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_s2 * wB - this.m_s1 * wA;
              // Cdot.y = wB - wA;
              const Cdot_y = wB - wA;
              // b2Vec2 df = m_K.Solve(-Cdot);
              const df = this.m_K.Solve(-Cdot_x, -Cdot_y, b2PrismaticJoint.SolveVelocityConstraints_s_df);
              // m_impulse += df;
              this.m_impulse.SelfAdd(df);
              // b2Vec2 P = df.x * m_perp;
              const P = b2Vec2.MulSV(df.x, this.m_perp, b2PrismaticJoint.SolveVelocityConstraints_s_P);
              // float32 LA = df.x * m_s1 + df.y;
              const LA = df.x * this.m_s1 + df.y;
              // float32 LB = df.x * m_s2 + df.y;
              const LB = df.x * this.m_s2 + df.y;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * LA;
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * LB;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // b2Vec2 d = cB + rB - cA - rA;
          const d = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2PrismaticJoint.SolvePositionConstraints_s_d);
          // b2Vec2 axis = b2Mul(qA, m_localXAxisA);
          const axis = b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);
          // float32 a1 = b2Cross(d + rA, axis);
          const a1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), axis);
          // float32 a2 = b2Cross(rB, axis);
          const a2 = b2Vec2.CrossVV(rB, axis);
          // b2Vec2 perp = b2Mul(qA, m_localYAxisA);
          const perp = b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);
          // float32 s1 = b2Cross(d + rA, perp);
          const s1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), perp);
          // float32 s2 = b2Cross(rB, perp);
          const s2 = b2Vec2.CrossVV(rB, perp);
          // b2Vec3 impulse;
          let impulse = b2PrismaticJoint.SolvePositionConstraints_s_impulse;
          // b2Vec2 C1;
          // C1.x = b2Dot(perp, d);
          const C1_x = b2Vec2.DotVV(perp, d);
          // C1.y = aB - aA - m_referenceAngle;
          const C1_y = aB - aA - this.m_referenceAngle;
          let linearError = b2Abs(C1_x);
          const angularError = b2Abs(C1_y);
          let active = false;
          let C2 = 0;
          if (this.m_enableLimit) {
              // float32 translation = b2Dot(axis, d);
              const translation = b2Vec2.DotVV(axis, d);
              if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {
                  C2 = translation;
                  linearError = b2Max(linearError, b2Abs(translation));
                  active = true;
              }
              else if (translation <= this.m_lowerTranslation) {
                  C2 = b2Min(translation - this.m_lowerTranslation, 0.0);
                  linearError = b2Max(linearError, this.m_lowerTranslation - translation);
                  active = true;
              }
              else if (translation >= this.m_upperTranslation) {
                  C2 = b2Max(translation - this.m_upperTranslation, 0.0);
                  linearError = b2Max(linearError, translation - this.m_upperTranslation);
                  active = true;
              }
          }
          if (active) {
              // float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
              const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
              // float32 k12 = iA * s1 + iB * s2;
              const k12 = iA * s1 + iB * s2;
              // float32 k13 = iA * s1 * a1 + iB * s2 * a2;
              const k13 = iA * s1 * a1 + iB * s2 * a2;
              // float32 k22 = iA + iB;
              let k22 = iA + iB;
              if (k22 === 0) {
                  // For fixed rotation
                  k22 = 1;
              }
              // float32 k23 = iA * a1 + iB * a2;
              const k23 = iA * a1 + iB * a2;
              // float32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
              const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
              // b2Mat33 K;
              const K = this.m_K3;
              // K.ex.Set(k11, k12, k13);
              K.ex.SetXYZ(k11, k12, k13);
              // K.ey.Set(k12, k22, k23);
              K.ey.SetXYZ(k12, k22, k23);
              // K.ez.Set(k13, k23, k33);
              K.ez.SetXYZ(k13, k23, k33);
              // b2Vec3 C;
              // C.x = C1.x;
              // C.y = C1.y;
              // C.z = C2;
              // impulse = K.Solve33(-C);
              impulse = K.Solve33((-C1_x), (-C1_y), (-C2), impulse);
          }
          else {
              // float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
              const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
              // float32 k12 = iA * s1 + iB * s2;
              const k12 = iA * s1 + iB * s2;
              // float32 k22 = iA + iB;
              let k22 = iA + iB;
              if (k22 === 0) {
                  k22 = 1;
              }
              // b2Mat22 K;
              const K2 = this.m_K2;
              // K.ex.Set(k11, k12);
              K2.ex.Set(k11, k12);
              // K.ey.Set(k12, k22);
              K2.ey.Set(k12, k22);
              // b2Vec2 impulse1 = K.Solve(-C1);
              const impulse1 = K2.Solve((-C1_x), (-C1_y), b2PrismaticJoint.SolvePositionConstraints_s_impulse1);
              impulse.x = impulse1.x;
              impulse.y = impulse1.y;
              impulse.z = 0;
          }
          // b2Vec2 P = impulse.x * perp + impulse.z * axis;
          const P = b2Vec2.AddVV(b2Vec2.MulSV(impulse.x, perp, b2Vec2.s_t0), b2Vec2.MulSV(impulse.z, axis, b2Vec2.s_t1), b2PrismaticJoint.SolvePositionConstraints_s_P);
          // float32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;
          const LA = impulse.x * s1 + impulse.y + impulse.z * a1;
          // float32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;
          const LB = impulse.x * s2 + impulse.y + impulse.z * a2;
          // cA -= mA * P;
          cA.SelfMulSub(mA, P);
          aA -= iA * LA;
          // cB += mB * P;
          cB.SelfMulAdd(mB, P);
          aB += iB * LB;
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          return linearError <= b2_linearSlop && angularError <= b2_angularSlop;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          out.x = inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse) * this.m_axis.x);
          out.y = inv_dt * (this.m_impulse.y * this.m_perp.y + (this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse) * this.m_axis.y);
          return out;
      }
      GetReactionTorque(inv_dt) {
          return inv_dt * this.m_impulse.y;
      }
      GetLocalAnchorA() { return this.m_localAnchorA; }
      GetLocalAnchorB() { return this.m_localAnchorB; }
      GetLocalAxisA() { return this.m_localXAxisA; }
      GetReferenceAngle() { return this.m_referenceAngle; }
      GetJointTranslation() {
          // b2Vec2 pA = m_bodyA.GetWorldPoint(m_localAnchorA);
          const pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, b2PrismaticJoint.GetJointTranslation_s_pA);
          // b2Vec2 pB = m_bodyB.GetWorldPoint(m_localAnchorB);
          const pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, b2PrismaticJoint.GetJointTranslation_s_pB);
          // b2Vec2 d = pB - pA;
          const d = b2Vec2.SubVV(pB, pA, b2PrismaticJoint.GetJointTranslation_s_d);
          // b2Vec2 axis = m_bodyA.GetWorldVector(m_localXAxisA);
          const axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA, b2PrismaticJoint.GetJointTranslation_s_axis);
          // float32 translation = b2Dot(d, axis);
          const translation = b2Vec2.DotVV(d, axis);
          return translation;
      }
      GetJointSpeed() {
          const bA = this.m_bodyA;
          const bB = this.m_bodyB;
          // b2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);
          b2Vec2.SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);
          const rA = b2Rot.MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);
          b2Vec2.SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);
          const rB = b2Rot.MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);
          // b2Vec2 pA = bA->m_sweep.c + rA;
          const pA = b2Vec2.AddVV(bA.m_sweep.c, rA, b2Vec2.s_t0); // pA uses s_t0
          // b2Vec2 pB = bB->m_sweep.c + rB;
          const pB = b2Vec2.AddVV(bB.m_sweep.c, rB, b2Vec2.s_t1); // pB uses s_t1
          // b2Vec2 d = pB - pA;
          const d = b2Vec2.SubVV(pB, pA, b2Vec2.s_t2); // d uses s_t2
          // b2Vec2 axis = b2Mul(bA.m_xf.q, m_localXAxisA);
          const axis = bA.GetWorldVector(this.m_localXAxisA, this.m_axis);
          const vA = bA.m_linearVelocity;
          const vB = bB.m_linearVelocity;
          const wA = bA.m_angularVelocity;
          const wB = bB.m_angularVelocity;
          // float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));
          const speed = b2Vec2.DotVV(d, b2Vec2.CrossSV(wA, axis, b2Vec2.s_t0)) +
              b2Vec2.DotVV(axis, b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, rA, b2Vec2.s_t1), b2Vec2.s_t0));
          return speed;
      }
      IsLimitEnabled() {
          return this.m_enableLimit;
      }
      EnableLimit(flag) {
          if (flag !== this.m_enableLimit) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_enableLimit = flag;
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
      }
      GetLowerLimit() {
          return this.m_lowerTranslation;
      }
      GetUpperLimit() {
          return this.m_upperTranslation;
      }
      SetLimits(lower, upper) {
          if (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_lowerTranslation = lower;
              this.m_upperTranslation = upper;
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
      }
      IsMotorEnabled() {
          return this.m_enableMotor;
      }
      EnableMotor(flag) {
          if (flag !== this.m_enableMotor) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_enableMotor = flag;
          }
      }
      SetMotorSpeed(speed) {
          if (speed !== this.m_motorSpeed) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_motorSpeed = speed;
          }
      }
      GetMotorSpeed() {
          return this.m_motorSpeed;
      }
      SetMaxMotorForce(force) {
          if (force !== this.m_maxMotorForce) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_maxMotorForce = force;
          }
      }
      GetMaxMotorForce() { return this.m_maxMotorForce; }
      GetMotorForce(inv_dt) {
          return inv_dt * this.m_motorImpulse;
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
          log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
          log("  jd.enableLimit = %s;\n", (this.m_enableLimit) ? ("true") : ("false"));
          log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation);
          log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation);
          log("  jd.enableMotor = %s;\n", (this.m_enableMotor) ? ("true") : ("false"));
          log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
          log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
      Draw(draw) {
          const xfA = this.m_bodyA.GetTransform();
          const xfB = this.m_bodyB.GetTransform();
          const pA = b2Transform.MulXV(xfA, this.m_localAnchorA, b2PrismaticJoint.Draw_s_pA);
          const pB = b2Transform.MulXV(xfB, this.m_localAnchorB, b2PrismaticJoint.Draw_s_pB);
          // b2Vec2 axis = b2Mul(xfA.q, m_localXAxisA);
          const axis = b2Rot.MulRV(xfA.q, this.m_localXAxisA, b2PrismaticJoint.Draw_s_axis);
          const c1 = b2PrismaticJoint.Draw_s_c1; // b2Color c1(0.7f, 0.7f, 0.7f);
          const c2 = b2PrismaticJoint.Draw_s_c2; // b2Color c2(0.3f, 0.9f, 0.3f);
          const c3 = b2PrismaticJoint.Draw_s_c3; // b2Color c3(0.9f, 0.3f, 0.3f);
          const c4 = b2PrismaticJoint.Draw_s_c4; // b2Color c4(0.3f, 0.3f, 0.9f);
          const c5 = b2PrismaticJoint.Draw_s_c5; // b2Color c5(0.4f, 0.4f, 0.4f);
          draw.DrawSegment(pA, pB, c5);
          if (this.m_enableLimit) {
              // b2Vec2 lower = pA + m_lowerTranslation * axis;
              const lower = b2Vec2.AddVMulSV(pA, this.m_lowerTranslation, axis, b2PrismaticJoint.Draw_s_lower);
              // b2Vec2 upper = pA + m_upperTranslation * axis;
              const upper = b2Vec2.AddVMulSV(pA, this.m_upperTranslation, axis, b2PrismaticJoint.Draw_s_upper);
              // b2Vec2 perp = b2Mul(xfA.q, m_localYAxisA);
              const perp = b2Rot.MulRV(xfA.q, this.m_localYAxisA, b2PrismaticJoint.Draw_s_perp);
              draw.DrawSegment(lower, upper, c1);
              // draw.DrawSegment(lower - 0.5 * perp, lower + 0.5 * perp, c2);
              draw.DrawSegment(b2Vec2.AddVMulSV(lower, -0.5, perp, b2Vec2.s_t0), b2Vec2.AddVMulSV(lower, 0.5, perp, b2Vec2.s_t1), c2);
              // draw.DrawSegment(upper - 0.5 * perp, upper + 0.5 * perp, c3);
              draw.DrawSegment(b2Vec2.AddVMulSV(upper, -0.5, perp, b2Vec2.s_t0), b2Vec2.AddVMulSV(upper, 0.5, perp, b2Vec2.s_t1), c3);
          }
          else {
              // draw.DrawSegment(pA - 1.0 * axis, pA + 1.0 * axis, c1);
              draw.DrawSegment(b2Vec2.AddVMulSV(pA, -1.0, axis, b2Vec2.s_t0), b2Vec2.AddVMulSV(pA, 1.0, axis, b2Vec2.s_t1), c1);
          }
          draw.DrawPoint(pA, 5.0, c1);
          draw.DrawPoint(pB, 5.0, c4);
      }
  }
  b2PrismaticJoint.InitVelocityConstraints_s_d = new b2Vec2();
  b2PrismaticJoint.InitVelocityConstraints_s_P = new b2Vec2();
  b2PrismaticJoint.SolveVelocityConstraints_s_P = new b2Vec2();
  // private static SolveVelocityConstraints_s_f2r = new b2Vec2();
  // private static SolveVelocityConstraints_s_f1 = new b2Vec3();
  // private static SolveVelocityConstraints_s_df3 = new b2Vec3();
  b2PrismaticJoint.SolveVelocityConstraints_s_df = new b2Vec2();
  // A velocity based solver computes reaction forces(impulses) using the velocity constraint solver.Under this context,
  // the position solver is not there to resolve forces.It is only there to cope with integration error.
  //
  // Therefore, the pseudo impulses in the position solver do not have any physical meaning.Thus it is okay if they suck.
  //
  // We could take the active state from the velocity solver.However, the joint might push past the limit when the velocity
  // solver indicates the limit is inactive.
  b2PrismaticJoint.SolvePositionConstraints_s_d = new b2Vec2();
  b2PrismaticJoint.SolvePositionConstraints_s_impulse = new b2Vec3();
  b2PrismaticJoint.SolvePositionConstraints_s_impulse1 = new b2Vec2();
  b2PrismaticJoint.SolvePositionConstraints_s_P = new b2Vec2();
  b2PrismaticJoint.GetJointTranslation_s_pA = new b2Vec2();
  b2PrismaticJoint.GetJointTranslation_s_pB = new b2Vec2();
  b2PrismaticJoint.GetJointTranslation_s_d = new b2Vec2();
  b2PrismaticJoint.GetJointTranslation_s_axis = new b2Vec2();
  b2PrismaticJoint.Draw_s_pA = new b2Vec2();
  b2PrismaticJoint.Draw_s_pB = new b2Vec2();
  b2PrismaticJoint.Draw_s_axis = new b2Vec2();
  b2PrismaticJoint.Draw_s_c1 = new b2Color(0.7, 0.7, 0.7);
  b2PrismaticJoint.Draw_s_c2 = new b2Color(0.3, 0.9, 0.3);
  b2PrismaticJoint.Draw_s_c3 = new b2Color(0.9, 0.3, 0.3);
  b2PrismaticJoint.Draw_s_c4 = new b2Color(0.3, 0.3, 0.9);
  b2PrismaticJoint.Draw_s_c5 = new b2Color(0.4, 0.4, 0.4);
  b2PrismaticJoint.Draw_s_lower = new b2Vec2();
  b2PrismaticJoint.Draw_s_upper = new b2Vec2();
  b2PrismaticJoint.Draw_s_perp = new b2Vec2();

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  const b2_minPulleyLength = 2;
  /// Pulley joint definition. This requires two ground anchors,
  /// two dynamic body anchor points, and a pulley ratio.
  class b2PulleyJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_pulleyJoint);
          this.groundAnchorA = new b2Vec2(-1, 1);
          this.groundAnchorB = new b2Vec2(1, 1);
          this.localAnchorA = new b2Vec2(-1, 0);
          this.localAnchorB = new b2Vec2(1, 0);
          this.lengthA = 0;
          this.lengthB = 0;
          this.ratio = 1;
          this.collideConnected = true;
      }
      Initialize(bA, bB, groundA, groundB, anchorA, anchorB, r) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.groundAnchorA.Copy(groundA);
          this.groundAnchorB.Copy(groundB);
          this.bodyA.GetLocalPoint(anchorA, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchorB, this.localAnchorB);
          this.lengthA = b2Vec2.DistanceVV(anchorA, groundA);
          this.lengthB = b2Vec2.DistanceVV(anchorB, groundB);
          this.ratio = r;
          // DEBUG: b2Assert(this.ratio > b2_epsilon);
      }
  }
  class b2PulleyJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_groundAnchorA = new b2Vec2();
          this.m_groundAnchorB = new b2Vec2();
          this.m_lengthA = 0;
          this.m_lengthB = 0;
          // Solver shared
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_constant = 0;
          this.m_ratio = 0;
          this.m_impulse = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_uA = new b2Vec2();
          this.m_uB = new b2Vec2();
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_mass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_groundAnchorA.Copy(b2Maybe(def.groundAnchorA, new b2Vec2(-1, 1)));
          this.m_groundAnchorB.Copy(b2Maybe(def.groundAnchorB, new b2Vec2(1, 0)));
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, new b2Vec2(-1, 0)));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, new b2Vec2(1, 0)));
          this.m_lengthA = b2Maybe(def.lengthA, 0);
          this.m_lengthB = b2Maybe(def.lengthB, 0);
          // DEBUG: b2Assert(b2Maybe(def.ratio, 1) !== 0);
          this.m_ratio = b2Maybe(def.ratio, 1);
          this.m_constant = b2Maybe(def.lengthA, 0) + this.m_ratio * b2Maybe(def.lengthB, 0);
          this.m_impulse = 0;
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const cA = data.positions[this.m_indexA].c;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const cB = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // b2Rot qA(aA), qB(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // Get the pulley axes.
          // m_uA = cA + m_rA - m_groundAnchorA;
          this.m_uA.Copy(cA).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);
          // m_uB = cB + m_rB - m_groundAnchorB;
          this.m_uB.Copy(cB).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
          const lengthA = this.m_uA.Length();
          const lengthB = this.m_uB.Length();
          if (lengthA > 10 * b2_linearSlop) {
              this.m_uA.SelfMul(1 / lengthA);
          }
          else {
              this.m_uA.SetZero();
          }
          if (lengthB > 10 * b2_linearSlop) {
              this.m_uB.SelfMul(1 / lengthB);
          }
          else {
              this.m_uB.SetZero();
          }
          // Compute effective mass.
          const ruA = b2Vec2.CrossVV(this.m_rA, this.m_uA);
          const ruB = b2Vec2.CrossVV(this.m_rB, this.m_uB);
          const mA = this.m_invMassA + this.m_invIA * ruA * ruA;
          const mB = this.m_invMassB + this.m_invIB * ruB * ruB;
          this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
          if (this.m_mass > 0) {
              this.m_mass = 1 / this.m_mass;
          }
          if (data.step.warmStarting) {
              // Scale impulses to support variable time steps.
              this.m_impulse *= data.step.dtRatio;
              // Warm starting.
              // b2Vec2 PA = -(m_impulse) * m_uA;
              const PA = b2Vec2.MulSV(-(this.m_impulse), this.m_uA, b2PulleyJoint.InitVelocityConstraints_s_PA);
              // b2Vec2 PB = (-m_ratio * m_impulse) * m_uB;
              const PB = b2Vec2.MulSV((-this.m_ratio * this.m_impulse), this.m_uB, b2PulleyJoint.InitVelocityConstraints_s_PB);
              // vA += m_invMassA * PA;
              vA.SelfMulAdd(this.m_invMassA, PA);
              wA += this.m_invIA * b2Vec2.CrossVV(this.m_rA, PA);
              // vB += m_invMassB * PB;
              vB.SelfMulAdd(this.m_invMassB, PB);
              wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, PB);
          }
          else {
              this.m_impulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // b2Vec2 vpA = vA + b2Cross(wA, m_rA);
          const vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2PulleyJoint.SolveVelocityConstraints_s_vpA);
          // b2Vec2 vpB = vB + b2Cross(wB, m_rB);
          const vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2PulleyJoint.SolveVelocityConstraints_s_vpB);
          const Cdot = -b2Vec2.DotVV(this.m_uA, vpA) - this.m_ratio * b2Vec2.DotVV(this.m_uB, vpB);
          const impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          // b2Vec2 PA = -impulse * m_uA;
          const PA = b2Vec2.MulSV(-impulse, this.m_uA, b2PulleyJoint.SolveVelocityConstraints_s_PA);
          // b2Vec2 PB = -m_ratio * impulse * m_uB;
          const PB = b2Vec2.MulSV(-this.m_ratio * impulse, this.m_uB, b2PulleyJoint.SolveVelocityConstraints_s_PB);
          // vA += m_invMassA * PA;
          vA.SelfMulAdd(this.m_invMassA, PA);
          wA += this.m_invIA * b2Vec2.CrossVV(this.m_rA, PA);
          // vB += m_invMassB * PB;
          vB.SelfMulAdd(this.m_invMassB, PB);
          wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, PB);
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          // b2Rot qA(aA), qB(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // Get the pulley axes.
          // b2Vec2 uA = cA + rA - m_groundAnchorA;
          const uA = this.m_uA.Copy(cA).SelfAdd(rA).SelfSub(this.m_groundAnchorA);
          // b2Vec2 uB = cB + rB - m_groundAnchorB;
          const uB = this.m_uB.Copy(cB).SelfAdd(rB).SelfSub(this.m_groundAnchorB);
          const lengthA = uA.Length();
          const lengthB = uB.Length();
          if (lengthA > 10 * b2_linearSlop) {
              uA.SelfMul(1 / lengthA);
          }
          else {
              uA.SetZero();
          }
          if (lengthB > 10 * b2_linearSlop) {
              uB.SelfMul(1 / lengthB);
          }
          else {
              uB.SetZero();
          }
          // Compute effective mass.
          const ruA = b2Vec2.CrossVV(rA, uA);
          const ruB = b2Vec2.CrossVV(rB, uB);
          const mA = this.m_invMassA + this.m_invIA * ruA * ruA;
          const mB = this.m_invMassB + this.m_invIB * ruB * ruB;
          let mass = mA + this.m_ratio * this.m_ratio * mB;
          if (mass > 0) {
              mass = 1 / mass;
          }
          const C = this.m_constant - lengthA - this.m_ratio * lengthB;
          const linearError = b2Abs(C);
          const impulse = -mass * C;
          // b2Vec2 PA = -impulse * uA;
          const PA = b2Vec2.MulSV(-impulse, uA, b2PulleyJoint.SolvePositionConstraints_s_PA);
          // b2Vec2 PB = -m_ratio * impulse * uB;
          const PB = b2Vec2.MulSV(-this.m_ratio * impulse, uB, b2PulleyJoint.SolvePositionConstraints_s_PB);
          // cA += m_invMassA * PA;
          cA.SelfMulAdd(this.m_invMassA, PA);
          aA += this.m_invIA * b2Vec2.CrossVV(rA, PA);
          // cB += m_invMassB * PB;
          cB.SelfMulAdd(this.m_invMassB, PB);
          aB += this.m_invIB * b2Vec2.CrossVV(rB, PB);
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          return linearError < b2_linearSlop;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          // b2Vec2 P = m_impulse * m_uB;
          // return inv_dt * P;
          out.x = inv_dt * this.m_impulse * this.m_uB.x;
          out.y = inv_dt * this.m_impulse * this.m_uB.y;
          return out;
      }
      GetReactionTorque(inv_dt) {
          return 0;
      }
      GetGroundAnchorA() {
          return this.m_groundAnchorA;
      }
      GetGroundAnchorB() {
          return this.m_groundAnchorB;
      }
      GetLengthA() {
          return this.m_lengthA;
      }
      GetLengthB() {
          return this.m_lengthB;
      }
      GetRatio() {
          return this.m_ratio;
      }
      GetCurrentLengthA() {
          // b2Vec2 p = m_bodyA->GetWorldPoint(m_localAnchorA);
          // b2Vec2 s = m_groundAnchorA;
          // b2Vec2 d = p - s;
          // return d.Length();
          const p = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, b2PulleyJoint.GetCurrentLengthA_s_p);
          const s = this.m_groundAnchorA;
          return b2Vec2.DistanceVV(p, s);
      }
      GetCurrentLengthB() {
          // b2Vec2 p = m_bodyB->GetWorldPoint(m_localAnchorB);
          // b2Vec2 s = m_groundAnchorB;
          // b2Vec2 d = p - s;
          // return d.Length();
          const p = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, b2PulleyJoint.GetCurrentLengthB_s_p);
          const s = this.m_groundAnchorB;
          return b2Vec2.DistanceVV(p, s);
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.groundAnchorA.Set(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y);
          log("  jd.groundAnchorB.Set(%.15f, %.15f);\n", this.m_groundAnchorB.x, this.m_groundAnchorB.y);
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.lengthA = %.15f;\n", this.m_lengthA);
          log("  jd.lengthB = %.15f;\n", this.m_lengthB);
          log("  jd.ratio = %.15f;\n", this.m_ratio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
      ShiftOrigin(newOrigin) {
          this.m_groundAnchorA.SelfSub(newOrigin);
          this.m_groundAnchorB.SelfSub(newOrigin);
      }
  }
  b2PulleyJoint.InitVelocityConstraints_s_PA = new b2Vec2();
  b2PulleyJoint.InitVelocityConstraints_s_PB = new b2Vec2();
  b2PulleyJoint.SolveVelocityConstraints_s_vpA = new b2Vec2();
  b2PulleyJoint.SolveVelocityConstraints_s_vpB = new b2Vec2();
  b2PulleyJoint.SolveVelocityConstraints_s_PA = new b2Vec2();
  b2PulleyJoint.SolveVelocityConstraints_s_PB = new b2Vec2();
  b2PulleyJoint.SolvePositionConstraints_s_PA = new b2Vec2();
  b2PulleyJoint.SolvePositionConstraints_s_PB = new b2Vec2();
  b2PulleyJoint.GetCurrentLengthA_s_p = new b2Vec2();
  b2PulleyJoint.GetCurrentLengthB_s_p = new b2Vec2();

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Revolute joint definition. This requires defining an anchor point where the
  /// bodies are joined. The definition uses local anchor points so that the
  /// initial configuration can violate the constraint slightly. You also need to
  /// specify the initial relative angle for joint limits. This helps when saving
  /// and loading a game.
  /// The local anchor points are measured from the body's origin
  /// rather than the center of mass because:
  /// 1. you might not know where the center of mass will be.
  /// 2. if you add/remove shapes from a body and recompute the mass,
  ///    the joints will be broken.
  class b2RevoluteJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_revoluteJoint);
          this.localAnchorA = new b2Vec2(0, 0);
          this.localAnchorB = new b2Vec2(0, 0);
          this.referenceAngle = 0;
          this.enableLimit = false;
          this.lowerAngle = 0;
          this.upperAngle = 0;
          this.enableMotor = false;
          this.motorSpeed = 0;
          this.maxMotorTorque = 0;
      }
      Initialize(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }
  }
  class b2RevoluteJoint extends b2Joint {
      constructor(def) {
          super(def);
          // Solver shared
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_impulse = new b2Vec2();
          this.m_motorImpulse = 0;
          this.m_lowerImpulse = 0;
          this.m_upperImpulse = 0;
          this.m_enableMotor = false;
          this.m_maxMotorTorque = 0;
          this.m_motorSpeed = 0;
          this.m_enableLimit = false;
          this.m_referenceAngle = 0;
          this.m_lowerAngle = 0;
          this.m_upperAngle = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_K = new b2Mat22();
          this.m_angle = 0;
          this.m_axialMass = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);
          this.m_impulse.SetZero();
          this.m_motorImpulse = 0;
          this.m_lowerAngle = b2Maybe(def.lowerAngle, 0);
          this.m_upperAngle = b2Maybe(def.upperAngle, 0);
          this.m_maxMotorTorque = b2Maybe(def.maxMotorTorque, 0);
          this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);
          this.m_enableLimit = b2Maybe(def.enableLimit, false);
          this.m_enableMotor = b2Maybe(def.enableMotor, false);
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // b2Rot qA(aA), qB(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // J = [-I -r1_skew I r2_skew]
          // r_skew = [-ry; rx]
          // Matlab
          // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x]
          //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB]
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          this.m_K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
          this.m_K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
          this.m_K.ex.y = this.m_K.ey.x;
          this.m_K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
          this.m_axialMass = iA + iB;
          let fixedRotation;
          if (this.m_axialMass > 0.0) {
              this.m_axialMass = 1.0 / this.m_axialMass;
              fixedRotation = false;
          }
          else {
              fixedRotation = true;
          }
          this.m_angle = aB - aA - this.m_referenceAngle;
          if (this.m_enableLimit === false || fixedRotation) {
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
          if (this.m_enableMotor === false || fixedRotation) {
              this.m_motorImpulse = 0.0;
          }
          if (data.step.warmStarting) {
              // Scale impulses to support a variable time step.
              this.m_impulse.SelfMul(data.step.dtRatio);
              this.m_motorImpulse *= data.step.dtRatio;
              this.m_lowerImpulse *= data.step.dtRatio;
              this.m_upperImpulse *= data.step.dtRatio;
              const axialImpulse = this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse;
              // b2Vec2 P(m_impulse.x, m_impulse.y);
              const P = b2RevoluteJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x, this.m_impulse.y);
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + axialImpulse);
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + axialImpulse);
          }
          else {
              this.m_impulse.SetZero();
              this.m_motorImpulse = 0;
              this.m_lowerImpulse = 0;
              this.m_upperImpulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const fixedRotation = (iA + iB === 0);
          // Solve motor constraint.
          if (this.m_enableMotor && !fixedRotation) {
              const Cdot = wB - wA - this.m_motorSpeed;
              let impulse = -this.m_axialMass * Cdot;
              const oldImpulse = this.m_motorImpulse;
              const maxImpulse = data.step.dt * this.m_maxMotorTorque;
              this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
              impulse = this.m_motorImpulse - oldImpulse;
              wA -= iA * impulse;
              wB += iB * impulse;
          }
          // Solve limit constraint.
          if (this.m_enableLimit && !fixedRotation) {
              // Lower limit
              {
                  const C = this.m_angle - this.m_lowerAngle;
                  const Cdot = wB - wA;
                  let impulse = -this.m_axialMass * (Cdot + b2Max(C, 0.0) * data.step.inv_dt);
                  const oldImpulse = this.m_lowerImpulse;
                  this.m_lowerImpulse = b2Max(this.m_lowerImpulse + impulse, 0.0);
                  impulse = this.m_lowerImpulse - oldImpulse;
                  wA -= iA * impulse;
                  wB += iB * impulse;
              }
              // Upper limit
              // Note: signs are flipped to keep C positive when the constraint is satisfied.
              // This also keeps the impulse positive when the limit is active.
              {
                  const C = this.m_upperAngle - this.m_angle;
                  const Cdot = wA - wB;
                  let impulse = -this.m_axialMass * (Cdot + b2Max(C, 0.0) * data.step.inv_dt);
                  const oldImpulse = this.m_upperImpulse;
                  this.m_upperImpulse = b2Max(this.m_upperImpulse + impulse, 0.0);
                  impulse = this.m_upperImpulse - oldImpulse;
                  wA += iA * impulse;
                  wB -= iB * impulse;
              }
          }
          // Solve point-to-point constraint
          {
              // b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
              const Cdot_v2 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2);
              // b2Vec2 impulse = m_K.Solve(-Cdot);
              const impulse_v2 = this.m_K.Solve(-Cdot_v2.x, -Cdot_v2.y, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2);
              this.m_impulse.x += impulse_v2.x;
              this.m_impulse.y += impulse_v2.y;
              // vA -= mA * impulse;
              vA.SelfMulSub(mA, impulse_v2);
              wA -= iA * b2Vec2.CrossVV(this.m_rA, impulse_v2);
              // vB += mB * impulse;
              vB.SelfMulAdd(mB, impulse_v2);
              wB += iB * b2Vec2.CrossVV(this.m_rB, impulse_v2);
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          // b2Rot qA(aA), qB(aB);
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          let angularError = 0;
          let positionError = 0;
          const fixedRotation = (this.m_invIA + this.m_invIB === 0);
          // Solve angular limit constraint.
          if (this.m_enableLimit && !fixedRotation) {
              const angle = aB - aA - this.m_referenceAngle;
              let C = 0.0;
              if (b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2_angularSlop) {
                  // Prevent large angular corrections
                  C = b2Clamp(angle - this.m_lowerAngle, -b2_maxAngularCorrection, b2_maxAngularCorrection);
              }
              else if (angle <= this.m_lowerAngle) {
                  // Prevent large angular corrections and allow some slop.
                  C = b2Clamp(angle - this.m_lowerAngle + b2_angularSlop, -b2_maxAngularCorrection, 0.0);
              }
              else if (angle >= this.m_upperAngle) {
                  // Prevent large angular corrections and allow some slop.
                  C = b2Clamp(angle - this.m_upperAngle - b2_angularSlop, 0.0, b2_maxAngularCorrection);
              }
              const limitImpulse = -this.m_axialMass * C;
              aA -= this.m_invIA * limitImpulse;
              aB += this.m_invIB * limitImpulse;
              angularError = b2Abs(C);
          }
          // Solve point-to-point constraint.
          {
              qA.SetAngle(aA);
              qB.SetAngle(aB);
              // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
              b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
              const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
              // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
              b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
              const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
              // b2Vec2 C = cB + rB - cA - rA;
              const C_v2 = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2RevoluteJoint.SolvePositionConstraints_s_C_v2);
              // positionError = C.Length();
              positionError = C_v2.Length();
              const mA = this.m_invMassA, mB = this.m_invMassB;
              const iA = this.m_invIA, iB = this.m_invIB;
              const K = this.m_K;
              K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
              K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
              K.ey.x = K.ex.y;
              K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
              // b2Vec2 impulse = -K.Solve(C);
              const impulse = K.Solve(C_v2.x, C_v2.y, b2RevoluteJoint.SolvePositionConstraints_s_impulse).SelfNeg();
              // cA -= mA * impulse;
              cA.SelfMulSub(mA, impulse);
              aA -= iA * b2Vec2.CrossVV(rA, impulse);
              // cB += mB * impulse;
              cB.SelfMulAdd(mB, impulse);
              aB += iB * b2Vec2.CrossVV(rB, impulse);
          }
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          // b2Vec2 P(this.m_impulse.x, this.m_impulse.y);
          // return inv_dt * P;
          out.x = inv_dt * this.m_impulse.x;
          out.y = inv_dt * this.m_impulse.y;
          return out;
      }
      GetReactionTorque(inv_dt) {
          return inv_dt * (this.m_lowerImpulse - this.m_upperImpulse);
      }
      GetLocalAnchorA() { return this.m_localAnchorA; }
      GetLocalAnchorB() { return this.m_localAnchorB; }
      GetReferenceAngle() { return this.m_referenceAngle; }
      GetJointAngle() {
          // b2Body* bA = this.m_bodyA;
          // b2Body* bB = this.m_bodyB;
          // return bB.this.m_sweep.a - bA.this.m_sweep.a - this.m_referenceAngle;
          return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
      }
      GetJointSpeed() {
          // b2Body* bA = this.m_bodyA;
          // b2Body* bB = this.m_bodyB;
          // return bB.this.m_angularVelocity - bA.this.m_angularVelocity;
          return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
      }
      IsMotorEnabled() {
          return this.m_enableMotor;
      }
      EnableMotor(flag) {
          if (flag !== this.m_enableMotor) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_enableMotor = flag;
          }
      }
      GetMotorTorque(inv_dt) {
          return inv_dt * this.m_motorImpulse;
      }
      GetMotorSpeed() {
          return this.m_motorSpeed;
      }
      SetMaxMotorTorque(torque) {
          if (torque !== this.m_maxMotorTorque) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_maxMotorTorque = torque;
          }
      }
      GetMaxMotorTorque() { return this.m_maxMotorTorque; }
      IsLimitEnabled() {
          return this.m_enableLimit;
      }
      EnableLimit(flag) {
          if (flag !== this.m_enableLimit) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_enableLimit = flag;
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
      }
      GetLowerLimit() {
          return this.m_lowerAngle;
      }
      GetUpperLimit() {
          return this.m_upperAngle;
      }
      SetLimits(lower, upper) {
          if (lower !== this.m_lowerAngle || upper !== this.m_upperAngle) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
              this.m_lowerAngle = lower;
              this.m_upperAngle = upper;
          }
      }
      SetMotorSpeed(speed) {
          if (speed !== this.m_motorSpeed) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_motorSpeed = speed;
          }
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
          log("  jd.enableLimit = %s;\n", (this.m_enableLimit) ? ("true") : ("false"));
          log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle);
          log("  jd.upperAngle = %.15f;\n", this.m_upperAngle);
          log("  jd.enableMotor = %s;\n", (this.m_enableMotor) ? ("true") : ("false"));
          log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
          log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
      Draw(draw) {
          const xfA = this.m_bodyA.GetTransform();
          const xfB = this.m_bodyB.GetTransform();
          const pA = b2Transform.MulXV(xfA, this.m_localAnchorA, b2RevoluteJoint.Draw_s_pA);
          const pB = b2Transform.MulXV(xfB, this.m_localAnchorB, b2RevoluteJoint.Draw_s_pB);
          const c1 = b2RevoluteJoint.Draw_s_c1; // b2Color c1(0.7f, 0.7f, 0.7f);
          const c2 = b2RevoluteJoint.Draw_s_c2; // b2Color c2(0.3f, 0.9f, 0.3f);
          const c3 = b2RevoluteJoint.Draw_s_c3; // b2Color c3(0.9f, 0.3f, 0.3f);
          const c4 = b2RevoluteJoint.Draw_s_c4; // b2Color c4(0.3f, 0.3f, 0.9f);
          const c5 = b2RevoluteJoint.Draw_s_c5; // b2Color c5(0.4f, 0.4f, 0.4f);
          draw.DrawPoint(pA, 5.0, c4);
          draw.DrawPoint(pB, 5.0, c5);
          const aA = this.m_bodyA.GetAngle();
          const aB = this.m_bodyB.GetAngle();
          const angle = aB - aA - this.m_referenceAngle;
          const L = 0.1; // SHY CHANGE
          // b2Vec2 r = L * b2Vec2(Math.cos(angle), Math.sin(angle));
          const r = b2RevoluteJoint.Draw_s_r.Set(L * Math.cos(angle), L * Math.sin(angle));
          // draw.DrawSegment(pB, pB + r, c1);
          draw.DrawSegment(pB, b2Vec2.AddVV(pB, r, b2Vec2.s_t0), c1);
          draw.DrawCircle(pB, L, c1);
          if (this.m_enableLimit) {
              // b2Vec2 rlo = L * b2Vec2(Math.cos(m_lowerAngle), Math.sin(m_lowerAngle));
              const rlo = b2RevoluteJoint.Draw_s_rlo.Set(L * Math.cos(this.m_lowerAngle), L * Math.sin(this.m_lowerAngle));
              // b2Vec2 rhi = L * b2Vec2(Math.cos(m_upperAngle), Math.sin(m_upperAngle));
              const rhi = b2RevoluteJoint.Draw_s_rhi.Set(L * Math.cos(this.m_upperAngle), L * Math.sin(this.m_upperAngle));
              // draw.DrawSegment(pB, pB + rlo, c2);
              draw.DrawSegment(pB, b2Vec2.AddVV(pB, rlo, b2Vec2.s_t0), c2);
              // draw.DrawSegment(pB, pB + rhi, c3);
              draw.DrawSegment(pB, b2Vec2.AddVV(pB, rhi, b2Vec2.s_t0), c3);
          }
          const color = b2RevoluteJoint.Draw_s_color_; // b2Color color(0.5f, 0.8f, 0.8f);
          draw.DrawSegment(xfA.p, pA, color);
          draw.DrawSegment(pA, pB, color);
          draw.DrawSegment(xfB.p, pB, color);
      }
  }
  b2RevoluteJoint.InitVelocityConstraints_s_P = new b2Vec2();
  // private static SolveVelocityConstraints_s_P: b2Vec2 = new b2Vec2();
  b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();
  // private static SolveVelocityConstraints_s_Cdot1: b2Vec2 = new b2Vec2();
  // private static SolveVelocityConstraints_s_impulse_v3: b2Vec3 = new b2Vec3();
  // private static SolveVelocityConstraints_s_reduced_v2: b2Vec2 = new b2Vec2();
  b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2 = new b2Vec2();
  b2RevoluteJoint.SolvePositionConstraints_s_C_v2 = new b2Vec2();
  b2RevoluteJoint.SolvePositionConstraints_s_impulse = new b2Vec2();
  b2RevoluteJoint.Draw_s_pA = new b2Vec2();
  b2RevoluteJoint.Draw_s_pB = new b2Vec2();
  b2RevoluteJoint.Draw_s_c1 = new b2Color(0.7, 0.7, 0.7);
  b2RevoluteJoint.Draw_s_c2 = new b2Color(0.3, 0.9, 0.3);
  b2RevoluteJoint.Draw_s_c3 = new b2Color(0.9, 0.3, 0.3);
  b2RevoluteJoint.Draw_s_c4 = new b2Color(0.3, 0.3, 0.9);
  b2RevoluteJoint.Draw_s_c5 = new b2Color(0.4, 0.4, 0.4);
  b2RevoluteJoint.Draw_s_color_ = new b2Color(0.5, 0.8, 0.8);
  b2RevoluteJoint.Draw_s_r = new b2Vec2();
  b2RevoluteJoint.Draw_s_rlo = new b2Vec2();
  b2RevoluteJoint.Draw_s_rhi = new b2Vec2();

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Weld joint definition. You need to specify local anchor points
  /// where they are attached and the relative body angle. The position
  /// of the anchor points is important for computing the reaction torque.
  class b2WeldJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_weldJoint);
          this.localAnchorA = new b2Vec2();
          this.localAnchorB = new b2Vec2();
          this.referenceAngle = 0;
          this.stiffness = 0;
          this.damping = 0;
      }
      Initialize(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }
  }
  class b2WeldJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_stiffness = 0;
          this.m_damping = 0;
          this.m_bias = 0;
          // Solver shared
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_referenceAngle = 0;
          this.m_gamma = 0;
          this.m_impulse = new b2Vec3(0, 0, 0);
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_mass = new b2Mat33();
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_K = new b2Mat33();
          this.m_stiffness = b2Maybe(def.stiffness, 0);
          this.m_damping = b2Maybe(def.damping, 0);
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);
          this.m_impulse.SetZero();
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // J = [-I -r1_skew I r2_skew]
          //     [ 0       -1 0       1]
          // r_skew = [-ry; rx]
          // Matlab
          // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
          //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
          //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const K = this.m_K;
          K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
          K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
          K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
          K.ex.y = K.ey.x;
          K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
          K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
          K.ex.z = K.ez.x;
          K.ey.z = K.ez.y;
          K.ez.z = iA + iB;
          if (this.m_stiffness > 0) {
              K.GetInverse22(this.m_mass);
              let invM = iA + iB;
              const C = aB - aA - this.m_referenceAngle;
              // Damping coefficient
              const d = this.m_damping;
              // Spring stiffness
              const k = this.m_stiffness;
              // magic formulas
              const h = data.step.dt;
              this.m_gamma = h * (d + h * k);
              this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;
              this.m_bias = C * h * k * this.m_gamma;
              invM += this.m_gamma;
              this.m_mass.ez.z = invM !== 0 ? 1 / invM : 0;
          }
          else {
              K.GetSymInverse33(this.m_mass);
              this.m_gamma = 0;
              this.m_bias = 0;
          }
          if (data.step.warmStarting) {
              // Scale impulses to support a variable time step.
              this.m_impulse.SelfMul(data.step.dtRatio);
              // b2Vec2 P(m_impulse.x, m_impulse.y);
              const P = b2WeldJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x, this.m_impulse.y);
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + this.m_impulse.z);
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + this.m_impulse.z);
          }
          else {
              this.m_impulse.SetZero();
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          if (this.m_stiffness > 0) {
              const Cdot2 = wB - wA;
              const impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
              this.m_impulse.z += impulse2;
              wA -= iA * impulse2;
              wB += iB * impulse2;
              // b2Vec2 Cdot1 = vB + b2Vec2.CrossSV(wB, this.m_rB) - vA - b2Vec2.CrossSV(wA, this.m_rA);
              const Cdot1 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2WeldJoint.SolveVelocityConstraints_s_Cdot1);
              // b2Vec2 impulse1 = -b2Mul22(m_mass, Cdot1);
              const impulse1 = b2Mat33.MulM33XY(this.m_mass, Cdot1.x, Cdot1.y, b2WeldJoint.SolveVelocityConstraints_s_impulse1).SelfNeg();
              this.m_impulse.x += impulse1.x;
              this.m_impulse.y += impulse1.y;
              // b2Vec2 P = impulse1;
              const P = impulse1;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              // wA -= iA * b2Cross(m_rA, P);
              wA -= iA * b2Vec2.CrossVV(this.m_rA, P);
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              // wB += iB * b2Cross(m_rB, P);
              wB += iB * b2Vec2.CrossVV(this.m_rB, P);
          }
          else {
              // b2Vec2 Cdot1 = vB + b2Cross(wB, this.m_rB) - vA - b2Cross(wA, this.m_rA);
              const Cdot1 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2WeldJoint.SolveVelocityConstraints_s_Cdot1);
              const Cdot2 = wB - wA;
              // b2Vec3 const Cdot(Cdot1.x, Cdot1.y, Cdot2);
              // b2Vec3 impulse = -b2Mul(m_mass, Cdot);
              const impulse = b2Mat33.MulM33XYZ(this.m_mass, Cdot1.x, Cdot1.y, Cdot2, b2WeldJoint.SolveVelocityConstraints_s_impulse).SelfNeg();
              this.m_impulse.SelfAdd(impulse);
              // b2Vec2 P(impulse.x, impulse.y);
              const P = b2WeldJoint.SolveVelocityConstraints_s_P.Set(impulse.x, impulse.y);
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + impulse.z);
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + impulse.z);
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          let positionError, angularError;
          const K = this.m_K;
          K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
          K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
          K.ez.x = -rA.y * iA - rB.y * iB;
          K.ex.y = K.ey.x;
          K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
          K.ez.y = rA.x * iA + rB.x * iB;
          K.ex.z = K.ez.x;
          K.ey.z = K.ez.y;
          K.ez.z = iA + iB;
          if (this.m_stiffness > 0) {
              // b2Vec2 C1 =  cB + rB - cA - rA;
              const C1 = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2WeldJoint.SolvePositionConstraints_s_C1);
              positionError = C1.Length();
              angularError = 0;
              // b2Vec2 P = -K.Solve22(C1);
              const P = K.Solve22(C1.x, C1.y, b2WeldJoint.SolvePositionConstraints_s_P).SelfNeg();
              // cA -= mA * P;
              cA.SelfMulSub(mA, P);
              aA -= iA * b2Vec2.CrossVV(rA, P);
              // cB += mB * P;
              cB.SelfMulAdd(mB, P);
              aB += iB * b2Vec2.CrossVV(rB, P);
          }
          else {
              // b2Vec2 C1 =  cB + rB - cA - rA;
              const C1 = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2WeldJoint.SolvePositionConstraints_s_C1);
              const C2 = aB - aA - this.m_referenceAngle;
              positionError = C1.Length();
              angularError = b2Abs(C2);
              // b2Vec3 C(C1.x, C1.y, C2);
              // b2Vec3 impulse = -K.Solve33(C);
              const impulse = K.Solve33(C1.x, C1.y, C2, b2WeldJoint.SolvePositionConstraints_s_impulse).SelfNeg();
              // b2Vec2 P(impulse.x, impulse.y);
              const P = b2WeldJoint.SolvePositionConstraints_s_P.Set(impulse.x, impulse.y);
              // cA -= mA * P;
              cA.SelfMulSub(mA, P);
              aA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + impulse.z);
              // cB += mB * P;
              cB.SelfMulAdd(mB, P);
              aB += iB * (b2Vec2.CrossVV(this.m_rB, P) + impulse.z);
          }
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          // b2Vec2 P(this.m_impulse.x, this.m_impulse.y);
          // return inv_dt * P;
          out.x = inv_dt * this.m_impulse.x;
          out.y = inv_dt * this.m_impulse.y;
          return out;
      }
      GetReactionTorque(inv_dt) {
          return inv_dt * this.m_impulse.z;
      }
      GetLocalAnchorA() { return this.m_localAnchorA; }
      GetLocalAnchorB() { return this.m_localAnchorB; }
      GetReferenceAngle() { return this.m_referenceAngle; }
      SetStiffness(stiffness) { this.m_stiffness = stiffness; }
      GetStiffness() { return this.m_stiffness; }
      SetDamping(damping) { this.m_damping = damping; }
      GetDamping() { return this.m_damping; }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2WeldJointDef = new b2WeldJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
          log("  jd.stiffness = %.15f;\n", this.m_stiffness);
          log("  jd.damping = %.15f;\n", this.m_damping);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
  }
  b2WeldJoint.InitVelocityConstraints_s_P = new b2Vec2();
  b2WeldJoint.SolveVelocityConstraints_s_Cdot1 = new b2Vec2();
  b2WeldJoint.SolveVelocityConstraints_s_impulse1 = new b2Vec2();
  b2WeldJoint.SolveVelocityConstraints_s_impulse = new b2Vec3();
  b2WeldJoint.SolveVelocityConstraints_s_P = new b2Vec2();
  b2WeldJoint.SolvePositionConstraints_s_C1 = new b2Vec2();
  b2WeldJoint.SolvePositionConstraints_s_P = new b2Vec2();
  b2WeldJoint.SolvePositionConstraints_s_impulse = new b2Vec3();

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  /// Wheel joint definition. This requires defining a line of
  /// motion using an axis and an anchor point. The definition uses local
  /// anchor points and a local axis so that the initial configuration
  /// can violate the constraint slightly. The joint translation is zero
  /// when the local anchor points coincide in world space. Using local
  /// anchors and a local axis helps when saving and loading a game.
  class b2WheelJointDef extends b2JointDef {
      constructor() {
          super(exports.JointType.e_wheelJoint);
          this.localAnchorA = new b2Vec2(0, 0);
          this.localAnchorB = new b2Vec2(0, 0);
          this.localAxisA = new b2Vec2(1, 0);
          this.enableLimit = false;
          this.lowerTranslation = 0;
          this.upperTranslation = 0;
          this.enableMotor = false;
          this.maxMotorTorque = 0;
          this.motorSpeed = 0;
          this.stiffness = 0;
          this.damping = 0;
      }
      Initialize(bA, bB, anchor, axis) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.bodyA.GetLocalVector(axis, this.localAxisA);
      }
  }
  class b2WheelJoint extends b2Joint {
      constructor(def) {
          super(def);
          this.m_localAnchorA = new b2Vec2();
          this.m_localAnchorB = new b2Vec2();
          this.m_localXAxisA = new b2Vec2();
          this.m_localYAxisA = new b2Vec2();
          this.m_impulse = 0;
          this.m_motorImpulse = 0;
          this.m_springImpulse = 0;
          this.m_lowerImpulse = 0;
          this.m_upperImpulse = 0;
          this.m_translation = 0;
          this.m_lowerTranslation = 0;
          this.m_upperTranslation = 0;
          this.m_maxMotorTorque = 0;
          this.m_motorSpeed = 0;
          this.m_enableLimit = false;
          this.m_enableMotor = false;
          this.m_stiffness = 0;
          this.m_damping = 0;
          // Solver temp
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_localCenterA = new b2Vec2();
          this.m_localCenterB = new b2Vec2();
          this.m_invMassA = 0;
          this.m_invMassB = 0;
          this.m_invIA = 0;
          this.m_invIB = 0;
          this.m_ax = new b2Vec2();
          this.m_ay = new b2Vec2();
          this.m_sAx = 0;
          this.m_sBx = 0;
          this.m_sAy = 0;
          this.m_sBy = 0;
          this.m_mass = 0;
          this.m_motorMass = 0;
          this.m_axialMass = 0;
          this.m_springMass = 0;
          this.m_bias = 0;
          this.m_gamma = 0;
          this.m_qA = new b2Rot();
          this.m_qB = new b2Rot();
          this.m_lalcA = new b2Vec2();
          this.m_lalcB = new b2Vec2();
          this.m_rA = new b2Vec2();
          this.m_rB = new b2Vec2();
          this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          this.m_localXAxisA.Copy(b2Maybe(def.localAxisA, b2Vec2.UNITX));
          b2Vec2.CrossOneV(this.m_localXAxisA, this.m_localYAxisA);
          this.m_lowerTranslation = b2Maybe(def.lowerTranslation, 0);
          this.m_upperTranslation = b2Maybe(def.upperTranslation, 0);
          this.m_enableLimit = b2Maybe(def.enableLimit, false);
          this.m_maxMotorTorque = b2Maybe(def.maxMotorTorque, 0);
          this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);
          this.m_enableMotor = b2Maybe(def.enableMotor, false);
          this.m_ax.SetZero();
          this.m_ay.SetZero();
          this.m_stiffness = b2Maybe(def.stiffness, 0);
          this.m_damping = b2Maybe(def.damping, 0);
      }
      GetMotorSpeed() {
          return this.m_motorSpeed;
      }
      GetMaxMotorTorque() {
          return this.m_maxMotorTorque;
      }
      SetSpringFrequencyHz(hz) {
          this.m_stiffness = hz;
      }
      GetSpringFrequencyHz() {
          return this.m_stiffness;
      }
      SetSpringDampingRatio(ratio) {
          this.m_damping = ratio;
      }
      GetSpringDampingRatio() {
          return this.m_damping;
      }
      InitVelocityConstraints(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const cA = data.positions[this.m_indexA].c;
          const aA = data.positions[this.m_indexA].a;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const cB = data.positions[this.m_indexB].c;
          const aB = data.positions[this.m_indexB].a;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          // Compute the effective masses.
          // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // b2Vec2 d = cB + rB - cA - rA;
          const d = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2WheelJoint.InitVelocityConstraints_s_d);
          // Point to line constraint
          {
              // m_ay = b2Mul(qA, m_localYAxisA);
              b2Rot.MulRV(qA, this.m_localYAxisA, this.m_ay);
              // m_sAy = b2Cross(d + rA, m_ay);
              this.m_sAy = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_ay);
              // m_sBy = b2Cross(rB, m_ay);
              this.m_sBy = b2Vec2.CrossVV(rB, this.m_ay);
              this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
              if (this.m_mass > 0) {
                  this.m_mass = 1 / this.m_mass;
              }
          }
          // Spring constraint
          b2Rot.MulRV(qA, this.m_localXAxisA, this.m_ax); // m_ax = b2Mul(qA, m_localXAxisA);
          this.m_sAx = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_ax);
          this.m_sBx = b2Vec2.CrossVV(rB, this.m_ax);
          const invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
          if (invMass > 0.0) {
              this.m_axialMass = 1.0 / invMass;
          }
          else {
              this.m_axialMass = 0.0;
          }
          this.m_springMass = 0;
          this.m_bias = 0;
          this.m_gamma = 0;
          if (this.m_stiffness > 0.0 && invMass > 0.0) {
              this.m_springMass = 1.0 / invMass;
              const C = b2Vec2.DotVV(d, this.m_ax);
              // magic formulas
              const h = data.step.dt;
              this.m_gamma = h * (this.m_damping + h * this.m_stiffness);
              if (this.m_gamma > 0.0) {
                  this.m_gamma = 1.0 / this.m_gamma;
              }
              this.m_bias = C * h * this.m_stiffness * this.m_gamma;
              this.m_springMass = invMass + this.m_gamma;
              if (this.m_springMass > 0.0) {
                  this.m_springMass = 1.0 / this.m_springMass;
              }
          }
          else {
              this.m_springImpulse = 0.0;
          }
          if (this.m_enableLimit) {
              this.m_translation = b2Vec2.DotVV(this.m_ax, d);
          }
          else {
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
          if (this.m_enableMotor) {
              this.m_motorMass = iA + iB;
              if (this.m_motorMass > 0) {
                  this.m_motorMass = 1 / this.m_motorMass;
              }
          }
          else {
              this.m_motorMass = 0;
              this.m_motorImpulse = 0;
          }
          if (data.step.warmStarting) {
              // Account for variable time step.
              this.m_impulse *= data.step.dtRatio;
              this.m_springImpulse *= data.step.dtRatio;
              this.m_motorImpulse *= data.step.dtRatio;
              const axialImpulse = this.m_springImpulse + this.m_lowerImpulse - this.m_upperImpulse;
              // b2Vec2 P = m_impulse * m_ay + m_springImpulse * m_ax;
              const P = b2Vec2.AddVV(b2Vec2.MulSV(this.m_impulse, this.m_ay, b2Vec2.s_t0), b2Vec2.MulSV(axialImpulse, this.m_ax, b2Vec2.s_t1), b2WheelJoint.InitVelocityConstraints_s_P);
              // float32 LA = m_impulse * m_sAy + m_springImpulse * m_sAx + m_motorImpulse;
              const LA = this.m_impulse * this.m_sAy + axialImpulse * this.m_sAx + this.m_motorImpulse;
              // float32 LB = m_impulse * m_sBy + m_springImpulse * m_sBx + m_motorImpulse;
              const LB = this.m_impulse * this.m_sBy + axialImpulse * this.m_sBx + this.m_motorImpulse;
              // vA -= m_invMassA * P;
              vA.SelfMulSub(this.m_invMassA, P);
              wA -= this.m_invIA * LA;
              // vB += m_invMassB * P;
              vB.SelfMulAdd(this.m_invMassB, P);
              wB += this.m_invIB * LB;
          }
          else {
              this.m_impulse = 0;
              this.m_springImpulse = 0;
              this.m_motorImpulse = 0;
              this.m_lowerImpulse = 0;
              this.m_upperImpulse = 0;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolveVelocityConstraints(data) {
          const mA = this.m_invMassA, mB = this.m_invMassB;
          const iA = this.m_invIA, iB = this.m_invIB;
          const vA = data.velocities[this.m_indexA].v;
          let wA = data.velocities[this.m_indexA].w;
          const vB = data.velocities[this.m_indexB].v;
          let wB = data.velocities[this.m_indexB].w;
          // Solve spring constraint
          {
              const Cdot = b2Vec2.DotVV(this.m_ax, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_sBx * wB - this.m_sAx * wA;
              const impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
              this.m_springImpulse += impulse;
              // b2Vec2 P = impulse * m_ax;
              const P = b2Vec2.MulSV(impulse, this.m_ax, b2WheelJoint.SolveVelocityConstraints_s_P);
              const LA = impulse * this.m_sAx;
              const LB = impulse * this.m_sBx;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * LA;
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * LB;
          }
          // Solve rotational motor constraint
          {
              const Cdot = wB - wA - this.m_motorSpeed;
              let impulse = -this.m_motorMass * Cdot;
              const oldImpulse = this.m_motorImpulse;
              const maxImpulse = data.step.dt * this.m_maxMotorTorque;
              this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
              impulse = this.m_motorImpulse - oldImpulse;
              wA -= iA * impulse;
              wB += iB * impulse;
          }
          if (this.m_enableLimit) {
              // Lower limit
              {
                  const C = this.m_translation - this.m_lowerTranslation;
                  const Cdot = b2Vec2.DotVV(this.m_ax, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_sBx * wB - this.m_sAx * wA;
                  let impulse = -this.m_axialMass * (Cdot + b2Max(C, 0.0) * data.step.inv_dt);
                  const oldImpulse = this.m_lowerImpulse;
                  this.m_lowerImpulse = b2Max(this.m_lowerImpulse + impulse, 0.0);
                  impulse = this.m_lowerImpulse - oldImpulse;
                  // b2Vec2 P = impulse * this.m_ax;
                  const P = b2Vec2.MulSV(impulse, this.m_ax, b2WheelJoint.SolveVelocityConstraints_s_P);
                  const LA = impulse * this.m_sAx;
                  const LB = impulse * this.m_sBx;
                  // vA -= mA * P;
                  vA.SelfMulSub(mA, P);
                  wA -= iA * LA;
                  // vB += mB * P;
                  vB.SelfMulAdd(mB, P);
                  wB += iB * LB;
              }
              // Upper limit
              // Note: signs are flipped to keep C positive when the constraint is satisfied.
              // This also keeps the impulse positive when the limit is active.
              {
                  const C = this.m_upperTranslation - this.m_translation;
                  const Cdot = b2Vec2.DotVV(this.m_ax, b2Vec2.SubVV(vA, vB, b2Vec2.s_t0)) + this.m_sAx * wA - this.m_sBx * wB;
                  let impulse = -this.m_axialMass * (Cdot + b2Max(C, 0.0) * data.step.inv_dt);
                  const oldImpulse = this.m_upperImpulse;
                  this.m_upperImpulse = b2Max(this.m_upperImpulse + impulse, 0.0);
                  impulse = this.m_upperImpulse - oldImpulse;
                  // b2Vec2 P = impulse * this.m_ax;
                  const P = b2Vec2.MulSV(impulse, this.m_ax, b2WheelJoint.SolveVelocityConstraints_s_P);
                  const LA = impulse * this.m_sAx;
                  const LB = impulse * this.m_sBx;
                  // vA += mA * P;
                  vA.SelfMulAdd(mA, P);
                  wA += iA * LA;
                  // vB -= mB * P;
                  vB.SelfMulSub(mB, P);
                  wB -= iB * LB;
              }
          }
          // Solve point to line constraint
          {
              const Cdot = b2Vec2.DotVV(this.m_ay, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_sBy * wB - this.m_sAy * wA;
              const impulse = -this.m_mass * Cdot;
              this.m_impulse += impulse;
              // b2Vec2 P = impulse * m_ay;
              const P = b2Vec2.MulSV(impulse, this.m_ay, b2WheelJoint.SolveVelocityConstraints_s_P);
              const LA = impulse * this.m_sAy;
              const LB = impulse * this.m_sBy;
              // vA -= mA * P;
              vA.SelfMulSub(mA, P);
              wA -= iA * LA;
              // vB += mB * P;
              vB.SelfMulAdd(mB, P);
              wB += iB * LB;
          }
          // data.velocities[this.m_indexA].v = vA;
          data.velocities[this.m_indexA].w = wA;
          // data.velocities[this.m_indexB].v = vB;
          data.velocities[this.m_indexB].w = wB;
      }
      SolvePositionConstraints(data) {
          const cA = data.positions[this.m_indexA].c;
          let aA = data.positions[this.m_indexA].a;
          const cB = data.positions[this.m_indexB].c;
          let aB = data.positions[this.m_indexB].a;
          // const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);
          // // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
          // b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          // const rA: b2Vec2 = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          // // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
          // b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          // const rB: b2Vec2 = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          // // b2Vec2 d = (cB - cA) + rB - rA;
          // const d: b2Vec2 = b2Vec2.AddVV(
          //   b2Vec2.SubVV(cB, cA, b2Vec2.s_t0),
          //   b2Vec2.SubVV(rB, rA, b2Vec2.s_t1),
          //   b2WheelJoint.SolvePositionConstraints_s_d);
          // // b2Vec2 ay = b2Mul(qA, m_localYAxisA);
          // const ay: b2Vec2 = b2Rot.MulRV(qA, this.m_localYAxisA, this.m_ay);
          // // float32 sAy = b2Cross(d + rA, ay);
          // const sAy = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), ay);
          // // float32 sBy = b2Cross(rB, ay);
          // const sBy = b2Vec2.CrossVV(rB, ay);
          // // float32 C = b2Dot(d, ay);
          // const C: number = b2Vec2.DotVV(d, this.m_ay);
          // const k: number = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
          // let impulse: number;
          // if (k !== 0) {
          //   impulse = - C / k;
          // } else {
          //   impulse = 0;
          // }
          // // b2Vec2 P = impulse * ay;
          // const P: b2Vec2 = b2Vec2.MulSV(impulse, ay, b2WheelJoint.SolvePositionConstraints_s_P);
          // const LA: number = impulse * sAy;
          // const LB: number = impulse * sBy;
          // // cA -= m_invMassA * P;
          // cA.SelfMulSub(this.m_invMassA, P);
          // aA -= this.m_invIA * LA;
          // // cB += m_invMassB * P;
          // cB.SelfMulAdd(this.m_invMassB, P);
          // aB += this.m_invIB * LB;
          let linearError = 0.0;
          if (this.m_enableLimit) {
              // b2Rot qA(aA), qB(aB);
              const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
              // b2Vec2 rA = b2Mul(qA, this.m_localAnchorA - this.m_localCenterA);
              // b2Vec2 rB = b2Mul(qB, this.m_localAnchorB - this.m_localCenterB);
              // b2Vec2 d = (cB - cA) + rB - rA;
              // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
              b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
              const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
              // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
              b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
              const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
              // b2Vec2 d = (cB - cA) + rB - rA;
              const d = b2Vec2.AddVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), b2Vec2.SubVV(rB, rA, b2Vec2.s_t1), b2WheelJoint.SolvePositionConstraints_s_d);
              // b2Vec2 ax = b2Mul(qA, this.m_localXAxisA);
              const ax = b2Rot.MulRV(qA, this.m_localXAxisA, this.m_ax);
              // float sAx = b2Cross(d + rA, this.m_ax);
              const sAx = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_ax);
              // float sBx = b2Cross(rB, this.m_ax);
              const sBx = b2Vec2.CrossVV(rB, this.m_ax);
              let C = 0.0;
              const translation = b2Vec2.DotVV(ax, d);
              if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2_linearSlop) {
                  C = translation;
              }
              else if (translation <= this.m_lowerTranslation) {
                  C = b2Min(translation - this.m_lowerTranslation, 0.0);
              }
              else if (translation >= this.m_upperTranslation) {
                  C = b2Max(translation - this.m_upperTranslation, 0.0);
              }
              if (C !== 0.0) {
                  const invMass = this.m_invMassA + this.m_invMassB + this.m_invIA * sAx * sAx + this.m_invIB * sBx * sBx;
                  let impulse = 0.0;
                  if (invMass !== 0.0) {
                      impulse = -C / invMass;
                  }
                  const P = b2Vec2.MulSV(impulse, ax, b2WheelJoint.SolvePositionConstraints_s_P);
                  const LA = impulse * sAx;
                  const LB = impulse * sBx;
                  // cA -= m_invMassA * P;
                  cA.SelfMulSub(this.m_invMassA, P);
                  aA -= this.m_invIA * LA;
                  // cB += m_invMassB * P;
                  cB.SelfMulAdd(this.m_invMassB, P);
                  // aB += m_invIB * LB;
                  aB += this.m_invIB * LB;
                  linearError = b2Abs(C);
              }
          }
          // Solve perpendicular constraint
          {
              // b2Rot qA(aA), qB(aB);
              const qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
              // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
              // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
              // b2Vec2 d = (cB - cA) + rB - rA;
              // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
              b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
              const rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
              // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
              b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
              const rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
              // b2Vec2 d = (cB - cA) + rB - rA;
              const d = b2Vec2.AddVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), b2Vec2.SubVV(rB, rA, b2Vec2.s_t1), b2WheelJoint.SolvePositionConstraints_s_d);
              // b2Vec2 ay = b2Mul(qA, m_localYAxisA);
              const ay = b2Rot.MulRV(qA, this.m_localYAxisA, this.m_ay);
              // float sAy = b2Cross(d + rA, ay);
              const sAy = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), ay);
              // float sBy = b2Cross(rB, ay);
              const sBy = b2Vec2.CrossVV(rB, ay);
              // float C = b2Dot(d, ay);
              const C = b2Vec2.DotVV(d, ay);
              const invMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
              let impulse = 0.0;
              if (invMass !== 0.0) {
                  impulse = -C / invMass;
              }
              // b2Vec2 P = impulse * ay;
              // const LA: number = impulse * sAy;
              // const LB: number = impulse * sBy;
              const P = b2Vec2.MulSV(impulse, ay, b2WheelJoint.SolvePositionConstraints_s_P);
              const LA = impulse * sAy;
              const LB = impulse * sBy;
              // cA -= m_invMassA * P;
              cA.SelfMulSub(this.m_invMassA, P);
              aA -= this.m_invIA * LA;
              // cB += m_invMassB * P;
              cB.SelfMulAdd(this.m_invMassB, P);
              aB += this.m_invIB * LB;
              linearError = b2Max(linearError, b2Abs(C));
          }
          // data.positions[this.m_indexA].c = cA;
          data.positions[this.m_indexA].a = aA;
          // data.positions[this.m_indexB].c = cB;
          data.positions[this.m_indexB].a = aB;
          return linearError <= b2_linearSlop;
      }
      GetDefinition(def) {
          // DEBUG: b2Assert(false); // TODO
          return def;
      }
      GetAnchorA(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
      }
      GetAnchorB(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
      }
      GetReactionForce(inv_dt, out) {
          out.x = inv_dt * (this.m_impulse * this.m_ay.x + (this.m_springImpulse + this.m_lowerImpulse - this.m_upperImpulse) * this.m_ax.x);
          out.y = inv_dt * (this.m_impulse * this.m_ay.y + (this.m_springImpulse + this.m_lowerImpulse - this.m_upperImpulse) * this.m_ax.y);
          return out;
      }
      GetReactionTorque(inv_dt) {
          return inv_dt * this.m_motorImpulse;
      }
      GetLocalAnchorA() { return this.m_localAnchorA; }
      GetLocalAnchorB() { return this.m_localAnchorB; }
      GetLocalAxisA() { return this.m_localXAxisA; }
      GetJointTranslation() {
          return this.GetPrismaticJointTranslation();
      }
      GetJointLinearSpeed() {
          return this.GetPrismaticJointSpeed();
      }
      GetJointAngle() {
          return this.GetRevoluteJointAngle();
      }
      GetJointAngularSpeed() {
          return this.GetRevoluteJointSpeed();
      }
      GetPrismaticJointTranslation() {
          const bA = this.m_bodyA;
          const bB = this.m_bodyB;
          const pA = bA.GetWorldPoint(this.m_localAnchorA, new b2Vec2());
          const pB = bB.GetWorldPoint(this.m_localAnchorB, new b2Vec2());
          const d = b2Vec2.SubVV(pB, pA, new b2Vec2());
          const axis = bA.GetWorldVector(this.m_localXAxisA, new b2Vec2());
          const translation = b2Vec2.DotVV(d, axis);
          return translation;
      }
      GetPrismaticJointSpeed() {
          const bA = this.m_bodyA;
          const bB = this.m_bodyB;
          // b2Vec2 rA = b2Mul(bA.m_xf.q, m_localAnchorA - bA.m_sweep.localCenter);
          b2Vec2.SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);
          const rA = b2Rot.MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);
          // b2Vec2 rB = b2Mul(bB.m_xf.q, m_localAnchorB - bB.m_sweep.localCenter);
          b2Vec2.SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);
          const rB = b2Rot.MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);
          // b2Vec2 pA = bA.m_sweep.c + rA;
          const pA = b2Vec2.AddVV(bA.m_sweep.c, rA, b2Vec2.s_t0); // pA uses s_t0
          // b2Vec2 pB = bB.m_sweep.c + rB;
          const pB = b2Vec2.AddVV(bB.m_sweep.c, rB, b2Vec2.s_t1); // pB uses s_t1
          // b2Vec2 d = pB - pA;
          const d = b2Vec2.SubVV(pB, pA, b2Vec2.s_t2); // d uses s_t2
          // b2Vec2 axis = b2Mul(bA.m_xf.q, m_localXAxisA);
          const axis = bA.GetWorldVector(this.m_localXAxisA, new b2Vec2());
          const vA = bA.m_linearVelocity;
          const vB = bB.m_linearVelocity;
          const wA = bA.m_angularVelocity;
          const wB = bB.m_angularVelocity;
          // float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));
          const speed = b2Vec2.DotVV(d, b2Vec2.CrossSV(wA, axis, b2Vec2.s_t0)) +
              b2Vec2.DotVV(axis, b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, rA, b2Vec2.s_t1), b2Vec2.s_t0));
          return speed;
      }
      GetRevoluteJointAngle() {
          // b2Body* bA = this.m_bodyA;
          // b2Body* bB = this.m_bodyB;
          // return bB.this.m_sweep.a - bA.this.m_sweep.a;
          return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a;
      }
      GetRevoluteJointSpeed() {
          const wA = this.m_bodyA.m_angularVelocity;
          const wB = this.m_bodyB.m_angularVelocity;
          return wB - wA;
      }
      IsMotorEnabled() {
          return this.m_enableMotor;
      }
      EnableMotor(flag) {
          if (flag !== this.m_enableMotor) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_enableMotor = flag;
          }
      }
      SetMotorSpeed(speed) {
          if (speed !== this.m_motorSpeed) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_motorSpeed = speed;
          }
      }
      SetMaxMotorTorque(force) {
          if (force !== this.m_maxMotorTorque) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_maxMotorTorque = force;
          }
      }
      GetMotorTorque(inv_dt) {
          return inv_dt * this.m_motorImpulse;
      }
      /// Is the joint limit enabled?
      IsLimitEnabled() {
          return this.m_enableLimit;
      }
      /// Enable/disable the joint translation limit.
      EnableLimit(flag) {
          if (flag !== this.m_enableLimit) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_enableLimit = flag;
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
      }
      /// Get the lower joint translation limit, usually in meters.
      GetLowerLimit() {
          return this.m_lowerTranslation;
      }
      /// Get the upper joint translation limit, usually in meters.
      GetUpperLimit() {
          return this.m_upperTranslation;
      }
      /// Set the joint translation limits, usually in meters.
      SetLimits(lower, upper) {
          // b2Assert(lower <= upper);
          if (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation) {
              this.m_bodyA.SetAwake(true);
              this.m_bodyB.SetAwake(true);
              this.m_lowerTranslation = lower;
              this.m_upperTranslation = upper;
              this.m_lowerImpulse = 0.0;
              this.m_upperImpulse = 0.0;
          }
      }
      Dump(log) {
          const indexA = this.m_bodyA.m_islandIndex;
          const indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2WheelJointDef = new b2WheelJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", (this.m_collideConnected) ? ("true") : ("false"));
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
          log("  jd.enableMotor = %s;\n", (this.m_enableMotor) ? ("true") : ("false"));
          log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
          log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
          log("  jd.stiffness = %.15f;\n", this.m_stiffness);
          log("  jd.damping = %.15f;\n", this.m_damping);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
      }
      Draw(draw) {
          const xfA = this.m_bodyA.GetTransform();
          const xfB = this.m_bodyB.GetTransform();
          const pA = b2Transform.MulXV(xfA, this.m_localAnchorA, b2WheelJoint.Draw_s_pA);
          const pB = b2Transform.MulXV(xfB, this.m_localAnchorB, b2WheelJoint.Draw_s_pB);
          // b2Vec2 axis = b2Mul(xfA.q, m_localXAxisA);
          const axis = b2Rot.MulRV(xfA.q, this.m_localXAxisA, b2WheelJoint.Draw_s_axis);
          const c1 = b2WheelJoint.Draw_s_c1; // b2Color c1(0.7f, 0.7f, 0.7f);
          const c2 = b2WheelJoint.Draw_s_c2; // b2Color c2(0.3f, 0.9f, 0.3f);
          const c3 = b2WheelJoint.Draw_s_c3; // b2Color c3(0.9f, 0.3f, 0.3f);
          const c4 = b2WheelJoint.Draw_s_c4; // b2Color c4(0.3f, 0.3f, 0.9f);
          const c5 = b2WheelJoint.Draw_s_c5; // b2Color c5(0.4f, 0.4f, 0.4f);
          draw.DrawSegment(pA, pB, c5);
          if (this.m_enableLimit) {
              // b2Vec2 lower = pA + m_lowerTranslation * axis;
              const lower = b2Vec2.AddVMulSV(pA, this.m_lowerTranslation, axis, b2WheelJoint.Draw_s_lower);
              // b2Vec2 upper = pA + m_upperTranslation * axis;
              const upper = b2Vec2.AddVMulSV(pA, this.m_upperTranslation, axis, b2WheelJoint.Draw_s_upper);
              // b2Vec2 perp = b2Mul(xfA.q, m_localYAxisA);
              const perp = b2Rot.MulRV(xfA.q, this.m_localYAxisA, b2WheelJoint.Draw_s_perp);
              // draw.DrawSegment(lower, upper, c1);
              draw.DrawSegment(lower, upper, c1);
              // draw.DrawSegment(lower - 0.5f * perp, lower + 0.5f * perp, c2);
              draw.DrawSegment(b2Vec2.AddVMulSV(lower, -0.5, perp, b2Vec2.s_t0), b2Vec2.AddVMulSV(lower, 0.5, perp, b2Vec2.s_t1), c2);
              // draw.DrawSegment(upper - 0.5f * perp, upper + 0.5f * perp, c3);
              draw.DrawSegment(b2Vec2.AddVMulSV(upper, -0.5, perp, b2Vec2.s_t0), b2Vec2.AddVMulSV(upper, 0.5, perp, b2Vec2.s_t1), c3);
          }
          else {
              // draw.DrawSegment(pA - 1.0f * axis, pA + 1.0f * axis, c1);
              draw.DrawSegment(b2Vec2.AddVMulSV(pA, -1.0, axis, b2Vec2.s_t0), b2Vec2.AddVMulSV(pA, 1.0, axis, b2Vec2.s_t1), c1);
          }
          draw.DrawPoint(pA, 5.0, c1);
          draw.DrawPoint(pB, 5.0, c4);
      }
  }
  b2WheelJoint.InitVelocityConstraints_s_d = new b2Vec2();
  b2WheelJoint.InitVelocityConstraints_s_P = new b2Vec2();
  b2WheelJoint.SolveVelocityConstraints_s_P = new b2Vec2();
  b2WheelJoint.SolvePositionConstraints_s_d = new b2Vec2();
  b2WheelJoint.SolvePositionConstraints_s_P = new b2Vec2();
  ///
  b2WheelJoint.Draw_s_pA = new b2Vec2();
  b2WheelJoint.Draw_s_pB = new b2Vec2();
  b2WheelJoint.Draw_s_axis = new b2Vec2();
  b2WheelJoint.Draw_s_c1 = new b2Color(0.7, 0.7, 0.7);
  b2WheelJoint.Draw_s_c2 = new b2Color(0.3, 0.9, 0.3);
  b2WheelJoint.Draw_s_c3 = new b2Color(0.9, 0.3, 0.3);
  b2WheelJoint.Draw_s_c4 = new b2Color(0.3, 0.3, 0.9);
  b2WheelJoint.Draw_s_c5 = new b2Color(0.4, 0.4, 0.4);
  b2WheelJoint.Draw_s_lower = new b2Vec2();
  b2WheelJoint.Draw_s_upper = new b2Vec2();
  b2WheelJoint.Draw_s_perp = new b2Vec2();

  /*
   * Copyright (c) 2013 Google, Inc.
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  (function (b2ParticleFlag) {
      /// Water particle.
      b2ParticleFlag[b2ParticleFlag["b2_waterParticle"] = 0] = "b2_waterParticle";
      /// Removed after next simulation step.
      b2ParticleFlag[b2ParticleFlag["b2_zombieParticle"] = 2] = "b2_zombieParticle";
      /// Zero velocity.
      b2ParticleFlag[b2ParticleFlag["b2_wallParticle"] = 4] = "b2_wallParticle";
      /// With restitution from stretching.
      b2ParticleFlag[b2ParticleFlag["b2_springParticle"] = 8] = "b2_springParticle";
      /// With restitution from deformation.
      b2ParticleFlag[b2ParticleFlag["b2_elasticParticle"] = 16] = "b2_elasticParticle";
      /// With viscosity.
      b2ParticleFlag[b2ParticleFlag["b2_viscousParticle"] = 32] = "b2_viscousParticle";
      /// Without isotropic pressure.
      b2ParticleFlag[b2ParticleFlag["b2_powderParticle"] = 64] = "b2_powderParticle";
      /// With surface tension.
      b2ParticleFlag[b2ParticleFlag["b2_tensileParticle"] = 128] = "b2_tensileParticle";
      /// Mix color between contacting particles.
      b2ParticleFlag[b2ParticleFlag["b2_colorMixingParticle"] = 256] = "b2_colorMixingParticle";
      /// Call b2DestructionListener on destruction.
      b2ParticleFlag[b2ParticleFlag["b2_destructionListenerParticle"] = 512] = "b2_destructionListenerParticle";
      /// Prevents other particles from leaking.
      b2ParticleFlag[b2ParticleFlag["b2_barrierParticle"] = 1024] = "b2_barrierParticle";
      /// Less compressibility.
      b2ParticleFlag[b2ParticleFlag["b2_staticPressureParticle"] = 2048] = "b2_staticPressureParticle";
      /// Makes pairs or triads with other particles.
      b2ParticleFlag[b2ParticleFlag["b2_reactiveParticle"] = 4096] = "b2_reactiveParticle";
      /// With high repulsive force.
      b2ParticleFlag[b2ParticleFlag["b2_repulsiveParticle"] = 8192] = "b2_repulsiveParticle";
      /// Call b2ContactListener when this particle is about to interact with
      /// a rigid body or stops interacting with a rigid body.
      /// This results in an expensive operation compared to using
      /// b2_fixtureContactFilterParticle to detect collisions between
      /// particles.
      b2ParticleFlag[b2ParticleFlag["b2_fixtureContactListenerParticle"] = 16384] = "b2_fixtureContactListenerParticle";
      /// Call b2ContactListener when this particle is about to interact with
      /// another particle or stops interacting with another particle.
      /// This results in an expensive operation compared to using
      /// b2_particleContactFilterParticle to detect collisions between
      /// particles.
      b2ParticleFlag[b2ParticleFlag["b2_particleContactListenerParticle"] = 32768] = "b2_particleContactListenerParticle";
      /// Call b2ContactFilter when this particle interacts with rigid bodies.
      b2ParticleFlag[b2ParticleFlag["b2_fixtureContactFilterParticle"] = 65536] = "b2_fixtureContactFilterParticle";
      /// Call b2ContactFilter when this particle interacts with other
      /// particles.
      b2ParticleFlag[b2ParticleFlag["b2_particleContactFilterParticle"] = 131072] = "b2_particleContactFilterParticle";
  })(exports.ParticleFlag || (exports.ParticleFlag = {}));
  class b2ParticleDef {
      constructor() {
          this.flags = 0;
          this.position = new b2Vec2();
          this.velocity = new b2Vec2();
          this.color = new b2Color(0, 0, 0, 0);
          this.lifetime = 0.0;
          this.userData = null;
          this.group = null;
      }
  }
  function b2CalculateParticleIterations(gravity, radius, timeStep) {
      // In some situations you may want more particle iterations than this,
      // but to avoid excessive cycle cost, don't recommend more than this.
      const B2_MAX_RECOMMENDED_PARTICLE_ITERATIONS = 8;
      const B2_RADIUS_THRESHOLD = 0.01;
      const iterations = Math.ceil(Math.sqrt(gravity / (B2_RADIUS_THRESHOLD * radius)) * timeStep);
      return b2Clamp(iterations, 1, B2_MAX_RECOMMENDED_PARTICLE_ITERATIONS);
  }
  class b2ParticleHandle {
      constructor() {
          this.m_index = b2_invalidParticleIndex;
      }
      GetIndex() { return this.m_index; }
      SetIndex(index) { this.m_index = index; }
  }
  // #endif

  /*
   * Copyright (c) 2013 Google, Inc.
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  (function (b2ParticleGroupFlag) {
      /// Prevents overlapping or leaking.
      b2ParticleGroupFlag[b2ParticleGroupFlag["b2_solidParticleGroup"] = 1] = "b2_solidParticleGroup";
      /// Keeps its shape.
      b2ParticleGroupFlag[b2ParticleGroupFlag["b2_rigidParticleGroup"] = 2] = "b2_rigidParticleGroup";
      /// Won't be destroyed if it gets empty.
      b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupCanBeEmpty"] = 4] = "b2_particleGroupCanBeEmpty";
      /// Will be destroyed on next simulation step.
      b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupWillBeDestroyed"] = 8] = "b2_particleGroupWillBeDestroyed";
      /// Updates depth data on next simulation step.
      b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupNeedsUpdateDepth"] = 16] = "b2_particleGroupNeedsUpdateDepth";
      b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupInternalMask"] = 24] = "b2_particleGroupInternalMask";
  })(exports.ParticleGroupFlag || (exports.ParticleGroupFlag = {}));
  class b2ParticleGroupDef {
      constructor() {
          this.flags = 0;
          this.groupFlags = 0;
          this.position = new b2Vec2();
          this.angle = 0.0;
          this.linearVelocity = new b2Vec2();
          this.angularVelocity = 0.0;
          this.color = new b2Color();
          this.strength = 1.0;
          this.shapeCount = 0;
          this.stride = 0;
          this.particleCount = 0;
          this.lifetime = 0;
          this.userData = null;
          this.group = null;
      }
  }
  class b2ParticleGroup {
      constructor(system) {
          this.m_firstIndex = 0;
          this.m_lastIndex = 0;
          this.m_groupFlags = 0;
          this.m_strength = 1.0;
          this.m_prev = null;
          this.m_next = null;
          this.m_timestamp = -1;
          this.m_mass = 0.0;
          this.m_inertia = 0.0;
          this.m_center = new b2Vec2();
          this.m_linearVelocity = new b2Vec2();
          this.m_angularVelocity = 0.0;
          this.m_transform = new b2Transform();
          ///m_transform.SetIdentity();
          this.m_userData = null;
          this.m_system = system;
      }
      GetNext() {
          return this.m_next;
      }
      GetParticleSystem() {
          return this.m_system;
      }
      GetParticleCount() {
          return this.m_lastIndex - this.m_firstIndex;
      }
      GetBufferIndex() {
          return this.m_firstIndex;
      }
      ContainsParticle(index) {
          return this.m_firstIndex <= index && index < this.m_lastIndex;
      }
      GetAllParticleFlags() {
          if (!this.m_system.m_flagsBuffer.data) {
              throw new Error();
          }
          let flags = 0;
          for (let i = this.m_firstIndex; i < this.m_lastIndex; i++) {
              flags |= this.m_system.m_flagsBuffer.data[i];
          }
          return flags;
      }
      GetGroupFlags() {
          return this.m_groupFlags;
      }
      SetGroupFlags(flags) {
          // DEBUG: b2Assert((flags & b2ParticleGroupFlag.b2_particleGroupInternalMask) === 0);
          flags |= this.m_groupFlags & exports.ParticleGroupFlag.b2_particleGroupInternalMask;
          this.m_system.SetGroupFlags(this, flags);
      }
      GetMass() {
          this.UpdateStatistics();
          return this.m_mass;
      }
      GetInertia() {
          this.UpdateStatistics();
          return this.m_inertia;
      }
      GetCenter() {
          this.UpdateStatistics();
          return this.m_center;
      }
      GetLinearVelocity() {
          this.UpdateStatistics();
          return this.m_linearVelocity;
      }
      GetAngularVelocity() {
          this.UpdateStatistics();
          return this.m_angularVelocity;
      }
      GetTransform() {
          return this.m_transform;
      }
      GetPosition() {
          return this.m_transform.p;
      }
      GetAngle() {
          return this.m_transform.q.GetAngle();
      }
      GetLinearVelocityFromWorldPoint(worldPoint, out) {
          const s_t0 = b2ParticleGroup.GetLinearVelocityFromWorldPoint_s_t0;
          this.UpdateStatistics();
          ///  return m_linearVelocity + b2Cross(m_angularVelocity, worldPoint - m_center);
          return b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(worldPoint, this.m_center, s_t0), out);
      }
      GetUserData() {
          return this.m_userData;
      }
      SetUserData(data) {
          this.m_userData = data;
      }
      ApplyForce(force) {
          this.m_system.ApplyForce(this.m_firstIndex, this.m_lastIndex, force);
      }
      ApplyLinearImpulse(impulse) {
          this.m_system.ApplyLinearImpulse(this.m_firstIndex, this.m_lastIndex, impulse);
      }
      DestroyParticles(callDestructionListener) {
          if (this.m_system.m_world.IsLocked()) {
              throw new Error();
          }
          for (let i = this.m_firstIndex; i < this.m_lastIndex; i++) {
              this.m_system.DestroyParticle(i, callDestructionListener);
          }
      }
      UpdateStatistics() {
          if (!this.m_system.m_positionBuffer.data) {
              throw new Error();
          }
          if (!this.m_system.m_velocityBuffer.data) {
              throw new Error();
          }
          const p = new b2Vec2();
          const v = new b2Vec2();
          if (this.m_timestamp !== this.m_system.m_timestamp) {
              const m = this.m_system.GetParticleMass();
              ///  this.m_mass = 0;
              this.m_mass = m * (this.m_lastIndex - this.m_firstIndex);
              this.m_center.SetZero();
              this.m_linearVelocity.SetZero();
              for (let i = this.m_firstIndex; i < this.m_lastIndex; i++) {
                  ///  this.m_mass += m;
                  ///  this.m_center += m * this.m_system.m_positionBuffer.data[i];
                  this.m_center.SelfMulAdd(m, this.m_system.m_positionBuffer.data[i]);
                  ///  this.m_linearVelocity += m * this.m_system.m_velocityBuffer.data[i];
                  this.m_linearVelocity.SelfMulAdd(m, this.m_system.m_velocityBuffer.data[i]);
              }
              if (this.m_mass > 0) {
                  const inv_mass = 1 / this.m_mass;
                  ///this.m_center *= 1 / this.m_mass;
                  this.m_center.SelfMul(inv_mass);
                  ///this.m_linearVelocity *= 1 / this.m_mass;
                  this.m_linearVelocity.SelfMul(inv_mass);
              }
              this.m_inertia = 0;
              this.m_angularVelocity = 0;
              for (let i = this.m_firstIndex; i < this.m_lastIndex; i++) {
                  ///b2Vec2 p = this.m_system.m_positionBuffer.data[i] - this.m_center;
                  b2Vec2.SubVV(this.m_system.m_positionBuffer.data[i], this.m_center, p);
                  ///b2Vec2 v = this.m_system.m_velocityBuffer.data[i] - this.m_linearVelocity;
                  b2Vec2.SubVV(this.m_system.m_velocityBuffer.data[i], this.m_linearVelocity, v);
                  this.m_inertia += m * b2Vec2.DotVV(p, p);
                  this.m_angularVelocity += m * b2Vec2.CrossVV(p, v);
              }
              if (this.m_inertia > 0) {
                  this.m_angularVelocity *= 1 / this.m_inertia;
              }
              this.m_timestamp = this.m_system.m_timestamp;
          }
      }
  }
  b2ParticleGroup.GetLinearVelocityFromWorldPoint_s_t0 = new b2Vec2();
  // #endif

  /*
   * Copyright (c) 2013 Google, Inc.
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  // #if B2_ENABLE_PARTICLE
  // DEBUG: import { b2Assert } from "../common/b2_settings.js";
  class b2StackQueue {
      constructor(capacity) {
          this.m_buffer = [];
          this.m_front = 0;
          this.m_back = 0;
          this.m_buffer.fill(null, 0, capacity);
      }
      get m_capacity() { return this.m_buffer.length; }
      Push(item) {
          if (this.m_back >= this.m_capacity) {
              for (let i = this.m_front; i < this.m_back; i++) {
                  this.m_buffer[i - this.m_front] = this.m_buffer[i];
              }
              this.m_back -= this.m_front;
              this.m_front = 0;
          }
          this.m_buffer[this.m_back] = item;
          this.m_back++;
      }
      Pop() {
          // DEBUG: b2Assert(this.m_front < this.m_back);
          this.m_buffer[this.m_front] = null;
          this.m_front++;
      }
      Empty() {
          // DEBUG: b2Assert(this.m_front <= this.m_back);
          return this.m_front === this.m_back;
      }
      Front() {
          const item = this.m_buffer[this.m_front];
          if (!item) {
              throw new Error();
          }
          return item;
      }
  }
  // #endif

  /*
   * Copyright (c) 2013 Google, Inc.
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * A field representing the nearest generator from each point.
   */
  class b2VoronoiDiagram {
      constructor(generatorCapacity) {
          this.m_generatorCapacity = 0;
          this.m_generatorCount = 0;
          this.m_countX = 0;
          this.m_countY = 0;
          this.m_diagram = [];
          this.m_generatorBuffer = b2MakeArray(generatorCapacity, (index) => new b2VoronoiDiagram_Generator());
          this.m_generatorCapacity = generatorCapacity;
      }
      /**
       * Add a generator.
       *
       * @param center the position of the generator.
       * @param tag a tag used to identify the generator in callback functions.
       * @param necessary whether to callback for nodes associated with the generator.
       */
      AddGenerator(center, tag, necessary) {
          // DEBUG: b2Assert(this.m_generatorCount < this.m_generatorCapacity);
          const g = this.m_generatorBuffer[this.m_generatorCount++];
          g.center.Copy(center);
          g.tag = tag;
          g.necessary = necessary;
      }
      /**
       * Generate the Voronoi diagram. It is rasterized with a given
       * interval in the same range as the necessary generators exist.
       *
       * @param radius the interval of the diagram.
       * @param margin margin for which the range of the diagram is extended.
       */
      Generate(radius, margin) {
          const inverseRadius = 1 / radius;
          const lower = new b2Vec2(+b2_maxFloat, +b2_maxFloat);
          const upper = new b2Vec2(-b2_maxFloat, -b2_maxFloat);
          let necessary_count = 0;
          for (let k = 0; k < this.m_generatorCount; k++) {
              const g = this.m_generatorBuffer[k];
              if (g.necessary) {
                  b2Vec2.MinV(lower, g.center, lower);
                  b2Vec2.MaxV(upper, g.center, upper);
                  ++necessary_count;
              }
          }
          if (necessary_count === 0) {
              ///debugger;
              this.m_countX = 0;
              this.m_countY = 0;
              return;
          }
          lower.x -= margin;
          lower.y -= margin;
          upper.x += margin;
          upper.y += margin;
          this.m_countX = 1 + Math.floor(inverseRadius * (upper.x - lower.x));
          this.m_countY = 1 + Math.floor(inverseRadius * (upper.y - lower.y));
          this.m_diagram = []; // b2MakeArray(this.m_countX * this.m_countY, (index) => null);
          // (4 * m_countX * m_countY) is the queue capacity that is experimentally
          // known to be necessary and sufficient for general particle distributions.
          const queue = new b2StackQueue(4 * this.m_countX * this.m_countY);
          for (let k = 0; k < this.m_generatorCount; k++) {
              const g = this.m_generatorBuffer[k];
              ///  g.center = inverseRadius * (g.center - lower);
              g.center.SelfSub(lower).SelfMul(inverseRadius);
              const x = Math.floor(g.center.x);
              const y = Math.floor(g.center.y);
              if (x >= 0 && y >= 0 && x < this.m_countX && y < this.m_countY) {
                  queue.Push(new b2VoronoiDiagram_Task(x, y, x + y * this.m_countX, g));
              }
          }
          while (!queue.Empty()) {
              const task = queue.Front();
              const x = task.m_x;
              const y = task.m_y;
              const i = task.m_i;
              const g = task.m_generator;
              queue.Pop();
              if (!this.m_diagram[i]) {
                  this.m_diagram[i] = g;
                  if (x > 0) {
                      queue.Push(new b2VoronoiDiagram_Task(x - 1, y, i - 1, g));
                  }
                  if (y > 0) {
                      queue.Push(new b2VoronoiDiagram_Task(x, y - 1, i - this.m_countX, g));
                  }
                  if (x < this.m_countX - 1) {
                      queue.Push(new b2VoronoiDiagram_Task(x + 1, y, i + 1, g));
                  }
                  if (y < this.m_countY - 1) {
                      queue.Push(new b2VoronoiDiagram_Task(x, y + 1, i + this.m_countX, g));
                  }
              }
          }
          for (let y = 0; y < this.m_countY; y++) {
              for (let x = 0; x < this.m_countX - 1; x++) {
                  const i = x + y * this.m_countX;
                  const a = this.m_diagram[i];
                  const b = this.m_diagram[i + 1];
                  if (a !== b) {
                      queue.Push(new b2VoronoiDiagram_Task(x, y, i, b));
                      queue.Push(new b2VoronoiDiagram_Task(x + 1, y, i + 1, a));
                  }
              }
          }
          for (let y = 0; y < this.m_countY - 1; y++) {
              for (let x = 0; x < this.m_countX; x++) {
                  const i = x + y * this.m_countX;
                  const a = this.m_diagram[i];
                  const b = this.m_diagram[i + this.m_countX];
                  if (a !== b) {
                      queue.Push(new b2VoronoiDiagram_Task(x, y, i, b));
                      queue.Push(new b2VoronoiDiagram_Task(x, y + 1, i + this.m_countX, a));
                  }
              }
          }
          while (!queue.Empty()) {
              const task = queue.Front();
              const x = task.m_x;
              const y = task.m_y;
              const i = task.m_i;
              const k = task.m_generator;
              queue.Pop();
              const a = this.m_diagram[i];
              const b = k;
              if (a !== b) {
                  const ax = a.center.x - x;
                  const ay = a.center.y - y;
                  const bx = b.center.x - x;
                  const by = b.center.y - y;
                  const a2 = ax * ax + ay * ay;
                  const b2 = bx * bx + by * by;
                  if (a2 > b2) {
                      this.m_diagram[i] = b;
                      if (x > 0) {
                          queue.Push(new b2VoronoiDiagram_Task(x - 1, y, i - 1, b));
                      }
                      if (y > 0) {
                          queue.Push(new b2VoronoiDiagram_Task(x, y - 1, i - this.m_countX, b));
                      }
                      if (x < this.m_countX - 1) {
                          queue.Push(new b2VoronoiDiagram_Task(x + 1, y, i + 1, b));
                      }
                      if (y < this.m_countY - 1) {
                          queue.Push(new b2VoronoiDiagram_Task(x, y + 1, i + this.m_countX, b));
                      }
                  }
              }
          }
      }
      /**
       * Enumerate all nodes that contain at least one necessary
       * generator.
       */
      GetNodes(callback) {
          for (let y = 0; y < this.m_countY - 1; y++) {
              for (let x = 0; x < this.m_countX - 1; x++) {
                  const i = x + y * this.m_countX;
                  const a = this.m_diagram[i];
                  const b = this.m_diagram[i + 1];
                  const c = this.m_diagram[i + this.m_countX];
                  const d = this.m_diagram[i + 1 + this.m_countX];
                  if (b !== c) {
                      if (a !== b && a !== c &&
                          (a.necessary || b.necessary || c.necessary)) {
                          callback(a.tag, b.tag, c.tag);
                      }
                      if (d !== b && d !== c &&
                          (a.necessary || b.necessary || c.necessary)) {
                          callback(b.tag, d.tag, c.tag);
                      }
                  }
              }
          }
      }
  }
  class b2VoronoiDiagram_Generator {
      constructor() {
          this.center = new b2Vec2();
          this.tag = 0;
          this.necessary = false;
      }
  }
  class b2VoronoiDiagram_Task {
      constructor(x, y, i, g) {
          this.m_x = x;
          this.m_y = y;
          this.m_i = i;
          this.m_generator = g;
      }
  }
  // #endif

  /*
   * Copyright (c) 2013 Google, Inc.
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  function std_iter_swap(array, a, b) {
      const tmp = array[a];
      array[a] = array[b];
      array[b] = tmp;
  }
  function default_compare(a, b) { return a < b; }
  function std_sort(array, first = 0, len = array.length - first, cmp = default_compare) {
      let left = first;
      const stack = [];
      let pos = 0;
      for (;;) { /* outer loop */
          for (; left + 1 < len; len++) { /* sort left to len-1 */
              const pivot = array[left + Math.floor(Math.random() * (len - left))]; /* pick random pivot */
              stack[pos++] = len; /* sort right part later */
              for (let right = left - 1;;) { /* inner loop: partitioning */
                  while (cmp(array[++right], pivot)) { } /* look for greater element */
                  while (cmp(pivot, array[--len])) { } /* look for smaller element */
                  if (right >= len) {
                      break;
                  } /* partition point found? */
                  std_iter_swap(array, right, len); /* the only swap */
              } /* partitioned, continue left part */
          }
          if (pos === 0) {
              break;
          } /* stack empty? */
          left = len; /* left to right is sorted */
          len = stack[--pos]; /* get next range to sort */
      }
      return array;
  }
  function std_stable_sort(array, first = 0, len = array.length - first, cmp = default_compare) {
      return std_sort(array, first, len, cmp);
  }
  function std_remove_if(array, predicate, length = array.length) {
      let l = 0;
      for (let c = 0; c < length; ++c) {
          // if we can be collapsed, keep l where it is.
          if (predicate(array[c])) {
              continue;
          }
          // this node can't be collapsed; push it back as far as we can.
          if (c === l) {
              ++l;
              continue; // quick exit if we're already in the right spot
          }
          // array[l++] = array[c];
          std_iter_swap(array, l++, c);
      }
      return l;
  }
  function std_lower_bound(array, first, last, val, cmp) {
      let count = last - first;
      while (count > 0) {
          const step = Math.floor(count / 2);
          let it = first + step;
          if (cmp(array[it], val)) {
              first = ++it;
              count -= step + 1;
          }
          else {
              count = step;
          }
      }
      return first;
  }
  function std_upper_bound(array, first, last, val, cmp) {
      let count = last - first;
      while (count > 0) {
          const step = Math.floor(count / 2);
          let it = first + step;
          if (!cmp(val, array[it])) {
              first = ++it;
              count -= step + 1;
          }
          else {
              count = step;
          }
      }
      return first;
  }
  function std_rotate(array, first, n_first, last) {
      let next = n_first;
      while (first !== next) {
          std_iter_swap(array, first++, next++);
          if (next === last) {
              next = n_first;
          }
          else if (first === n_first) {
              n_first = next;
          }
      }
  }
  function std_unique(array, first, last, cmp) {
      if (first === last) {
          return last;
      }
      let result = first;
      while (++first !== last) {
          if (!cmp(array[result], array[first])) {
              ///array[++result] = array[first];
              std_iter_swap(array, ++result, first);
          }
      }
      return ++result;
  }
  class b2GrowableBuffer {
      constructor(allocator) {
          this.data = [];
          this.count = 0;
          this.capacity = 0;
          this.allocator = allocator;
      }
      Append() {
          if (this.count >= this.capacity) {
              this.Grow();
          }
          return this.count++;
      }
      Reserve(newCapacity) {
          if (this.capacity >= newCapacity) {
              return;
          }
          // DEBUG: b2Assert(this.capacity === this.data.length);
          for (let i = this.capacity; i < newCapacity; ++i) {
              this.data[i] = this.allocator();
          }
          this.capacity = newCapacity;
      }
      Grow() {
          // Double the capacity.
          const newCapacity = this.capacity ? 2 * this.capacity : b2_minParticleSystemBufferCapacity;
          // DEBUG: b2Assert(newCapacity > this.capacity);
          this.Reserve(newCapacity);
      }
      Free() {
          if (this.data.length === 0) {
              return;
          }
          this.data = [];
          this.capacity = 0;
          this.count = 0;
      }
      Shorten(newEnd) {
          // DEBUG: b2Assert(false);
      }
      Data() {
          return this.data;
      }
      GetCount() {
          return this.count;
      }
      SetCount(newCount) {
          // DEBUG: b2Assert(0 <= newCount && newCount <= this.capacity);
          this.count = newCount;
      }
      GetCapacity() {
          return this.capacity;
      }
      RemoveIf(pred) {
          // DEBUG: let count = 0;
          // DEBUG: for (let i = 0; i < this.count; ++i) {
          // DEBUG:   if (!pred(this.data[i])) {
          // DEBUG:     count++;
          // DEBUG:   }
          // DEBUG: }
          this.count = std_remove_if(this.data, pred, this.count);
          // DEBUG: b2Assert(count === this.count);
      }
      Unique(pred) {
          this.count = std_unique(this.data, 0, this.count, pred);
      }
  }
  class b2FixtureParticleQueryCallback extends b2QueryCallback {
      constructor(system) {
          super();
          this.m_system = system;
      }
      ShouldQueryParticleSystem(system) {
          // Skip reporting particles.
          return false;
      }
      ReportFixture(fixture) {
          if (fixture.IsSensor()) {
              return true;
          }
          const shape = fixture.GetShape();
          const childCount = shape.GetChildCount();
          for (let childIndex = 0; childIndex < childCount; childIndex++) {
              const aabb = fixture.GetAABB(childIndex);
              const enumerator = this.m_system.GetInsideBoundsEnumerator(aabb);
              let index;
              while ((index = enumerator.GetNext()) >= 0) {
                  this.ReportFixtureAndParticle(fixture, childIndex, index);
              }
          }
          return true;
      }
      ReportParticle(system, index) {
          return false;
      }
      ReportFixtureAndParticle(fixture, childIndex, index) {
          // DEBUG: b2Assert(false); // pure virtual
      }
  }
  class b2ParticleContact {
      constructor() {
          this.indexA = 0;
          this.indexB = 0;
          this.weight = 0;
          this.normal = new b2Vec2();
          this.flags = 0;
      }
      SetIndices(a, b) {
          // DEBUG: b2Assert(a <= b2_maxParticleIndex && b <= b2_maxParticleIndex);
          this.indexA = a;
          this.indexB = b;
      }
      SetWeight(w) {
          this.weight = w;
      }
      SetNormal(n) {
          this.normal.Copy(n);
      }
      SetFlags(f) {
          this.flags = f;
      }
      GetIndexA() {
          return this.indexA;
      }
      GetIndexB() {
          return this.indexB;
      }
      GetWeight() {
          return this.weight;
      }
      GetNormal() {
          return this.normal;
      }
      GetFlags() {
          return this.flags;
      }
      IsEqual(rhs) {
          return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && this.weight === rhs.weight && this.normal.x === rhs.normal.x && this.normal.y === rhs.normal.y;
      }
      IsNotEqual(rhs) {
          return !this.IsEqual(rhs);
      }
      ApproximatelyEqual(rhs) {
          const MAX_WEIGHT_DIFF = 0.01; // Weight 0 ~ 1, so about 1%
          const MAX_NORMAL_DIFF_SQ = 0.01 * 0.01; // Normal length = 1, so 1%
          return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && b2Abs(this.weight - rhs.weight) < MAX_WEIGHT_DIFF && b2Vec2.DistanceSquaredVV(this.normal, rhs.normal) < MAX_NORMAL_DIFF_SQ;
      }
  }
  class b2ParticleBodyContact {
      constructor() {
          this.index = 0; // Index of the particle making contact.
          this.weight = 0.0; // Weight of the contact. A value between 0.0f and 1.0f.
          this.normal = new b2Vec2(); // The normalized direction from the particle to the body.
          this.mass = 0.0; // The effective mass used in calculating force.
      }
  }
  class b2ParticlePair {
      constructor() {
          this.indexA = 0; // Indices of the respective particles making pair.
          this.indexB = 0;
          this.flags = 0; // The logical sum of the particle flags. See the b2ParticleFlag enum.
          this.strength = 0.0; // The strength of cohesion among the particles.
          this.distance = 0.0; // The initial distance of the particles.
      }
  }
  class b2ParticleTriad {
      constructor() {
          this.indexA = 0; // Indices of the respective particles making triad.
          this.indexB = 0;
          this.indexC = 0;
          this.flags = 0; // The logical sum of the particle flags. See the b2ParticleFlag enum.
          this.strength = 0.0; // The strength of cohesion among the particles.
          this.pa = new b2Vec2(0.0, 0.0); // Values used for calculation.
          this.pb = new b2Vec2(0.0, 0.0);
          this.pc = new b2Vec2(0.0, 0.0);
          this.ka = 0.0;
          this.kb = 0.0;
          this.kc = 0.0;
          this.s = 0.0;
      }
  }
  class b2ParticleSystemDef {
      constructor() {
          // Initialize physical coefficients to the maximum values that
          // maintain numerical stability.
          /**
           * Enable strict Particle/Body contact check.
           * See SetStrictContactCheck for details.
           */
          this.strictContactCheck = false;
          /**
           * Set the particle density.
           * See SetDensity for details.
           */
          this.density = 1.0;
          /**
           * Change the particle gravity scale. Adjusts the effect of the
           * global gravity vector on particles. Default value is 1.0f.
           */
          this.gravityScale = 1.0;
          /**
           * Particles behave as circles with this radius. In Box2D units.
           */
          this.radius = 1.0;
          /**
           * Set the maximum number of particles.
           * By default, there is no maximum. The particle buffers can
           * continue to grow while b2World's block allocator still has
           * memory.
           * See SetMaxParticleCount for details.
           */
          this.maxCount = 0;
          /**
           * Increases pressure in response to compression
           * Smaller values allow more compression
           */
          this.pressureStrength = 0.005;
          /**
           * Reduces velocity along the collision normal
           * Smaller value reduces less
           */
          this.dampingStrength = 1.0;
          /**
           * Restores shape of elastic particle groups
           * Larger values increase elastic particle velocity
           */
          this.elasticStrength = 0.25;
          /**
           * Restores length of spring particle groups
           * Larger values increase spring particle velocity
           */
          this.springStrength = 0.25;
          /**
           * Reduces relative velocity of viscous particles
           * Larger values slow down viscous particles more
           */
          this.viscousStrength = 0.25;
          /**
           * Produces pressure on tensile particles
           * 0~0.2. Larger values increase the amount of surface tension.
           */
          this.surfaceTensionPressureStrength = 0.2;
          /**
           * Smoothes outline of tensile particles
           * 0~0.2. Larger values result in rounder, smoother,
           * water-drop-like clusters of particles.
           */
          this.surfaceTensionNormalStrength = 0.2;
          /**
           * Produces additional pressure on repulsive particles
           * Larger values repulse more
           * Negative values mean attraction. The range where particles
           * behave stably is about -0.2 to 2.0.
           */
          this.repulsiveStrength = 1.0;
          /**
           * Produces repulsion between powder particles
           * Larger values repulse more
           */
          this.powderStrength = 0.5;
          /**
           * Pushes particles out of solid particle group
           * Larger values repulse more
           */
          this.ejectionStrength = 0.5;
          /**
           * Produces static pressure
           * Larger values increase the pressure on neighboring partilces
           * For a description of static pressure, see
           * http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics
           */
          this.staticPressureStrength = 0.2;
          /**
           * Reduces instability in static pressure calculation
           * Larger values make stabilize static pressure with fewer
           * iterations
           */
          this.staticPressureRelaxation = 0.2;
          /**
           * Computes static pressure more precisely
           * See SetStaticPressureIterations for details
           */
          this.staticPressureIterations = 8;
          /**
           * Determines how fast colors are mixed
           * 1.0f ==> mixed immediately
           * 0.5f ==> mixed half way each simulation step (see
           * b2World::Step())
           */
          this.colorMixingStrength = 0.5;
          /**
           * Whether to destroy particles by age when no more particles
           * can be created.  See #b2ParticleSystem::SetDestructionByAge()
           * for more information.
           */
          this.destroyByAge = true;
          /**
           * Granularity of particle lifetimes in seconds.  By default
           * this is set to (1.0f / 60.0f) seconds.  b2ParticleSystem uses
           * a 32-bit signed value to track particle lifetimes so the
           * maximum lifetime of a particle is (2^32 - 1) / (1.0f /
           * lifetimeGranularity) seconds. With the value set to 1/60 the
           * maximum lifetime or age of a particle is 2.27 years.
           */
          this.lifetimeGranularity = 1.0 / 60.0;
      }
      Copy(def) {
          this.strictContactCheck = def.strictContactCheck;
          this.density = def.density;
          this.gravityScale = def.gravityScale;
          this.radius = def.radius;
          this.maxCount = def.maxCount;
          this.pressureStrength = def.pressureStrength;
          this.dampingStrength = def.dampingStrength;
          this.elasticStrength = def.elasticStrength;
          this.springStrength = def.springStrength;
          this.viscousStrength = def.viscousStrength;
          this.surfaceTensionPressureStrength = def.surfaceTensionPressureStrength;
          this.surfaceTensionNormalStrength = def.surfaceTensionNormalStrength;
          this.repulsiveStrength = def.repulsiveStrength;
          this.powderStrength = def.powderStrength;
          this.ejectionStrength = def.ejectionStrength;
          this.staticPressureStrength = def.staticPressureStrength;
          this.staticPressureRelaxation = def.staticPressureRelaxation;
          this.staticPressureIterations = def.staticPressureIterations;
          this.colorMixingStrength = def.colorMixingStrength;
          this.destroyByAge = def.destroyByAge;
          this.lifetimeGranularity = def.lifetimeGranularity;
          return this;
      }
      Clone() {
          return new b2ParticleSystemDef().Copy(this);
      }
  }
  class b2ParticleSystem {
      constructor(def, world) {
          this.m_paused = false;
          this.m_timestamp = 0;
          this.m_allParticleFlags = 0;
          this.m_needsUpdateAllParticleFlags = false;
          this.m_allGroupFlags = 0;
          this.m_needsUpdateAllGroupFlags = false;
          this.m_hasForce = false;
          this.m_iterationIndex = 0;
          this.m_inverseDensity = 0.0;
          this.m_particleDiameter = 0.0;
          this.m_inverseDiameter = 0.0;
          this.m_squaredDiameter = 0.0;
          this.m_count = 0;
          this.m_internalAllocatedCapacity = 0;
          /**
           * Allocator for b2ParticleHandle instances.
           */
          ///m_handleAllocator: any = null;
          /**
           * Maps particle indicies to handles.
           */
          this.m_handleIndexBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_flagsBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_positionBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_velocityBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_forceBuffer = [];
          /**
           * this.m_weightBuffer is populated in ComputeWeight and used in
           * ComputeDepth(), SolveStaticPressure() and SolvePressure().
           */
          this.m_weightBuffer = [];
          /**
           * When any particles have the flag b2_staticPressureParticle,
           * this.m_staticPressureBuffer is first allocated and used in
           * SolveStaticPressure() and SolvePressure().  It will be
           * reallocated on subsequent CreateParticle() calls.
           */
          this.m_staticPressureBuffer = [];
          /**
           * this.m_accumulationBuffer is used in many functions as a temporary
           * buffer for scalar values.
           */
          this.m_accumulationBuffer = [];
          /**
           * When any particles have the flag b2_tensileParticle,
           * this.m_accumulation2Buffer is first allocated and used in
           * SolveTensile() as a temporary buffer for vector values.  It
           * will be reallocated on subsequent CreateParticle() calls.
           */
          this.m_accumulation2Buffer = [];
          /**
           * When any particle groups have the flag b2_solidParticleGroup,
           * this.m_depthBuffer is first allocated and populated in
           * ComputeDepth() and used in SolveSolid(). It will be
           * reallocated on subsequent CreateParticle() calls.
           */
          this.m_depthBuffer = [];
          this.m_colorBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_groupBuffer = [];
          this.m_userDataBuffer = new b2ParticleSystem_UserOverridableBuffer();
          /**
           * Stuck particle detection parameters and record keeping
           */
          this.m_stuckThreshold = 0;
          this.m_lastBodyContactStepBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_bodyContactCountBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_consecutiveContactStepsBuffer = new b2ParticleSystem_UserOverridableBuffer();
          this.m_stuckParticleBuffer = new b2GrowableBuffer(() => 0);
          this.m_proxyBuffer = new b2GrowableBuffer(() => new b2ParticleSystem_Proxy());
          this.m_contactBuffer = new b2GrowableBuffer(() => new b2ParticleContact());
          this.m_bodyContactBuffer = new b2GrowableBuffer(() => new b2ParticleBodyContact());
          this.m_pairBuffer = new b2GrowableBuffer(() => new b2ParticlePair());
          this.m_triadBuffer = new b2GrowableBuffer(() => new b2ParticleTriad());
          /**
           * Time each particle should be destroyed relative to the last
           * time this.m_timeElapsed was initialized.  Each unit of time
           * corresponds to b2ParticleSystemDef::lifetimeGranularity
           * seconds.
           */
          this.m_expirationTimeBuffer = new b2ParticleSystem_UserOverridableBuffer();
          /**
           * List of particle indices sorted by expiration time.
           */
          this.m_indexByExpirationTimeBuffer = new b2ParticleSystem_UserOverridableBuffer();
          /**
           * Time elapsed in 32:32 fixed point.  Each non-fractional unit
           * of time corresponds to
           * b2ParticleSystemDef::lifetimeGranularity seconds.
           */
          this.m_timeElapsed = 0;
          /**
           * Whether the expiration time buffer has been modified and
           * needs to be resorted.
           */
          this.m_expirationTimeBufferRequiresSorting = false;
          this.m_groupCount = 0;
          this.m_groupList = null;
          this.m_def = new b2ParticleSystemDef();
          this.m_prev = null;
          this.m_next = null;
          this.UpdateBodyContacts_callback = null;
          this.SolveCollision_callback = null;
          this.SetStrictContactCheck(def.strictContactCheck);
          this.SetDensity(def.density);
          this.SetGravityScale(def.gravityScale);
          this.SetRadius(def.radius);
          this.SetMaxParticleCount(def.maxCount);
          // DEBUG: b2Assert(def.lifetimeGranularity > 0.0);
          this.m_def = def.Clone();
          this.m_world = world;
          this.SetDestructionByAge(this.m_def.destroyByAge);
      }
      static computeTag(x, y) {
          ///return ((uint32)(y + yOffset) << yShift) + (uint32)(xScale * x + xOffset);
          return ((((y + b2ParticleSystem.yOffset) >>> 0) << b2ParticleSystem.yShift) + ((b2ParticleSystem.xScale * x + b2ParticleSystem.xOffset) >>> 0)) >>> 0;
      }
      static computeRelativeTag(tag, x, y) {
          ///return tag + (y << yShift) + (x << xShift);
          return (tag + (y << b2ParticleSystem.yShift) + (x << b2ParticleSystem.xShift)) >>> 0;
      }
      Drop() {
          while (this.m_groupList) {
              this.DestroyParticleGroup(this.m_groupList);
          }
          this.FreeUserOverridableBuffer(this.m_handleIndexBuffer);
          this.FreeUserOverridableBuffer(this.m_flagsBuffer);
          this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer);
          this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer);
          this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer);
          this.FreeUserOverridableBuffer(this.m_positionBuffer);
          this.FreeUserOverridableBuffer(this.m_velocityBuffer);
          this.FreeUserOverridableBuffer(this.m_colorBuffer);
          this.FreeUserOverridableBuffer(this.m_userDataBuffer);
          this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer);
          this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer);
          this.FreeBuffer(this.m_forceBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_weightBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_staticPressureBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_accumulationBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_accumulation2Buffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_depthBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_groupBuffer, this.m_internalAllocatedCapacity);
      }
      /**
       * Create a particle whose properties have been defined.
       *
       * No reference to the definition is retained.
       *
       * A simulation step must occur before it's possible to interact
       * with a newly created particle.  For example,
       * DestroyParticleInShape() will not destroy a particle until
       * b2World::Step() has been called.
       *
       * warning: This function is locked during callbacks.
       */
      CreateParticle(def) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          if (this.m_count >= this.m_internalAllocatedCapacity) {
              // Double the particle capacity.
              const capacity = this.m_count ? 2 * this.m_count : b2_minParticleSystemBufferCapacity;
              this.ReallocateInternalAllocatedBuffers(capacity);
          }
          if (this.m_count >= this.m_internalAllocatedCapacity) {
              // If the oldest particle should be destroyed...
              if (this.m_def.destroyByAge) {
                  this.DestroyOldestParticle(0, false);
                  // Need to destroy this particle *now* so that it's possible to
                  // create a new particle.
                  this.SolveZombie();
              }
              else {
                  return b2_invalidParticleIndex;
              }
          }
          const index = this.m_count++;
          this.m_flagsBuffer.data[index] = 0;
          if (this.m_lastBodyContactStepBuffer.data) {
              this.m_lastBodyContactStepBuffer.data[index] = 0;
          }
          if (this.m_bodyContactCountBuffer.data) {
              this.m_bodyContactCountBuffer.data[index] = 0;
          }
          if (this.m_consecutiveContactStepsBuffer.data) {
              this.m_consecutiveContactStepsBuffer.data[index] = 0;
          }
          this.m_positionBuffer.data[index] = (this.m_positionBuffer.data[index] || new b2Vec2()).Copy(b2Maybe(def.position, b2Vec2.ZERO));
          this.m_velocityBuffer.data[index] = (this.m_velocityBuffer.data[index] || new b2Vec2()).Copy(b2Maybe(def.velocity, b2Vec2.ZERO));
          this.m_weightBuffer[index] = 0;
          this.m_forceBuffer[index] = (this.m_forceBuffer[index] || new b2Vec2()).SetZero();
          if (this.m_staticPressureBuffer) {
              this.m_staticPressureBuffer[index] = 0;
          }
          if (this.m_depthBuffer) {
              this.m_depthBuffer[index] = 0;
          }
          const color = new b2Color().Copy(b2Maybe(def.color, b2Color.ZERO));
          if (this.m_colorBuffer.data || !color.IsZero()) {
              this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);
              this.m_colorBuffer.data[index] = (this.m_colorBuffer.data[index] || new b2Color()).Copy(color);
          }
          if (this.m_userDataBuffer.data || def.userData) {
              this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);
              this.m_userDataBuffer.data[index] = def.userData;
          }
          if (this.m_handleIndexBuffer.data) {
              this.m_handleIndexBuffer.data[index] = null;
          }
          ///Proxy& proxy = m_proxyBuffer.Append();
          const proxy = this.m_proxyBuffer.data[this.m_proxyBuffer.Append()];
          // If particle lifetimes are enabled or the lifetime is set in the particle
          // definition, initialize the lifetime.
          const lifetime = b2Maybe(def.lifetime, 0.0);
          const finiteLifetime = lifetime > 0.0;
          if (this.m_expirationTimeBuffer.data || finiteLifetime) {
              this.SetParticleLifetime(index, finiteLifetime ? lifetime :
                  this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed()));
              // Add a reference to the newly added particle to the end of the
              // queue.
              this.m_indexByExpirationTimeBuffer.data[index] = index;
          }
          proxy.index = index;
          const group = b2Maybe(def.group, null);
          this.m_groupBuffer[index] = group;
          if (group) {
              if (group.m_firstIndex < group.m_lastIndex) {
                  // Move particles in the group just before the new particle.
                  this.RotateBuffer(group.m_firstIndex, group.m_lastIndex, index);
                  // DEBUG: b2Assert(group.m_lastIndex === index);
                  // Update the index range of the group to contain the new particle.
                  group.m_lastIndex = index + 1;
              }
              else {
                  // If the group is empty, reset the index range to contain only the
                  // new particle.
                  group.m_firstIndex = index;
                  group.m_lastIndex = index + 1;
              }
          }
          this.SetParticleFlags(index, b2Maybe(def.flags, 0));
          return index;
      }
      /**
       * Retrieve a handle to the particle at the specified index.
       *
       * Please see #b2ParticleHandle for why you might want a handle.
       */
      GetParticleHandleFromIndex(index) {
          // DEBUG: b2Assert(index >= 0 && index < this.GetParticleCount() && index !== b2_invalidParticleIndex);
          this.m_handleIndexBuffer.data = this.RequestBuffer(this.m_handleIndexBuffer.data);
          let handle = this.m_handleIndexBuffer.data[index];
          if (handle) {
              return handle;
          }
          // Create a handle.
          ///handle = m_handleAllocator.Allocate();
          handle = new b2ParticleHandle();
          // DEBUG: b2Assert(handle !== null);
          handle.SetIndex(index);
          this.m_handleIndexBuffer.data[index] = handle;
          return handle;
      }
      /**
       * Destroy a particle.
       *
       * The particle is removed after the next simulation step (see
       * b2World::Step()).
       *
       * @param index Index of the particle to destroy.
       * @param callDestructionListener Whether to call the
       *      destruction listener just before the particle is
       *      destroyed.
       */
      DestroyParticle(index, callDestructionListener = false) {
          let flags = exports.ParticleFlag.b2_zombieParticle;
          if (callDestructionListener) {
              flags |= exports.ParticleFlag.b2_destructionListenerParticle;
          }
          this.SetParticleFlags(index, this.m_flagsBuffer.data[index] | flags);
      }
      /**
       * Destroy the Nth oldest particle in the system.
       *
       * The particle is removed after the next b2World::Step().
       *
       * @param index Index of the Nth oldest particle to
       *      destroy, 0 will destroy the oldest particle in the
       *      system, 1 will destroy the next oldest particle etc.
       * @param callDestructionListener Whether to call the
       *      destruction listener just before the particle is
       *      destroyed.
       */
      DestroyOldestParticle(index, callDestructionListener = false) {
          const particleCount = this.GetParticleCount();
          // DEBUG: b2Assert(index >= 0 && index < particleCount);
          // Make sure particle lifetime tracking is enabled.
          // DEBUG: b2Assert(this.m_indexByExpirationTimeBuffer.data !== null);
          // Destroy the oldest particle (preferring to destroy finite
          // lifetime particles first) to free a slot in the buffer.
          const oldestFiniteLifetimeParticle = this.m_indexByExpirationTimeBuffer.data[particleCount - (index + 1)];
          const oldestInfiniteLifetimeParticle = this.m_indexByExpirationTimeBuffer.data[index];
          this.DestroyParticle(this.m_expirationTimeBuffer.data[oldestFiniteLifetimeParticle] > 0.0 ?
              oldestFiniteLifetimeParticle : oldestInfiniteLifetimeParticle, callDestructionListener);
      }
      /**
       * Destroy particles inside a shape.
       *
       * warning: This function is locked during callbacks.
       *
       * In addition, this function immediately destroys particles in
       * the shape in constrast to DestroyParticle() which defers the
       * destruction until the next simulation step.
       *
       * @return Number of particles destroyed.
       * @param shape Shape which encloses particles
       *      that should be destroyed.
       * @param xf Transform applied to the shape.
       * @param callDestructionListener Whether to call the
       *      world b2DestructionListener for each particle
       *      destroyed.
       */
      DestroyParticlesInShape(shape, xf, callDestructionListener = false) {
          const s_aabb = b2ParticleSystem.DestroyParticlesInShape_s_aabb;
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          const callback = new b2ParticleSystem_DestroyParticlesInShapeCallback(this, shape, xf, callDestructionListener);
          const aabb = s_aabb;
          shape.ComputeAABB(aabb, xf, 0);
          this.m_world.QueryAABB(callback, aabb);
          return callback.Destroyed();
      }
      /**
       * Create a particle group whose properties have been defined.
       *
       * No reference to the definition is retained.
       *
       * warning: This function is locked during callbacks.
       */
      CreateParticleGroup(groupDef) {
          const s_transform = b2ParticleSystem.CreateParticleGroup_s_transform;
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          const transform = s_transform;
          transform.SetPositionAngle(b2Maybe(groupDef.position, b2Vec2.ZERO), b2Maybe(groupDef.angle, 0));
          const firstIndex = this.m_count;
          if (groupDef.shape) {
              this.CreateParticlesWithShapeForGroup(groupDef.shape, groupDef, transform);
          }
          if (groupDef.shapes) {
              this.CreateParticlesWithShapesForGroup(groupDef.shapes, b2Maybe(groupDef.shapeCount, groupDef.shapes.length), groupDef, transform);
          }
          if (groupDef.positionData) {
              const count = b2Maybe(groupDef.particleCount, groupDef.positionData.length);
              for (let i = 0; i < count; i++) {
                  const p = groupDef.positionData[i];
                  this.CreateParticleForGroup(groupDef, transform, p);
              }
          }
          const lastIndex = this.m_count;
          let group = new b2ParticleGroup(this);
          group.m_firstIndex = firstIndex;
          group.m_lastIndex = lastIndex;
          group.m_strength = b2Maybe(groupDef.strength, 1);
          group.m_userData = groupDef.userData;
          group.m_transform.Copy(transform);
          group.m_prev = null;
          group.m_next = this.m_groupList;
          if (this.m_groupList) {
              this.m_groupList.m_prev = group;
          }
          this.m_groupList = group;
          ++this.m_groupCount;
          for (let i = firstIndex; i < lastIndex; i++) {
              this.m_groupBuffer[i] = group;
          }
          this.SetGroupFlags(group, b2Maybe(groupDef.groupFlags, 0));
          // Create pairs and triads between particles in the group.
          const filter = new b2ParticleSystem_ConnectionFilter();
          this.UpdateContacts(true);
          this.UpdatePairsAndTriads(firstIndex, lastIndex, filter);
          if (groupDef.group) {
              this.JoinParticleGroups(groupDef.group, group);
              group = groupDef.group;
          }
          return group;
      }
      /**
       * Join two particle groups.
       *
       * warning: This function is locked during callbacks.
       *
       * @param groupA the first group. Expands to encompass the second group.
       * @param groupB the second group. It is destroyed.
       */
      JoinParticleGroups(groupA, groupB) {
          if (this.m_world.IsLocked()) {
              throw new Error();
          }
          // DEBUG: b2Assert(groupA !== groupB);
          this.RotateBuffer(groupB.m_firstIndex, groupB.m_lastIndex, this.m_count);
          // DEBUG: b2Assert(groupB.m_lastIndex === this.m_count);
          this.RotateBuffer(groupA.m_firstIndex, groupA.m_lastIndex, groupB.m_firstIndex);
          // DEBUG: b2Assert(groupA.m_lastIndex === groupB.m_firstIndex);
          // Create pairs and triads connecting groupA and groupB.
          const filter = new b2ParticleSystem_JoinParticleGroupsFilter(groupB.m_firstIndex);
          this.UpdateContacts(true);
          this.UpdatePairsAndTriads(groupA.m_firstIndex, groupB.m_lastIndex, filter);
          for (let i = groupB.m_firstIndex; i < groupB.m_lastIndex; i++) {
              this.m_groupBuffer[i] = groupA;
          }
          const groupFlags = groupA.m_groupFlags | groupB.m_groupFlags;
          this.SetGroupFlags(groupA, groupFlags);
          groupA.m_lastIndex = groupB.m_lastIndex;
          groupB.m_firstIndex = groupB.m_lastIndex;
          this.DestroyParticleGroup(groupB);
      }
      /**
       * Split particle group into multiple disconnected groups.
       *
       * warning: This function is locked during callbacks.
       *
       * @param group the group to be split.
       */
      SplitParticleGroup(group) {
          this.UpdateContacts(true);
          const particleCount = group.GetParticleCount();
          // We create several linked lists. Each list represents a set of connected particles.
          const nodeBuffer = b2MakeArray(particleCount, (index) => new b2ParticleSystem_ParticleListNode());
          b2ParticleSystem.InitializeParticleLists(group, nodeBuffer);
          this.MergeParticleListsInContact(group, nodeBuffer);
          const survivingList = b2ParticleSystem.FindLongestParticleList(group, nodeBuffer);
          this.MergeZombieParticleListNodes(group, nodeBuffer, survivingList);
          this.CreateParticleGroupsFromParticleList(group, nodeBuffer, survivingList);
          this.UpdatePairsAndTriadsWithParticleList(group, nodeBuffer);
      }
      /**
       * Get the world particle group list. With the returned group,
       * use b2ParticleGroup::GetNext to get the next group in the
       * world list.
       *
       * A null group indicates the end of the list.
       *
       * @return the head of the world particle group list.
       */
      GetParticleGroupList() {
          return this.m_groupList;
      }
      /**
       * Get the number of particle groups.
       */
      GetParticleGroupCount() {
          return this.m_groupCount;
      }
      /**
       * Get the number of particles.
       */
      GetParticleCount() {
          return this.m_count;
      }
      /**
       * Get the maximum number of particles.
       */
      GetMaxParticleCount() {
          return this.m_def.maxCount;
      }
      /**
       * Set the maximum number of particles.
       *
       * A value of 0 means there is no maximum. The particle buffers
       * can continue to grow while b2World's block allocator still
       * has memory.
       *
       * Note: If you try to CreateParticle() with more than this
       * count, b2_invalidParticleIndex is returned unless
       * SetDestructionByAge() is used to enable the destruction of
       * the oldest particles in the system.
       */
      SetMaxParticleCount(count) {
          // DEBUG: b2Assert(this.m_count <= count);
          this.m_def.maxCount = count;
      }
      /**
       * Get all existing particle flags.
       */
      GetAllParticleFlags() {
          return this.m_allParticleFlags;
      }
      /**
       * Get all existing particle group flags.
       */
      GetAllGroupFlags() {
          return this.m_allGroupFlags;
      }
      /**
       * Pause or unpause the particle system. When paused,
       * b2World::Step() skips over this particle system. All
       * b2ParticleSystem function calls still work.
       *
       * @param paused paused is true to pause, false to un-pause.
       */
      SetPaused(paused) {
          this.m_paused = paused;
      }
      /**
       * Initially, true, then, the last value passed into
       * SetPaused().
       *
       * @return true if the particle system is being updated in b2World::Step().
       */
      GetPaused() {
          return this.m_paused;
      }
      /**
       * Change the particle density.
       *
       * Particle density affects the mass of the particles, which in
       * turn affects how the particles interact with b2Bodies. Note
       * that the density does not affect how the particles interact
       * with each other.
       */
      SetDensity(density) {
          this.m_def.density = density;
          this.m_inverseDensity = 1 / this.m_def.density;
      }
      /**
       * Get the particle density.
       */
      GetDensity() {
          return this.m_def.density;
      }
      /**
       * Change the particle gravity scale. Adjusts the effect of the
       * global gravity vector on particles.
       */
      SetGravityScale(gravityScale) {
          this.m_def.gravityScale = gravityScale;
      }
      /**
       * Get the particle gravity scale.
       */
      GetGravityScale() {
          return this.m_def.gravityScale;
      }
      /**
       * Damping is used to reduce the velocity of particles. The
       * damping parameter can be larger than 1.0f but the damping
       * effect becomes sensitive to the time step when the damping
       * parameter is large.
       */
      SetDamping(damping) {
          this.m_def.dampingStrength = damping;
      }
      /**
       * Get damping for particles
       */
      GetDamping() {
          return this.m_def.dampingStrength;
      }
      /**
       * Change the number of iterations when calculating the static
       * pressure of particles. By default, 8 iterations. You can
       * reduce the number of iterations down to 1 in some situations,
       * but this may cause instabilities when many particles come
       * together. If you see particles popping away from each other
       * like popcorn, you may have to increase the number of
       * iterations.
       *
       * For a description of static pressure, see
       * http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics
       */
      SetStaticPressureIterations(iterations) {
          this.m_def.staticPressureIterations = iterations;
      }
      /**
       * Get the number of iterations for static pressure of
       * particles.
       */
      GetStaticPressureIterations() {
          return this.m_def.staticPressureIterations;
      }
      /**
       * Change the particle radius.
       *
       * You should set this only once, on world start.
       * If you change the radius during execution, existing particles
       * may explode, shrink, or behave unexpectedly.
       */
      SetRadius(radius) {
          this.m_particleDiameter = 2 * radius;
          this.m_squaredDiameter = this.m_particleDiameter * this.m_particleDiameter;
          this.m_inverseDiameter = 1 / this.m_particleDiameter;
      }
      /**
       * Get the particle radius.
       */
      GetRadius() {
          return this.m_particleDiameter / 2;
      }
      /**
       * Get the position of each particle
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle positions array.
       */
      GetPositionBuffer() {
          return this.m_positionBuffer.data;
      }
      /**
       * Get the velocity of each particle
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle velocities array.
       */
      GetVelocityBuffer() {
          return this.m_velocityBuffer.data;
      }
      /**
       * Get the color of each particle
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle colors array.
       */
      GetColorBuffer() {
          this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);
          return this.m_colorBuffer.data;
      }
      /**
       * Get the particle-group of each particle.
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle group array.
       */
      GetGroupBuffer() {
          return this.m_groupBuffer;
      }
      /**
       * Get the weight of each particle
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle positions array.
       */
      GetWeightBuffer() {
          return this.m_weightBuffer;
      }
      /**
       * Get the user-specified data of each particle.
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle user-data array.
       */
      GetUserDataBuffer() {
          this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);
          return this.m_userDataBuffer.data;
      }
      /**
       * Get the flags for each particle. See the b2ParticleFlag enum.
       *
       * Array is length GetParticleCount()
       *
       * @return the pointer to the head of the particle-flags array.
       */
      GetFlagsBuffer() {
          return this.m_flagsBuffer.data;
      }
      /**
       * Set flags for a particle. See the b2ParticleFlag enum.
       */
      SetParticleFlags(index, newFlags) {
          const oldFlags = this.m_flagsBuffer.data[index];
          if (oldFlags & ~newFlags) {
              // If any flags might be removed
              this.m_needsUpdateAllParticleFlags = true;
          }
          if (~this.m_allParticleFlags & newFlags) {
              // If any flags were added
              if (newFlags & exports.ParticleFlag.b2_tensileParticle) {
                  this.m_accumulation2Buffer = this.RequestBuffer(this.m_accumulation2Buffer);
              }
              if (newFlags & exports.ParticleFlag.b2_colorMixingParticle) {
                  this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);
              }
              this.m_allParticleFlags |= newFlags;
          }
          this.m_flagsBuffer.data[index] = newFlags;
      }
      /**
       * Get flags for a particle. See the b2ParticleFlag enum.
       */
      GetParticleFlags(index) {
          return this.m_flagsBuffer.data[index];
      }
      /**
       * Set an external buffer for particle data.
       *
       * Normally, the b2World's block allocator is used for particle
       * data. However, sometimes you may have an OpenGL or Java
       * buffer for particle data. To avoid data duplication, you may
       * supply this external buffer.
       *
       * Note that, when b2World's block allocator is used, the
       * particle data buffers can grow as required. However, when
       * external buffers are used, the maximum number of particles is
       * clamped to the size of the smallest external buffer.
       *
       * @param buffer a pointer to a block of memory.
       * @param capacity the number of values in the block.
       */
      SetFlagsBuffer(buffer) {
          this.SetUserOverridableBuffer(this.m_flagsBuffer, buffer);
      }
      SetPositionBuffer(buffer) {
          if (buffer instanceof Float32Array) {
              if (buffer.length % 2 !== 0) {
                  throw new Error();
              }
              const count = buffer.length / 2;
              const array = new Array(count);
              for (let i = 0; i < count; ++i) {
                  array[i] = new b2TypedVec2(buffer.subarray(i * 2, i * 2 + 2));
              }
              buffer = array;
          }
          this.SetUserOverridableBuffer(this.m_positionBuffer, buffer);
      }
      SetVelocityBuffer(buffer) {
          if (buffer instanceof Float32Array) {
              if (buffer.length % 2 !== 0) {
                  throw new Error();
              }
              const count = buffer.length / 2;
              const array = new Array(count);
              for (let i = 0; i < count; ++i) {
                  array[i] = new b2TypedVec2(buffer.subarray(i * 2, i * 2 + 2));
              }
              buffer = array;
          }
          this.SetUserOverridableBuffer(this.m_velocityBuffer, buffer);
      }
      SetColorBuffer(buffer) {
          if (buffer instanceof Float32Array) {
              if (buffer.length % 4 !== 0) {
                  throw new Error();
              }
              const count = buffer.length / 4;
              const array = new Array(count);
              for (let i = 0; i < count; ++i) {
                  array[i] = new b2TypedColor(buffer.subarray(i * 4, i * 4 + 4));
              }
              buffer = array;
          }
          this.SetUserOverridableBuffer(this.m_colorBuffer, buffer);
      }
      SetUserDataBuffer(buffer) {
          this.SetUserOverridableBuffer(this.m_userDataBuffer, buffer);
      }
      /**
       * Get contacts between particles
       * Contact data can be used for many reasons, for example to
       * trigger rendering or audio effects.
       */
      GetContacts() {
          return this.m_contactBuffer.data;
      }
      GetContactCount() {
          return this.m_contactBuffer.count;
      }
      /**
       * Get contacts between particles and bodies
       *
       * Contact data can be used for many reasons, for example to
       * trigger rendering or audio effects.
       */
      GetBodyContacts() {
          return this.m_bodyContactBuffer.data;
      }
      GetBodyContactCount() {
          return this.m_bodyContactBuffer.count;
      }
      /**
       * Get array of particle pairs. The particles in a pair:
       *   (1) are contacting,
       *   (2) are in the same particle group,
       *   (3) are part of a rigid particle group, or are spring, elastic,
       *       or wall particles.
       *   (4) have at least one particle that is a spring or barrier
       *       particle (i.e. one of the types in k_pairFlags),
       *   (5) have at least one particle that returns true for
       *       ConnectionFilter::IsNecessary,
       *   (6) are not zombie particles.
       *
       * Essentially, this is an array of spring or barrier particles
       * that are interacting. The array is sorted by b2ParticlePair's
       * indexA, and then indexB. There are no duplicate entries.
       */
      GetPairs() {
          return this.m_pairBuffer.data;
      }
      GetPairCount() {
          return this.m_pairBuffer.count;
      }
      /**
       * Get array of particle triads. The particles in a triad:
       *   (1) are in the same particle group,
       *   (2) are in a Voronoi triangle together,
       *   (3) are within b2_maxTriadDistance particle diameters of each
       *       other,
       *   (4) return true for ConnectionFilter::ShouldCreateTriad
       *   (5) have at least one particle of type elastic (i.e. one of the
       *       types in k_triadFlags),
       *   (6) are part of a rigid particle group, or are spring, elastic,
       *       or wall particles.
       *   (7) are not zombie particles.
       *
       * Essentially, this is an array of elastic particles that are
       * interacting. The array is sorted by b2ParticleTriad's indexA,
       * then indexB, then indexC. There are no duplicate entries.
       */
      GetTriads() {
          return this.m_triadBuffer.data;
      }
      GetTriadCount() {
          return this.m_triadBuffer.count;
      }
      /**
       * Set an optional threshold for the maximum number of
       * consecutive particle iterations that a particle may contact
       * multiple bodies before it is considered a candidate for being
       * "stuck". Setting to zero or less disables.
       */
      SetStuckThreshold(steps) {
          this.m_stuckThreshold = steps;
          if (steps > 0) {
              this.m_lastBodyContactStepBuffer.data = this.RequestBuffer(this.m_lastBodyContactStepBuffer.data);
              this.m_bodyContactCountBuffer.data = this.RequestBuffer(this.m_bodyContactCountBuffer.data);
              this.m_consecutiveContactStepsBuffer.data = this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data);
          }
      }
      /**
       * Get potentially stuck particles from the last step; the user
       * must decide if they are stuck or not, and if so, delete or
       * move them
       */
      GetStuckCandidates() {
          ///return m_stuckParticleBuffer.Data();
          return this.m_stuckParticleBuffer.Data();
      }
      /**
       * Get the number of stuck particle candidates from the last
       * step.
       */
      GetStuckCandidateCount() {
          ///return m_stuckParticleBuffer.GetCount();
          return this.m_stuckParticleBuffer.GetCount();
      }
      /**
       * Compute the kinetic energy that can be lost by damping force
       */
      ComputeCollisionEnergy() {
          const s_v = b2ParticleSystem.ComputeCollisionEnergy_s_v;
          const vel_data = this.m_velocityBuffer.data;
          let sum_v2 = 0;
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const n = contact.normal;
              ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];
              const v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);
              const vn = b2Vec2.DotVV(v, n);
              if (vn < 0) {
                  sum_v2 += vn * vn;
              }
          }
          return 0.5 * this.GetParticleMass() * sum_v2;
      }
      /**
       * Set strict Particle/Body contact check.
       *
       * This is an option that will help ensure correct behavior if
       * there are corners in the world model where Particle/Body
       * contact is ambiguous. This option scales at n*log(n) of the
       * number of Particle/Body contacts, so it is best to only
       * enable if it is necessary for your geometry. Enable if you
       * see strange particle behavior around b2Body intersections.
       */
      SetStrictContactCheck(enabled) {
          this.m_def.strictContactCheck = enabled;
      }
      /**
       * Get the status of the strict contact check.
       */
      GetStrictContactCheck() {
          return this.m_def.strictContactCheck;
      }
      /**
       * Set the lifetime (in seconds) of a particle relative to the
       * current time.  A lifetime of less than or equal to 0.0f
       * results in the particle living forever until it's manually
       * destroyed by the application.
       */
      SetParticleLifetime(index, lifetime) {
          // DEBUG: b2Assert(this.ValidateParticleIndex(index));
          const initializeExpirationTimes = this.m_indexByExpirationTimeBuffer.data === null;
          this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);
          this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);
          // Initialize the inverse mapping buffer.
          if (initializeExpirationTimes) {
              const particleCount = this.GetParticleCount();
              for (let i = 0; i < particleCount; ++i) {
                  this.m_indexByExpirationTimeBuffer.data[i] = i;
              }
          }
          ///const int32 quantizedLifetime = (int32)(lifetime / m_def.lifetimeGranularity);
          const quantizedLifetime = lifetime / this.m_def.lifetimeGranularity;
          // Use a negative lifetime so that it's possible to track which
          // of the infinite lifetime particles are older.
          const newExpirationTime = quantizedLifetime > 0.0 ? this.GetQuantizedTimeElapsed() + quantizedLifetime : quantizedLifetime;
          if (newExpirationTime !== this.m_expirationTimeBuffer.data[index]) {
              this.m_expirationTimeBuffer.data[index] = newExpirationTime;
              this.m_expirationTimeBufferRequiresSorting = true;
          }
      }
      /**
       * Get the lifetime (in seconds) of a particle relative to the
       * current time.  A value > 0.0f is returned if the particle is
       * scheduled to be destroyed in the future, values <= 0.0f
       * indicate the particle has an infinite lifetime.
       */
      GetParticleLifetime(index) {
          // DEBUG: b2Assert(this.ValidateParticleIndex(index));
          return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[index]);
      }
      /**
       * Enable / disable destruction of particles in CreateParticle()
       * when no more particles can be created due to a prior call to
       * SetMaxParticleCount().  When this is enabled, the oldest
       * particle is destroyed in CreateParticle() favoring the
       * destruction of particles with a finite lifetime over
       * particles with infinite lifetimes. This feature is enabled by
       * default when particle lifetimes are tracked.  Explicitly
       * enabling this feature using this function enables particle
       * lifetime tracking.
       */
      SetDestructionByAge(enable) {
          if (enable) {
              this.GetExpirationTimeBuffer();
          }
          this.m_def.destroyByAge = enable;
      }
      /**
       * Get whether the oldest particle will be destroyed in
       * CreateParticle() when the maximum number of particles are
       * present in the system.
       */
      GetDestructionByAge() {
          return this.m_def.destroyByAge;
      }
      /**
       * Get the array of particle expiration times indexed by
       * particle index.
       *
       * GetParticleCount() items are in the returned array.
       */
      GetExpirationTimeBuffer() {
          this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);
          return this.m_expirationTimeBuffer.data;
      }
      /**
       * Convert a expiration time value in returned by
       * GetExpirationTimeBuffer() to a time in seconds relative to
       * the current simulation time.
       */
      ExpirationTimeToLifetime(expirationTime) {
          return (expirationTime > 0 ?
              expirationTime - this.GetQuantizedTimeElapsed() :
              expirationTime) * this.m_def.lifetimeGranularity;
      }
      /**
       * Get the array of particle indices ordered by reverse
       * lifetime. The oldest particle indexes are at the end of the
       * array with the newest at the start.  Particles with infinite
       * lifetimes (i.e expiration times less than or equal to 0) are
       * placed at the start of the array.
       * ExpirationTimeToLifetime(GetExpirationTimeBuffer()[index]) is
       * equivalent to GetParticleLifetime(index).
       *
       * GetParticleCount() items are in the returned array.
       */
      GetIndexByExpirationTimeBuffer() {
          // If particles are present, initialize / reinitialize the lifetime buffer.
          if (this.GetParticleCount()) {
              this.SetParticleLifetime(0, this.GetParticleLifetime(0));
          }
          else {
              this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);
          }
          return this.m_indexByExpirationTimeBuffer.data;
      }
      /**
       * Apply an impulse to one particle. This immediately modifies
       * the velocity. Similar to b2Body::ApplyLinearImpulse.
       *
       * @param index the particle that will be modified.
       * @param impulse impulse the world impulse vector, usually in N-seconds or kg-m/s.
       */
      ParticleApplyLinearImpulse(index, impulse) {
          this.ApplyLinearImpulse(index, index + 1, impulse);
      }
      /**
       * Apply an impulse to all particles between 'firstIndex' and
       * 'lastIndex'. This immediately modifies the velocity. Note
       * that the impulse is applied to the total mass of all
       * particles. So, calling ParticleApplyLinearImpulse(0, impulse)
       * and ParticleApplyLinearImpulse(1, impulse) will impart twice
       * as much velocity as calling just ApplyLinearImpulse(0, 1,
       * impulse).
       *
       * @param firstIndex the first particle to be modified.
       * @param lastIndex the last particle to be modified.
       * @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
       */
      ApplyLinearImpulse(firstIndex, lastIndex, impulse) {
          const vel_data = this.m_velocityBuffer.data;
          const numParticles = (lastIndex - firstIndex);
          const totalMass = numParticles * this.GetParticleMass();
          ///const b2Vec2 velocityDelta = impulse / totalMass;
          const velocityDelta = new b2Vec2().Copy(impulse).SelfMul(1 / totalMass);
          for (let i = firstIndex; i < lastIndex; i++) {
              ///m_velocityBuffer.data[i] += velocityDelta;
              vel_data[i].SelfAdd(velocityDelta);
          }
      }
      static IsSignificantForce(force) {
          return force.x !== 0 || force.y !== 0;
      }
      /**
       * Apply a force to the center of a particle.
       *
       * @param index the particle that will be modified.
       * @param force the world force vector, usually in Newtons (N).
       */
      ParticleApplyForce(index, force) {
          if (b2ParticleSystem.IsSignificantForce(force) &&
              this.ForceCanBeApplied(this.m_flagsBuffer.data[index])) {
              this.PrepareForceBuffer();
              ///m_forceBuffer[index] += force;
              this.m_forceBuffer[index].SelfAdd(force);
          }
      }
      /**
       * Distribute a force across several particles. The particles
       * must not be wall particles. Note that the force is
       * distributed across all the particles, so calling this
       * function for indices 0..N is not the same as calling
       * ParticleApplyForce(i, force) for i in 0..N.
       *
       * @param firstIndex the first particle to be modified.
       * @param lastIndex the last particle to be modified.
       * @param force the world force vector, usually in Newtons (N).
       */
      ApplyForce(firstIndex, lastIndex, force) {
          // Ensure we're not trying to apply force to particles that can't move,
          // such as wall particles.
          // DEBUG: let flags = 0;
          // DEBUG: for (let i = firstIndex; i < lastIndex; i++) {
          // DEBUG:   flags |= this.m_flagsBuffer.data[i];
          // DEBUG: }
          // DEBUG: b2Assert(this.ForceCanBeApplied(flags));
          // Early out if force does nothing (optimization).
          ///const b2Vec2 distributedForce = force / (float32)(lastIndex - firstIndex);
          const distributedForce = new b2Vec2().Copy(force).SelfMul(1 / (lastIndex - firstIndex));
          if (b2ParticleSystem.IsSignificantForce(distributedForce)) {
              this.PrepareForceBuffer();
              // Distribute the force over all the particles.
              for (let i = firstIndex; i < lastIndex; i++) {
                  ///m_forceBuffer[i] += distributedForce;
                  this.m_forceBuffer[i].SelfAdd(distributedForce);
              }
          }
      }
      /**
       * Get the next particle-system in the world's particle-system
       * list.
       */
      GetNext() {
          return this.m_next;
      }
      /**
       * Query the particle system for all particles that potentially
       * overlap the provided AABB.
       * b2QueryCallback::ShouldQueryParticleSystem is ignored.
       *
       * @param callback a user implemented callback class.
       * @param aabb the query box.
       */
      QueryAABB(callback, aabb) {
          if (this.m_proxyBuffer.count === 0) {
              return;
          }
          const beginProxy = 0;
          const endProxy = this.m_proxyBuffer.count;
          const firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x, this.m_inverseDiameter * aabb.lowerBound.y), b2ParticleSystem_Proxy.CompareProxyTag);
          const lastProxy = std_upper_bound(this.m_proxyBuffer.data, firstProxy, endProxy, b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x, this.m_inverseDiameter * aabb.upperBound.y), b2ParticleSystem_Proxy.CompareTagProxy);
          const pos_data = this.m_positionBuffer.data;
          for (let k = firstProxy; k < lastProxy; ++k) {
              const proxy = this.m_proxyBuffer.data[k];
              const i = proxy.index;
              const p = pos_data[i];
              if (aabb.lowerBound.x < p.x && p.x < aabb.upperBound.x &&
                  aabb.lowerBound.y < p.y && p.y < aabb.upperBound.y) {
                  if (!callback.ReportParticle(this, i)) {
                      break;
                  }
              }
          }
      }
      /**
       * Query the particle system for all particles that potentially
       * overlap the provided shape's AABB. Calls QueryAABB
       * internally. b2QueryCallback::ShouldQueryParticleSystem is
       * ignored.
       *
       * @param callback a user implemented callback class.
       * @param shape the query shape
       * @param xf the transform of the AABB
       * @param childIndex
       */
      QueryShapeAABB(callback, shape, xf, childIndex = 0) {
          const s_aabb = b2ParticleSystem.QueryShapeAABB_s_aabb;
          const aabb = s_aabb;
          shape.ComputeAABB(aabb, xf, childIndex);
          this.QueryAABB(callback, aabb);
      }
      QueryPointAABB(callback, point, slop = b2_linearSlop) {
          const s_aabb = b2ParticleSystem.QueryPointAABB_s_aabb;
          const aabb = s_aabb;
          aabb.lowerBound.Set(point.x - slop, point.y - slop);
          aabb.upperBound.Set(point.x + slop, point.y + slop);
          this.QueryAABB(callback, aabb);
      }
      /**
       * Ray-cast the particle system for all particles in the path of
       * the ray. Your callback controls whether you get the closest
       * point, any point, or n-points. The ray-cast ignores particles
       * that contain the starting point.
       * b2RayCastCallback::ShouldQueryParticleSystem is ignored.
       *
       * @param callback a user implemented callback class.
       * @param point1 the ray starting point
       * @param point2 the ray ending point
       */
      RayCast(callback, point1, point2) {
          const s_aabb = b2ParticleSystem.RayCast_s_aabb;
          const s_p = b2ParticleSystem.RayCast_s_p;
          const s_v = b2ParticleSystem.RayCast_s_v;
          const s_n = b2ParticleSystem.RayCast_s_n;
          const s_point = b2ParticleSystem.RayCast_s_point;
          if (this.m_proxyBuffer.count === 0) {
              return;
          }
          const pos_data = this.m_positionBuffer.data;
          const aabb = s_aabb;
          b2Vec2.MinV(point1, point2, aabb.lowerBound);
          b2Vec2.MaxV(point1, point2, aabb.upperBound);
          let fraction = 1;
          // solving the following equation:
          // ((1-t)*point1+t*point2-position)^2=diameter^2
          // where t is a potential fraction
          ///b2Vec2 v = point2 - point1;
          const v = b2Vec2.SubVV(point2, point1, s_v);
          const v2 = b2Vec2.DotVV(v, v);
          const enumerator = this.GetInsideBoundsEnumerator(aabb);
          let i;
          while ((i = enumerator.GetNext()) >= 0) {
              ///b2Vec2 p = point1 - m_positionBuffer.data[i];
              const p = b2Vec2.SubVV(point1, pos_data[i], s_p);
              const pv = b2Vec2.DotVV(p, v);
              const p2 = b2Vec2.DotVV(p, p);
              const determinant = pv * pv - v2 * (p2 - this.m_squaredDiameter);
              if (determinant >= 0) {
                  const sqrtDeterminant = b2Sqrt(determinant);
                  // find a solution between 0 and fraction
                  let t = (-pv - sqrtDeterminant) / v2;
                  if (t > fraction) {
                      continue;
                  }
                  if (t < 0) {
                      t = (-pv + sqrtDeterminant) / v2;
                      if (t < 0 || t > fraction) {
                          continue;
                      }
                  }
                  ///b2Vec2 n = p + t * v;
                  const n = b2Vec2.AddVMulSV(p, t, v, s_n);
                  n.Normalize();
                  ///float32 f = callback.ReportParticle(this, i, point1 + t * v, n, t);
                  const f = callback.ReportParticle(this, i, b2Vec2.AddVMulSV(point1, t, v, s_point), n, t);
                  fraction = b2Min(fraction, f);
                  if (fraction <= 0) {
                      break;
                  }
              }
          }
      }
      /**
       * Compute the axis-aligned bounding box for all particles
       * contained within this particle system.
       * @param aabb Returns the axis-aligned bounding box of the system.
       */
      ComputeAABB(aabb) {
          const particleCount = this.GetParticleCount();
          // DEBUG: b2Assert(aabb !== null);
          aabb.lowerBound.x = +b2_maxFloat;
          aabb.lowerBound.y = +b2_maxFloat;
          aabb.upperBound.x = -b2_maxFloat;
          aabb.upperBound.y = -b2_maxFloat;
          const pos_data = this.m_positionBuffer.data;
          for (let i = 0; i < particleCount; i++) {
              const p = pos_data[i];
              b2Vec2.MinV(aabb.lowerBound, p, aabb.lowerBound);
              b2Vec2.MaxV(aabb.upperBound, p, aabb.upperBound);
          }
          aabb.lowerBound.x -= this.m_particleDiameter;
          aabb.lowerBound.y -= this.m_particleDiameter;
          aabb.upperBound.x += this.m_particleDiameter;
          aabb.upperBound.y += this.m_particleDiameter;
      }
      FreeBuffer(b, capacity) {
          if (b === null) {
              return;
          }
          b.length = 0;
      }
      FreeUserOverridableBuffer(b) {
          if (b.userSuppliedCapacity === 0) {
              this.FreeBuffer(b.data, this.m_internalAllocatedCapacity);
          }
      }
      /**
       * Reallocate a buffer
       */
      ReallocateBuffer3(oldBuffer, oldCapacity, newCapacity) {
          // b2Assert(newCapacity > oldCapacity);
          if (newCapacity <= oldCapacity) {
              throw new Error();
          }
          const newBuffer = (oldBuffer) ? oldBuffer.slice() : [];
          newBuffer.length = newCapacity;
          return newBuffer;
      }
      /**
       * Reallocate a buffer
       */
      ReallocateBuffer5(buffer, userSuppliedCapacity, oldCapacity, newCapacity, deferred) {
          // b2Assert(newCapacity > oldCapacity);
          if (newCapacity <= oldCapacity) {
              throw new Error();
          }
          // A 'deferred' buffer is reallocated only if it is not NULL.
          // If 'userSuppliedCapacity' is not zero, buffer is user supplied and must
          // be kept.
          // b2Assert(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity);
          if (!(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity)) {
              throw new Error();
          }
          if ((!deferred || buffer) && !userSuppliedCapacity) {
              buffer = this.ReallocateBuffer3(buffer, oldCapacity, newCapacity);
          }
          return buffer; // TODO: fix this
      }
      /**
       * Reallocate a buffer
       */
      ReallocateBuffer4(buffer, oldCapacity, newCapacity, deferred) {
          // DEBUG: b2Assert(newCapacity > oldCapacity);
          return this.ReallocateBuffer5(buffer.data, buffer.userSuppliedCapacity, oldCapacity, newCapacity, deferred);
      }
      RequestBuffer(buffer) {
          if (!buffer) {
              if (this.m_internalAllocatedCapacity === 0) {
                  this.ReallocateInternalAllocatedBuffers(b2_minParticleSystemBufferCapacity);
              }
              buffer = [];
              buffer.length = this.m_internalAllocatedCapacity;
          }
          return buffer;
      }
      /**
       * Reallocate the handle / index map and schedule the allocation
       * of a new pool for handle allocation.
       */
      ReallocateHandleBuffers(newCapacity) {
          // DEBUG: b2Assert(newCapacity > this.m_internalAllocatedCapacity);
          // Reallocate a new handle / index map buffer, copying old handle pointers
          // is fine since they're kept around.
          this.m_handleIndexBuffer.data = this.ReallocateBuffer4(this.m_handleIndexBuffer, this.m_internalAllocatedCapacity, newCapacity, true);
          // Set the size of the next handle allocation.
          ///this.m_handleAllocator.SetItemsPerSlab(newCapacity - this.m_internalAllocatedCapacity);
      }
      ReallocateInternalAllocatedBuffers(capacity) {
          function LimitCapacity(capacity, maxCount) {
              return maxCount && capacity > maxCount ? maxCount : capacity;
          }
          // Don't increase capacity beyond the smallest user-supplied buffer size.
          capacity = LimitCapacity(capacity, this.m_def.maxCount);
          capacity = LimitCapacity(capacity, this.m_flagsBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_positionBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_velocityBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_colorBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_userDataBuffer.userSuppliedCapacity);
          if (this.m_internalAllocatedCapacity < capacity) {
              this.ReallocateHandleBuffers(capacity);
              this.m_flagsBuffer.data = this.ReallocateBuffer4(this.m_flagsBuffer, this.m_internalAllocatedCapacity, capacity, false);
              // Conditionally defer these as they are optional if the feature is
              // not enabled.
              const stuck = this.m_stuckThreshold > 0;
              this.m_lastBodyContactStepBuffer.data = this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer, this.m_internalAllocatedCapacity, capacity, stuck);
              this.m_bodyContactCountBuffer.data = this.ReallocateBuffer4(this.m_bodyContactCountBuffer, this.m_internalAllocatedCapacity, capacity, stuck);
              this.m_consecutiveContactStepsBuffer.data = this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer, this.m_internalAllocatedCapacity, capacity, stuck);
              this.m_positionBuffer.data = this.ReallocateBuffer4(this.m_positionBuffer, this.m_internalAllocatedCapacity, capacity, false);
              this.m_velocityBuffer.data = this.ReallocateBuffer4(this.m_velocityBuffer, this.m_internalAllocatedCapacity, capacity, false);
              this.m_forceBuffer = this.ReallocateBuffer5(this.m_forceBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
              this.m_weightBuffer = this.ReallocateBuffer5(this.m_weightBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
              this.m_staticPressureBuffer = this.ReallocateBuffer5(this.m_staticPressureBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);
              this.m_accumulationBuffer = this.ReallocateBuffer5(this.m_accumulationBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
              this.m_accumulation2Buffer = this.ReallocateBuffer5(this.m_accumulation2Buffer, 0, this.m_internalAllocatedCapacity, capacity, true);
              this.m_depthBuffer = this.ReallocateBuffer5(this.m_depthBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);
              this.m_colorBuffer.data = this.ReallocateBuffer4(this.m_colorBuffer, this.m_internalAllocatedCapacity, capacity, true);
              this.m_groupBuffer = this.ReallocateBuffer5(this.m_groupBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
              this.m_userDataBuffer.data = this.ReallocateBuffer4(this.m_userDataBuffer, this.m_internalAllocatedCapacity, capacity, true);
              this.m_expirationTimeBuffer.data = this.ReallocateBuffer4(this.m_expirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, true);
              this.m_indexByExpirationTimeBuffer.data = this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, false);
              this.m_internalAllocatedCapacity = capacity;
          }
      }
      CreateParticleForGroup(groupDef, xf, p) {
          const particleDef = new b2ParticleDef();
          particleDef.flags = b2Maybe(groupDef.flags, 0);
          ///particleDef.position = b2Mul(xf, p);
          b2Transform.MulXV(xf, p, particleDef.position);
          ///particleDef.velocity =
          ///  groupDef.linearVelocity +
          ///  b2Cross(groupDef.angularVelocity,
          ///      particleDef.position - groupDef.position);
          b2Vec2.AddVV(b2Maybe(groupDef.linearVelocity, b2Vec2.ZERO), b2Vec2.CrossSV(b2Maybe(groupDef.angularVelocity, 0), b2Vec2.SubVV(particleDef.position, b2Maybe(groupDef.position, b2Vec2.ZERO), b2Vec2.s_t0), b2Vec2.s_t0), particleDef.velocity);
          particleDef.color.Copy(b2Maybe(groupDef.color, b2Color.ZERO));
          particleDef.lifetime = b2Maybe(groupDef.lifetime, 0);
          particleDef.userData = groupDef.userData;
          this.CreateParticle(particleDef);
      }
      CreateParticlesStrokeShapeForGroup(shape, groupDef, xf) {
          const s_edge = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge;
          const s_d = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d;
          const s_p = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p;
          let stride = b2Maybe(groupDef.stride, 0);
          if (stride === 0) {
              stride = this.GetParticleStride();
          }
          let positionOnEdge = 0;
          const childCount = shape.GetChildCount();
          for (let childIndex = 0; childIndex < childCount; childIndex++) {
              let edge = null;
              if (shape.GetType() === exports.ShapeType.e_edgeShape) {
                  edge = shape;
              }
              else {
                  // DEBUG: b2Assert(shape.GetType() === b2ShapeType.e_chainShape);
                  edge = s_edge;
                  shape.GetChildEdge(edge, childIndex);
              }
              const d = b2Vec2.SubVV(edge.m_vertex2, edge.m_vertex1, s_d);
              const edgeLength = d.Length();
              while (positionOnEdge < edgeLength) {
                  ///b2Vec2 p = edge.m_vertex1 + positionOnEdge / edgeLength * d;
                  const p = b2Vec2.AddVMulSV(edge.m_vertex1, positionOnEdge / edgeLength, d, s_p);
                  this.CreateParticleForGroup(groupDef, xf, p);
                  positionOnEdge += stride;
              }
              positionOnEdge -= edgeLength;
          }
      }
      CreateParticlesFillShapeForGroup(shape, groupDef, xf) {
          const s_aabb = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb;
          const s_p = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p;
          let stride = b2Maybe(groupDef.stride, 0);
          if (stride === 0) {
              stride = this.GetParticleStride();
          }
          ///b2Transform identity;
          /// identity.SetIdentity();
          const identity = b2Transform.IDENTITY;
          const aabb = s_aabb;
          // DEBUG: b2Assert(shape.GetChildCount() === 1);
          shape.ComputeAABB(aabb, identity, 0);
          for (let y = Math.floor(aabb.lowerBound.y / stride) * stride; y < aabb.upperBound.y; y += stride) {
              for (let x = Math.floor(aabb.lowerBound.x / stride) * stride; x < aabb.upperBound.x; x += stride) {
                  const p = s_p.Set(x, y);
                  if (shape.TestPoint(identity, p)) {
                      this.CreateParticleForGroup(groupDef, xf, p);
                  }
              }
          }
      }
      CreateParticlesWithShapeForGroup(shape, groupDef, xf) {
          switch (shape.GetType()) {
              case exports.ShapeType.e_edgeShape:
              case exports.ShapeType.e_chainShape:
                  this.CreateParticlesStrokeShapeForGroup(shape, groupDef, xf);
                  break;
              case exports.ShapeType.e_polygonShape:
              case exports.ShapeType.e_circleShape:
                  this.CreateParticlesFillShapeForGroup(shape, groupDef, xf);
                  break;
          }
      }
      CreateParticlesWithShapesForGroup(shapes, shapeCount, groupDef, xf) {
          const compositeShape = new b2ParticleSystem_CompositeShape(shapes, shapeCount);
          this.CreateParticlesFillShapeForGroup(compositeShape, groupDef, xf);
      }
      CloneParticle(oldIndex, group) {
          const def = new b2ParticleDef();
          def.flags = this.m_flagsBuffer.data[oldIndex];
          def.position.Copy(this.m_positionBuffer.data[oldIndex]);
          def.velocity.Copy(this.m_velocityBuffer.data[oldIndex]);
          if (this.m_colorBuffer.data) {
              def.color.Copy(this.m_colorBuffer.data[oldIndex]);
          }
          if (this.m_userDataBuffer.data) {
              def.userData = this.m_userDataBuffer.data[oldIndex];
          }
          def.group = group;
          const newIndex = this.CreateParticle(def);
          if (this.m_handleIndexBuffer.data) {
              const handle = this.m_handleIndexBuffer.data[oldIndex];
              if (handle) {
                  handle.SetIndex(newIndex);
              }
              this.m_handleIndexBuffer.data[newIndex] = handle;
              this.m_handleIndexBuffer.data[oldIndex] = null;
          }
          if (this.m_lastBodyContactStepBuffer.data) {
              this.m_lastBodyContactStepBuffer.data[newIndex] =
                  this.m_lastBodyContactStepBuffer.data[oldIndex];
          }
          if (this.m_bodyContactCountBuffer.data) {
              this.m_bodyContactCountBuffer.data[newIndex] =
                  this.m_bodyContactCountBuffer.data[oldIndex];
          }
          if (this.m_consecutiveContactStepsBuffer.data) {
              this.m_consecutiveContactStepsBuffer.data[newIndex] =
                  this.m_consecutiveContactStepsBuffer.data[oldIndex];
          }
          if (this.m_hasForce) {
              this.m_forceBuffer[newIndex].Copy(this.m_forceBuffer[oldIndex]);
          }
          if (this.m_staticPressureBuffer) {
              this.m_staticPressureBuffer[newIndex] = this.m_staticPressureBuffer[oldIndex];
          }
          if (this.m_depthBuffer) {
              this.m_depthBuffer[newIndex] = this.m_depthBuffer[oldIndex];
          }
          if (this.m_expirationTimeBuffer.data) {
              this.m_expirationTimeBuffer.data[newIndex] =
                  this.m_expirationTimeBuffer.data[oldIndex];
          }
          return newIndex;
      }
      DestroyParticlesInGroup(group, callDestructionListener = false) {
          for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
              this.DestroyParticle(i, callDestructionListener);
          }
      }
      DestroyParticleGroup(group) {
          // DEBUG: b2Assert(this.m_groupCount > 0);
          // DEBUG: b2Assert(group !== null);
          if (this.m_world.m_destructionListener) {
              this.m_world.m_destructionListener.SayGoodbyeParticleGroup(group);
          }
          this.SetGroupFlags(group, 0);
          for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
              this.m_groupBuffer[i] = null;
          }
          if (group.m_prev) {
              group.m_prev.m_next = group.m_next;
          }
          if (group.m_next) {
              group.m_next.m_prev = group.m_prev;
          }
          if (group === this.m_groupList) {
              this.m_groupList = group.m_next;
          }
          --this.m_groupCount;
      }
      static ParticleCanBeConnected(flags, group) {
          return ((flags & (exports.ParticleFlag.b2_wallParticle | exports.ParticleFlag.b2_springParticle | exports.ParticleFlag.b2_elasticParticle)) !== 0) ||
              ((group !== null) && ((group.GetGroupFlags() & exports.ParticleGroupFlag.b2_rigidParticleGroup) !== 0));
      }
      UpdatePairsAndTriads(firstIndex, lastIndex, filter) {
          const s_dab = b2ParticleSystem.UpdatePairsAndTriads_s_dab;
          const s_dbc = b2ParticleSystem.UpdatePairsAndTriads_s_dbc;
          const s_dca = b2ParticleSystem.UpdatePairsAndTriads_s_dca;
          const pos_data = this.m_positionBuffer.data;
          // Create pairs or triads.
          // All particles in each pair/triad should satisfy the following:
          // * firstIndex <= index < lastIndex
          // * don't have b2_zombieParticle
          // * ParticleCanBeConnected returns true
          // * ShouldCreatePair/ShouldCreateTriad returns true
          // Any particles in each pair/triad should satisfy the following:
          // * filter.IsNeeded returns true
          // * have one of k_pairFlags/k_triadsFlags
          // DEBUG: b2Assert(firstIndex <= lastIndex);
          let particleFlags = 0;
          for (let i = firstIndex; i < lastIndex; i++) {
              particleFlags |= this.m_flagsBuffer.data[i];
          }
          if (particleFlags & b2ParticleSystem.k_pairFlags) {
              for (let k = 0; k < this.m_contactBuffer.count; k++) {
                  const contact = this.m_contactBuffer.data[k];
                  const a = contact.indexA;
                  const b = contact.indexB;
                  const af = this.m_flagsBuffer.data[a];
                  const bf = this.m_flagsBuffer.data[b];
                  const groupA = this.m_groupBuffer[a];
                  const groupB = this.m_groupBuffer[b];
                  if (a >= firstIndex && a < lastIndex &&
                      b >= firstIndex && b < lastIndex &&
                      !((af | bf) & exports.ParticleFlag.b2_zombieParticle) &&
                      ((af | bf) & b2ParticleSystem.k_pairFlags) &&
                      (filter.IsNecessary(a) || filter.IsNecessary(b)) &&
                      b2ParticleSystem.ParticleCanBeConnected(af, groupA) &&
                      b2ParticleSystem.ParticleCanBeConnected(bf, groupB) &&
                      filter.ShouldCreatePair(a, b)) {
                      ///b2ParticlePair& pair = m_pairBuffer.Append();
                      const pair = this.m_pairBuffer.data[this.m_pairBuffer.Append()];
                      pair.indexA = a;
                      pair.indexB = b;
                      pair.flags = contact.flags;
                      pair.strength = b2Min(groupA ? groupA.m_strength : 1, groupB ? groupB.m_strength : 1);
                      ///pair.distance = b2Distance(pos_data[a], pos_data[b]); // TODO: this was wrong!
                      pair.distance = b2Vec2.DistanceVV(pos_data[a], pos_data[b]);
                  }
                  ///std::stable_sort(m_pairBuffer.Begin(), m_pairBuffer.End(), ComparePairIndices);
                  std_stable_sort(this.m_pairBuffer.data, 0, this.m_pairBuffer.count, b2ParticleSystem.ComparePairIndices);
                  ///m_pairBuffer.Unique(MatchPairIndices);
                  this.m_pairBuffer.Unique(b2ParticleSystem.MatchPairIndices);
              }
          }
          if (particleFlags & b2ParticleSystem.k_triadFlags) {
              const diagram = new b2VoronoiDiagram(lastIndex - firstIndex);
              ///let necessary_count = 0;
              for (let i = firstIndex; i < lastIndex; i++) {
                  const flags = this.m_flagsBuffer.data[i];
                  const group = this.m_groupBuffer[i];
                  if (!(flags & exports.ParticleFlag.b2_zombieParticle) &&
                      b2ParticleSystem.ParticleCanBeConnected(flags, group)) {
                      ///if (filter.IsNecessary(i)) {
                      ///++necessary_count;
                      ///}
                      diagram.AddGenerator(pos_data[i], i, filter.IsNecessary(i));
                  }
              }
              ///if (necessary_count === 0) {
              /////debugger;
              ///for (let i = firstIndex; i < lastIndex; i++) {
              ///  filter.IsNecessary(i);
              ///}
              ///}
              const stride = this.GetParticleStride();
              diagram.Generate(stride / 2, stride * 2);
              const system = this;
              const callback = /*UpdateTriadsCallback*/ (a, b, c) => {
                  const af = system.m_flagsBuffer.data[a];
                  const bf = system.m_flagsBuffer.data[b];
                  const cf = system.m_flagsBuffer.data[c];
                  if (((af | bf | cf) & b2ParticleSystem.k_triadFlags) &&
                      filter.ShouldCreateTriad(a, b, c)) {
                      const pa = pos_data[a];
                      const pb = pos_data[b];
                      const pc = pos_data[c];
                      const dab = b2Vec2.SubVV(pa, pb, s_dab);
                      const dbc = b2Vec2.SubVV(pb, pc, s_dbc);
                      const dca = b2Vec2.SubVV(pc, pa, s_dca);
                      const maxDistanceSquared = b2_maxTriadDistanceSquared * system.m_squaredDiameter;
                      if (b2Vec2.DotVV(dab, dab) > maxDistanceSquared ||
                          b2Vec2.DotVV(dbc, dbc) > maxDistanceSquared ||
                          b2Vec2.DotVV(dca, dca) > maxDistanceSquared) {
                          return;
                      }
                      const groupA = system.m_groupBuffer[a];
                      const groupB = system.m_groupBuffer[b];
                      const groupC = system.m_groupBuffer[c];
                      ///b2ParticleTriad& triad = m_system.m_triadBuffer.Append();
                      const triad = system.m_triadBuffer.data[system.m_triadBuffer.Append()];
                      triad.indexA = a;
                      triad.indexB = b;
                      triad.indexC = c;
                      triad.flags = af | bf | cf;
                      triad.strength = b2Min(b2Min(groupA ? groupA.m_strength : 1, groupB ? groupB.m_strength : 1), groupC ? groupC.m_strength : 1);
                      ///let midPoint = b2Vec2.MulSV(1.0 / 3.0, b2Vec2.AddVV(pa, b2Vec2.AddVV(pb, pc, new b2Vec2()), new b2Vec2()), new b2Vec2());
                      const midPoint_x = (pa.x + pb.x + pc.x) / 3.0;
                      const midPoint_y = (pa.y + pb.y + pc.y) / 3.0;
                      ///triad.pa = b2Vec2.SubVV(pa, midPoint, new b2Vec2());
                      triad.pa.x = pa.x - midPoint_x;
                      triad.pa.y = pa.y - midPoint_y;
                      ///triad.pb = b2Vec2.SubVV(pb, midPoint, new b2Vec2());
                      triad.pb.x = pb.x - midPoint_x;
                      triad.pb.y = pb.y - midPoint_y;
                      ///triad.pc = b2Vec2.SubVV(pc, midPoint, new b2Vec2());
                      triad.pc.x = pc.x - midPoint_x;
                      triad.pc.y = pc.y - midPoint_y;
                      triad.ka = -b2Vec2.DotVV(dca, dab);
                      triad.kb = -b2Vec2.DotVV(dab, dbc);
                      triad.kc = -b2Vec2.DotVV(dbc, dca);
                      triad.s = b2Vec2.CrossVV(pa, pb) + b2Vec2.CrossVV(pb, pc) + b2Vec2.CrossVV(pc, pa);
                  }
              };
              diagram.GetNodes(callback);
              ///std::stable_sort(m_triadBuffer.Begin(), m_triadBuffer.End(), CompareTriadIndices);
              std_stable_sort(this.m_triadBuffer.data, 0, this.m_triadBuffer.count, b2ParticleSystem.CompareTriadIndices);
              ///m_triadBuffer.Unique(MatchTriadIndices);
              this.m_triadBuffer.Unique(b2ParticleSystem.MatchTriadIndices);
          }
      }
      UpdatePairsAndTriadsWithReactiveParticles() {
          const filter = new b2ParticleSystem_ReactiveFilter(this.m_flagsBuffer);
          this.UpdatePairsAndTriads(0, this.m_count, filter);
          for (let i = 0; i < this.m_count; i++) {
              this.m_flagsBuffer.data[i] &= ~exports.ParticleFlag.b2_reactiveParticle;
          }
          this.m_allParticleFlags &= ~exports.ParticleFlag.b2_reactiveParticle;
      }
      static ComparePairIndices(a, b) {
          const diffA = a.indexA - b.indexA;
          if (diffA !== 0) {
              return diffA < 0;
          }
          return a.indexB < b.indexB;
      }
      static MatchPairIndices(a, b) {
          return a.indexA === b.indexA && a.indexB === b.indexB;
      }
      static CompareTriadIndices(a, b) {
          const diffA = a.indexA - b.indexA;
          if (diffA !== 0) {
              return diffA < 0;
          }
          const diffB = a.indexB - b.indexB;
          if (diffB !== 0) {
              return diffB < 0;
          }
          return a.indexC < b.indexC;
      }
      static MatchTriadIndices(a, b) {
          return a.indexA === b.indexA && a.indexB === b.indexB && a.indexC === b.indexC;
      }
      static InitializeParticleLists(group, nodeBuffer) {
          const bufferIndex = group.GetBufferIndex();
          const particleCount = group.GetParticleCount();
          for (let i = 0; i < particleCount; i++) {
              const node = nodeBuffer[i];
              node.list = node;
              node.next = null;
              node.count = 1;
              node.index = i + bufferIndex;
          }
      }
      MergeParticleListsInContact(group, nodeBuffer) {
          const bufferIndex = group.GetBufferIndex();
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              /*const b2ParticleContact&*/
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              if (!group.ContainsParticle(a) || !group.ContainsParticle(b)) {
                  continue;
              }
              let listA = nodeBuffer[a - bufferIndex].list;
              let listB = nodeBuffer[b - bufferIndex].list;
              if (listA === listB) {
                  continue;
              }
              // To minimize the cost of insertion, make sure listA is longer than
              // listB.
              if (listA.count < listB.count) {
                  const _tmp = listA;
                  listA = listB;
                  listB = _tmp; ///b2Swap(listA, listB);
              }
              // DEBUG: b2Assert(listA.count >= listB.count);
              b2ParticleSystem.MergeParticleLists(listA, listB);
          }
      }
      static MergeParticleLists(listA, listB) {
          // Insert listB between index 0 and 1 of listA
          // Example:
          //     listA => a1 => a2 => a3 => null
          //     listB => b1 => b2 => null
          // to
          //     listA => listB => b1 => b2 => a1 => a2 => a3 => null
          // DEBUG: b2Assert(listA !== listB);
          for (let b = listB;;) {
              b.list = listA;
              const nextB = b.next;
              if (nextB) {
                  b = nextB;
              }
              else {
                  b.next = listA.next;
                  break;
              }
          }
          listA.next = listB;
          listA.count += listB.count;
          listB.count = 0;
      }
      static FindLongestParticleList(group, nodeBuffer) {
          const particleCount = group.GetParticleCount();
          let result = nodeBuffer[0];
          for (let i = 0; i < particleCount; i++) {
              const node = nodeBuffer[i];
              if (result.count < node.count) {
                  result = node;
              }
          }
          return result;
      }
      MergeZombieParticleListNodes(group, nodeBuffer, survivingList) {
          const particleCount = group.GetParticleCount();
          for (let i = 0; i < particleCount; i++) {
              const node = nodeBuffer[i];
              if (node !== survivingList &&
                  (this.m_flagsBuffer.data[node.index] & exports.ParticleFlag.b2_zombieParticle)) {
                  b2ParticleSystem.MergeParticleListAndNode(survivingList, node);
              }
          }
      }
      static MergeParticleListAndNode(list, node) {
          // Insert node between index 0 and 1 of list
          // Example:
          //     list => a1 => a2 => a3 => null
          //     node => null
          // to
          //     list => node => a1 => a2 => a3 => null
          // DEBUG: b2Assert(node !== list);
          // DEBUG: b2Assert(node.list === node);
          // DEBUG: b2Assert(node.count === 1);
          node.list = list;
          node.next = list.next;
          list.next = node;
          list.count++;
          node.count = 0;
      }
      CreateParticleGroupsFromParticleList(group, nodeBuffer, survivingList) {
          const particleCount = group.GetParticleCount();
          const def = new b2ParticleGroupDef();
          def.groupFlags = group.GetGroupFlags();
          def.userData = group.GetUserData();
          for (let i = 0; i < particleCount; i++) {
              const list = nodeBuffer[i];
              if (!list.count || list === survivingList) {
                  continue;
              }
              // DEBUG: b2Assert(list.list === list);
              const newGroup = this.CreateParticleGroup(def);
              for (let node = list; node; node = node.next) {
                  const oldIndex = node.index;
                  // DEBUG: const flags = this.m_flagsBuffer.data[oldIndex];
                  // DEBUG: b2Assert(!(flags & b2ParticleFlag.b2_zombieParticle));
                  const newIndex = this.CloneParticle(oldIndex, newGroup);
                  this.m_flagsBuffer.data[oldIndex] |= exports.ParticleFlag.b2_zombieParticle;
                  node.index = newIndex;
              }
          }
      }
      UpdatePairsAndTriadsWithParticleList(group, nodeBuffer) {
          const bufferIndex = group.GetBufferIndex();
          // Update indices in pairs and triads. If an index belongs to the group,
          // replace it with the corresponding value in nodeBuffer.
          // Note that nodeBuffer is allocated only for the group and the index should
          // be shifted by bufferIndex.
          for (let k = 0; k < this.m_pairBuffer.count; k++) {
              const pair = this.m_pairBuffer.data[k];
              const a = pair.indexA;
              const b = pair.indexB;
              if (group.ContainsParticle(a)) {
                  pair.indexA = nodeBuffer[a - bufferIndex].index;
              }
              if (group.ContainsParticle(b)) {
                  pair.indexB = nodeBuffer[b - bufferIndex].index;
              }
          }
          for (let k = 0; k < this.m_triadBuffer.count; k++) {
              const triad = this.m_triadBuffer.data[k];
              const a = triad.indexA;
              const b = triad.indexB;
              const c = triad.indexC;
              if (group.ContainsParticle(a)) {
                  triad.indexA = nodeBuffer[a - bufferIndex].index;
              }
              if (group.ContainsParticle(b)) {
                  triad.indexB = nodeBuffer[b - bufferIndex].index;
              }
              if (group.ContainsParticle(c)) {
                  triad.indexC = nodeBuffer[c - bufferIndex].index;
              }
          }
      }
      ComputeDepth() {
          const contactGroups = []; // TODO: static
          let contactGroupsCount = 0;
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const groupA = this.m_groupBuffer[a];
              const groupB = this.m_groupBuffer[b];
              if (groupA && groupA === groupB &&
                  (groupA.m_groupFlags & exports.ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth)) {
                  contactGroups[contactGroupsCount++] = contact;
              }
          }
          const groupsToUpdate = []; // TODO: static
          let groupsToUpdateCount = 0;
          for (let group = this.m_groupList; group; group = group.GetNext()) {
              if (group.m_groupFlags & exports.ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {
                  groupsToUpdate[groupsToUpdateCount++] = group;
                  this.SetGroupFlags(group, group.m_groupFlags &
                      ~exports.ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);
                  for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                      this.m_accumulationBuffer[i] = 0;
                  }
              }
          }
          // Compute sum of weight of contacts except between different groups.
          for (let k = 0; k < contactGroupsCount; k++) {
              const contact = contactGroups[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const w = contact.weight;
              this.m_accumulationBuffer[a] += w;
              this.m_accumulationBuffer[b] += w;
          }
          // DEBUG: b2Assert(this.m_depthBuffer !== null);
          for (let i = 0; i < groupsToUpdateCount; i++) {
              const group = groupsToUpdate[i];
              for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                  const w = this.m_accumulationBuffer[i];
                  this.m_depthBuffer[i] = w < 0.8 ? 0 : b2_maxFloat;
              }
          }
          // The number of iterations is equal to particle number from the deepest
          // particle to the nearest surface particle, and in general it is smaller
          // than sqrt of total particle number.
          ///int32 iterationCount = (int32)b2Sqrt((float)m_count);
          const iterationCount = b2Sqrt(this.m_count) >> 0;
          for (let t = 0; t < iterationCount; t++) {
              let updated = false;
              for (let k = 0; k < contactGroupsCount; k++) {
                  const contact = contactGroups[k];
                  const a = contact.indexA;
                  const b = contact.indexB;
                  const r = 1 - contact.weight;
                  ///float32& ap0 = m_depthBuffer[a];
                  const ap0 = this.m_depthBuffer[a];
                  ///float32& bp0 = m_depthBuffer[b];
                  const bp0 = this.m_depthBuffer[b];
                  const ap1 = bp0 + r;
                  const bp1 = ap0 + r;
                  if (ap0 > ap1) {
                      ///ap0 = ap1;
                      this.m_depthBuffer[a] = ap1;
                      updated = true;
                  }
                  if (bp0 > bp1) {
                      ///bp0 = bp1;
                      this.m_depthBuffer[b] = bp1;
                      updated = true;
                  }
              }
              if (!updated) {
                  break;
              }
          }
          for (let i = 0; i < groupsToUpdateCount; i++) {
              const group = groupsToUpdate[i];
              for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                  if (this.m_depthBuffer[i] < b2_maxFloat) {
                      this.m_depthBuffer[i] *= this.m_particleDiameter;
                  }
                  else {
                      this.m_depthBuffer[i] = 0;
                  }
              }
          }
      }
      GetInsideBoundsEnumerator(aabb) {
          const lowerTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x - 1, this.m_inverseDiameter * aabb.lowerBound.y - 1);
          const upperTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x + 1, this.m_inverseDiameter * aabb.upperBound.y + 1);
          ///const Proxy* beginProxy = m_proxyBuffer.Begin();
          const beginProxy = 0;
          ///const Proxy* endProxy = m_proxyBuffer.End();
          const endProxy = this.m_proxyBuffer.count;
          ///const Proxy* firstProxy = std::lower_bound(beginProxy, endProxy, lowerTag);
          const firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, lowerTag, b2ParticleSystem_Proxy.CompareProxyTag);
          ///const Proxy* lastProxy = std::upper_bound(firstProxy, endProxy, upperTag);
          const lastProxy = std_upper_bound(this.m_proxyBuffer.data, beginProxy, endProxy, upperTag, b2ParticleSystem_Proxy.CompareTagProxy);
          // DEBUG: b2Assert(beginProxy <= firstProxy);
          // DEBUG: b2Assert(firstProxy <= lastProxy);
          // DEBUG: b2Assert(lastProxy <= endProxy);
          return new b2ParticleSystem_InsideBoundsEnumerator(this, lowerTag, upperTag, firstProxy, lastProxy);
      }
      UpdateAllParticleFlags() {
          this.m_allParticleFlags = 0;
          for (let i = 0; i < this.m_count; i++) {
              this.m_allParticleFlags |= this.m_flagsBuffer.data[i];
          }
          this.m_needsUpdateAllParticleFlags = false;
      }
      UpdateAllGroupFlags() {
          this.m_allGroupFlags = 0;
          for (let group = this.m_groupList; group; group = group.GetNext()) {
              this.m_allGroupFlags |= group.m_groupFlags;
          }
          this.m_needsUpdateAllGroupFlags = false;
      }
      AddContact(a, b, contacts) {
          // DEBUG: b2Assert(contacts === this.m_contactBuffer);
          const flags_data = this.m_flagsBuffer.data;
          const pos_data = this.m_positionBuffer.data;
          ///b2Vec2 d = m_positionBuffer.data[b] - m_positionBuffer.data[a];
          const d = b2Vec2.SubVV(pos_data[b], pos_data[a], b2ParticleSystem.AddContact_s_d);
          const distBtParticlesSq = b2Vec2.DotVV(d, d);
          if (0 < distBtParticlesSq && distBtParticlesSq < this.m_squaredDiameter) {
              const invD = b2InvSqrt(distBtParticlesSq);
              ///b2ParticleContact& contact = contacts.Append();
              const contact = this.m_contactBuffer.data[this.m_contactBuffer.Append()];
              contact.indexA = a;
              contact.indexB = b;
              contact.flags = flags_data[a] | flags_data[b];
              contact.weight = 1 - distBtParticlesSq * invD * this.m_inverseDiameter;
              contact.normal.x = invD * d.x;
              contact.normal.y = invD * d.y;
          }
      }
      FindContacts_Reference(contacts) {
          // DEBUG: b2Assert(contacts === this.m_contactBuffer);
          const beginProxy = 0;
          const endProxy = this.m_proxyBuffer.count;
          this.m_contactBuffer.count = 0;
          for (let a = beginProxy, c = beginProxy; a < endProxy; a++) {
              const rightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 0);
              for (let b = a + 1; b < endProxy; b++) {
                  if (rightTag < this.m_proxyBuffer.data[b].tag) {
                      break;
                  }
                  this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);
              }
              const bottomLeftTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, -1, 1);
              for (; c < endProxy; c++) {
                  if (bottomLeftTag <= this.m_proxyBuffer.data[c].tag) {
                      break;
                  }
              }
              const bottomRightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 1);
              for (let b = c; b < endProxy; b++) {
                  if (bottomRightTag < this.m_proxyBuffer.data[b].tag) {
                      break;
                  }
                  this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);
              }
          }
      }
      ///void ReorderForFindContact(FindContactInput* reordered, int alignedCount) const;
      ///void GatherChecksOneParticle(const uint32 bound, const int startIndex, const int particleIndex, int* nextUncheckedIndex, b2GrowableBuffer<FindContactCheck>& checks) const;
      ///void GatherChecks(b2GrowableBuffer<FindContactCheck>& checks) const;
      ///void FindContacts_Simd(b2GrowableBuffer<b2ParticleContact>& contacts) const;
      FindContacts(contacts) {
          this.FindContacts_Reference(contacts);
      }
      ///static void UpdateProxyTags(const uint32* const tags, b2GrowableBuffer<Proxy>& proxies);
      ///static bool ProxyBufferHasIndex(int32 index, const Proxy* const a, int count);
      ///static int NumProxiesWithSameTag(const Proxy* const a, const Proxy* const b, int count);
      ///static bool AreProxyBuffersTheSame(const b2GrowableBuffer<Proxy>& a, const b2GrowableBuffer<Proxy>& b);
      UpdateProxies_Reference(proxies) {
          // DEBUG: b2Assert(proxies === this.m_proxyBuffer);
          const pos_data = this.m_positionBuffer.data;
          const inv_diam = this.m_inverseDiameter;
          for (let k = 0; k < this.m_proxyBuffer.count; ++k) {
              const proxy = this.m_proxyBuffer.data[k];
              const i = proxy.index;
              const p = pos_data[i];
              proxy.tag = b2ParticleSystem.computeTag(inv_diam * p.x, inv_diam * p.y);
          }
      }
      ///void UpdateProxies_Simd(b2GrowableBuffer<Proxy>& proxies) const;
      UpdateProxies(proxies) {
          this.UpdateProxies_Reference(proxies);
      }
      SortProxies(proxies) {
          // DEBUG: b2Assert(proxies === this.m_proxyBuffer);
          ///std::sort(proxies.Begin(), proxies.End());
          std_sort(this.m_proxyBuffer.data, 0, this.m_proxyBuffer.count, b2ParticleSystem_Proxy.CompareProxyProxy);
      }
      FilterContacts(contacts) {
          // Optionally filter the contact.
          const contactFilter = this.GetParticleContactFilter();
          if (contactFilter === null) {
              return;
          }
          /// contacts.RemoveIf(b2ParticleContactRemovePredicate(this, contactFilter));
          // DEBUG: b2Assert(contacts === this.m_contactBuffer);
          const system = this;
          const predicate = (contact) => {
              return ((contact.flags & exports.ParticleFlag.b2_particleContactFilterParticle) !== 0) && !contactFilter.ShouldCollideParticleParticle(system, contact.indexA, contact.indexB);
          };
          this.m_contactBuffer.RemoveIf(predicate);
      }
      NotifyContactListenerPreContact(particlePairs) {
          const contactListener = this.GetParticleContactListener();
          if (contactListener === null) {
              return;
          }
          ///particlePairs.Initialize(m_contactBuffer.Begin(), m_contactBuffer.GetCount(), GetFlagsBuffer());
          particlePairs.Initialize(this.m_contactBuffer, this.m_flagsBuffer);
          throw new Error(); // TODO: notify
      }
      NotifyContactListenerPostContact(particlePairs) {
          const contactListener = this.GetParticleContactListener();
          if (contactListener === null) {
              return;
          }
          // Loop through all new contacts, reporting any new ones, and
          // "invalidating" the ones that still exist.
          ///const b2ParticleContact* const endContact = m_contactBuffer.End();
          ///for (b2ParticleContact* contact = m_contactBuffer.Begin(); contact < endContact; ++contact)
          for (let k = 0; k < this.m_contactBuffer.count; ++k) {
              const contact = this.m_contactBuffer.data[k];
              {
                  // Just started touching, inform the listener.
                  contactListener.BeginContactParticleParticle(this, contact);
              }
          }
          // Report particles that are no longer touching.
          // That is, any pairs that were not invalidated above.
          ///const int32 pairCount = particlePairs.GetCount();
          ///const ParticlePair* const pairs = particlePairs.GetBuffer();
          ///const int8* const valid = particlePairs.GetValidBuffer();
          ///for (int32 i = 0; i < pairCount; ++i)
          ///{
          ///  if (valid[i])
          ///  {
          ///    contactListener.EndContactParticleParticle(this, pairs[i].first, pairs[i].second);
          ///  }
          ///}
          throw new Error(); // TODO: notify
      }
      static b2ParticleContactIsZombie(contact) {
          return (contact.flags & exports.ParticleFlag.b2_zombieParticle) === exports.ParticleFlag.b2_zombieParticle;
      }
      UpdateContacts(exceptZombie) {
          this.UpdateProxies(this.m_proxyBuffer);
          this.SortProxies(this.m_proxyBuffer);
          const particlePairs = new b2ParticlePairSet(); // TODO: static
          this.NotifyContactListenerPreContact(particlePairs);
          this.FindContacts(this.m_contactBuffer);
          this.FilterContacts(this.m_contactBuffer);
          this.NotifyContactListenerPostContact(particlePairs);
          if (exceptZombie) {
              this.m_contactBuffer.RemoveIf(b2ParticleSystem.b2ParticleContactIsZombie);
          }
      }
      NotifyBodyContactListenerPreContact(fixtureSet) {
          const contactListener = this.GetFixtureContactListener();
          if (contactListener === null) {
              return;
          }
          ///fixtureSet.Initialize(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.GetCount(), GetFlagsBuffer());
          fixtureSet.Initialize(this.m_bodyContactBuffer, this.m_flagsBuffer);
          throw new Error(); // TODO: notify
      }
      NotifyBodyContactListenerPostContact(fixtureSet) {
          const contactListener = this.GetFixtureContactListener();
          if (contactListener === null) {
              return;
          }
          // Loop through all new contacts, reporting any new ones, and
          // "invalidating" the ones that still exist.
          ///for (b2ParticleBodyContact* contact = m_bodyContactBuffer.Begin(); contact !== m_bodyContactBuffer.End(); ++contact)
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              {
                  // Just started touching, report it!
                  contactListener.BeginContactFixtureParticle(this, contact);
              }
          }
          // If the contact listener is enabled, report all fixtures that are no
          // longer in contact with particles.
          ///const FixtureParticle* const fixtureParticles = fixtureSet.GetBuffer();
          ///const int8* const fixtureParticlesValid = fixtureSet.GetValidBuffer();
          ///const int32 fixtureParticleCount = fixtureSet.GetCount();
          ///for (int32 i = 0; i < fixtureParticleCount; ++i)
          ///{
          ///  if (fixtureParticlesValid[i])
          ///  {
          ///    const FixtureParticle* const fixtureParticle = &fixtureParticles[i];
          ///    contactListener.EndContactFixtureParticle(fixtureParticle.first, this, fixtureParticle.second);
          ///  }
          ///}
          throw new Error(); // TODO: notify
      }
      UpdateBodyContacts() {
          const s_aabb = b2ParticleSystem.UpdateBodyContacts_s_aabb;
          // If the particle contact listener is enabled, generate a set of
          // fixture / particle contacts.
          const fixtureSet = new b2ParticleSystem_FixtureParticleSet(); // TODO: static
          this.NotifyBodyContactListenerPreContact(fixtureSet);
          if (this.m_stuckThreshold > 0) {
              const particleCount = this.GetParticleCount();
              for (let i = 0; i < particleCount; i++) {
                  // Detect stuck particles, see comment in
                  // b2ParticleSystem::DetectStuckParticle()
                  this.m_bodyContactCountBuffer.data[i] = 0;
                  if (this.m_timestamp > (this.m_lastBodyContactStepBuffer.data[i] + 1)) {
                      this.m_consecutiveContactStepsBuffer.data[i] = 0;
                  }
              }
          }
          this.m_bodyContactBuffer.SetCount(0);
          this.m_stuckParticleBuffer.SetCount(0);
          const aabb = s_aabb;
          this.ComputeAABB(aabb);
          if (this.UpdateBodyContacts_callback === null) {
              this.UpdateBodyContacts_callback = new b2ParticleSystem_UpdateBodyContactsCallback(this);
          }
          const callback = this.UpdateBodyContacts_callback;
          callback.m_contactFilter = this.GetFixtureContactFilter();
          this.m_world.QueryAABB(callback, aabb);
          if (this.m_def.strictContactCheck) {
              this.RemoveSpuriousBodyContacts();
          }
          this.NotifyBodyContactListenerPostContact(fixtureSet);
      }
      Solve(step) {
          const s_subStep = b2ParticleSystem.Solve_s_subStep;
          if (this.m_count === 0) {
              return;
          }
          // If particle lifetimes are enabled, destroy particles that are too old.
          if (this.m_expirationTimeBuffer.data) {
              this.SolveLifetimes(step);
          }
          if (this.m_allParticleFlags & exports.ParticleFlag.b2_zombieParticle) {
              this.SolveZombie();
          }
          if (this.m_needsUpdateAllParticleFlags) {
              this.UpdateAllParticleFlags();
          }
          if (this.m_needsUpdateAllGroupFlags) {
              this.UpdateAllGroupFlags();
          }
          if (this.m_paused) {
              return;
          }
          for (this.m_iterationIndex = 0; this.m_iterationIndex < step.particleIterations; this.m_iterationIndex++) {
              ++this.m_timestamp;
              const subStep = s_subStep.Copy(step);
              subStep.dt /= step.particleIterations;
              subStep.inv_dt *= step.particleIterations;
              this.UpdateContacts(false);
              this.UpdateBodyContacts();
              this.ComputeWeight();
              if (this.m_allGroupFlags & exports.ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {
                  this.ComputeDepth();
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_reactiveParticle) {
                  this.UpdatePairsAndTriadsWithReactiveParticles();
              }
              if (this.m_hasForce) {
                  this.SolveForce(subStep);
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_viscousParticle) {
                  this.SolveViscous();
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_repulsiveParticle) {
                  this.SolveRepulsive(subStep);
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_powderParticle) {
                  this.SolvePowder(subStep);
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_tensileParticle) {
                  this.SolveTensile(subStep);
              }
              if (this.m_allGroupFlags & exports.ParticleGroupFlag.b2_solidParticleGroup) {
                  this.SolveSolid(subStep);
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_colorMixingParticle) {
                  this.SolveColorMixing();
              }
              this.SolveGravity(subStep);
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_staticPressureParticle) {
                  this.SolveStaticPressure(subStep);
              }
              this.SolvePressure(subStep);
              this.SolveDamping(subStep);
              if (this.m_allParticleFlags & b2ParticleSystem.k_extraDampingFlags) {
                  this.SolveExtraDamping();
              }
              // SolveElastic and SolveSpring refer the current velocities for
              // numerical stability, they should be called as late as possible.
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_elasticParticle) {
                  this.SolveElastic(subStep);
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_springParticle) {
                  this.SolveSpring(subStep);
              }
              this.LimitVelocity(subStep);
              if (this.m_allGroupFlags & exports.ParticleGroupFlag.b2_rigidParticleGroup) {
                  this.SolveRigidDamping();
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_barrierParticle) {
                  this.SolveBarrier(subStep);
              }
              // SolveCollision, SolveRigid and SolveWall should be called after
              // other force functions because they may require particles to have
              // specific velocities.
              this.SolveCollision(subStep);
              if (this.m_allGroupFlags & exports.ParticleGroupFlag.b2_rigidParticleGroup) {
                  this.SolveRigid(subStep);
              }
              if (this.m_allParticleFlags & exports.ParticleFlag.b2_wallParticle) {
                  this.SolveWall();
              }
              // The particle positions can be updated only at the end of substep.
              for (let i = 0; i < this.m_count; i++) {
                  ///m_positionBuffer.data[i] += subStep.dt * m_velocityBuffer.data[i];
                  this.m_positionBuffer.data[i].SelfMulAdd(subStep.dt, this.m_velocityBuffer.data[i]);
              }
          }
      }
      SolveCollision(step) {
          const s_aabb = b2ParticleSystem.SolveCollision_s_aabb;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          // This function detects particles which are crossing boundary of bodies
          // and modifies velocities of them so that they will move just in front of
          // boundary. This function function also applies the reaction force to
          // bodies as precisely as the numerical stability is kept.
          const aabb = s_aabb;
          aabb.lowerBound.x = +b2_maxFloat;
          aabb.lowerBound.y = +b2_maxFloat;
          aabb.upperBound.x = -b2_maxFloat;
          aabb.upperBound.y = -b2_maxFloat;
          for (let i = 0; i < this.m_count; i++) {
              const v = vel_data[i];
              const p1 = pos_data[i];
              ///let p2 = p1 + step.dt * v;
              const p2_x = p1.x + step.dt * v.x;
              const p2_y = p1.y + step.dt * v.y;
              ///aabb.lowerBound = b2Min(aabb.lowerBound, b2Min(p1, p2));
              aabb.lowerBound.x = b2Min(aabb.lowerBound.x, b2Min(p1.x, p2_x));
              aabb.lowerBound.y = b2Min(aabb.lowerBound.y, b2Min(p1.y, p2_y));
              ///aabb.upperBound = b2Max(aabb.upperBound, b2Max(p1, p2));
              aabb.upperBound.x = b2Max(aabb.upperBound.x, b2Max(p1.x, p2_x));
              aabb.upperBound.y = b2Max(aabb.upperBound.y, b2Max(p1.y, p2_y));
          }
          if (this.SolveCollision_callback === null) {
              this.SolveCollision_callback = new b2ParticleSystem_SolveCollisionCallback(this, step);
          }
          const callback = this.SolveCollision_callback;
          callback.m_step = step;
          this.m_world.QueryAABB(callback, aabb);
      }
      LimitVelocity(step) {
          const vel_data = this.m_velocityBuffer.data;
          const criticalVelocitySquared = this.GetCriticalVelocitySquared(step);
          for (let i = 0; i < this.m_count; i++) {
              const v = vel_data[i];
              const v2 = b2Vec2.DotVV(v, v);
              if (v2 > criticalVelocitySquared) {
                  ///v *= b2Sqrt(criticalVelocitySquared / v2);
                  v.SelfMul(b2Sqrt(criticalVelocitySquared / v2));
              }
          }
      }
      SolveGravity(step) {
          const s_gravity = b2ParticleSystem.SolveGravity_s_gravity;
          const vel_data = this.m_velocityBuffer.data;
          ///b2Vec2 gravity = step.dt * m_def.gravityScale * m_world.GetGravity();
          const gravity = b2Vec2.MulSV(step.dt * this.m_def.gravityScale, this.m_world.GetGravity(), s_gravity);
          for (let i = 0; i < this.m_count; i++) {
              vel_data[i].SelfAdd(gravity);
          }
      }
      SolveBarrier(step) {
          const s_aabb = b2ParticleSystem.SolveBarrier_s_aabb;
          const s_va = b2ParticleSystem.SolveBarrier_s_va;
          const s_vb = b2ParticleSystem.SolveBarrier_s_vb;
          const s_pba = b2ParticleSystem.SolveBarrier_s_pba;
          const s_vba = b2ParticleSystem.SolveBarrier_s_vba;
          const s_vc = b2ParticleSystem.SolveBarrier_s_vc;
          const s_pca = b2ParticleSystem.SolveBarrier_s_pca;
          const s_vca = b2ParticleSystem.SolveBarrier_s_vca;
          const s_qba = b2ParticleSystem.SolveBarrier_s_qba;
          const s_qca = b2ParticleSystem.SolveBarrier_s_qca;
          const s_dv = b2ParticleSystem.SolveBarrier_s_dv;
          const s_f = b2ParticleSystem.SolveBarrier_s_f;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          // If a particle is passing between paired barrier particles,
          // its velocity will be decelerated to avoid passing.
          for (let i = 0; i < this.m_count; i++) {
              const flags = this.m_flagsBuffer.data[i];
              ///if ((flags & b2ParticleSystem.k_barrierWallFlags) === b2ParticleSystem.k_barrierWallFlags)
              if ((flags & b2ParticleSystem.k_barrierWallFlags) !== 0) {
                  vel_data[i].SetZero();
              }
          }
          const tmax = b2_barrierCollisionTime * step.dt;
          const mass = this.GetParticleMass();
          for (let k = 0; k < this.m_pairBuffer.count; k++) {
              const pair = this.m_pairBuffer.data[k];
              if (pair.flags & exports.ParticleFlag.b2_barrierParticle) {
                  const a = pair.indexA;
                  const b = pair.indexB;
                  const pa = pos_data[a];
                  const pb = pos_data[b];
                  /// b2AABB aabb;
                  const aabb = s_aabb;
                  ///aabb.lowerBound = b2Min(pa, pb);
                  b2Vec2.MinV(pa, pb, aabb.lowerBound);
                  ///aabb.upperBound = b2Max(pa, pb);
                  b2Vec2.MaxV(pa, pb, aabb.upperBound);
                  const aGroup = this.m_groupBuffer[a];
                  const bGroup = this.m_groupBuffer[b];
                  ///b2Vec2 va = GetLinearVelocity(aGroup, a, pa);
                  const va = this.GetLinearVelocity(aGroup, a, pa, s_va);
                  ///b2Vec2 vb = GetLinearVelocity(bGroup, b, pb);
                  const vb = this.GetLinearVelocity(bGroup, b, pb, s_vb);
                  ///b2Vec2 pba = pb - pa;
                  const pba = b2Vec2.SubVV(pb, pa, s_pba);
                  ///b2Vec2 vba = vb - va;
                  const vba = b2Vec2.SubVV(vb, va, s_vba);
                  ///InsideBoundsEnumerator enumerator = GetInsideBoundsEnumerator(aabb);
                  const enumerator = this.GetInsideBoundsEnumerator(aabb);
                  let c;
                  while ((c = enumerator.GetNext()) >= 0) {
                      const pc = pos_data[c];
                      const cGroup = this.m_groupBuffer[c];
                      if (aGroup !== cGroup && bGroup !== cGroup) {
                          ///b2Vec2 vc = GetLinearVelocity(cGroup, c, pc);
                          const vc = this.GetLinearVelocity(cGroup, c, pc, s_vc);
                          // Solve the equation below:
                          //   (1-s)*(pa+t*va)+s*(pb+t*vb) = pc+t*vc
                          // which expresses that the particle c will pass a line
                          // connecting the particles a and b at the time of t.
                          // if s is between 0 and 1, c will pass between a and b.
                          ///b2Vec2 pca = pc - pa;
                          const pca = b2Vec2.SubVV(pc, pa, s_pca);
                          ///b2Vec2 vca = vc - va;
                          const vca = b2Vec2.SubVV(vc, va, s_vca);
                          const e2 = b2Vec2.CrossVV(vba, vca);
                          const e1 = b2Vec2.CrossVV(pba, vca) - b2Vec2.CrossVV(pca, vba);
                          const e0 = b2Vec2.CrossVV(pba, pca);
                          let s, t;
                          ///b2Vec2 qba, qca;
                          const qba = s_qba, qca = s_qca;
                          if (e2 === 0) {
                              if (e1 === 0) {
                                  continue;
                              }
                              t = -e0 / e1;
                              if (!(t >= 0 && t < tmax)) {
                                  continue;
                              }
                              ///qba = pba + t * vba;
                              b2Vec2.AddVMulSV(pba, t, vba, qba);
                              ///qca = pca + t * vca;
                              b2Vec2.AddVMulSV(pca, t, vca, qca);
                              s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);
                              if (!(s >= 0 && s <= 1)) {
                                  continue;
                              }
                          }
                          else {
                              const det = e1 * e1 - 4 * e0 * e2;
                              if (det < 0) {
                                  continue;
                              }
                              const sqrtDet = b2Sqrt(det);
                              let t1 = (-e1 - sqrtDet) / (2 * e2);
                              let t2 = (-e1 + sqrtDet) / (2 * e2);
                              ///if (t1 > t2) b2Swap(t1, t2);
                              if (t1 > t2) {
                                  const tmp = t1;
                                  t1 = t2;
                                  t2 = tmp;
                              }
                              t = t1;
                              ///qba = pba + t * vba;
                              b2Vec2.AddVMulSV(pba, t, vba, qba);
                              ///qca = pca + t * vca;
                              b2Vec2.AddVMulSV(pca, t, vca, qca);
                              ///s = b2Dot(qba, qca) / b2Dot(qba, qba);
                              s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);
                              if (!(t >= 0 && t < tmax && s >= 0 && s <= 1)) {
                                  t = t2;
                                  if (!(t >= 0 && t < tmax)) {
                                      continue;
                                  }
                                  ///qba = pba + t * vba;
                                  b2Vec2.AddVMulSV(pba, t, vba, qba);
                                  ///qca = pca + t * vca;
                                  b2Vec2.AddVMulSV(pca, t, vca, qca);
                                  ///s = b2Dot(qba, qca) / b2Dot(qba, qba);
                                  s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);
                                  if (!(s >= 0 && s <= 1)) {
                                      continue;
                                  }
                              }
                          }
                          // Apply a force to particle c so that it will have the
                          // interpolated velocity at the collision point on line ab.
                          ///b2Vec2 dv = va + s * vba - vc;
                          const dv = s_dv;
                          dv.x = va.x + s * vba.x - vc.x;
                          dv.y = va.y + s * vba.y - vc.y;
                          ///b2Vec2 f = GetParticleMass() * dv;
                          const f = b2Vec2.MulSV(mass, dv, s_f);
                          if (cGroup && this.IsRigidGroup(cGroup)) {
                              // If c belongs to a rigid group, the force will be
                              // distributed in the group.
                              const mass = cGroup.GetMass();
                              const inertia = cGroup.GetInertia();
                              if (mass > 0) {
                                  ///cGroup.m_linearVelocity += 1 / mass * f;
                                  cGroup.m_linearVelocity.SelfMulAdd(1 / mass, f);
                              }
                              if (inertia > 0) {
                                  ///cGroup.m_angularVelocity += b2Cross(pc - cGroup.GetCenter(), f) / inertia;
                                  cGroup.m_angularVelocity += b2Vec2.CrossVV(b2Vec2.SubVV(pc, cGroup.GetCenter(), b2Vec2.s_t0), f) / inertia;
                              }
                          }
                          else {
                              ///m_velocityBuffer.data[c] += dv;
                              vel_data[c].SelfAdd(dv);
                          }
                          // Apply a reversed force to particle c after particle
                          // movement so that momentum will be preserved.
                          ///ParticleApplyForce(c, -step.inv_dt * f);
                          this.ParticleApplyForce(c, f.SelfMul(-step.inv_dt));
                      }
                  }
              }
          }
      }
      SolveStaticPressure(step) {
          this.m_staticPressureBuffer = this.RequestBuffer(this.m_staticPressureBuffer);
          const criticalPressure = this.GetCriticalPressure(step);
          const pressurePerWeight = this.m_def.staticPressureStrength * criticalPressure;
          const maxPressure = b2_maxParticlePressure * criticalPressure;
          const relaxation = this.m_def.staticPressureRelaxation;
          /// Compute pressure satisfying the modified Poisson equation:
          ///   Sum_for_j((p_i - p_j) * w_ij) + relaxation * p_i =
          ///   pressurePerWeight * (w_i - b2_minParticleWeight)
          /// by iterating the calculation:
          ///   p_i = (Sum_for_j(p_j * w_ij) + pressurePerWeight *
          ///         (w_i - b2_minParticleWeight)) / (w_i + relaxation)
          /// where
          ///   p_i and p_j are static pressure of particle i and j
          ///   w_ij is contact weight between particle i and j
          ///   w_i is sum of contact weight of particle i
          for (let t = 0; t < this.m_def.staticPressureIterations; t++) {
              ///memset(m_accumulationBuffer, 0, sizeof(*m_accumulationBuffer) * m_count);
              for (let i = 0; i < this.m_count; i++) {
                  this.m_accumulationBuffer[i] = 0;
              }
              for (let k = 0; k < this.m_contactBuffer.count; k++) {
                  const contact = this.m_contactBuffer.data[k];
                  if (contact.flags & exports.ParticleFlag.b2_staticPressureParticle) {
                      const a = contact.indexA;
                      const b = contact.indexB;
                      const w = contact.weight;
                      this.m_accumulationBuffer[a] += w * this.m_staticPressureBuffer[b]; // a <- b
                      this.m_accumulationBuffer[b] += w * this.m_staticPressureBuffer[a]; // b <- a
                  }
              }
              for (let i = 0; i < this.m_count; i++) {
                  const w = this.m_weightBuffer[i];
                  if (this.m_flagsBuffer.data[i] & exports.ParticleFlag.b2_staticPressureParticle) {
                      const wh = this.m_accumulationBuffer[i];
                      const h = (wh + pressurePerWeight * (w - b2_minParticleWeight)) /
                          (w + relaxation);
                      this.m_staticPressureBuffer[i] = b2Clamp(h, 0.0, maxPressure);
                  }
                  else {
                      this.m_staticPressureBuffer[i] = 0;
                  }
              }
          }
      }
      ComputeWeight() {
          // calculates the sum of contact-weights for each particle
          // that means dimensionless density
          ///memset(m_weightBuffer, 0, sizeof(*m_weightBuffer) * m_count);
          for (let k = 0; k < this.m_count; k++) {
              this.m_weightBuffer[k] = 0;
          }
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              const w = contact.weight;
              this.m_weightBuffer[a] += w;
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const w = contact.weight;
              this.m_weightBuffer[a] += w;
              this.m_weightBuffer[b] += w;
          }
      }
      SolvePressure(step) {
          const s_f = b2ParticleSystem.SolvePressure_s_f;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          // calculates pressure as a linear function of density
          const criticalPressure = this.GetCriticalPressure(step);
          const pressurePerWeight = this.m_def.pressureStrength * criticalPressure;
          const maxPressure = b2_maxParticlePressure * criticalPressure;
          for (let i = 0; i < this.m_count; i++) {
              const w = this.m_weightBuffer[i];
              const h = pressurePerWeight * b2Max(0.0, w - b2_minParticleWeight);
              this.m_accumulationBuffer[i] = b2Min(h, maxPressure);
          }
          // ignores particles which have their own repulsive force
          if (this.m_allParticleFlags & b2ParticleSystem.k_noPressureFlags) {
              for (let i = 0; i < this.m_count; i++) {
                  if (this.m_flagsBuffer.data[i] & b2ParticleSystem.k_noPressureFlags) {
                      this.m_accumulationBuffer[i] = 0;
                  }
              }
          }
          // static pressure
          if (this.m_allParticleFlags & exports.ParticleFlag.b2_staticPressureParticle) {
              // DEBUG: b2Assert(this.m_staticPressureBuffer !== null);
              for (let i = 0; i < this.m_count; i++) {
                  if (this.m_flagsBuffer.data[i] & exports.ParticleFlag.b2_staticPressureParticle) {
                      this.m_accumulationBuffer[i] += this.m_staticPressureBuffer[i];
                  }
              }
          }
          // applies pressure between each particles in contact
          const velocityPerPressure = step.dt / (this.m_def.density * this.m_particleDiameter);
          const inv_mass = this.GetParticleInvMass();
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              const b = contact.body;
              const w = contact.weight;
              const m = contact.mass;
              const n = contact.normal;
              const p = pos_data[a];
              const h = this.m_accumulationBuffer[a] + pressurePerWeight * w;
              ///b2Vec2 f = velocityPerPressure * w * m * h * n;
              const f = b2Vec2.MulSV(velocityPerPressure * w * m * h, n, s_f);
              ///m_velocityBuffer.data[a] -= GetParticleInvMass() * f;
              vel_data[a].SelfMulSub(inv_mass, f);
              b.ApplyLinearImpulse(f, p, true);
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const w = contact.weight;
              const n = contact.normal;
              const h = this.m_accumulationBuffer[a] + this.m_accumulationBuffer[b];
              ///b2Vec2 f = velocityPerPressure * w * h * n;
              const f = b2Vec2.MulSV(velocityPerPressure * w * h, n, s_f);
              ///m_velocityBuffer.data[a] -= f;
              vel_data[a].SelfSub(f);
              ///m_velocityBuffer.data[b] += f;
              vel_data[b].SelfAdd(f);
          }
      }
      SolveDamping(step) {
          const s_v = b2ParticleSystem.SolveDamping_s_v;
          const s_f = b2ParticleSystem.SolveDamping_s_f;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          // reduces normal velocity of each contact
          const linearDamping = this.m_def.dampingStrength;
          const quadraticDamping = 1 / this.GetCriticalVelocity(step);
          const inv_mass = this.GetParticleInvMass();
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              const b = contact.body;
              const w = contact.weight;
              const m = contact.mass;
              const n = contact.normal;
              const p = pos_data[a];
              ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];
              const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);
              const vn = b2Vec2.DotVV(v, n);
              if (vn < 0) {
                  const damping = b2Max(linearDamping * w, b2Min(-quadraticDamping * vn, 0.5));
                  ///b2Vec2 f = damping * m * vn * n;
                  const f = b2Vec2.MulSV(damping * m * vn, n, s_f);
                  ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;
                  vel_data[a].SelfMulAdd(inv_mass, f);
                  ///b.ApplyLinearImpulse(-f, p, true);
                  b.ApplyLinearImpulse(f.SelfNeg(), p, true);
              }
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const w = contact.weight;
              const n = contact.normal;
              ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];
              const v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);
              const vn = b2Vec2.DotVV(v, n);
              if (vn < 0) {
                  ///float32 damping = b2Max(linearDamping * w, b2Min(- quadraticDamping * vn, 0.5f));
                  const damping = b2Max(linearDamping * w, b2Min(-quadraticDamping * vn, 0.5));
                  ///b2Vec2 f = damping * vn * n;
                  const f = b2Vec2.MulSV(damping * vn, n, s_f);
                  ///this.m_velocityBuffer.data[a] += f;
                  vel_data[a].SelfAdd(f);
                  ///this.m_velocityBuffer.data[b] -= f;
                  vel_data[b].SelfSub(f);
              }
          }
      }
      SolveRigidDamping() {
          const s_t0 = b2ParticleSystem.SolveRigidDamping_s_t0;
          const s_t1 = b2ParticleSystem.SolveRigidDamping_s_t1;
          const s_p = b2ParticleSystem.SolveRigidDamping_s_p;
          const s_v = b2ParticleSystem.SolveRigidDamping_s_v;
          const invMassA = [0.0], invInertiaA = [0.0], tangentDistanceA = [0.0]; // TODO: static
          const invMassB = [0.0], invInertiaB = [0.0], tangentDistanceB = [0.0]; // TODO: static
          // Apply impulse to rigid particle groups colliding with other objects
          // to reduce relative velocity at the colliding point.
          const pos_data = this.m_positionBuffer.data;
          const damping = this.m_def.dampingStrength;
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              const aGroup = this.m_groupBuffer[a];
              if (aGroup && this.IsRigidGroup(aGroup)) {
                  const b = contact.body;
                  const n = contact.normal;
                  const w = contact.weight;
                  const p = pos_data[a];
                  ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - aGroup.GetLinearVelocityFromWorldPoint(p);
                  const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, s_t0), aGroup.GetLinearVelocityFromWorldPoint(p, s_t1), s_v);
                  const vn = b2Vec2.DotVV(v, n);
                  if (vn < 0) {
                      // The group's average velocity at particle position 'p' is pushing
                      // the particle into the body.
                      ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassA, &invInertiaA, &tangentDistanceA, true, aGroup, a, p, n);
                      this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, p, n);
                      // Calculate b.m_I from public functions of b2Body.
                      ///this.InitDampingParameter(&invMassB, &invInertiaB, &tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);
                      this.InitDampingParameter(invMassB, invInertiaB, tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);
                      ///float32 f = damping * b2Min(w, 1.0) * this.ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, vn);
                      const f = damping * b2Min(w, 1.0) * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);
                      ///this.ApplyDamping(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, f, n);
                      this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], true, aGroup, a, f, n);
                      ///b.ApplyLinearImpulse(-f * n, p, true);
                      b.ApplyLinearImpulse(b2Vec2.MulSV(-f, n, b2Vec2.s_t0), p, true);
                  }
              }
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              const n = contact.normal;
              const w = contact.weight;
              const aGroup = this.m_groupBuffer[a];
              const bGroup = this.m_groupBuffer[b];
              const aRigid = this.IsRigidGroup(aGroup);
              const bRigid = this.IsRigidGroup(bGroup);
              if (aGroup !== bGroup && (aRigid || bRigid)) {
                  ///b2Vec2 p = 0.5f * (this.m_positionBuffer.data[a] + this.m_positionBuffer.data[b]);
                  const p = b2Vec2.MidVV(pos_data[a], pos_data[b], s_p);
                  ///b2Vec2 v = GetLinearVelocity(bGroup, b, p) - GetLinearVelocity(aGroup, a, p);
                  const v = b2Vec2.SubVV(this.GetLinearVelocity(bGroup, b, p, s_t0), this.GetLinearVelocity(aGroup, a, p, s_t1), s_v);
                  const vn = b2Vec2.DotVV(v, n);
                  if (vn < 0) {
                      ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassA, &invInertiaA, &tangentDistanceA, aRigid, aGroup, a, p, n);
                      this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, p, n);
                      ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassB, &invInertiaB, &tangentDistanceB, bRigid, bGroup, b, p, n);
                      this.InitDampingParameterWithRigidGroupOrParticle(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, p, n);
                      ///float32 f = damping * w * this.ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, vn);
                      const f = damping * w * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);
                      ///this.ApplyDamping(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, f, n);
                      this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], aRigid, aGroup, a, f, n);
                      ///this.ApplyDamping(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, -f, n);
                      this.ApplyDamping(invMassB[0], invInertiaB[0], tangentDistanceB[0], bRigid, bGroup, b, -f, n);
                  }
              }
          }
      }
      SolveExtraDamping() {
          const s_v = b2ParticleSystem.SolveExtraDamping_s_v;
          const s_f = b2ParticleSystem.SolveExtraDamping_s_f;
          const vel_data = this.m_velocityBuffer.data;
          // Applies additional damping force between bodies and particles which can
          // produce strong repulsive force. Applying damping force multiple times
          // is effective in suppressing vibration.
          const pos_data = this.m_positionBuffer.data;
          const inv_mass = this.GetParticleInvMass();
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              if (this.m_flagsBuffer.data[a] & b2ParticleSystem.k_extraDampingFlags) {
                  const b = contact.body;
                  const m = contact.mass;
                  const n = contact.normal;
                  const p = pos_data[a];
                  ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];
                  const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);
                  ///float32 vn = b2Dot(v, n);
                  const vn = b2Vec2.DotVV(v, n);
                  if (vn < 0) {
                      ///b2Vec2 f = 0.5f * m * vn * n;
                      const f = b2Vec2.MulSV(0.5 * m * vn, n, s_f);
                      ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;
                      vel_data[a].SelfMulAdd(inv_mass, f);
                      ///b.ApplyLinearImpulse(-f, p, true);
                      b.ApplyLinearImpulse(f.SelfNeg(), p, true);
                  }
              }
          }
      }
      SolveWall() {
          const vel_data = this.m_velocityBuffer.data;
          for (let i = 0; i < this.m_count; i++) {
              if (this.m_flagsBuffer.data[i] & exports.ParticleFlag.b2_wallParticle) {
                  vel_data[i].SetZero();
              }
          }
      }
      SolveRigid(step) {
          const s_position = b2ParticleSystem.SolveRigid_s_position;
          const s_rotation = b2ParticleSystem.SolveRigid_s_rotation;
          const s_transform = b2ParticleSystem.SolveRigid_s_transform;
          const s_velocityTransform = b2ParticleSystem.SolveRigid_s_velocityTransform;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          for (let group = this.m_groupList; group; group = group.GetNext()) {
              if (group.m_groupFlags & exports.ParticleGroupFlag.b2_rigidParticleGroup) {
                  group.UpdateStatistics();
                  ///b2Rot rotation(step.dt * group.m_angularVelocity);
                  const rotation = s_rotation;
                  rotation.SetAngle(step.dt * group.m_angularVelocity);
                  ///b2Transform transform(group.m_center + step.dt * group.m_linearVelocity - b2Mul(rotation, group.m_center), rotation);
                  const position = b2Vec2.AddVV(group.m_center, b2Vec2.SubVV(b2Vec2.MulSV(step.dt, group.m_linearVelocity, b2Vec2.s_t0), b2Rot.MulRV(rotation, group.m_center, b2Vec2.s_t1), b2Vec2.s_t0), s_position);
                  const transform = s_transform;
                  transform.SetPositionRotation(position, rotation);
                  ///group.m_transform = b2Mul(transform, group.m_transform);
                  b2Transform.MulXX(transform, group.m_transform, group.m_transform);
                  const velocityTransform = s_velocityTransform;
                  velocityTransform.p.x = step.inv_dt * transform.p.x;
                  velocityTransform.p.y = step.inv_dt * transform.p.y;
                  velocityTransform.q.s = step.inv_dt * transform.q.s;
                  velocityTransform.q.c = step.inv_dt * (transform.q.c - 1);
                  for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                      ///m_velocityBuffer.data[i] = b2Mul(velocityTransform, m_positionBuffer.data[i]);
                      b2Transform.MulXV(velocityTransform, pos_data[i], vel_data[i]);
                  }
              }
          }
      }
      SolveElastic(step) {
          const s_pa = b2ParticleSystem.SolveElastic_s_pa;
          const s_pb = b2ParticleSystem.SolveElastic_s_pb;
          const s_pc = b2ParticleSystem.SolveElastic_s_pc;
          const s_r = b2ParticleSystem.SolveElastic_s_r;
          const s_t0 = b2ParticleSystem.SolveElastic_s_t0;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          const elasticStrength = step.inv_dt * this.m_def.elasticStrength;
          for (let k = 0; k < this.m_triadBuffer.count; k++) {
              const triad = this.m_triadBuffer.data[k];
              if (triad.flags & exports.ParticleFlag.b2_elasticParticle) {
                  const a = triad.indexA;
                  const b = triad.indexB;
                  const c = triad.indexC;
                  const oa = triad.pa;
                  const ob = triad.pb;
                  const oc = triad.pc;
                  ///b2Vec2 pa = m_positionBuffer.data[a];
                  const pa = s_pa.Copy(pos_data[a]);
                  ///b2Vec2 pb = m_positionBuffer.data[b];
                  const pb = s_pb.Copy(pos_data[b]);
                  ///b2Vec2 pc = m_positionBuffer.data[c];
                  const pc = s_pc.Copy(pos_data[c]);
                  const va = vel_data[a];
                  const vb = vel_data[b];
                  const vc = vel_data[c];
                  ///pa += step.dt * va;
                  pa.SelfMulAdd(step.dt, va);
                  ///pb += step.dt * vb;
                  pb.SelfMulAdd(step.dt, vb);
                  ///pc += step.dt * vc;
                  pc.SelfMulAdd(step.dt, vc);
                  ///b2Vec2 midPoint = (float32) 1 / 3 * (pa + pb + pc);
                  const midPoint_x = (pa.x + pb.x + pc.x) / 3.0;
                  const midPoint_y = (pa.y + pb.y + pc.y) / 3.0;
                  ///pa -= midPoint;
                  pa.x -= midPoint_x;
                  pa.y -= midPoint_y;
                  ///pb -= midPoint;
                  pb.x -= midPoint_x;
                  pb.y -= midPoint_y;
                  ///pc -= midPoint;
                  pc.x -= midPoint_x;
                  pc.y -= midPoint_y;
                  ///b2Rot r;
                  const r = s_r;
                  r.s = b2Vec2.CrossVV(oa, pa) + b2Vec2.CrossVV(ob, pb) + b2Vec2.CrossVV(oc, pc);
                  r.c = b2Vec2.DotVV(oa, pa) + b2Vec2.DotVV(ob, pb) + b2Vec2.DotVV(oc, pc);
                  const r2 = r.s * r.s + r.c * r.c;
                  let invR = b2InvSqrt(r2);
                  if (!isFinite(invR)) {
                      invR = 1.98177537e+019;
                  }
                  r.s *= invR;
                  r.c *= invR;
                  ///r.angle = Math.atan2(r.s, r.c); // TODO: optimize
                  const strength = elasticStrength * triad.strength;
                  ///va += strength * (b2Mul(r, oa) - pa);
                  b2Rot.MulRV(r, oa, s_t0);
                  b2Vec2.SubVV(s_t0, pa, s_t0);
                  b2Vec2.MulSV(strength, s_t0, s_t0);
                  va.SelfAdd(s_t0);
                  ///vb += strength * (b2Mul(r, ob) - pb);
                  b2Rot.MulRV(r, ob, s_t0);
                  b2Vec2.SubVV(s_t0, pb, s_t0);
                  b2Vec2.MulSV(strength, s_t0, s_t0);
                  vb.SelfAdd(s_t0);
                  ///vc += strength * (b2Mul(r, oc) - pc);
                  b2Rot.MulRV(r, oc, s_t0);
                  b2Vec2.SubVV(s_t0, pc, s_t0);
                  b2Vec2.MulSV(strength, s_t0, s_t0);
                  vc.SelfAdd(s_t0);
              }
          }
      }
      SolveSpring(step) {
          const s_pa = b2ParticleSystem.SolveSpring_s_pa;
          const s_pb = b2ParticleSystem.SolveSpring_s_pb;
          const s_d = b2ParticleSystem.SolveSpring_s_d;
          const s_f = b2ParticleSystem.SolveSpring_s_f;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          const springStrength = step.inv_dt * this.m_def.springStrength;
          for (let k = 0; k < this.m_pairBuffer.count; k++) {
              const pair = this.m_pairBuffer.data[k];
              if (pair.flags & exports.ParticleFlag.b2_springParticle) {
                  ///int32 a = pair.indexA;
                  const a = pair.indexA;
                  ///int32 b = pair.indexB;
                  const b = pair.indexB;
                  ///b2Vec2 pa = m_positionBuffer.data[a];
                  const pa = s_pa.Copy(pos_data[a]);
                  ///b2Vec2 pb = m_positionBuffer.data[b];
                  const pb = s_pb.Copy(pos_data[b]);
                  ///b2Vec2& va = m_velocityBuffer.data[a];
                  const va = vel_data[a];
                  ///b2Vec2& vb = m_velocityBuffer.data[b];
                  const vb = vel_data[b];
                  ///pa += step.dt * va;
                  pa.SelfMulAdd(step.dt, va);
                  ///pb += step.dt * vb;
                  pb.SelfMulAdd(step.dt, vb);
                  ///b2Vec2 d = pb - pa;
                  const d = b2Vec2.SubVV(pb, pa, s_d);
                  ///float32 r0 = pair.distance;
                  const r0 = pair.distance;
                  ///float32 r1 = d.Length();
                  const r1 = d.Length();
                  ///float32 strength = springStrength * pair.strength;
                  const strength = springStrength * pair.strength;
                  ///b2Vec2 f = strength * (r0 - r1) / r1 * d;
                  const f = b2Vec2.MulSV(strength * (r0 - r1) / r1, d, s_f);
                  ///va -= f;
                  va.SelfSub(f);
                  ///vb += f;
                  vb.SelfAdd(f);
              }
          }
      }
      SolveTensile(step) {
          const s_weightedNormal = b2ParticleSystem.SolveTensile_s_weightedNormal;
          const s_s = b2ParticleSystem.SolveTensile_s_s;
          const s_f = b2ParticleSystem.SolveTensile_s_f;
          const vel_data = this.m_velocityBuffer.data;
          // DEBUG: b2Assert(this.m_accumulation2Buffer !== null);
          for (let i = 0; i < this.m_count; i++) {
              this.m_accumulation2Buffer[i] = new b2Vec2();
              this.m_accumulation2Buffer[i].SetZero();
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              if (contact.flags & exports.ParticleFlag.b2_tensileParticle) {
                  const a = contact.indexA;
                  const b = contact.indexB;
                  const w = contact.weight;
                  const n = contact.normal;
                  ///b2Vec2 weightedNormal = (1 - w) * w * n;
                  const weightedNormal = b2Vec2.MulSV((1 - w) * w, n, s_weightedNormal);
                  ///m_accumulation2Buffer[a] -= weightedNormal;
                  this.m_accumulation2Buffer[a].SelfSub(weightedNormal);
                  ///m_accumulation2Buffer[b] += weightedNormal;
                  this.m_accumulation2Buffer[b].SelfAdd(weightedNormal);
              }
          }
          const criticalVelocity = this.GetCriticalVelocity(step);
          const pressureStrength = this.m_def.surfaceTensionPressureStrength * criticalVelocity;
          const normalStrength = this.m_def.surfaceTensionNormalStrength * criticalVelocity;
          const maxVelocityVariation = b2_maxParticleForce * criticalVelocity;
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              if (contact.flags & exports.ParticleFlag.b2_tensileParticle) {
                  const a = contact.indexA;
                  const b = contact.indexB;
                  const w = contact.weight;
                  const n = contact.normal;
                  const h = this.m_weightBuffer[a] + this.m_weightBuffer[b];
                  ///b2Vec2 s = m_accumulation2Buffer[b] - m_accumulation2Buffer[a];
                  const s = b2Vec2.SubVV(this.m_accumulation2Buffer[b], this.m_accumulation2Buffer[a], s_s);
                  const fn = b2Min(pressureStrength * (h - 2) + normalStrength * b2Vec2.DotVV(s, n), maxVelocityVariation) * w;
                  ///b2Vec2 f = fn * n;
                  const f = b2Vec2.MulSV(fn, n, s_f);
                  ///m_velocityBuffer.data[a] -= f;
                  vel_data[a].SelfSub(f);
                  ///m_velocityBuffer.data[b] += f;
                  vel_data[b].SelfAdd(f);
              }
          }
      }
      SolveViscous() {
          const s_v = b2ParticleSystem.SolveViscous_s_v;
          const s_f = b2ParticleSystem.SolveViscous_s_f;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          const viscousStrength = this.m_def.viscousStrength;
          const inv_mass = this.GetParticleInvMass();
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              if (this.m_flagsBuffer.data[a] & exports.ParticleFlag.b2_viscousParticle) {
                  const b = contact.body;
                  const w = contact.weight;
                  const m = contact.mass;
                  const p = pos_data[a];
                  ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];
                  const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);
                  ///b2Vec2 f = viscousStrength * m * w * v;
                  const f = b2Vec2.MulSV(viscousStrength * m * w, v, s_f);
                  ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;
                  vel_data[a].SelfMulAdd(inv_mass, f);
                  ///b.ApplyLinearImpulse(-f, p, true);
                  b.ApplyLinearImpulse(f.SelfNeg(), p, true);
              }
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              if (contact.flags & exports.ParticleFlag.b2_viscousParticle) {
                  const a = contact.indexA;
                  const b = contact.indexB;
                  const w = contact.weight;
                  ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];
                  const v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);
                  ///b2Vec2 f = viscousStrength * w * v;
                  const f = b2Vec2.MulSV(viscousStrength * w, v, s_f);
                  ///m_velocityBuffer.data[a] += f;
                  vel_data[a].SelfAdd(f);
                  ///m_velocityBuffer.data[b] -= f;
                  vel_data[b].SelfSub(f);
              }
          }
      }
      SolveRepulsive(step) {
          const s_f = b2ParticleSystem.SolveRepulsive_s_f;
          const vel_data = this.m_velocityBuffer.data;
          const repulsiveStrength = this.m_def.repulsiveStrength * this.GetCriticalVelocity(step);
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              if (contact.flags & exports.ParticleFlag.b2_repulsiveParticle) {
                  const a = contact.indexA;
                  const b = contact.indexB;
                  if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {
                      const w = contact.weight;
                      const n = contact.normal;
                      ///b2Vec2 f = repulsiveStrength * w * n;
                      const f = b2Vec2.MulSV(repulsiveStrength * w, n, s_f);
                      ///m_velocityBuffer.data[a] -= f;
                      vel_data[a].SelfSub(f);
                      ///m_velocityBuffer.data[b] += f;
                      vel_data[b].SelfAdd(f);
                  }
              }
          }
      }
      SolvePowder(step) {
          const s_f = b2ParticleSystem.SolvePowder_s_f;
          const pos_data = this.m_positionBuffer.data;
          const vel_data = this.m_velocityBuffer.data;
          const powderStrength = this.m_def.powderStrength * this.GetCriticalVelocity(step);
          const minWeight = 1.0 - b2_particleStride;
          const inv_mass = this.GetParticleInvMass();
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              const a = contact.index;
              if (this.m_flagsBuffer.data[a] & exports.ParticleFlag.b2_powderParticle) {
                  const w = contact.weight;
                  if (w > minWeight) {
                      const b = contact.body;
                      const m = contact.mass;
                      const p = pos_data[a];
                      const n = contact.normal;
                      const f = b2Vec2.MulSV(powderStrength * m * (w - minWeight), n, s_f);
                      vel_data[a].SelfMulSub(inv_mass, f);
                      b.ApplyLinearImpulse(f, p, true);
                  }
              }
          }
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              if (contact.flags & exports.ParticleFlag.b2_powderParticle) {
                  const w = contact.weight;
                  if (w > minWeight) {
                      const a = contact.indexA;
                      const b = contact.indexB;
                      const n = contact.normal;
                      const f = b2Vec2.MulSV(powderStrength * (w - minWeight), n, s_f);
                      vel_data[a].SelfSub(f);
                      vel_data[b].SelfAdd(f);
                  }
              }
          }
      }
      SolveSolid(step) {
          const s_f = b2ParticleSystem.SolveSolid_s_f;
          const vel_data = this.m_velocityBuffer.data;
          // applies extra repulsive force from solid particle groups
          this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);
          const ejectionStrength = step.inv_dt * this.m_def.ejectionStrength;
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              const a = contact.indexA;
              const b = contact.indexB;
              if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {
                  const w = contact.weight;
                  const n = contact.normal;
                  const h = this.m_depthBuffer[a] + this.m_depthBuffer[b];
                  const f = b2Vec2.MulSV(ejectionStrength * h * w, n, s_f);
                  vel_data[a].SelfSub(f);
                  vel_data[b].SelfAdd(f);
              }
          }
      }
      SolveForce(step) {
          const vel_data = this.m_velocityBuffer.data;
          const velocityPerForce = step.dt * this.GetParticleInvMass();
          for (let i = 0; i < this.m_count; i++) {
              ///m_velocityBuffer.data[i] += velocityPerForce * m_forceBuffer[i];
              vel_data[i].SelfMulAdd(velocityPerForce, this.m_forceBuffer[i]);
          }
          this.m_hasForce = false;
      }
      SolveColorMixing() {
          // mixes color between contacting particles
          const colorMixing = 0.5 * this.m_def.colorMixingStrength;
          if (colorMixing) {
              for (let k = 0; k < this.m_contactBuffer.count; k++) {
                  const contact = this.m_contactBuffer.data[k];
                  const a = contact.indexA;
                  const b = contact.indexB;
                  if (this.m_flagsBuffer.data[a] & this.m_flagsBuffer.data[b] &
                      exports.ParticleFlag.b2_colorMixingParticle) {
                      const colorA = this.m_colorBuffer.data[a];
                      const colorB = this.m_colorBuffer.data[b];
                      // Use the static method to ensure certain compilers inline
                      // this correctly.
                      b2Color.MixColors(colorA, colorB, colorMixing);
                  }
              }
          }
      }
      SolveZombie() {
          // removes particles with zombie flag
          let newCount = 0;
          const newIndices = []; // TODO: static
          for (let i = 0; i < this.m_count; i++) {
              newIndices[i] = b2_invalidParticleIndex;
          }
          // DEBUG: b2Assert(newIndices.length === this.m_count);
          let allParticleFlags = 0;
          for (let i = 0; i < this.m_count; i++) {
              const flags = this.m_flagsBuffer.data[i];
              if (flags & exports.ParticleFlag.b2_zombieParticle) {
                  const destructionListener = this.m_world.m_destructionListener;
                  if ((flags & exports.ParticleFlag.b2_destructionListenerParticle) && destructionListener) {
                      destructionListener.SayGoodbyeParticle(this, i);
                  }
                  // Destroy particle handle.
                  if (this.m_handleIndexBuffer.data) {
                      const handle = this.m_handleIndexBuffer.data[i];
                      if (handle) {
                          handle.SetIndex(b2_invalidParticleIndex);
                          this.m_handleIndexBuffer.data[i] = null;
                          ///m_handleAllocator.Free(handle);
                      }
                  }
                  newIndices[i] = b2_invalidParticleIndex;
              }
              else {
                  newIndices[i] = newCount;
                  if (i !== newCount) {
                      // Update handle to reference new particle index.
                      if (this.m_handleIndexBuffer.data) {
                          const handle = this.m_handleIndexBuffer.data[i];
                          if (handle) {
                              handle.SetIndex(newCount);
                          }
                          this.m_handleIndexBuffer.data[newCount] = handle;
                      }
                      this.m_flagsBuffer.data[newCount] = this.m_flagsBuffer.data[i];
                      if (this.m_lastBodyContactStepBuffer.data) {
                          this.m_lastBodyContactStepBuffer.data[newCount] = this.m_lastBodyContactStepBuffer.data[i];
                      }
                      if (this.m_bodyContactCountBuffer.data) {
                          this.m_bodyContactCountBuffer.data[newCount] = this.m_bodyContactCountBuffer.data[i];
                      }
                      if (this.m_consecutiveContactStepsBuffer.data) {
                          this.m_consecutiveContactStepsBuffer.data[newCount] = this.m_consecutiveContactStepsBuffer.data[i];
                      }
                      this.m_positionBuffer.data[newCount].Copy(this.m_positionBuffer.data[i]);
                      this.m_velocityBuffer.data[newCount].Copy(this.m_velocityBuffer.data[i]);
                      this.m_groupBuffer[newCount] = this.m_groupBuffer[i];
                      if (this.m_hasForce) {
                          this.m_forceBuffer[newCount].Copy(this.m_forceBuffer[i]);
                      }
                      if (this.m_staticPressureBuffer) {
                          this.m_staticPressureBuffer[newCount] = this.m_staticPressureBuffer[i];
                      }
                      if (this.m_depthBuffer) {
                          this.m_depthBuffer[newCount] = this.m_depthBuffer[i];
                      }
                      if (this.m_colorBuffer.data) {
                          this.m_colorBuffer.data[newCount].Copy(this.m_colorBuffer.data[i]);
                      }
                      if (this.m_userDataBuffer.data) {
                          this.m_userDataBuffer.data[newCount] = this.m_userDataBuffer.data[i];
                      }
                      if (this.m_expirationTimeBuffer.data) {
                          this.m_expirationTimeBuffer.data[newCount] = this.m_expirationTimeBuffer.data[i];
                      }
                  }
                  newCount++;
                  allParticleFlags |= flags;
              }
          }
          // predicate functions
          const Test = {
              ///static bool IsProxyInvalid(const Proxy& proxy)
              IsProxyInvalid: (proxy) => {
                  return proxy.index < 0;
              },
              ///static bool IsContactInvalid(const b2ParticleContact& contact)
              IsContactInvalid: (contact) => {
                  return contact.indexA < 0 || contact.indexB < 0;
              },
              ///static bool IsBodyContactInvalid(const b2ParticleBodyContact& contact)
              IsBodyContactInvalid: (contact) => {
                  return contact.index < 0;
              },
              ///static bool IsPairInvalid(const b2ParticlePair& pair)
              IsPairInvalid: (pair) => {
                  return pair.indexA < 0 || pair.indexB < 0;
              },
              ///static bool IsTriadInvalid(const b2ParticleTriad& triad)
              IsTriadInvalid: (triad) => {
                  return triad.indexA < 0 || triad.indexB < 0 || triad.indexC < 0;
              },
          };
          // update proxies
          for (let k = 0; k < this.m_proxyBuffer.count; k++) {
              const proxy = this.m_proxyBuffer.data[k];
              proxy.index = newIndices[proxy.index];
          }
          this.m_proxyBuffer.RemoveIf(Test.IsProxyInvalid);
          // update contacts
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              contact.indexA = newIndices[contact.indexA];
              contact.indexB = newIndices[contact.indexB];
          }
          this.m_contactBuffer.RemoveIf(Test.IsContactInvalid);
          // update particle-body contacts
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              contact.index = newIndices[contact.index];
          }
          this.m_bodyContactBuffer.RemoveIf(Test.IsBodyContactInvalid);
          // update pairs
          for (let k = 0; k < this.m_pairBuffer.count; k++) {
              const pair = this.m_pairBuffer.data[k];
              pair.indexA = newIndices[pair.indexA];
              pair.indexB = newIndices[pair.indexB];
          }
          this.m_pairBuffer.RemoveIf(Test.IsPairInvalid);
          // update triads
          for (let k = 0; k < this.m_triadBuffer.count; k++) {
              const triad = this.m_triadBuffer.data[k];
              triad.indexA = newIndices[triad.indexA];
              triad.indexB = newIndices[triad.indexB];
              triad.indexC = newIndices[triad.indexC];
          }
          this.m_triadBuffer.RemoveIf(Test.IsTriadInvalid);
          // Update lifetime indices.
          if (this.m_indexByExpirationTimeBuffer.data) {
              let writeOffset = 0;
              for (let readOffset = 0; readOffset < this.m_count; readOffset++) {
                  const newIndex = newIndices[this.m_indexByExpirationTimeBuffer.data[readOffset]];
                  if (newIndex !== b2_invalidParticleIndex) {
                      this.m_indexByExpirationTimeBuffer.data[writeOffset++] = newIndex;
                  }
              }
          }
          // update groups
          for (let group = this.m_groupList; group; group = group.GetNext()) {
              let firstIndex = newCount;
              let lastIndex = 0;
              let modified = false;
              for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {
                  const j = newIndices[i];
                  if (j >= 0) {
                      firstIndex = b2Min(firstIndex, j);
                      lastIndex = b2Max(lastIndex, j + 1);
                  }
                  else {
                      modified = true;
                  }
              }
              if (firstIndex < lastIndex) {
                  group.m_firstIndex = firstIndex;
                  group.m_lastIndex = lastIndex;
                  if (modified) {
                      if (group.m_groupFlags & exports.ParticleGroupFlag.b2_solidParticleGroup) {
                          this.SetGroupFlags(group, group.m_groupFlags | exports.ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);
                      }
                  }
              }
              else {
                  group.m_firstIndex = 0;
                  group.m_lastIndex = 0;
                  if (!(group.m_groupFlags & exports.ParticleGroupFlag.b2_particleGroupCanBeEmpty)) {
                      this.SetGroupFlags(group, group.m_groupFlags | exports.ParticleGroupFlag.b2_particleGroupWillBeDestroyed);
                  }
              }
          }
          // update particle count
          this.m_count = newCount;
          this.m_allParticleFlags = allParticleFlags;
          this.m_needsUpdateAllParticleFlags = false;
          // destroy bodies with no particles
          for (let group = this.m_groupList; group;) {
              const next = group.GetNext();
              if (group.m_groupFlags & exports.ParticleGroupFlag.b2_particleGroupWillBeDestroyed) {
                  this.DestroyParticleGroup(group);
              }
              group = next;
          }
      }
      /**
       * Destroy all particles which have outlived their lifetimes set
       * by SetParticleLifetime().
       */
      SolveLifetimes(step) {
          // Update the time elapsed.
          this.m_timeElapsed = this.LifetimeToExpirationTime(step.dt);
          // Get the floor (non-fractional component) of the elapsed time.
          const quantizedTimeElapsed = this.GetQuantizedTimeElapsed();
          const expirationTimes = this.m_expirationTimeBuffer.data;
          const expirationTimeIndices = this.m_indexByExpirationTimeBuffer.data;
          const particleCount = this.GetParticleCount();
          // Sort the lifetime buffer if it's required.
          if (this.m_expirationTimeBufferRequiresSorting) {
              ///const ExpirationTimeComparator expirationTimeComparator(expirationTimes);
              ///std::sort(expirationTimeIndices, expirationTimeIndices + particleCount, expirationTimeComparator);
              /**
               * Compare the lifetime of particleIndexA and particleIndexB
               * returning true if the lifetime of A is greater than B for
               * particles that will expire.  If either particle's lifetime is
               * infinite (<= 0.0f) this function return true if the lifetime
               * of A is lesser than B. When used with std::sort() this
               * results in an array of particle indicies sorted in reverse
               * order by particle lifetime.
               *
               * For example, the set of lifetimes
               * (1.0, 0.7, 0.3, 0.0, -1.0, 2.0)
               * would be sorted as
               * (0.0, 1.0, -2.0, 1.0, 0.7, 0.3)
               */
              const ExpirationTimeComparator = (particleIndexA, particleIndexB) => {
                  const expirationTimeA = expirationTimes[particleIndexA];
                  const expirationTimeB = expirationTimes[particleIndexB];
                  const infiniteExpirationTimeA = expirationTimeA <= 0.0;
                  const infiniteExpirationTimeB = expirationTimeB <= 0.0;
                  return infiniteExpirationTimeA === infiniteExpirationTimeB ?
                      expirationTimeA > expirationTimeB : infiniteExpirationTimeA;
              };
              std_sort(expirationTimeIndices, 0, particleCount, ExpirationTimeComparator);
              this.m_expirationTimeBufferRequiresSorting = false;
          }
          // Destroy particles which have expired.
          for (let i = particleCount - 1; i >= 0; --i) {
              const particleIndex = expirationTimeIndices[i];
              const expirationTime = expirationTimes[particleIndex];
              // If no particles need to be destroyed, skip this.
              if (quantizedTimeElapsed < expirationTime || expirationTime <= 0) {
                  break;
              }
              // Destroy this particle.
              this.DestroyParticle(particleIndex);
          }
      }
      RotateBuffer(start, mid, end) {
          // move the particles assigned to the given group toward the end of array
          if (start === mid || mid === end) {
              return;
          }
          // DEBUG: b2Assert(mid >= start && mid <= end);
          function newIndices(i) {
              if (i < start) {
                  return i;
              }
              else if (i < mid) {
                  return i + end - mid;
              }
              else if (i < end) {
                  return i + start - mid;
              }
              else {
                  return i;
              }
          }
          ///std::rotate(m_flagsBuffer.data + start, m_flagsBuffer.data + mid, m_flagsBuffer.data + end);
          std_rotate(this.m_flagsBuffer.data, start, mid, end);
          if (this.m_lastBodyContactStepBuffer.data) {
              ///std::rotate(m_lastBodyContactStepBuffer.data + start, m_lastBodyContactStepBuffer.data + mid, m_lastBodyContactStepBuffer.data + end);
              std_rotate(this.m_lastBodyContactStepBuffer.data, start, mid, end);
          }
          if (this.m_bodyContactCountBuffer.data) {
              ///std::rotate(m_bodyContactCountBuffer.data + start, m_bodyContactCountBuffer.data + mid, m_bodyContactCountBuffer.data + end);
              std_rotate(this.m_bodyContactCountBuffer.data, start, mid, end);
          }
          if (this.m_consecutiveContactStepsBuffer.data) {
              ///std::rotate(m_consecutiveContactStepsBuffer.data + start, m_consecutiveContactStepsBuffer.data + mid, m_consecutiveContactStepsBuffer.data + end);
              std_rotate(this.m_consecutiveContactStepsBuffer.data, start, mid, end);
          }
          ///std::rotate(m_positionBuffer.data + start, m_positionBuffer.data + mid, m_positionBuffer.data + end);
          std_rotate(this.m_positionBuffer.data, start, mid, end);
          ///std::rotate(m_velocityBuffer.data + start, m_velocityBuffer.data + mid, m_velocityBuffer.data + end);
          std_rotate(this.m_velocityBuffer.data, start, mid, end);
          ///std::rotate(m_groupBuffer + start, m_groupBuffer + mid, m_groupBuffer + end);
          std_rotate(this.m_groupBuffer, start, mid, end);
          if (this.m_hasForce) {
              ///std::rotate(m_forceBuffer + start, m_forceBuffer + mid, m_forceBuffer + end);
              std_rotate(this.m_forceBuffer, start, mid, end);
          }
          if (this.m_staticPressureBuffer) {
              ///std::rotate(m_staticPressureBuffer + start, m_staticPressureBuffer + mid, m_staticPressureBuffer + end);
              std_rotate(this.m_staticPressureBuffer, start, mid, end);
          }
          if (this.m_depthBuffer) {
              ///std::rotate(m_depthBuffer + start, m_depthBuffer + mid, m_depthBuffer + end);
              std_rotate(this.m_depthBuffer, start, mid, end);
          }
          if (this.m_colorBuffer.data) {
              ///std::rotate(m_colorBuffer.data + start, m_colorBuffer.data + mid, m_colorBuffer.data + end);
              std_rotate(this.m_colorBuffer.data, start, mid, end);
          }
          if (this.m_userDataBuffer.data) {
              ///std::rotate(m_userDataBuffer.data + start, m_userDataBuffer.data + mid, m_userDataBuffer.data + end);
              std_rotate(this.m_userDataBuffer.data, start, mid, end);
          }
          // Update handle indices.
          if (this.m_handleIndexBuffer.data) {
              ///std::rotate(m_handleIndexBuffer.data + start, m_handleIndexBuffer.data + mid, m_handleIndexBuffer.data + end);
              std_rotate(this.m_handleIndexBuffer.data, start, mid, end);
              for (let i = start; i < end; ++i) {
                  const handle = this.m_handleIndexBuffer.data[i];
                  if (handle) {
                      handle.SetIndex(newIndices(handle.GetIndex()));
                  }
              }
          }
          if (this.m_expirationTimeBuffer.data) {
              ///std::rotate(m_expirationTimeBuffer.data + start, m_expirationTimeBuffer.data + mid, m_expirationTimeBuffer.data + end);
              std_rotate(this.m_expirationTimeBuffer.data, start, mid, end);
              // Update expiration time buffer indices.
              const particleCount = this.GetParticleCount();
              const indexByExpirationTime = this.m_indexByExpirationTimeBuffer.data;
              for (let i = 0; i < particleCount; ++i) {
                  indexByExpirationTime[i] = newIndices(indexByExpirationTime[i]);
              }
          }
          // update proxies
          for (let k = 0; k < this.m_proxyBuffer.count; k++) {
              const proxy = this.m_proxyBuffer.data[k];
              proxy.index = newIndices(proxy.index);
          }
          // update contacts
          for (let k = 0; k < this.m_contactBuffer.count; k++) {
              const contact = this.m_contactBuffer.data[k];
              contact.indexA = newIndices(contact.indexA);
              contact.indexB = newIndices(contact.indexB);
          }
          // update particle-body contacts
          for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {
              const contact = this.m_bodyContactBuffer.data[k];
              contact.index = newIndices(contact.index);
          }
          // update pairs
          for (let k = 0; k < this.m_pairBuffer.count; k++) {
              const pair = this.m_pairBuffer.data[k];
              pair.indexA = newIndices(pair.indexA);
              pair.indexB = newIndices(pair.indexB);
          }
          // update triads
          for (let k = 0; k < this.m_triadBuffer.count; k++) {
              const triad = this.m_triadBuffer.data[k];
              triad.indexA = newIndices(triad.indexA);
              triad.indexB = newIndices(triad.indexB);
              triad.indexC = newIndices(triad.indexC);
          }
          // update groups
          for (let group = this.m_groupList; group; group = group.GetNext()) {
              group.m_firstIndex = newIndices(group.m_firstIndex);
              group.m_lastIndex = newIndices(group.m_lastIndex - 1) + 1;
          }
      }
      GetCriticalVelocity(step) {
          return this.m_particleDiameter * step.inv_dt;
      }
      GetCriticalVelocitySquared(step) {
          const velocity = this.GetCriticalVelocity(step);
          return velocity * velocity;
      }
      GetCriticalPressure(step) {
          return this.m_def.density * this.GetCriticalVelocitySquared(step);
      }
      GetParticleStride() {
          return b2_particleStride * this.m_particleDiameter;
      }
      GetParticleMass() {
          const stride = this.GetParticleStride();
          return this.m_def.density * stride * stride;
      }
      GetParticleInvMass() {
          ///return 1.777777 * this.m_inverseDensity * this.m_inverseDiameter * this.m_inverseDiameter;
          // mass = density * stride^2, so we take the inverse of this.
          const inverseStride = this.m_inverseDiameter * (1.0 / b2_particleStride);
          return this.m_inverseDensity * inverseStride * inverseStride;
      }
      /**
       * Get the world's contact filter if any particles with the
       * b2_contactFilterParticle flag are present in the system.
       */
      GetFixtureContactFilter() {
          return (this.m_allParticleFlags & exports.ParticleFlag.b2_fixtureContactFilterParticle) ?
              this.m_world.m_contactManager.m_contactFilter : null;
      }
      /**
       * Get the world's contact filter if any particles with the
       * b2_particleContactFilterParticle flag are present in the
       * system.
       */
      GetParticleContactFilter() {
          return (this.m_allParticleFlags & exports.ParticleFlag.b2_particleContactFilterParticle) ?
              this.m_world.m_contactManager.m_contactFilter : null;
      }
      /**
       * Get the world's contact listener if any particles with the
       * b2_fixtureContactListenerParticle flag are present in the
       * system.
       */
      GetFixtureContactListener() {
          return (this.m_allParticleFlags & exports.ParticleFlag.b2_fixtureContactListenerParticle) ?
              this.m_world.m_contactManager.m_contactListener : null;
      }
      /**
       * Get the world's contact listener if any particles with the
       * b2_particleContactListenerParticle flag are present in the
       * system.
       */
      GetParticleContactListener() {
          return (this.m_allParticleFlags & exports.ParticleFlag.b2_particleContactListenerParticle) ?
              this.m_world.m_contactManager.m_contactListener : null;
      }
      SetUserOverridableBuffer(buffer, data) {
          buffer.data = data;
          buffer.userSuppliedCapacity = data.length;
      }
      SetGroupFlags(group, newFlags) {
          const oldFlags = group.m_groupFlags;
          if ((oldFlags ^ newFlags) & exports.ParticleGroupFlag.b2_solidParticleGroup) {
              // If the b2_solidParticleGroup flag changed schedule depth update.
              newFlags |= exports.ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth;
          }
          if (oldFlags & ~newFlags) {
              // If any flags might be removed
              this.m_needsUpdateAllGroupFlags = true;
          }
          if (~this.m_allGroupFlags & newFlags) {
              // If any flags were added
              if (newFlags & exports.ParticleGroupFlag.b2_solidParticleGroup) {
                  this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);
              }
              this.m_allGroupFlags |= newFlags;
          }
          group.m_groupFlags = newFlags;
      }
      static BodyContactCompare(lhs, rhs) {
          if (lhs.index === rhs.index) {
              // Subsort by weight, decreasing.
              return lhs.weight > rhs.weight;
          }
          return lhs.index < rhs.index;
      }
      RemoveSpuriousBodyContacts() {
          // At this point we have a list of contact candidates based on AABB
          // overlap.The AABB query that  generated this returns all collidable
          // fixtures overlapping particle bounding boxes.  This breaks down around
          // vertices where two shapes intersect, such as a "ground" surface made
          // of multiple b2PolygonShapes; it potentially applies a lot of spurious
          // impulses from normals that should not actually contribute.  See the
          // Ramp example in Testbed.
          //
          // To correct for this, we apply this algorithm:
          //   * sort contacts by particle and subsort by weight (nearest to farthest)
          //   * for each contact per particle:
          //      - project a point at the contact distance along the inverse of the
          //        contact normal
          //      - if this intersects the fixture that generated the contact, apply
          //         it, otherwise discard as impossible
          //      - repeat for up to n nearest contacts, currently we get good results
          //        from n=3.
          ///std::sort(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.End(), b2ParticleSystem::BodyContactCompare);
          std_sort(this.m_bodyContactBuffer.data, 0, this.m_bodyContactBuffer.count, b2ParticleSystem.BodyContactCompare);
          ///int32 discarded = 0;
          ///std::remove_if(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.End(), b2ParticleBodyContactRemovePredicate(this, &discarded));
          ///
          ///m_bodyContactBuffer.SetCount(m_bodyContactBuffer.GetCount() - discarded);
          const s_n = b2ParticleSystem.RemoveSpuriousBodyContacts_s_n;
          const s_pos = b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos;
          const s_normal = b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal;
          // Max number of contacts processed per particle, from nearest to farthest.
          // This must be at least 2 for correctness with concave shapes; 3 was
          // experimentally arrived at as looking reasonable.
          const k_maxContactsPerPoint = 3;
          const system = this;
          // Index of last particle processed.
          let lastIndex = -1;
          // Number of contacts processed for the current particle.
          let currentContacts = 0;
          // Output the number of discarded contacts.
          // let discarded = 0;
          const b2ParticleBodyContactRemovePredicate = (contact) => {
              // This implements the selection criteria described in
              // RemoveSpuriousBodyContacts().
              // This functor is iterating through a list of Body contacts per
              // Particle, ordered from near to far.  For up to the maximum number of
              // contacts we allow per point per step, we verify that the contact
              // normal of the Body that genenerated the contact makes physical sense
              // by projecting a point back along that normal and seeing if it
              // intersects the fixture generating the contact.
              if (contact.index !== lastIndex) {
                  currentContacts = 0;
                  lastIndex = contact.index;
              }
              if (currentContacts++ > k_maxContactsPerPoint) {
                  // ++discarded;
                  return true;
              }
              // Project along inverse normal (as returned in the contact) to get the
              // point to check.
              ///b2Vec2 n = contact.normal;
              const n = s_n.Copy(contact.normal);
              // weight is 1-(inv(diameter) * distance)
              ///n *= system.m_particleDiameter * (1 - contact.weight);
              n.SelfMul(system.m_particleDiameter * (1 - contact.weight));
              ///b2Vec2 pos = system.m_positionBuffer.data[contact.index] + n;
              const pos = b2Vec2.AddVV(system.m_positionBuffer.data[contact.index], n, s_pos);
              // pos is now a point projected back along the contact normal to the
              // contact distance. If the surface makes sense for a contact, pos will
              // now lie on or in the fixture generating
              if (!contact.fixture.TestPoint(pos)) {
                  const childCount = contact.fixture.GetShape().GetChildCount();
                  for (let childIndex = 0; childIndex < childCount; childIndex++) {
                      const normal = s_normal;
                      const distance = contact.fixture.ComputeDistance(pos, normal, childIndex);
                      if (distance < b2_linearSlop) {
                          return false;
                      }
                  }
                  // ++discarded;
                  return true;
              }
              return false;
          };
          this.m_bodyContactBuffer.count = std_remove_if(this.m_bodyContactBuffer.data, b2ParticleBodyContactRemovePredicate, this.m_bodyContactBuffer.count);
      }
      DetectStuckParticle(particle) {
          // Detect stuck particles
          //
          // The basic algorithm is to allow the user to specify an optional
          // threshold where we detect whenever a particle is contacting
          // more than one fixture for more than threshold consecutive
          // steps. This is considered to be "stuck", and these are put
          // in a list the user can query per step, if enabled, to deal with
          // such particles.
          if (this.m_stuckThreshold <= 0) {
              return;
          }
          // Get the state variables for this particle.
          ///int32 * const consecutiveCount = &m_consecutiveContactStepsBuffer.data[particle];
          ///int32 * const lastStep = &m_lastBodyContactStepBuffer.data[particle];
          ///int32 * const bodyCount = &m_bodyContactCountBuffer.data[particle];
          // This is only called when there is a body contact for this particle.
          ///++(*bodyCount);
          ++this.m_bodyContactCountBuffer.data[particle];
          // We want to only trigger detection once per step, the first time we
          // contact more than one fixture in a step for a given particle.
          ///if (*bodyCount === 2)
          if (this.m_bodyContactCountBuffer.data[particle] === 2) {
              ///++(*consecutiveCount);
              ++this.m_consecutiveContactStepsBuffer.data[particle];
              ///if (*consecutiveCount > m_stuckThreshold)
              if (this.m_consecutiveContactStepsBuffer.data[particle] > this.m_stuckThreshold) {
                  ///int32& newStuckParticle = m_stuckParticleBuffer.Append();
                  ///newStuckParticle = particle;
                  this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()] = particle;
              }
          }
          ///*lastStep = m_timestamp;
          this.m_lastBodyContactStepBuffer.data[particle] = this.m_timestamp;
      }
      /**
       * Determine whether a particle index is valid.
       */
      ValidateParticleIndex(index) {
          return index >= 0 && index < this.GetParticleCount() &&
              index !== b2_invalidParticleIndex;
      }
      /**
       * Get the time elapsed in
       * b2ParticleSystemDef::lifetimeGranularity.
       */
      GetQuantizedTimeElapsed() {
          ///return (int32)(m_timeElapsed >> 32);
          return Math.floor(this.m_timeElapsed / 0x100000000);
      }
      /**
       * Convert a lifetime in seconds to an expiration time.
       */
      LifetimeToExpirationTime(lifetime) {
          ///return m_timeElapsed + (int64)((lifetime / m_def.lifetimeGranularity) * (float32)(1LL << 32));
          return this.m_timeElapsed + Math.floor(((lifetime / this.m_def.lifetimeGranularity) * 0x100000000));
      }
      ForceCanBeApplied(flags) {
          return !(flags & exports.ParticleFlag.b2_wallParticle);
      }
      PrepareForceBuffer() {
          if (!this.m_hasForce) {
              ///memset(m_forceBuffer, 0, sizeof(*m_forceBuffer) * m_count);
              for (let i = 0; i < this.m_count; i++) {
                  this.m_forceBuffer[i].SetZero();
              }
              this.m_hasForce = true;
          }
      }
      IsRigidGroup(group) {
          return (group !== null) && ((group.m_groupFlags & exports.ParticleGroupFlag.b2_rigidParticleGroup) !== 0);
      }
      GetLinearVelocity(group, particleIndex, point, out) {
          if (group && this.IsRigidGroup(group)) {
              return group.GetLinearVelocityFromWorldPoint(point, out);
          }
          else {
              ///return m_velocityBuffer.data[particleIndex];
              return out.Copy(this.m_velocityBuffer.data[particleIndex]);
          }
      }
      InitDampingParameter(invMass, invInertia, tangentDistance, mass, inertia, center, point, normal) {
          ///*invMass = mass > 0 ? 1 / mass : 0;
          invMass[0] = mass > 0 ? 1 / mass : 0;
          ///*invInertia = inertia > 0 ? 1 / inertia : 0;
          invInertia[0] = inertia > 0 ? 1 / inertia : 0;
          ///*tangentDistance = b2Cross(point - center, normal);
          tangentDistance[0] = b2Vec2.CrossVV(b2Vec2.SubVV(point, center, b2Vec2.s_t0), normal);
      }
      InitDampingParameterWithRigidGroupOrParticle(invMass, invInertia, tangentDistance, isRigidGroup, group, particleIndex, point, normal) {
          if (group && isRigidGroup) {
              this.InitDampingParameter(invMass, invInertia, tangentDistance, group.GetMass(), group.GetInertia(), group.GetCenter(), point, normal);
          }
          else {
              const flags = this.m_flagsBuffer.data[particleIndex];
              this.InitDampingParameter(invMass, invInertia, tangentDistance, flags & exports.ParticleFlag.b2_wallParticle ? 0 : this.GetParticleMass(), 0, point, point, normal);
          }
      }
      ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, normalVelocity) {
          const invMass = invMassA + invInertiaA * tangentDistanceA * tangentDistanceA +
              invMassB + invInertiaB * tangentDistanceB * tangentDistanceB;
          return invMass > 0 ? normalVelocity / invMass : 0;
      }
      ApplyDamping(invMass, invInertia, tangentDistance, isRigidGroup, group, particleIndex, impulse, normal) {
          if (group && isRigidGroup) {
              ///group.m_linearVelocity += impulse * invMass * normal;
              group.m_linearVelocity.SelfMulAdd(impulse * invMass, normal);
              ///group.m_angularVelocity += impulse * tangentDistance * invInertia;
              group.m_angularVelocity += impulse * tangentDistance * invInertia;
          }
          else {
              ///m_velocityBuffer.data[particleIndex] += impulse * invMass * normal;
              this.m_velocityBuffer.data[particleIndex].SelfMulAdd(impulse * invMass, normal);
          }
      }
  }
  b2ParticleSystem.xTruncBits = 12;
  b2ParticleSystem.yTruncBits = 12;
  b2ParticleSystem.tagBits = 8 * 4; // 8u * sizeof(uint32);
  b2ParticleSystem.yOffset = 1 << (b2ParticleSystem.yTruncBits - 1);
  b2ParticleSystem.yShift = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits;
  b2ParticleSystem.xShift = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits - b2ParticleSystem.xTruncBits;
  b2ParticleSystem.xScale = 1 << b2ParticleSystem.xShift;
  b2ParticleSystem.xOffset = b2ParticleSystem.xScale * (1 << (b2ParticleSystem.xTruncBits - 1));
  b2ParticleSystem.yMask = ((1 << b2ParticleSystem.yTruncBits) - 1) << b2ParticleSystem.yShift;
  b2ParticleSystem.xMask = ~b2ParticleSystem.yMask;
  b2ParticleSystem.DestroyParticlesInShape_s_aabb = new b2AABB();
  b2ParticleSystem.CreateParticleGroup_s_transform = new b2Transform();
  b2ParticleSystem.ComputeCollisionEnergy_s_v = new b2Vec2();
  b2ParticleSystem.QueryShapeAABB_s_aabb = new b2AABB();
  b2ParticleSystem.QueryPointAABB_s_aabb = new b2AABB();
  b2ParticleSystem.RayCast_s_aabb = new b2AABB();
  b2ParticleSystem.RayCast_s_p = new b2Vec2();
  b2ParticleSystem.RayCast_s_v = new b2Vec2();
  b2ParticleSystem.RayCast_s_n = new b2Vec2();
  b2ParticleSystem.RayCast_s_point = new b2Vec2();
  /**
   * All particle types that require creating pairs
   */
  b2ParticleSystem.k_pairFlags = exports.ParticleFlag.b2_springParticle;
  /**
   * All particle types that require creating triads
   */
  b2ParticleSystem.k_triadFlags = exports.ParticleFlag.b2_elasticParticle;
  /**
   * All particle types that do not produce dynamic pressure
   */
  b2ParticleSystem.k_noPressureFlags = exports.ParticleFlag.b2_powderParticle | exports.ParticleFlag.b2_tensileParticle;
  /**
   * All particle types that apply extra damping force with bodies
   */
  b2ParticleSystem.k_extraDampingFlags = exports.ParticleFlag.b2_staticPressureParticle;
  b2ParticleSystem.k_barrierWallFlags = exports.ParticleFlag.b2_barrierParticle | exports.ParticleFlag.b2_wallParticle;
  b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge = new b2EdgeShape();
  b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d = new b2Vec2();
  b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p = new b2Vec2();
  b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb = new b2AABB();
  b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p = new b2Vec2();
  b2ParticleSystem.UpdatePairsAndTriads_s_dab = new b2Vec2();
  b2ParticleSystem.UpdatePairsAndTriads_s_dbc = new b2Vec2();
  b2ParticleSystem.UpdatePairsAndTriads_s_dca = new b2Vec2();
  b2ParticleSystem.AddContact_s_d = new b2Vec2();
  b2ParticleSystem.UpdateBodyContacts_s_aabb = new b2AABB();
  b2ParticleSystem.Solve_s_subStep = new b2TimeStep();
  b2ParticleSystem.SolveCollision_s_aabb = new b2AABB();
  b2ParticleSystem.SolveGravity_s_gravity = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_aabb = new b2AABB();
  b2ParticleSystem.SolveBarrier_s_va = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_vb = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_pba = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_vba = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_vc = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_pca = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_vca = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_qba = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_qca = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_dv = new b2Vec2();
  b2ParticleSystem.SolveBarrier_s_f = new b2Vec2();
  b2ParticleSystem.SolvePressure_s_f = new b2Vec2();
  b2ParticleSystem.SolveDamping_s_v = new b2Vec2();
  b2ParticleSystem.SolveDamping_s_f = new b2Vec2();
  b2ParticleSystem.SolveRigidDamping_s_t0 = new b2Vec2();
  b2ParticleSystem.SolveRigidDamping_s_t1 = new b2Vec2();
  b2ParticleSystem.SolveRigidDamping_s_p = new b2Vec2();
  b2ParticleSystem.SolveRigidDamping_s_v = new b2Vec2();
  b2ParticleSystem.SolveExtraDamping_s_v = new b2Vec2();
  b2ParticleSystem.SolveExtraDamping_s_f = new b2Vec2();
  b2ParticleSystem.SolveRigid_s_position = new b2Vec2();
  b2ParticleSystem.SolveRigid_s_rotation = new b2Rot();
  b2ParticleSystem.SolveRigid_s_transform = new b2Transform();
  b2ParticleSystem.SolveRigid_s_velocityTransform = new b2Transform();
  b2ParticleSystem.SolveElastic_s_pa = new b2Vec2();
  b2ParticleSystem.SolveElastic_s_pb = new b2Vec2();
  b2ParticleSystem.SolveElastic_s_pc = new b2Vec2();
  b2ParticleSystem.SolveElastic_s_r = new b2Rot();
  b2ParticleSystem.SolveElastic_s_t0 = new b2Vec2();
  b2ParticleSystem.SolveSpring_s_pa = new b2Vec2();
  b2ParticleSystem.SolveSpring_s_pb = new b2Vec2();
  b2ParticleSystem.SolveSpring_s_d = new b2Vec2();
  b2ParticleSystem.SolveSpring_s_f = new b2Vec2();
  b2ParticleSystem.SolveTensile_s_weightedNormal = new b2Vec2();
  b2ParticleSystem.SolveTensile_s_s = new b2Vec2();
  b2ParticleSystem.SolveTensile_s_f = new b2Vec2();
  b2ParticleSystem.SolveViscous_s_v = new b2Vec2();
  b2ParticleSystem.SolveViscous_s_f = new b2Vec2();
  b2ParticleSystem.SolveRepulsive_s_f = new b2Vec2();
  b2ParticleSystem.SolvePowder_s_f = new b2Vec2();
  b2ParticleSystem.SolveSolid_s_f = new b2Vec2();
  b2ParticleSystem.RemoveSpuriousBodyContacts_s_n = new b2Vec2();
  b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos = new b2Vec2();
  b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal = new b2Vec2();
  class b2ParticleSystem_UserOverridableBuffer {
      constructor() {
          this._data = null;
          this.userSuppliedCapacity = 0;
      }
      get data() { return this._data; } // HACK: may return null
      set data(value) { this._data = value; }
  }
  class b2ParticleSystem_Proxy {
      constructor() {
          this.index = b2_invalidParticleIndex;
          this.tag = 0;
      }
      static CompareProxyProxy(a, b) {
          return a.tag < b.tag;
      }
      static CompareTagProxy(a, b) {
          return a < b.tag;
      }
      static CompareProxyTag(a, b) {
          return a.tag < b;
      }
  }
  class b2ParticleSystem_InsideBoundsEnumerator {
      /**
       * InsideBoundsEnumerator enumerates all particles inside the
       * given bounds.
       *
       * Construct an enumerator with bounds of tags and a range of
       * proxies.
       */
      constructor(system, lower, upper, first, last) {
          this.m_system = system;
          this.m_xLower = (lower & b2ParticleSystem.xMask) >>> 0;
          this.m_xUpper = (upper & b2ParticleSystem.xMask) >>> 0;
          this.m_yLower = (lower & b2ParticleSystem.yMask) >>> 0;
          this.m_yUpper = (upper & b2ParticleSystem.yMask) >>> 0;
          this.m_first = first;
          this.m_last = last;
          // DEBUG: b2Assert(this.m_first <= this.m_last);
      }
      /**
       * Get index of the next particle. Returns
       * b2_invalidParticleIndex if there are no more particles.
       */
      GetNext() {
          while (this.m_first < this.m_last) {
              const xTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem.xMask) >>> 0;
              // #if B2_ASSERT_ENABLED
              // DEBUG: const yTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem_yMask) >>> 0;
              // DEBUG: b2Assert(yTag >= this.m_yLower);
              // DEBUG: b2Assert(yTag <= this.m_yUpper);
              // #endif
              if (xTag >= this.m_xLower && xTag <= this.m_xUpper) {
                  return (this.m_system.m_proxyBuffer.data[this.m_first++]).index;
              }
              this.m_first++;
          }
          return b2_invalidParticleIndex;
      }
  }
  class b2ParticleSystem_ParticleListNode {
      constructor() {
          /**
           * The next node in the list.
           */
          this.next = null;
          /**
           * Number of entries in the list. Valid only for the node at the
           * head of the list.
           */
          this.count = 0;
          /**
           * Particle index.
           */
          this.index = 0;
      }
  }
  /**
   * @constructor
   */
  class b2ParticleSystem_FixedSetAllocator {
      Allocate(itemSize, count) {
          // TODO
          return count;
      }
      Clear() {
          // TODO
      }
      GetCount() {
          // TODO
          return 0;
      }
      Invalidate(itemIndex) {
          // TODO
      }
      GetValidBuffer() {
          // TODO
          return [];
      }
      GetBuffer() {
          // TODO
          return [];
      }
      SetCount(count) {
          // TODO
      }
  }
  class b2ParticleSystem_FixtureParticle {
      constructor(fixture, particle) {
          this.second = b2_invalidParticleIndex;
          this.first = fixture;
          this.second = particle;
      }
  }
  class b2ParticleSystem_FixtureParticleSet extends b2ParticleSystem_FixedSetAllocator {
      Initialize(bodyContactBuffer, flagsBuffer) {
          // TODO
      }
      Find(pair) {
          // TODO
          return b2_invalidParticleIndex;
      }
  }
  class b2ParticleSystem_ParticlePair {
      constructor(particleA, particleB) {
          this.first = b2_invalidParticleIndex;
          this.second = b2_invalidParticleIndex;
          this.first = particleA;
          this.second = particleB;
      }
  }
  class b2ParticlePairSet extends b2ParticleSystem_FixedSetAllocator {
      Initialize(contactBuffer, flagsBuffer) {
          // TODO
      }
      Find(pair) {
          // TODO
          return b2_invalidParticleIndex;
      }
  }
  class b2ParticleSystem_ConnectionFilter {
      /**
       * Is the particle necessary for connection?
       * A pair or a triad should contain at least one 'necessary'
       * particle.
       */
      IsNecessary(index) {
          return true;
      }
      /**
       * An additional condition for creating a pair.
       */
      ShouldCreatePair(a, b) {
          return true;
      }
      /**
       * An additional condition for creating a triad.
       */
      ShouldCreateTriad(a, b, c) {
          return true;
      }
  }
  class b2ParticleSystem_DestroyParticlesInShapeCallback extends b2QueryCallback {
      constructor(system, shape, xf, callDestructionListener) {
          super();
          this.m_callDestructionListener = false;
          this.m_destroyed = 0;
          this.m_system = system;
          this.m_shape = shape;
          this.m_xf = xf;
          this.m_callDestructionListener = callDestructionListener;
          this.m_destroyed = 0;
      }
      ReportFixture(fixture) {
          return false;
      }
      ReportParticle(particleSystem, index) {
          if (particleSystem !== this.m_system) {
              return false;
          }
          // DEBUG: b2Assert(index >= 0 && index < this.m_system.m_count);
          if (this.m_shape.TestPoint(this.m_xf, this.m_system.m_positionBuffer.data[index])) {
              this.m_system.DestroyParticle(index, this.m_callDestructionListener);
              this.m_destroyed++;
          }
          return true;
      }
      Destroyed() {
          return this.m_destroyed;
      }
  }
  class b2ParticleSystem_JoinParticleGroupsFilter extends b2ParticleSystem_ConnectionFilter {
      constructor(threshold) {
          super();
          this.m_threshold = 0;
          this.m_threshold = threshold;
      }
      /**
       * An additional condition for creating a pair.
       */
      ShouldCreatePair(a, b) {
          return (a < this.m_threshold && this.m_threshold <= b) ||
              (b < this.m_threshold && this.m_threshold <= a);
      }
      /**
       * An additional condition for creating a triad.
       */
      ShouldCreateTriad(a, b, c) {
          return (a < this.m_threshold || b < this.m_threshold || c < this.m_threshold) &&
              (this.m_threshold <= a || this.m_threshold <= b || this.m_threshold <= c);
      }
  }
  class b2ParticleSystem_CompositeShape extends b2Shape {
      constructor(shapes, shapeCount = shapes.length) {
          super(exports.ShapeType.e_unknown, 0);
          this.m_shapeCount = 0;
          this.m_shapes = shapes;
          this.m_shapeCount = shapeCount;
      }
      Clone() {
          // DEBUG: b2Assert(false);
          throw new Error();
      }
      GetChildCount() {
          return 1;
      }
      /**
       * @see b2Shape::TestPoint
       */
      TestPoint(xf, p) {
          for (let i = 0; i < this.m_shapeCount; i++) {
              if (this.m_shapes[i].TestPoint(xf, p)) {
                  return true;
              }
          }
          return false;
      }
      /**
       * @see b2Shape::ComputeDistance
       */
      ComputeDistance(xf, p, normal, childIndex) {
          // DEBUG: b2Assert(false);
          return 0;
      }
      /**
       * Implement b2Shape.
       */
      RayCast(output, input, xf, childIndex) {
          // DEBUG: b2Assert(false);
          return false;
      }
      /**
       * @see b2Shape::ComputeAABB
       */
      ComputeAABB(aabb, xf, childIndex) {
          const s_subaabb = new b2AABB();
          aabb.lowerBound.x = +b2_maxFloat;
          aabb.lowerBound.y = +b2_maxFloat;
          aabb.upperBound.x = -b2_maxFloat;
          aabb.upperBound.y = -b2_maxFloat;
          // DEBUG: b2Assert(childIndex === 0);
          for (let i = 0; i < this.m_shapeCount; i++) {
              const childCount = this.m_shapes[i].GetChildCount();
              for (let j = 0; j < childCount; j++) {
                  const subaabb = s_subaabb;
                  this.m_shapes[i].ComputeAABB(subaabb, xf, j);
                  aabb.Combine1(subaabb);
              }
          }
      }
      /**
       * @see b2Shape::ComputeMass
       */
      ComputeMass(massData, density) {
          // DEBUG: b2Assert(false);
      }
      SetupDistanceProxy(proxy, index) {
          // DEBUG: b2Assert(false);
      }
      ComputeSubmergedArea(normal, offset, xf, c) {
          // DEBUG: b2Assert(false);
          return 0;
      }
      Dump(log) {
          // DEBUG: b2Assert(false);
      }
  }
  class b2ParticleSystem_ReactiveFilter extends b2ParticleSystem_ConnectionFilter {
      constructor(flagsBuffer) {
          super();
          this.m_flagsBuffer = flagsBuffer;
      }
      IsNecessary(index) {
          return (this.m_flagsBuffer.data[index] & exports.ParticleFlag.b2_reactiveParticle) !== 0;
      }
  }
  class b2ParticleSystem_UpdateBodyContactsCallback extends b2FixtureParticleQueryCallback {
      constructor(system, contactFilter = null) {
          super(system); // base class constructor
          this.m_contactFilter = null;
          this.m_contactFilter = contactFilter;
      }
      ShouldCollideFixtureParticle(fixture, particleSystem, particleIndex) {
          // Call the contact filter if it's set, to determine whether to
          // filter this contact.  Returns true if contact calculations should
          // be performed, false otherwise.
          if (this.m_contactFilter) {
              const flags = this.m_system.GetFlagsBuffer();
              if (flags[particleIndex] & exports.ParticleFlag.b2_fixtureContactFilterParticle) {
                  return this.m_contactFilter.ShouldCollideFixtureParticle(fixture, this.m_system, particleIndex);
              }
          }
          return true;
      }
      ReportFixtureAndParticle(fixture, childIndex, a) {
          const s_n = b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n;
          const s_rp = b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp;
          const ap = this.m_system.m_positionBuffer.data[a];
          const n = s_n;
          const d = fixture.ComputeDistance(ap, n, childIndex);
          if (d < this.m_system.m_particleDiameter && this.ShouldCollideFixtureParticle(fixture, this.m_system, a)) {
              const b = fixture.GetBody();
              const bp = b.GetWorldCenter();
              const bm = b.GetMass();
              const bI = b.GetInertia() - bm * b.GetLocalCenter().LengthSquared();
              const invBm = bm > 0 ? 1 / bm : 0;
              const invBI = bI > 0 ? 1 / bI : 0;
              const invAm = this.m_system.m_flagsBuffer.data[a] &
                  exports.ParticleFlag.b2_wallParticle ? 0 : this.m_system.GetParticleInvMass();
              ///b2Vec2 rp = ap - bp;
              const rp = b2Vec2.SubVV(ap, bp, s_rp);
              const rpn = b2Vec2.CrossVV(rp, n);
              const invM = invAm + invBm + invBI * rpn * rpn;
              ///b2ParticleBodyContact& contact = m_system.m_bodyContactBuffer.Append();
              const contact = this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];
              contact.index = a;
              contact.body = b;
              contact.fixture = fixture;
              contact.weight = 1 - d * this.m_system.m_inverseDiameter;
              ///contact.normal = -n;
              contact.normal.Copy(n.SelfNeg());
              contact.mass = invM > 0 ? 1 / invM : 0;
              this.m_system.DetectStuckParticle(a);
          }
      }
  }
  b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n = new b2Vec2();
  b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp = new b2Vec2();
  class b2ParticleSystem_SolveCollisionCallback extends b2FixtureParticleQueryCallback {
      constructor(system, step) {
          super(system); // base class constructor
          this.m_step = step;
      }
      ReportFixtureAndParticle(fixture, childIndex, a) {
          const s_p1 = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1;
          const s_output = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output;
          const s_input = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input;
          const s_p = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p;
          const s_v = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v;
          const s_f = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f;
          const body = fixture.GetBody();
          const ap = this.m_system.m_positionBuffer.data[a];
          const av = this.m_system.m_velocityBuffer.data[a];
          const output = s_output;
          const input = s_input;
          if (this.m_system.m_iterationIndex === 0) {
              // Put 'ap' in the local space of the previous frame
              ///b2Vec2 p1 = b2MulT(body.m_xf0, ap);
              const p1 = b2Transform.MulTXV(body.m_xf0, ap, s_p1);
              if (fixture.GetShape().GetType() === exports.ShapeType.e_circleShape) {
                  // Make relative to the center of the circle
                  ///p1 -= body.GetLocalCenter();
                  p1.SelfSub(body.GetLocalCenter());
                  // Re-apply rotation about the center of the circle
                  ///p1 = b2Mul(body.m_xf0.q, p1);
                  b2Rot.MulRV(body.m_xf0.q, p1, p1);
                  // Subtract rotation of the current frame
                  ///p1 = b2MulT(body.m_xf.q, p1);
                  b2Rot.MulTRV(body.m_xf.q, p1, p1);
                  // Return to local space
                  ///p1 += body.GetLocalCenter();
                  p1.SelfAdd(body.GetLocalCenter());
              }
              // Return to global space and apply rotation of current frame
              ///input.p1 = b2Mul(body.m_xf, p1);
              b2Transform.MulXV(body.m_xf, p1, input.p1);
          }
          else {
              ///input.p1 = ap;
              input.p1.Copy(ap);
          }
          ///input.p2 = ap + m_step.dt * av;
          b2Vec2.AddVMulSV(ap, this.m_step.dt, av, input.p2);
          input.maxFraction = 1;
          if (fixture.RayCast(output, input, childIndex)) {
              const n = output.normal;
              ///b2Vec2 p = (1 - output.fraction) * input.p1 + output.fraction * input.p2 + b2_linearSlop * n;
              const p = s_p;
              p.x = (1 - output.fraction) * input.p1.x + output.fraction * input.p2.x + b2_linearSlop * n.x;
              p.y = (1 - output.fraction) * input.p1.y + output.fraction * input.p2.y + b2_linearSlop * n.y;
              ///b2Vec2 v = m_step.inv_dt * (p - ap);
              const v = s_v;
              v.x = this.m_step.inv_dt * (p.x - ap.x);
              v.y = this.m_step.inv_dt * (p.y - ap.y);
              ///m_system.m_velocityBuffer.data[a] = v;
              this.m_system.m_velocityBuffer.data[a].Copy(v);
              ///b2Vec2 f = m_step.inv_dt * m_system.GetParticleMass() * (av - v);
              const f = s_f;
              f.x = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.x - v.x);
              f.y = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.y - v.y);
              this.m_system.ParticleApplyForce(a, f);
          }
      }
      ReportParticle(system, index) {
          return false;
      }
  }
  b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1 = new b2Vec2();
  b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output = new b2RayCastOutput();
  b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input = new b2RayCastInput();
  b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p = new b2Vec2();
  b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v = new b2Vec2();
  b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f = new b2Vec2();
  // #endif

  /*
  * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
  * arising from the use of this software.
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  * 1. The origin of this software must not be misrepresented; you must not
  * claim that you wrote the original software. If you use this software
  * in a product, an acknowledgment in the product documentation would be
  * appreciated but is not required.
  * 2. Altered source versions must be plainly marked as such, and must not be
  * misrepresented as being the original software.
  * 3. This notice may not be removed or altered from any source distribution.
  */
  // #endif
  /// The world class manages all physics entities, dynamic simulation,
  /// and asynchronous queries. The world also contains efficient memory
  /// management facilities.
  class b2World {
      // #endif
      /// Construct a world object.
      /// @param gravity the world gravity vector.
      constructor(gravity) {
          this.m_contactManager = new b2ContactManager();
          this.m_bodyList = null;
          this.m_jointList = null;
          // #if B2_ENABLE_PARTICLE
          this.m_particleSystemList = null;
          // #endif
          this.m_bodyCount = 0;
          this.m_jointCount = 0;
          this.m_gravity = new b2Vec2();
          this.m_allowSleep = true;
          this.m_destructionListener = null;
          this.m_debugDraw = null;
          // This is used to compute the time step ratio to
          // support a variable time step.
          this.m_inv_dt0 = 0;
          this.m_newContacts = false;
          this.m_locked = false;
          this.m_clearForces = true;
          // These are for debugging the solver.
          this.m_warmStarting = true;
          this.m_continuousPhysics = true;
          this.m_subStepping = false;
          this.m_stepComplete = true;
          this.m_profile = new b2Profile();
          this.m_island = new b2Island();
          this.s_stack = [];
          // #if B2_ENABLE_CONTROLLER
          this.m_controllerList = null;
          this.m_controllerCount = 0;
          this.m_gravity.Copy(gravity);
      }
      /// Register a destruction listener. The listener is owned by you and must
      /// remain in scope.
      SetDestructionListener(listener) {
          this.m_destructionListener = listener;
      }
      /// Register a contact filter to provide specific control over collision.
      /// Otherwise the default filter is used (b2_defaultFilter). The listener is
      /// owned by you and must remain in scope.
      SetContactFilter(filter) {
          this.m_contactManager.m_contactFilter = filter;
      }
      /// Register a contact event listener. The listener is owned by you and must
      /// remain in scope.
      SetContactListener(listener) {
          this.m_contactManager.m_contactListener = listener;
      }
      /// Register a routine for debug drawing. The debug draw functions are called
      /// inside with b2World::DebugDraw method. The debug draw object is owned
      /// by you and must remain in scope.
      SetDebugDraw(debugDraw) {
          this.m_debugDraw = debugDraw;
      }
      /// Create a rigid body given a definition. No reference to the definition
      /// is retained.
      /// @warning This function is locked during callbacks.
      CreateBody(def = {}) {
          if (this.IsLocked()) {
              throw new Error();
          }
          const b = new b2Body(def, this);
          // Add to world doubly linked list.
          b.m_prev = null;
          b.m_next = this.m_bodyList;
          if (this.m_bodyList) {
              this.m_bodyList.m_prev = b;
          }
          this.m_bodyList = b;
          ++this.m_bodyCount;
          return b;
      }
      /// Destroy a rigid body given a definition. No reference to the definition
      /// is retained. This function is locked during callbacks.
      /// @warning This automatically deletes all associated shapes and joints.
      /// @warning This function is locked during callbacks.
      DestroyBody(b) {
          // DEBUG: b2Assert(this.m_bodyCount > 0);
          if (this.IsLocked()) {
              throw new Error();
          }
          // Delete the attached joints.
          let je = b.m_jointList;
          while (je) {
              const je0 = je;
              je = je.next;
              if (this.m_destructionListener) {
                  this.m_destructionListener.SayGoodbyeJoint(je0.joint);
              }
              this.DestroyJoint(je0.joint);
              b.m_jointList = je;
          }
          b.m_jointList = null;
          // #if B2_ENABLE_CONTROLLER
          // @see b2Controller list
          let coe = b.m_controllerList;
          while (coe) {
              const coe0 = coe;
              coe = coe.nextController;
              coe0.controller.RemoveBody(b);
          }
          // #endif
          // Delete the attached contacts.
          let ce = b.m_contactList;
          while (ce) {
              const ce0 = ce;
              ce = ce.next;
              this.m_contactManager.Destroy(ce0.contact);
          }
          b.m_contactList = null;
          // Delete the attached fixtures. This destroys broad-phase proxies.
          let f = b.m_fixtureList;
          while (f) {
              const f0 = f;
              f = f.m_next;
              if (this.m_destructionListener) {
                  this.m_destructionListener.SayGoodbyeFixture(f0);
              }
              f0.DestroyProxies();
              f0.Reset();
              b.m_fixtureList = f;
              b.m_fixtureCount -= 1;
          }
          b.m_fixtureList = null;
          b.m_fixtureCount = 0;
          // Remove world body list.
          if (b.m_prev) {
              b.m_prev.m_next = b.m_next;
          }
          if (b.m_next) {
              b.m_next.m_prev = b.m_prev;
          }
          if (b === this.m_bodyList) {
              this.m_bodyList = b.m_next;
          }
          --this.m_bodyCount;
      }
      static _Joint_Create(def) {
          switch (def.type) {
              case exports.JointType.e_distanceJoint: return new b2DistanceJoint(def);
              case exports.JointType.e_mouseJoint: return new b2MouseJoint(def);
              case exports.JointType.e_prismaticJoint: return new b2PrismaticJoint(def);
              case exports.JointType.e_revoluteJoint: return new b2RevoluteJoint(def);
              case exports.JointType.e_pulleyJoint: return new b2PulleyJoint(def);
              case exports.JointType.e_gearJoint: return new b2GearJoint(def);
              case exports.JointType.e_wheelJoint: return new b2WheelJoint(def);
              case exports.JointType.e_weldJoint: return new b2WeldJoint(def);
              case exports.JointType.e_frictionJoint: return new b2FrictionJoint(def);
              case exports.JointType.e_motorJoint: return new b2MotorJoint(def);
              case exports.JointType.e_areaJoint: return new b2AreaJoint(def);
          }
          throw new Error();
      }
      static _Joint_Destroy(joint) {
      }
      CreateJoint(def) {
          if (this.IsLocked()) {
              throw new Error();
          }
          const j = b2World._Joint_Create(def);
          // Connect to the world list.
          j.m_prev = null;
          j.m_next = this.m_jointList;
          if (this.m_jointList) {
              this.m_jointList.m_prev = j;
          }
          this.m_jointList = j;
          ++this.m_jointCount;
          // Connect to the bodies' doubly linked lists.
          // j.m_edgeA.other = j.m_bodyB; // done in b2Joint constructor
          j.m_edgeA.prev = null;
          j.m_edgeA.next = j.m_bodyA.m_jointList;
          if (j.m_bodyA.m_jointList) {
              j.m_bodyA.m_jointList.prev = j.m_edgeA;
          }
          j.m_bodyA.m_jointList = j.m_edgeA;
          // j.m_edgeB.other = j.m_bodyA; // done in b2Joint constructor
          j.m_edgeB.prev = null;
          j.m_edgeB.next = j.m_bodyB.m_jointList;
          if (j.m_bodyB.m_jointList) {
              j.m_bodyB.m_jointList.prev = j.m_edgeB;
          }
          j.m_bodyB.m_jointList = j.m_edgeB;
          const bodyA = j.m_bodyA;
          const bodyB = j.m_bodyB;
          const collideConnected = j.m_collideConnected;
          // If the joint prevents collisions, then flag any contacts for filtering.
          if (!collideConnected) {
              let edge = bodyB.GetContactList();
              while (edge) {
                  if (edge.other === bodyA) {
                      // Flag the contact for filtering at the next time step (where either
                      // body is awake).
                      edge.contact.FlagForFiltering();
                  }
                  edge = edge.next;
              }
          }
          // Note: creating a joint doesn't wake the bodies.
          return j;
      }
      /// Destroy a joint. This may cause the connected bodies to begin colliding.
      /// @warning This function is locked during callbacks.
      DestroyJoint(j) {
          if (this.IsLocked()) {
              throw new Error();
          }
          // Remove from the doubly linked list.
          if (j.m_prev) {
              j.m_prev.m_next = j.m_next;
          }
          if (j.m_next) {
              j.m_next.m_prev = j.m_prev;
          }
          if (j === this.m_jointList) {
              this.m_jointList = j.m_next;
          }
          // Disconnect from island graph.
          const bodyA = j.m_bodyA;
          const bodyB = j.m_bodyB;
          const collideConnected = j.m_collideConnected;
          // Wake up connected bodies.
          bodyA.SetAwake(true);
          bodyB.SetAwake(true);
          // Remove from body 1.
          if (j.m_edgeA.prev) {
              j.m_edgeA.prev.next = j.m_edgeA.next;
          }
          if (j.m_edgeA.next) {
              j.m_edgeA.next.prev = j.m_edgeA.prev;
          }
          if (j.m_edgeA === bodyA.m_jointList) {
              bodyA.m_jointList = j.m_edgeA.next;
          }
          j.m_edgeA.Reset();
          // Remove from body 2
          if (j.m_edgeB.prev) {
              j.m_edgeB.prev.next = j.m_edgeB.next;
          }
          if (j.m_edgeB.next) {
              j.m_edgeB.next.prev = j.m_edgeB.prev;
          }
          if (j.m_edgeB === bodyB.m_jointList) {
              bodyB.m_jointList = j.m_edgeB.next;
          }
          j.m_edgeB.Reset();
          b2World._Joint_Destroy(j);
          // DEBUG: b2Assert(this.m_jointCount > 0);
          --this.m_jointCount;
          // If the joint prevents collisions, then flag any contacts for filtering.
          if (!collideConnected) {
              let edge = bodyB.GetContactList();
              while (edge) {
                  if (edge.other === bodyA) {
                      // Flag the contact for filtering at the next time step (where either
                      // body is awake).
                      edge.contact.FlagForFiltering();
                  }
                  edge = edge.next;
              }
          }
      }
      // #if B2_ENABLE_PARTICLE
      CreateParticleSystem(def) {
          if (this.IsLocked()) {
              throw new Error();
          }
          const p = new b2ParticleSystem(def, this);
          // Add to world doubly linked list.
          p.m_prev = null;
          p.m_next = this.m_particleSystemList;
          if (this.m_particleSystemList) {
              this.m_particleSystemList.m_prev = p;
          }
          this.m_particleSystemList = p;
          return p;
      }
      DestroyParticleSystem(p) {
          if (this.IsLocked()) {
              throw new Error();
          }
          // Remove world particleSystem list.
          if (p.m_prev) {
              p.m_prev.m_next = p.m_next;
          }
          if (p.m_next) {
              p.m_next.m_prev = p.m_prev;
          }
          if (p === this.m_particleSystemList) {
              this.m_particleSystemList = p.m_next;
          }
      }
      CalculateReasonableParticleIterations(timeStep) {
          if (this.m_particleSystemList === null) {
              return 1;
          }
          function GetSmallestRadius(world) {
              let smallestRadius = b2_maxFloat;
              for (let system = world.GetParticleSystemList(); system !== null; system = system.m_next) {
                  smallestRadius = b2Min(smallestRadius, system.GetRadius());
              }
              return smallestRadius;
          }
          // Use the smallest radius, since that represents the worst-case.
          return b2CalculateParticleIterations(this.m_gravity.Length(), GetSmallestRadius(this), timeStep);
      }
      // #if B2_ENABLE_PARTICLE
      Step(dt, velocityIterations, positionIterations, particleIterations = this.CalculateReasonableParticleIterations(dt)) {
          // #else
          // public Step(dt: number, velocityIterations: number, positionIterations: number): void {
          // #endif
          const stepTimer = b2World.Step_s_stepTimer.Reset();
          // If new fixtures were added, we need to find the new contacts.
          if (this.m_newContacts) {
              this.m_contactManager.FindNewContacts();
              this.m_newContacts = false;
          }
          this.m_locked = true;
          const step = b2World.Step_s_step;
          step.dt = dt;
          step.velocityIterations = velocityIterations;
          step.positionIterations = positionIterations;
          // #if B2_ENABLE_PARTICLE
          step.particleIterations = particleIterations;
          // #endif
          if (dt > 0) {
              step.inv_dt = 1 / dt;
          }
          else {
              step.inv_dt = 0;
          }
          step.dtRatio = this.m_inv_dt0 * dt;
          step.warmStarting = this.m_warmStarting;
          // Update contacts. This is where some contacts are destroyed.
          const timer = b2World.Step_s_timer.Reset();
          this.m_contactManager.Collide();
          this.m_profile.collide = timer.GetMilliseconds();
          // Integrate velocities, solve velocity constraints, and integrate positions.
          if (this.m_stepComplete && step.dt > 0) {
              const timer = b2World.Step_s_timer.Reset();
              // #if B2_ENABLE_PARTICLE
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  p.Solve(step); // Particle Simulation
              }
              // #endif
              this.Solve(step);
              this.m_profile.solve = timer.GetMilliseconds();
          }
          // Handle TOI events.
          if (this.m_continuousPhysics && step.dt > 0) {
              const timer = b2World.Step_s_timer.Reset();
              this.SolveTOI(step);
              this.m_profile.solveTOI = timer.GetMilliseconds();
          }
          if (step.dt > 0) {
              this.m_inv_dt0 = step.inv_dt;
          }
          if (this.m_clearForces) {
              this.ClearForces();
          }
          this.m_locked = false;
          this.m_profile.step = stepTimer.GetMilliseconds();
      }
      /// Manually clear the force buffer on all bodies. By default, forces are cleared automatically
      /// after each call to Step. The default behavior is modified by calling SetAutoClearForces.
      /// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain
      /// a fixed sized time step under a variable frame-rate.
      /// When you perform sub-stepping you will disable auto clearing of forces and instead call
      /// ClearForces after all sub-steps are complete in one pass of your game loop.
      /// @see SetAutoClearForces
      ClearForces() {
          for (let body = this.m_bodyList; body; body = body.m_next) {
              body.m_force.SetZero();
              body.m_torque = 0;
          }
      }
      // #if B2_ENABLE_PARTICLE
      DrawParticleSystem(system) {
          if (this.m_debugDraw === null) {
              return;
          }
          const particleCount = system.GetParticleCount();
          if (particleCount) {
              const radius = system.GetRadius();
              const positionBuffer = system.GetPositionBuffer();
              if (system.m_colorBuffer.data) {
                  const colorBuffer = system.GetColorBuffer();
                  this.m_debugDraw.DrawParticles(positionBuffer, radius, colorBuffer, particleCount);
              }
              else {
                  this.m_debugDraw.DrawParticles(positionBuffer, radius, null, particleCount);
              }
          }
      }
      DebugDraw() {
          if (this.m_debugDraw === null) {
              return;
          }
          const flags = this.m_debugDraw.GetFlags();
          const color = b2World.DebugDraw_s_color.SetRGB(0, 0, 0);
          if (flags & exports.DrawFlags.e_shapeBit) {
              for (let b = this.m_bodyList; b; b = b.m_next) {
                  const xf = b.m_xf;
                  this.m_debugDraw.PushTransform(xf);
                  for (let f = b.GetFixtureList(); f; f = f.m_next) {
                      if (b.GetType() === exports.BodyType.b2_dynamicBody && b.m_mass === 0.0) {
                          // Bad body
                          this.DrawShape(f, new b2Color(1.0, 0.0, 0.0));
                      }
                      else if (!b.IsEnabled()) {
                          color.SetRGB(0.5, 0.5, 0.3);
                          this.DrawShape(f, color);
                      }
                      else if (b.GetType() === exports.BodyType.b2_staticBody) {
                          color.SetRGB(0.5, 0.9, 0.5);
                          this.DrawShape(f, color);
                      }
                      else if (b.GetType() === exports.BodyType.b2_kinematicBody) {
                          color.SetRGB(0.5, 0.5, 0.9);
                          this.DrawShape(f, color);
                      }
                      else if (!b.IsAwake()) {
                          color.SetRGB(0.6, 0.6, 0.6);
                          this.DrawShape(f, color);
                      }
                      else {
                          color.SetRGB(0.9, 0.7, 0.7);
                          this.DrawShape(f, color);
                      }
                  }
                  this.m_debugDraw.PopTransform(xf);
              }
          }
          // #if B2_ENABLE_PARTICLE
          if (flags & exports.DrawFlags.e_particleBit) {
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  this.DrawParticleSystem(p);
              }
          }
          // #endif
          if (flags & exports.DrawFlags.e_jointBit) {
              for (let j = this.m_jointList; j; j = j.m_next) {
                  j.Draw(this.m_debugDraw);
              }
          }
          if (flags & exports.DrawFlags.e_pairBit) {
              color.SetRGB(0.3, 0.9, 0.9);
              for (let contact = this.m_contactManager.m_contactList; contact; contact = contact.m_next) {
                  const fixtureA = contact.GetFixtureA();
                  const fixtureB = contact.GetFixtureB();
                  const indexA = contact.GetChildIndexA();
                  const indexB = contact.GetChildIndexB();
                  const cA = fixtureA.GetAABB(indexA).GetCenter();
                  const cB = fixtureB.GetAABB(indexB).GetCenter();
                  this.m_debugDraw.DrawSegment(cA, cB, color);
              }
          }
          if (flags & exports.DrawFlags.e_aabbBit) {
              color.SetRGB(0.9, 0.3, 0.9);
              const vs = b2World.DebugDraw_s_vs;
              for (let b = this.m_bodyList; b; b = b.m_next) {
                  if (!b.IsEnabled()) {
                      continue;
                  }
                  for (let f = b.GetFixtureList(); f; f = f.m_next) {
                      for (let i = 0; i < f.m_proxyCount; ++i) {
                          const proxy = f.m_proxies[i];
                          const aabb = proxy.treeNode.aabb;
                          vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
                          vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
                          vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
                          vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
                          this.m_debugDraw.DrawPolygon(vs, 4, color);
                      }
                  }
              }
          }
          if (flags & exports.DrawFlags.e_centerOfMassBit) {
              for (let b = this.m_bodyList; b; b = b.m_next) {
                  const xf = b2World.DebugDraw_s_xf;
                  xf.q.Copy(b.m_xf.q);
                  xf.p.Copy(b.GetWorldCenter());
                  this.m_debugDraw.DrawTransform(xf);
              }
          }
          // #if B2_ENABLE_CONTROLLER
          // @see b2Controller list
          if (flags & exports.DrawFlags.e_controllerBit) {
              for (let c = this.m_controllerList; c; c = c.m_next) {
                  c.Draw(this.m_debugDraw);
              }
          }
          // #endif
      }
      QueryAABB(...args) {
          if (args[0] instanceof b2QueryCallback) {
              this._QueryAABB(args[0], args[1]);
          }
          else {
              this._QueryAABB(null, args[0], args[1]);
          }
      }
      _QueryAABB(callback, aabb, fn) {
          this.m_contactManager.m_broadPhase.Query(aabb, (proxy) => {
              const fixture_proxy = proxy.userData;
              // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);
              const fixture = fixture_proxy.fixture;
              if (callback) {
                  return callback.ReportFixture(fixture);
              }
              else if (fn) {
                  return fn(fixture);
              }
              return true;
          });
          // #if B2_ENABLE_PARTICLE
          if (callback instanceof b2QueryCallback) {
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  if (callback.ShouldQueryParticleSystem(p)) {
                      p.QueryAABB(callback, aabb);
                  }
              }
          }
          // #endif
      }
      QueryAllAABB(aabb, out = []) {
          this.QueryAABB(aabb, (fixture) => { out.push(fixture); return true; });
          return out;
      }
      QueryPointAABB(...args) {
          if (args[0] instanceof b2QueryCallback) {
              this._QueryPointAABB(args[0], args[1]);
          }
          else {
              this._QueryPointAABB(null, args[0], args[1]);
          }
      }
      _QueryPointAABB(callback, point, fn) {
          this.m_contactManager.m_broadPhase.QueryPoint(point, (proxy) => {
              const fixture_proxy = proxy.userData;
              // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);
              const fixture = fixture_proxy.fixture;
              if (callback) {
                  return callback.ReportFixture(fixture);
              }
              else if (fn) {
                  return fn(fixture);
              }
              return true;
          });
          // #if B2_ENABLE_PARTICLE
          if (callback instanceof b2QueryCallback) {
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  if (callback.ShouldQueryParticleSystem(p)) {
                      p.QueryPointAABB(callback, point);
                  }
              }
          }
          // #endif
      }
      QueryAllPointAABB(point, out = []) {
          this.QueryPointAABB(point, (fixture) => { out.push(fixture); return true; });
          return out;
      }
      QueryFixtureShape(...args) {
          if (args[0] instanceof b2QueryCallback) {
              this._QueryFixtureShape(args[0], args[1], args[2], args[3]);
          }
          else {
              this._QueryFixtureShape(null, args[0], args[1], args[2], args[3]);
          }
      }
      _QueryFixtureShape(callback, shape, index, transform, fn) {
          const aabb = b2World.QueryFixtureShape_s_aabb;
          shape.ComputeAABB(aabb, transform, index);
          this.m_contactManager.m_broadPhase.Query(aabb, (proxy) => {
              const fixture_proxy = proxy.userData;
              // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);
              const fixture = fixture_proxy.fixture;
              if (b2TestOverlapShape(shape, index, fixture.GetShape(), fixture_proxy.childIndex, transform, fixture.GetBody().GetTransform())) {
                  if (callback) {
                      return callback.ReportFixture(fixture);
                  }
                  else if (fn) {
                      return fn(fixture);
                  }
              }
              return true;
          });
          // #if B2_ENABLE_PARTICLE
          if (callback instanceof b2QueryCallback) {
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  if (callback.ShouldQueryParticleSystem(p)) {
                      p.QueryAABB(callback, aabb);
                  }
              }
          }
          // #endif
      }
      QueryAllFixtureShape(shape, index, transform, out = []) {
          this.QueryFixtureShape(shape, index, transform, (fixture) => { out.push(fixture); return true; });
          return out;
      }
      QueryFixturePoint(...args) {
          if (args[0] instanceof b2QueryCallback) {
              this._QueryFixturePoint(args[0], args[1]);
          }
          else {
              this._QueryFixturePoint(null, args[0], args[1]);
          }
      }
      _QueryFixturePoint(callback, point, fn) {
          this.m_contactManager.m_broadPhase.QueryPoint(point, (proxy) => {
              const fixture_proxy = proxy.userData;
              // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);
              const fixture = fixture_proxy.fixture;
              if (fixture.TestPoint(point)) {
                  if (callback) {
                      return callback.ReportFixture(fixture);
                  }
                  else if (fn) {
                      return fn(fixture);
                  }
              }
              return true;
          });
          // #if B2_ENABLE_PARTICLE
          if (callback) {
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  if (callback.ShouldQueryParticleSystem(p)) {
                      p.QueryPointAABB(callback, point);
                  }
              }
          }
          // #endif
      }
      QueryAllFixturePoint(point, out = []) {
          this.QueryFixturePoint(point, (fixture) => { out.push(fixture); return true; });
          return out;
      }
      RayCast(...args) {
          if (args[0] instanceof b2RayCastCallback) {
              this._RayCast(args[0], args[1], args[2]);
          }
          else {
              this._RayCast(null, args[0], args[1], args[2]);
          }
      }
      _RayCast(callback, point1, point2, fn) {
          const input = b2World.RayCast_s_input;
          input.maxFraction = 1;
          input.p1.Copy(point1);
          input.p2.Copy(point2);
          this.m_contactManager.m_broadPhase.RayCast(input, (input, proxy) => {
              const fixture_proxy = proxy.userData;
              // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);
              const fixture = fixture_proxy.fixture;
              const index = fixture_proxy.childIndex;
              const output = b2World.RayCast_s_output;
              const hit = fixture.RayCast(output, input, index);
              if (hit) {
                  const fraction = output.fraction;
                  const point = b2World.RayCast_s_point;
                  point.Set((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
                  if (callback) {
                      return callback.ReportFixture(fixture, point, output.normal, fraction);
                  }
                  else if (fn) {
                      return fn(fixture, point, output.normal, fraction);
                  }
              }
              return input.maxFraction;
          });
          // #if B2_ENABLE_PARTICLE
          if (callback) {
              for (let p = this.m_particleSystemList; p; p = p.m_next) {
                  if (callback.ShouldQueryParticleSystem(p)) {
                      p.RayCast(callback, point1, point2);
                  }
              }
          }
          // #endif
      }
      RayCastOne(point1, point2) {
          let result = null;
          let min_fraction = 1;
          this.RayCast(point1, point2, (fixture, point, normal, fraction) => {
              if (fraction < min_fraction) {
                  min_fraction = fraction;
                  result = fixture;
              }
              return min_fraction;
          });
          return result;
      }
      RayCastAll(point1, point2, out = []) {
          this.RayCast(point1, point2, (fixture, point, normal, fraction) => {
              out.push(fixture);
              return 1;
          });
          return out;
      }
      /// Get the world body list. With the returned body, use b2Body::GetNext to get
      /// the next body in the world list. A NULL body indicates the end of the list.
      /// @return the head of the world body list.
      GetBodyList() {
          return this.m_bodyList;
      }
      /// Get the world joint list. With the returned joint, use b2Joint::GetNext to get
      /// the next joint in the world list. A NULL joint indicates the end of the list.
      /// @return the head of the world joint list.
      GetJointList() {
          return this.m_jointList;
      }
      // #if B2_ENABLE_PARTICLE
      GetParticleSystemList() {
          return this.m_particleSystemList;
      }
      // #endif
      /// Get the world contact list. With the returned contact, use b2Contact::GetNext to get
      /// the next contact in the world list. A NULL contact indicates the end of the list.
      /// @return the head of the world contact list.
      /// @warning contacts are created and destroyed in the middle of a time step.
      /// Use b2ContactListener to avoid missing contacts.
      GetContactList() {
          return this.m_contactManager.m_contactList;
      }
      /// Enable/disable sleep.
      SetAllowSleeping(flag) {
          if (flag === this.m_allowSleep) {
              return;
          }
          this.m_allowSleep = flag;
          if (!this.m_allowSleep) {
              for (let b = this.m_bodyList; b; b = b.m_next) {
                  b.SetAwake(true);
              }
          }
      }
      GetAllowSleeping() {
          return this.m_allowSleep;
      }
      /// Enable/disable warm starting. For testing.
      SetWarmStarting(flag) {
          this.m_warmStarting = flag;
      }
      GetWarmStarting() {
          return this.m_warmStarting;
      }
      /// Enable/disable continuous physics. For testing.
      SetContinuousPhysics(flag) {
          this.m_continuousPhysics = flag;
      }
      GetContinuousPhysics() {
          return this.m_continuousPhysics;
      }
      /// Enable/disable single stepped continuous physics. For testing.
      SetSubStepping(flag) {
          this.m_subStepping = flag;
      }
      GetSubStepping() {
          return this.m_subStepping;
      }
      /// Get the number of broad-phase proxies.
      GetProxyCount() {
          return this.m_contactManager.m_broadPhase.GetProxyCount();
      }
      /// Get the number of bodies.
      GetBodyCount() {
          return this.m_bodyCount;
      }
      /// Get the number of joints.
      GetJointCount() {
          return this.m_jointCount;
      }
      /// Get the number of contacts (each may have 0 or more contact points).
      GetContactCount() {
          return this.m_contactManager.m_contactCount;
      }
      /// Get the height of the dynamic tree.
      GetTreeHeight() {
          return this.m_contactManager.m_broadPhase.GetTreeHeight();
      }
      /// Get the balance of the dynamic tree.
      GetTreeBalance() {
          return this.m_contactManager.m_broadPhase.GetTreeBalance();
      }
      /// Get the quality metric of the dynamic tree. The smaller the better.
      /// The minimum is 1.
      GetTreeQuality() {
          return this.m_contactManager.m_broadPhase.GetTreeQuality();
      }
      /// Change the global gravity vector.
      SetGravity(gravity, wake = true) {
          if (!b2Vec2.IsEqualToV(this.m_gravity, gravity)) {
              this.m_gravity.Copy(gravity);
              if (wake) {
                  for (let b = this.m_bodyList; b; b = b.m_next) {
                      b.SetAwake(true);
                  }
              }
          }
      }
      /// Get the global gravity vector.
      GetGravity() {
          return this.m_gravity;
      }
      /// Is the world locked (in the middle of a time step).
      IsLocked() {
          return this.m_locked;
      }
      /// Set flag to control automatic clearing of forces after each time step.
      SetAutoClearForces(flag) {
          this.m_clearForces = flag;
      }
      /// Get the flag that controls automatic clearing of forces after each time step.
      GetAutoClearForces() {
          return this.m_clearForces;
      }
      /// Shift the world origin. Useful for large worlds.
      /// The body shift formula is: position -= newOrigin
      /// @param newOrigin the new origin with respect to the old origin
      ShiftOrigin(newOrigin) {
          if (this.IsLocked()) {
              throw new Error();
          }
          for (let b = this.m_bodyList; b; b = b.m_next) {
              b.m_xf.p.SelfSub(newOrigin);
              b.m_sweep.c0.SelfSub(newOrigin);
              b.m_sweep.c.SelfSub(newOrigin);
          }
          for (let j = this.m_jointList; j; j = j.m_next) {
              j.ShiftOrigin(newOrigin);
          }
          this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
      }
      /// Get the contact manager for testing.
      GetContactManager() {
          return this.m_contactManager;
      }
      /// Get the current profile.
      GetProfile() {
          return this.m_profile;
      }
      /// Dump the world into the log file.
      /// @warning this should be called outside of a time step.
      Dump(log) {
          if (this.m_locked) {
              return;
          }
          // b2OpenDump("box2d_dump.inl");
          log("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y);
          log("this.m_world.SetGravity(g);\n");
          log("const bodies: b2Body[] = [];\n");
          log("const joints: b2Joint[] = [];\n");
          let i = 0;
          for (let b = this.m_bodyList; b; b = b.m_next) {
              b.m_islandIndex = i;
              b.Dump(log);
              ++i;
          }
          i = 0;
          for (let j = this.m_jointList; j; j = j.m_next) {
              j.m_index = i;
              ++i;
          }
          // First pass on joints, skip gear joints.
          for (let j = this.m_jointList; j; j = j.m_next) {
              if (j.m_type === exports.JointType.e_gearJoint) {
                  continue;
              }
              log("{\n");
              j.Dump(log);
              log("}\n");
          }
          // Second pass on joints, only gear joints.
          for (let j = this.m_jointList; j; j = j.m_next) {
              if (j.m_type !== exports.JointType.e_gearJoint) {
                  continue;
              }
              log("{\n");
              j.Dump(log);
              log("}\n");
          }
          // b2CloseDump();
      }
      DrawShape(fixture, color) {
          if (this.m_debugDraw === null) {
              return;
          }
          const shape = fixture.GetShape();
          this.m_debugDraw.NextShape(fixture.GetUserData()) // SHY ADDED
          switch (shape.m_type) {
              case exports.ShapeType.e_circleShape: {
                  const circle = shape;
                  const center = circle.m_p;
                  const radius = circle.m_radius;
                  const axis = b2Vec2.UNITX;
                  this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
                  break;
              }
              case exports.ShapeType.e_edgeShape: {
                  const edge = shape;
                  const v1 = edge.m_vertex1;
                  const v2 = edge.m_vertex2;
                  this.m_debugDraw.DrawSegment(v1, v2, color);
                  if (edge.m_oneSided === false) {
                      this.m_debugDraw.DrawPoint(v1, 4.0, color);
                      this.m_debugDraw.DrawPoint(v2, 4.0, color);
                  }
                  break;
              }
              case exports.ShapeType.e_chainShape: {
                  const chain = shape;
                  const count = chain.m_count;
                  const vertices = chain.m_vertices;
                  let v1 = vertices[0];
                  for (let i = 1; i < count; ++i) {
                      const v2 = vertices[i];
                      this.m_debugDraw.DrawSegment(v1, v2, color);
                      v1 = v2;
                  }
                  break;
              }
              case exports.ShapeType.e_polygonShape: {
                  const poly = shape;
                  const vertexCount = poly.m_count;
                  const vertices = poly.m_vertices;
                  this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
                  break;
              }
          }
      }
      Solve(step) {
          // #if B2_ENABLE_PARTICLE
          // update previous transforms
          for (let b = this.m_bodyList; b; b = b.m_next) {
              b.m_xf0.Copy(b.m_xf);
          }
          // #endif
          // #if B2_ENABLE_CONTROLLER
          // @see b2Controller list
          for (let controller = this.m_controllerList; controller; controller = controller.m_next) {
              controller.Step(step);
          }
          // #endif
          this.m_profile.solveInit = 0;
          this.m_profile.solveVelocity = 0;
          this.m_profile.solvePosition = 0;
          // Size the island for the worst case.
          const island = this.m_island;
          island.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, this.m_contactManager.m_contactListener);
          // Clear all the island flags.
          for (let b = this.m_bodyList; b; b = b.m_next) {
              b.m_islandFlag = false;
          }
          for (let c = this.m_contactManager.m_contactList; c; c = c.m_next) {
              c.m_islandFlag = false;
          }
          for (let j = this.m_jointList; j; j = j.m_next) {
              j.m_islandFlag = false;
          }
          // Build and simulate all awake islands.
          // DEBUG: const stackSize: number = this.m_bodyCount;
          const stack = this.s_stack;
          for (let seed = this.m_bodyList; seed; seed = seed.m_next) {
              if (seed.m_islandFlag) {
                  continue;
              }
              if (!seed.IsAwake() || !seed.IsEnabled()) {
                  continue;
              }
              // The seed can be dynamic or kinematic.
              if (seed.GetType() === exports.BodyType.b2_staticBody) {
                  continue;
              }
              // Reset island and stack.
              island.Clear();
              let stackCount = 0;
              stack[stackCount++] = seed;
              seed.m_islandFlag = true;
              // Perform a depth first search (DFS) on the constraint graph.
              while (stackCount > 0) {
                  // Grab the next body off the stack and add it to the island.
                  const b = stack[--stackCount];
                  if (!b) {
                      throw new Error();
                  }
                  // DEBUG: b2Assert(b.IsEnabled());
                  island.AddBody(b);
                  // To keep islands as small as possible, we don't
                  // propagate islands across static bodies.
                  if (b.GetType() === exports.BodyType.b2_staticBody) {
                      continue;
                  }
                  // Make sure the body is awake. (without resetting sleep timer).
                  b.m_awakeFlag = true;
                  // Search all contacts connected to this body.
                  for (let ce = b.m_contactList; ce; ce = ce.next) {
                      const contact = ce.contact;
                      // Has this contact already been added to an island?
                      if (contact.m_islandFlag) {
                          continue;
                      }
                      // Is this contact solid and touching?
                      if (!contact.IsEnabled() || !contact.IsTouching()) {
                          continue;
                      }
                      // Skip sensors.
                      const sensorA = contact.m_fixtureA.m_isSensor;
                      const sensorB = contact.m_fixtureB.m_isSensor;
                      if (sensorA || sensorB) {
                          continue;
                      }
                      island.AddContact(contact);
                      contact.m_islandFlag = true;
                      const other = ce.other;
                      // Was the other body already added to this island?
                      if (other.m_islandFlag) {
                          continue;
                      }
                      // DEBUG: b2Assert(stackCount < stackSize);
                      stack[stackCount++] = other;
                      other.m_islandFlag = true;
                  }
                  // Search all joints connect to this body.
                  for (let je = b.m_jointList; je; je = je.next) {
                      if (je.joint.m_islandFlag) {
                          continue;
                      }
                      const other = je.other;
                      // Don't simulate joints connected to disabled bodies.
                      if (!other.IsEnabled()) {
                          continue;
                      }
                      island.AddJoint(je.joint);
                      je.joint.m_islandFlag = true;
                      if (other.m_islandFlag) {
                          continue;
                      }
                      // DEBUG: b2Assert(stackCount < stackSize);
                      stack[stackCount++] = other;
                      other.m_islandFlag = true;
                  }
              }
              const profile = new b2Profile();
              island.Solve(profile, step, this.m_gravity, this.m_allowSleep);
              this.m_profile.solveInit += profile.solveInit;
              this.m_profile.solveVelocity += profile.solveVelocity;
              this.m_profile.solvePosition += profile.solvePosition;
              // Post solve cleanup.
              for (let i = 0; i < island.m_bodyCount; ++i) {
                  // Allow static bodies to participate in other islands.
                  const b = island.m_bodies[i];
                  if (b.GetType() === exports.BodyType.b2_staticBody) {
                      b.m_islandFlag = false;
                  }
              }
          }
          for (let i = 0; i < stack.length; ++i) {
              if (!stack[i]) {
                  break;
              }
              stack[i] = null;
          }
          const timer = new b2Timer();
          // Synchronize fixtures, check for out of range bodies.
          for (let b = this.m_bodyList; b; b = b.m_next) {
              // If a body was not in an island then it did not move.
              if (!b.m_islandFlag) {
                  continue;
              }
              if (b.GetType() === exports.BodyType.b2_staticBody) {
                  continue;
              }
              // Update fixtures (for broad-phase).
              b.SynchronizeFixtures();
          }
          // Look for new contacts.
          this.m_contactManager.FindNewContacts();
          this.m_profile.broadphase = timer.GetMilliseconds();
      }
      SolveTOI(step) {
          const island = this.m_island;
          island.Initialize(2 * b2_maxTOIContacts, b2_maxTOIContacts, 0, this.m_contactManager.m_contactListener);
          if (this.m_stepComplete) {
              for (let b = this.m_bodyList; b; b = b.m_next) {
                  b.m_islandFlag = false;
                  b.m_sweep.alpha0 = 0;
              }
              for (let c = this.m_contactManager.m_contactList; c; c = c.m_next) {
                  // Invalidate TOI
                  c.m_toiFlag = false;
                  c.m_islandFlag = false;
                  c.m_toiCount = 0;
                  c.m_toi = 1;
              }
          }
          // Find TOI events and solve them.
          for (;;) {
              // Find the first TOI.
              let minContact = null;
              let minAlpha = 1;
              for (let c = this.m_contactManager.m_contactList; c; c = c.m_next) {
                  // Is this contact disabled?
                  if (!c.IsEnabled()) {
                      continue;
                  }
                  // Prevent excessive sub-stepping.
                  if (c.m_toiCount > b2_maxSubSteps) {
                      continue;
                  }
                  let alpha = 1;
                  if (c.m_toiFlag) {
                      // This contact has a valid cached TOI.
                      alpha = c.m_toi;
                  }
                  else {
                      const fA = c.GetFixtureA();
                      const fB = c.GetFixtureB();
                      // Is there a sensor?
                      if (fA.IsSensor() || fB.IsSensor()) {
                          continue;
                      }
                      const bA = fA.GetBody();
                      const bB = fB.GetBody();
                      const typeA = bA.m_type;
                      const typeB = bB.m_type;
                      // DEBUG: b2Assert(typeA !== b2BodyType.b2_staticBody || typeB !== b2BodyType.b2_staticBody);
                      const activeA = bA.IsAwake() && typeA !== exports.BodyType.b2_staticBody;
                      const activeB = bB.IsAwake() && typeB !== exports.BodyType.b2_staticBody;
                      // Is at least one body active (awake and dynamic or kinematic)?
                      if (!activeA && !activeB) {
                          continue;
                      }
                      const collideA = bA.IsBullet() || typeA !== exports.BodyType.b2_dynamicBody;
                      const collideB = bB.IsBullet() || typeB !== exports.BodyType.b2_dynamicBody;
                      // Are these two non-bullet dynamic bodies?
                      if (!collideA && !collideB) {
                          continue;
                      }
                      // Compute the TOI for this contact.
                      // Put the sweeps onto the same time interval.
                      let alpha0 = bA.m_sweep.alpha0;
                      if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                          alpha0 = bB.m_sweep.alpha0;
                          bA.m_sweep.Advance(alpha0);
                      }
                      else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                          alpha0 = bA.m_sweep.alpha0;
                          bB.m_sweep.Advance(alpha0);
                      }
                      // DEBUG: b2Assert(alpha0 < 1);
                      const indexA = c.GetChildIndexA();
                      const indexB = c.GetChildIndexB();
                      // Compute the time of impact in interval [0, minTOI]
                      const input = b2World.SolveTOI_s_toi_input;
                      input.proxyA.SetShape(fA.GetShape(), indexA);
                      input.proxyB.SetShape(fB.GetShape(), indexB);
                      input.sweepA.Copy(bA.m_sweep);
                      input.sweepB.Copy(bB.m_sweep);
                      input.tMax = 1;
                      const output = b2World.SolveTOI_s_toi_output;
                      b2TimeOfImpact(output, input);
                      // Beta is the fraction of the remaining portion of the .
                      const beta = output.t;
                      if (output.state === exports.TOIOutputState.e_touching) {
                          alpha = b2Min(alpha0 + (1 - alpha0) * beta, 1);
                      }
                      else {
                          alpha = 1;
                      }
                      c.m_toi = alpha;
                      c.m_toiFlag = true;
                  }
                  if (alpha < minAlpha) {
                      // This is the minimum TOI found so far.
                      minContact = c;
                      minAlpha = alpha;
                  }
              }
              if (minContact === null || 1 - 10 * b2_epsilon < minAlpha) {
                  // No more TOI events. Done!
                  this.m_stepComplete = true;
                  break;
              }
              // Advance the bodies to the TOI.
              const fA = minContact.GetFixtureA();
              const fB = minContact.GetFixtureB();
              const bA = fA.GetBody();
              const bB = fB.GetBody();
              const backup1 = b2World.SolveTOI_s_backup1.Copy(bA.m_sweep);
              const backup2 = b2World.SolveTOI_s_backup2.Copy(bB.m_sweep);
              bA.Advance(minAlpha);
              bB.Advance(minAlpha);
              // The TOI contact likely has some new contact points.
              minContact.Update(this.m_contactManager.m_contactListener);
              minContact.m_toiFlag = false;
              ++minContact.m_toiCount;
              // Is the contact solid?
              if (!minContact.IsEnabled() || !minContact.IsTouching()) {
                  // Restore the sweeps.
                  minContact.SetEnabled(false);
                  bA.m_sweep.Copy(backup1);
                  bB.m_sweep.Copy(backup2);
                  bA.SynchronizeTransform();
                  bB.SynchronizeTransform();
                  continue;
              }
              bA.SetAwake(true);
              bB.SetAwake(true);
              // Build the island
              island.Clear();
              island.AddBody(bA);
              island.AddBody(bB);
              island.AddContact(minContact);
              bA.m_islandFlag = true;
              bB.m_islandFlag = true;
              minContact.m_islandFlag = true;
              // Get contacts on bodyA and bodyB.
              // const bodies: b2Body[] = [bA, bB];
              for (let i = 0; i < 2; ++i) {
                  const body = (i === 0) ? (bA) : (bB); // bodies[i];
                  if (body.m_type === exports.BodyType.b2_dynamicBody) {
                      for (let ce = body.m_contactList; ce; ce = ce.next) {
                          if (island.m_bodyCount === island.m_bodyCapacity) {
                              break;
                          }
                          if (island.m_contactCount === island.m_contactCapacity) {
                              break;
                          }
                          const contact = ce.contact;
                          // Has this contact already been added to the island?
                          if (contact.m_islandFlag) {
                              continue;
                          }
                          // Only add static, kinematic, or bullet bodies.
                          const other = ce.other;
                          if (other.m_type === exports.BodyType.b2_dynamicBody &&
                              !body.IsBullet() && !other.IsBullet()) {
                              continue;
                          }
                          // Skip sensors.
                          const sensorA = contact.m_fixtureA.m_isSensor;
                          const sensorB = contact.m_fixtureB.m_isSensor;
                          if (sensorA || sensorB) {
                              continue;
                          }
                          // Tentatively advance the body to the TOI.
                          const backup = b2World.SolveTOI_s_backup.Copy(other.m_sweep);
                          if (!other.m_islandFlag) {
                              other.Advance(minAlpha);
                          }
                          // Update the contact points
                          contact.Update(this.m_contactManager.m_contactListener);
                          // Was the contact disabled by the user?
                          if (!contact.IsEnabled()) {
                              other.m_sweep.Copy(backup);
                              other.SynchronizeTransform();
                              continue;
                          }
                          // Are there contact points?
                          if (!contact.IsTouching()) {
                              other.m_sweep.Copy(backup);
                              other.SynchronizeTransform();
                              continue;
                          }
                          // Add the contact to the island
                          contact.m_islandFlag = true;
                          island.AddContact(contact);
                          // Has the other body already been added to the island?
                          if (other.m_islandFlag) {
                              continue;
                          }
                          // Add the other body to the island.
                          other.m_islandFlag = true;
                          if (other.m_type !== exports.BodyType.b2_staticBody) {
                              other.SetAwake(true);
                          }
                          island.AddBody(other);
                      }
                  }
              }
              const subStep = b2World.SolveTOI_s_subStep;
              subStep.dt = (1 - minAlpha) * step.dt;
              subStep.inv_dt = 1 / subStep.dt;
              subStep.dtRatio = 1;
              subStep.positionIterations = 20;
              subStep.velocityIterations = step.velocityIterations;
              // #if B2_ENABLE_PARTICLE
              subStep.particleIterations = step.particleIterations;
              // #endif
              subStep.warmStarting = false;
              island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);
              // Reset island flags and synchronize broad-phase proxies.
              for (let i = 0; i < island.m_bodyCount; ++i) {
                  const body = island.m_bodies[i];
                  body.m_islandFlag = false;
                  if (body.m_type !== exports.BodyType.b2_dynamicBody) {
                      continue;
                  }
                  body.SynchronizeFixtures();
                  // Invalidate all contact TOIs on this displaced body.
                  for (let ce = body.m_contactList; ce; ce = ce.next) {
                      ce.contact.m_toiFlag = false;
                      ce.contact.m_islandFlag = false;
                  }
              }
              // Commit fixture proxy movements to the broad-phase so that new contacts are created.
              // Also, some contacts can be destroyed.
              this.m_contactManager.FindNewContacts();
              if (this.m_subStepping) {
                  this.m_stepComplete = false;
                  break;
              }
          }
      }
      // #if B2_ENABLE_CONTROLLER
      AddController(controller) {
          // b2Assert(controller.m_world === null, "Controller can only be a member of one world");
          // controller.m_world = this;
          controller.m_next = this.m_controllerList;
          controller.m_prev = null;
          if (this.m_controllerList) {
              this.m_controllerList.m_prev = controller;
          }
          this.m_controllerList = controller;
          ++this.m_controllerCount;
          return controller;
      }
      RemoveController(controller) {
          // b2Assert(controller.m_world === this, "Controller is not a member of this world");
          if (controller.m_prev) {
              controller.m_prev.m_next = controller.m_next;
          }
          if (controller.m_next) {
              controller.m_next.m_prev = controller.m_prev;
          }
          if (this.m_controllerList === controller) {
              this.m_controllerList = controller.m_next;
          }
          --this.m_controllerCount;
          controller.m_prev = null;
          controller.m_next = null;
          // delete controller.m_world; // = null;
          return controller;
      }
  }
  // #endif
  /// Take a time step. This performs collision detection, integration,
  /// and constraint solution.
  /// @param timeStep the amount of time to simulate, this should not vary.
  /// @param velocityIterations for the velocity constraint solver.
  /// @param positionIterations for the position constraint solver.
  b2World.Step_s_step = new b2TimeStep();
  b2World.Step_s_stepTimer = new b2Timer();
  b2World.Step_s_timer = new b2Timer();
  // #endif
  /// Call this to draw shapes and other debug draw data.
  b2World.DebugDraw_s_color = new b2Color(0, 0, 0);
  b2World.DebugDraw_s_vs = b2Vec2.MakeArray(4);
  b2World.DebugDraw_s_xf = new b2Transform();
  b2World.QueryFixtureShape_s_aabb = new b2AABB();
  b2World.RayCast_s_input = new b2RayCastInput();
  b2World.RayCast_s_output = new b2RayCastOutput();
  b2World.RayCast_s_point = new b2Vec2();
  b2World.SolveTOI_s_subStep = new b2TimeStep();
  b2World.SolveTOI_s_backup = new b2Sweep();
  b2World.SolveTOI_s_backup1 = new b2Sweep();
  b2World.SolveTOI_s_backup2 = new b2Sweep();
  b2World.SolveTOI_s_toi_input = new b2TOIInput();
  b2World.SolveTOI_s_toi_output = new b2TOIOutput();

  // MIT License
  (function (b2StretchingModel) {
      b2StretchingModel[b2StretchingModel["b2_pbdStretchingModel"] = 0] = "b2_pbdStretchingModel";
      b2StretchingModel[b2StretchingModel["b2_xpbdStretchingModel"] = 1] = "b2_xpbdStretchingModel";
  })(exports.StretchingModel || (exports.StretchingModel = {}));
  (function (b2BendingModel) {
      b2BendingModel[b2BendingModel["b2_springAngleBendingModel"] = 0] = "b2_springAngleBendingModel";
      b2BendingModel[b2BendingModel["b2_pbdAngleBendingModel"] = 1] = "b2_pbdAngleBendingModel";
      b2BendingModel[b2BendingModel["b2_xpbdAngleBendingModel"] = 2] = "b2_xpbdAngleBendingModel";
      b2BendingModel[b2BendingModel["b2_pbdDistanceBendingModel"] = 3] = "b2_pbdDistanceBendingModel";
      b2BendingModel[b2BendingModel["b2_pbdHeightBendingModel"] = 4] = "b2_pbdHeightBendingModel";
      b2BendingModel[b2BendingModel["b2_pbdTriangleBendingModel"] = 5] = "b2_pbdTriangleBendingModel";
  })(exports.BendingModel || (exports.BendingModel = {}));
  ///
  class b2RopeTuning {
      constructor() {
          this.stretchingModel = exports.StretchingModel.b2_pbdStretchingModel;
          this.bendingModel = exports.BendingModel.b2_pbdAngleBendingModel;
          this.damping = 0.0;
          this.stretchStiffness = 1.0;
          this.stretchHertz = 0.0;
          this.stretchDamping = 0.0;
          this.bendStiffness = 0.5;
          this.bendHertz = 1.0;
          this.bendDamping = 0.0;
          this.isometric = false;
          this.fixedEffectiveMass = false;
          this.warmStart = false;
      }
      Copy(other) {
          this.stretchingModel = other.stretchingModel;
          this.bendingModel = other.bendingModel;
          this.damping = other.damping;
          this.stretchStiffness = other.stretchStiffness;
          this.stretchHertz = other.stretchHertz;
          this.stretchDamping = other.stretchDamping;
          this.bendStiffness = other.bendStiffness;
          this.bendHertz = other.bendHertz;
          this.bendDamping = other.bendDamping;
          this.isometric = other.isometric;
          this.fixedEffectiveMass = other.fixedEffectiveMass;
          this.warmStart = other.warmStart;
          return this;
      }
  }
  ///
  class b2RopeDef {
      constructor() {
          this.position = new b2Vec2();
          // b2Vec2* vertices;
          this.vertices = [];
          // int32 count;
          this.count = 0;
          // float* masses;
          this.masses = [];
          // b2Vec2 gravity;
          this.gravity = new b2Vec2();
          // b2RopeTuning tuning;
          this.tuning = new b2RopeTuning();
      }
  }
  class b2RopeStretch {
      constructor() {
          this.i1 = 0;
          this.i2 = 0;
          this.invMass1 = 0.0;
          this.invMass2 = 0.0;
          this.L = 0.0;
          this.lambda = 0.0;
          this.spring = 0.0;
          this.damper = 0.0;
      }
  }
  class b2RopeBend {
      constructor() {
          this.i1 = 0;
          this.i2 = 0;
          this.i3 = 0;
          this.invMass1 = 0.0;
          this.invMass2 = 0.0;
          this.invMass3 = 0.0;
          this.invEffectiveMass = 0.0;
          this.lambda = 0.0;
          this.L1 = 0.0;
          this.L2 = 0.0;
          this.alpha1 = 0.0;
          this.alpha2 = 0.0;
          this.spring = 0.0;
          this.damper = 0.0;
      }
  }
  ///
  class b2Rope {
      constructor() {
          this.m_position = new b2Vec2();
          this.m_count = 0;
          this.m_stretchCount = 0;
          this.m_bendCount = 0;
          // b2RopeStretch* m_stretchConstraints;
          this.m_stretchConstraints = [];
          // b2RopeBend* m_bendConstraints;
          this.m_bendConstraints = [];
          // b2Vec2* m_bindPositions;
          this.m_bindPositions = [];
          // b2Vec2* m_ps;
          this.m_ps = [];
          // b2Vec2* m_p0s;
          this.m_p0s = [];
          // b2Vec2* m_vs;
          this.m_vs = [];
          // float* m_invMasses;
          this.m_invMasses = [];
          // b2Vec2 m_gravity;
          this.m_gravity = new b2Vec2();
          this.m_tuning = new b2RopeTuning();
      }
      Create(def) {
          // b2Assert(def.count >= 3);
          this.m_position.Copy(def.position);
          this.m_count = def.count;
          function make_array(array, count, make) {
              for (let index = 0; index < count; ++index) {
                  array[index] = make(index);
              }
          }
          // this.m_bindPositions = (b2Vec2*)b2Alloc(this.m_count * sizeof(b2Vec2));
          make_array(this.m_bindPositions, this.m_count, () => new b2Vec2());
          // this.m_ps = (b2Vec2*)b2Alloc(this.m_count * sizeof(b2Vec2));
          make_array(this.m_ps, this.m_count, () => new b2Vec2());
          // this.m_p0s = (b2Vec2*)b2Alloc(this.m_count * sizeof(b2Vec2));
          make_array(this.m_p0s, this.m_count, () => new b2Vec2());
          // this.m_vs = (b2Vec2*)b2Alloc(this.m_count * sizeof(b2Vec2));
          make_array(this.m_vs, this.m_count, () => new b2Vec2());
          // this.m_invMasses = (float*)b2Alloc(this.m_count * sizeof(float));
          make_array(this.m_invMasses, this.m_count, () => 0.0);
          for (let i = 0; i < this.m_count; ++i) {
              this.m_bindPositions[i].Copy(def.vertices[i]);
              // this.m_ps[i] = def.vertices[i] + this.m_position;
              this.m_ps[i].Copy(def.vertices[i]).SelfAdd(this.m_position);
              // this.m_p0s[i] = def.vertices[i] + this.m_position;
              this.m_p0s[i].Copy(def.vertices[i]).SelfAdd(this.m_position);
              this.m_vs[i].SetZero();
              const m = def.masses[i];
              if (m > 0.0) {
                  this.m_invMasses[i] = 1.0 / m;
              }
              else {
                  this.m_invMasses[i] = 0.0;
              }
          }
          this.m_stretchCount = this.m_count - 1;
          this.m_bendCount = this.m_count - 2;
          // this.m_stretchConstraints = (b2RopeStretch*)b2Alloc(this.m_stretchCount * sizeof(b2RopeStretch));
          make_array(this.m_stretchConstraints, this.m_stretchCount, () => new b2RopeStretch());
          // this.m_bendConstraints = (b2RopeBend*)b2Alloc(this.m_bendCount * sizeof(b2RopeBend));
          make_array(this.m_bendConstraints, this.m_bendCount, () => new b2RopeBend());
          for (let i = 0; i < this.m_stretchCount; ++i) {
              const c = this.m_stretchConstraints[i];
              const p1 = this.m_ps[i];
              const p2 = this.m_ps[i + 1];
              c.i1 = i;
              c.i2 = i + 1;
              c.L = b2Vec2.DistanceVV(p1, p2);
              c.invMass1 = this.m_invMasses[i];
              c.invMass2 = this.m_invMasses[i + 1];
              c.lambda = 0.0;
              c.damper = 0.0;
              c.spring = 0.0;
          }
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const p1 = this.m_ps[i];
              const p2 = this.m_ps[i + 1];
              const p3 = this.m_ps[i + 2];
              c.i1 = i;
              c.i2 = i + 1;
              c.i3 = i + 2;
              c.invMass1 = this.m_invMasses[i];
              c.invMass2 = this.m_invMasses[i + 1];
              c.invMass3 = this.m_invMasses[i + 2];
              c.invEffectiveMass = 0.0;
              c.L1 = b2Vec2.DistanceVV(p1, p2);
              c.L2 = b2Vec2.DistanceVV(p2, p3);
              c.lambda = 0.0;
              // Pre-compute effective mass (TODO use flattened config)
              const e1 = b2Vec2.SubVV(p2, p1, new b2Vec2());
              const e2 = b2Vec2.SubVV(p3, p2, new b2Vec2());
              const L1sqr = e1.LengthSquared();
              const L2sqr = e2.LengthSquared();
              if (L1sqr * L2sqr === 0.0) {
                  continue;
              }
              // b2Vec2 Jd1 = (-1.0 / L1sqr) * e1.Skew();
              const Jd1 = new b2Vec2().Copy(e1).SelfSkew().SelfMul(-1.0 / L1sqr);
              // b2Vec2 Jd2 = (1.0 / L2sqr) * e2.Skew();
              const Jd2 = new b2Vec2().Copy(e2).SelfSkew().SelfMul(1.0 / L2sqr);
              // b2Vec2 J1 = -Jd1;
              const J1 = Jd1.Clone().SelfNeg();
              // b2Vec2 J2 = Jd1 - Jd2;
              const J2 = Jd1.Clone().SelfSub(Jd2);
              // b2Vec2 J3 = Jd2;
              const J3 = Jd2.Clone();
              c.invEffectiveMass = c.invMass1 * b2Vec2.DotVV(J1, J1) + c.invMass2 * b2Vec2.DotVV(J2, J2) + c.invMass3 * b2Vec2.DotVV(J3, J3);
              // b2Vec2 r = p3 - p1;
              const r = b2Vec2.SubVV(p3, p1, new b2Vec2());
              const rr = r.LengthSquared();
              if (rr === 0.0) {
                  continue;
              }
              // a1 = h2 / (h1 + h2)
              // a2 = h1 / (h1 + h2)
              c.alpha1 = b2Vec2.DotVV(e2, r) / rr;
              c.alpha2 = b2Vec2.DotVV(e1, r) / rr;
          }
          this.m_gravity.Copy(def.gravity);
          this.SetTuning(def.tuning);
      }
      SetTuning(tuning) {
          this.m_tuning.Copy(tuning);
          // Pre-compute spring and damper values based on tuning
          const bendOmega = 2.0 * b2_pi * this.m_tuning.bendHertz;
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const L1sqr = c.L1 * c.L1;
              const L2sqr = c.L2 * c.L2;
              if (L1sqr * L2sqr === 0.0) {
                  c.spring = 0.0;
                  c.damper = 0.0;
                  continue;
              }
              // Flatten the triangle formed by the two edges
              const J2 = 1.0 / c.L1 + 1.0 / c.L2;
              const sum = c.invMass1 / L1sqr + c.invMass2 * J2 * J2 + c.invMass3 / L2sqr;
              if (sum === 0.0) {
                  c.spring = 0.0;
                  c.damper = 0.0;
                  continue;
              }
              const mass = 1.0 / sum;
              c.spring = mass * bendOmega * bendOmega;
              c.damper = 2.0 * mass * this.m_tuning.bendDamping * bendOmega;
          }
          const stretchOmega = 2.0 * b2_pi * this.m_tuning.stretchHertz;
          for (let i = 0; i < this.m_stretchCount; ++i) {
              const c = this.m_stretchConstraints[i];
              const sum = c.invMass1 + c.invMass2;
              if (sum === 0.0) {
                  continue;
              }
              const mass = 1.0 / sum;
              c.spring = mass * stretchOmega * stretchOmega;
              c.damper = 2.0 * mass * this.m_tuning.stretchDamping * stretchOmega;
          }
      }
      Step(dt, iterations, position) {
          if (dt === 0.0) {
              return;
          }
          const inv_dt = 1.0 / dt;
          const d = Math.exp(-dt * this.m_tuning.damping);
          // Apply gravity and damping
          for (let i = 0; i < this.m_count; ++i) {
              if (this.m_invMasses[i] > 0.0) {
                  // this.m_vs[i] *= d;
                  this.m_vs[i].x *= d;
                  this.m_vs[i].y *= d;
                  // this.m_vs[i] += dt * this.m_gravity;
                  this.m_vs[i].x += dt * this.m_gravity.x;
                  this.m_vs[i].y += dt * this.m_gravity.y;
              }
              else {
                  // this.m_vs[i] = inv_dt * (this.m_bindPositions[i] + position - this.m_p0s[i]);
                  this.m_vs[i].x = inv_dt * (this.m_bindPositions[i].x + position.x - this.m_p0s[i].x);
                  this.m_vs[i].y = inv_dt * (this.m_bindPositions[i].y + position.y - this.m_p0s[i].y);
              }
          }
          // Apply bending spring
          if (this.m_tuning.bendingModel === exports.BendingModel.b2_springAngleBendingModel) {
              this.ApplyBendForces(dt);
          }
          for (let i = 0; i < this.m_bendCount; ++i) {
              this.m_bendConstraints[i].lambda = 0.0;
          }
          for (let i = 0; i < this.m_stretchCount; ++i) {
              this.m_stretchConstraints[i].lambda = 0.0;
          }
          // Update position
          for (let i = 0; i < this.m_count; ++i) {
              // this.m_ps[i] += dt * this.m_vs[i];
              this.m_ps[i].x += dt * this.m_vs[i].x;
              this.m_ps[i].y += dt * this.m_vs[i].y;
          }
          // Solve constraints
          for (let i = 0; i < iterations; ++i) {
              if (this.m_tuning.bendingModel === exports.BendingModel.b2_pbdAngleBendingModel) {
                  this.SolveBend_PBD_Angle();
              }
              else if (this.m_tuning.bendingModel === exports.BendingModel.b2_xpbdAngleBendingModel) {
                  this.SolveBend_XPBD_Angle(dt);
              }
              else if (this.m_tuning.bendingModel === exports.BendingModel.b2_pbdDistanceBendingModel) {
                  this.SolveBend_PBD_Distance();
              }
              else if (this.m_tuning.bendingModel === exports.BendingModel.b2_pbdHeightBendingModel) {
                  this.SolveBend_PBD_Height();
              }
              else if (this.m_tuning.bendingModel === exports.BendingModel.b2_pbdTriangleBendingModel) {
                  this.SolveBend_PBD_Triangle();
              }
              if (this.m_tuning.stretchingModel === exports.StretchingModel.b2_pbdStretchingModel) {
                  this.SolveStretch_PBD();
              }
              else if (this.m_tuning.stretchingModel === exports.StretchingModel.b2_xpbdStretchingModel) {
                  this.SolveStretch_XPBD(dt);
              }
          }
          // Constrain velocity
          for (let i = 0; i < this.m_count; ++i) {
              // this.m_vs[i] = inv_dt * (this.m_ps[i] - this.m_p0s[i]);
              this.m_vs[i].x = inv_dt * (this.m_ps[i].x - this.m_p0s[i].x);
              this.m_vs[i].y = inv_dt * (this.m_ps[i].y - this.m_p0s[i].y);
              this.m_p0s[i].Copy(this.m_ps[i]);
          }
      }
      Reset(position) {
          this.m_position.Copy(position);
          for (let i = 0; i < this.m_count; ++i) {
              // this.m_ps[i] = this.m_bindPositions[i] + this.m_position;
              this.m_ps[i].x = this.m_bindPositions[i].x + this.m_position.x;
              this.m_ps[i].y = this.m_bindPositions[i].y + this.m_position.y;
              // this.m_p0s[i] = this.m_bindPositions[i] + this.m_position;
              this.m_p0s[i].x = this.m_bindPositions[i].x + this.m_position.x;
              this.m_p0s[i].y = this.m_bindPositions[i].y + this.m_position.y;
              this.m_vs[i].SetZero();
          }
          for (let i = 0; i < this.m_bendCount; ++i) {
              this.m_bendConstraints[i].lambda = 0.0;
          }
          for (let i = 0; i < this.m_stretchCount; ++i) {
              this.m_stretchConstraints[i].lambda = 0.0;
          }
      }
      Draw(draw) {
          const c = new b2Color(0.4, 0.5, 0.7);
          const pg = new b2Color(0.1, 0.8, 0.1);
          const pd = new b2Color(0.7, 0.2, 0.4);
          for (let i = 0; i < this.m_count - 1; ++i) {
              draw.DrawSegment(this.m_ps[i], this.m_ps[i + 1], c);
              const pc = this.m_invMasses[i] > 0.0 ? pd : pg;
              draw.DrawPoint(this.m_ps[i], 5.0, pc);
          }
          const pc = this.m_invMasses[this.m_count - 1] > 0.0 ? pd : pg;
          draw.DrawPoint(this.m_ps[this.m_count - 1], 5.0, pc);
      }
      SolveStretch_PBD() {
          const stiffness = this.m_tuning.stretchStiffness;
          for (let i = 0; i < this.m_stretchCount; ++i) {
              const c = this.m_stretchConstraints[i];
              const p1 = this.m_ps[c.i1].Clone();
              const p2 = this.m_ps[c.i2].Clone();
              // b2Vec2 d = p2 - p1;
              const d = p2.Clone().SelfSub(p1);
              const L = d.Normalize();
              const sum = c.invMass1 + c.invMass2;
              if (sum === 0.0) {
                  continue;
              }
              const s1 = c.invMass1 / sum;
              const s2 = c.invMass2 / sum;
              // p1 -= stiffness * s1 * (c.L - L) * d;
              p1.x -= stiffness * s1 * (c.L - L) * d.x;
              p1.y -= stiffness * s1 * (c.L - L) * d.y;
              // p2 += stiffness * s2 * (c.L - L) * d;
              p2.x += stiffness * s2 * (c.L - L) * d.x;
              p2.y += stiffness * s2 * (c.L - L) * d.y;
              this.m_ps[c.i1].Copy(p1);
              this.m_ps[c.i2].Copy(p2);
          }
      }
      SolveStretch_XPBD(dt) {
          // 	b2Assert(dt > 0.0);
          for (let i = 0; i < this.m_stretchCount; ++i) {
              const c = this.m_stretchConstraints[i];
              const p1 = this.m_ps[c.i1].Clone();
              const p2 = this.m_ps[c.i2].Clone();
              const dp1 = p1.Clone().SelfSub(this.m_p0s[c.i1]);
              const dp2 = p2.Clone().SelfSub(this.m_p0s[c.i2]);
              // b2Vec2 u = p2 - p1;
              const u = p2.Clone().SelfSub(p1);
              const L = u.Normalize();
              // b2Vec2 J1 = -u;
              const J1 = u.Clone().SelfNeg();
              // b2Vec2 J2 = u;
              const J2 = u;
              const sum = c.invMass1 + c.invMass2;
              if (sum === 0.0) {
                  continue;
              }
              const alpha = 1.0 / (c.spring * dt * dt); // 1 / kg
              const beta = dt * dt * c.damper; // kg * s
              const sigma = alpha * beta / dt; // non-dimensional
              const C = L - c.L;
              // This is using the initial velocities
              const Cdot = b2Vec2.DotVV(J1, dp1) + b2Vec2.DotVV(J2, dp2);
              const B = C + alpha * c.lambda + sigma * Cdot;
              const sum2 = (1.0 + sigma) * sum + alpha;
              const impulse = -B / sum2;
              // p1 += (c.invMass1 * impulse) * J1;
              p1.x += (c.invMass1 * impulse) * J1.x;
              p1.y += (c.invMass1 * impulse) * J1.y;
              // p2 += (c.invMass2 * impulse) * J2;
              p2.x += (c.invMass2 * impulse) * J2.x;
              p2.y += (c.invMass2 * impulse) * J2.y;
              this.m_ps[c.i1].Copy(p1);
              this.m_ps[c.i2].Copy(p2);
              c.lambda += impulse;
          }
      }
      SolveBend_PBD_Angle() {
          const stiffness = this.m_tuning.bendStiffness;
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const p1 = this.m_ps[c.i1];
              const p2 = this.m_ps[c.i2];
              const p3 = this.m_ps[c.i3];
              // b2Vec2 d1 = p2 - p1;
              const d1 = p2.Clone().SelfSub(p1);
              // b2Vec2 d2 = p3 - p2;
              const d2 = p3.Clone().SelfSub(p2);
              const a = b2Vec2.CrossVV(d1, d2);
              const b = b2Vec2.DotVV(d1, d2);
              const angle = b2Atan2(a, b);
              let L1sqr = 0.0, L2sqr = 0.0;
              if (this.m_tuning.isometric) {
                  L1sqr = c.L1 * c.L1;
                  L2sqr = c.L2 * c.L2;
              }
              else {
                  L1sqr = d1.LengthSquared();
                  L2sqr = d2.LengthSquared();
              }
              if (L1sqr * L2sqr === 0.0) {
                  continue;
              }
              // b2Vec2 Jd1 = (-1.0 / L1sqr) * d1.Skew();
              const Jd1 = new b2Vec2().Copy(d1).SelfSkew().SelfMul(-1.0 / L1sqr);
              // b2Vec2 Jd2 = (1.0 / L2sqr) * d2.Skew();
              const Jd2 = new b2Vec2().Copy(d2).SelfSkew().SelfMul(1.0 / L2sqr);
              // b2Vec2 J1 = -Jd1;
              const J1 = Jd1.Clone().SelfNeg();
              // b2Vec2 J2 = Jd1 - Jd2;
              const J2 = Jd1.Clone().SelfSub(Jd2);
              // b2Vec2 J3 = Jd2;
              const J3 = Jd2;
              let sum = 0.0;
              if (this.m_tuning.fixedEffectiveMass) {
                  sum = c.invEffectiveMass;
              }
              else {
                  sum = c.invMass1 * b2Vec2.DotVV(J1, J1) + c.invMass2 * b2Vec2.DotVV(J2, J2) + c.invMass3 * b2Vec2.DotVV(J3, J3);
              }
              if (sum === 0.0) {
                  sum = c.invEffectiveMass;
              }
              const impulse = -stiffness * angle / sum;
              // p1 += (c.invMass1 * impulse) * J1;
              p1.x += (c.invMass1 * impulse) * J1.x;
              p1.y += (c.invMass1 * impulse) * J1.y;
              // p2 += (c.invMass2 * impulse) * J2;
              p2.x += (c.invMass2 * impulse) * J2.x;
              p2.y += (c.invMass2 * impulse) * J2.y;
              // p3 += (c.invMass3 * impulse) * J3;
              p3.x += (c.invMass3 * impulse) * J3.x;
              p3.y += (c.invMass3 * impulse) * J3.y;
              this.m_ps[c.i1].Copy(p1);
              this.m_ps[c.i2].Copy(p2);
              this.m_ps[c.i3].Copy(p3);
          }
      }
      SolveBend_XPBD_Angle(dt) {
          // b2Assert(dt > 0.0);
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const p1 = this.m_ps[c.i1];
              const p2 = this.m_ps[c.i2];
              const p3 = this.m_ps[c.i3];
              const dp1 = p1.Clone().SelfSub(this.m_p0s[c.i1]);
              const dp2 = p2.Clone().SelfSub(this.m_p0s[c.i2]);
              const dp3 = p3.Clone().SelfSub(this.m_p0s[c.i3]);
              // b2Vec2 d1 = p2 - p1;
              const d1 = p2.Clone().SelfSub(p1);
              // b2Vec2 d2 = p3 - p2;
              const d2 = p3.Clone().SelfSub(p2);
              let L1sqr, L2sqr;
              if (this.m_tuning.isometric) {
                  L1sqr = c.L1 * c.L1;
                  L2sqr = c.L2 * c.L2;
              }
              else {
                  L1sqr = d1.LengthSquared();
                  L2sqr = d2.LengthSquared();
              }
              if (L1sqr * L2sqr === 0.0) {
                  continue;
              }
              const a = b2Vec2.CrossVV(d1, d2);
              const b = b2Vec2.DotVV(d1, d2);
              const angle = b2Atan2(a, b);
              // b2Vec2 Jd1 = (-1.0 / L1sqr) * d1.Skew();
              // b2Vec2 Jd2 = (1.0 / L2sqr) * d2.Skew();
              // b2Vec2 J1 = -Jd1;
              // b2Vec2 J2 = Jd1 - Jd2;
              // b2Vec2 J3 = Jd2;
              // b2Vec2 Jd1 = (-1.0 / L1sqr) * d1.Skew();
              const Jd1 = new b2Vec2().Copy(d1).SelfSkew().SelfMul(-1.0 / L1sqr);
              // b2Vec2 Jd2 = (1.0 / L2sqr) * d2.Skew();
              const Jd2 = new b2Vec2().Copy(d2).SelfSkew().SelfMul(1.0 / L2sqr);
              // b2Vec2 J1 = -Jd1;
              const J1 = Jd1.Clone().SelfNeg();
              // b2Vec2 J2 = Jd1 - Jd2;
              const J2 = Jd1.Clone().SelfSub(Jd2);
              // b2Vec2 J3 = Jd2;
              const J3 = Jd2;
              let sum;
              if (this.m_tuning.fixedEffectiveMass) {
                  sum = c.invEffectiveMass;
              }
              else {
                  sum = c.invMass1 * b2Vec2.DotVV(J1, J1) + c.invMass2 * b2Vec2.DotVV(J2, J2) + c.invMass3 * b2Vec2.DotVV(J3, J3);
              }
              if (sum === 0.0) {
                  continue;
              }
              const alpha = 1.0 / (c.spring * dt * dt);
              const beta = dt * dt * c.damper;
              const sigma = alpha * beta / dt;
              const C = angle;
              // This is using the initial velocities
              const Cdot = b2Vec2.DotVV(J1, dp1) + b2Vec2.DotVV(J2, dp2) + b2Vec2.DotVV(J3, dp3);
              const B = C + alpha * c.lambda + sigma * Cdot;
              const sum2 = (1.0 + sigma) * sum + alpha;
              const impulse = -B / sum2;
              // p1 += (c.invMass1 * impulse) * J1;
              p1.x += (c.invMass1 * impulse) * J1.x;
              p1.y += (c.invMass1 * impulse) * J1.y;
              // p2 += (c.invMass2 * impulse) * J2;
              p2.x += (c.invMass2 * impulse) * J2.x;
              p2.y += (c.invMass2 * impulse) * J2.y;
              // p3 += (c.invMass3 * impulse) * J3;
              p3.x += (c.invMass3 * impulse) * J3.x;
              p3.y += (c.invMass3 * impulse) * J3.y;
              this.m_ps[c.i1].Copy(p1);
              this.m_ps[c.i2].Copy(p2);
              this.m_ps[c.i3].Copy(p3);
              c.lambda += impulse;
          }
      }
      SolveBend_PBD_Distance() {
          const stiffness = this.m_tuning.bendStiffness;
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const i1 = c.i1;
              const i2 = c.i3;
              const p1 = this.m_ps[i1].Clone();
              const p2 = this.m_ps[i2].Clone();
              // b2Vec2 d = p2 - p1;
              const d = p2.Clone().SelfSub(p1);
              const L = d.Normalize();
              const sum = c.invMass1 + c.invMass3;
              if (sum === 0.0) {
                  continue;
              }
              const s1 = c.invMass1 / sum;
              const s2 = c.invMass3 / sum;
              // p1 -= stiffness * s1 * (c.L1 + c.L2 - L) * d;
              p1.x -= stiffness * s1 * (c.L1 + c.L2 - L) * d.x;
              p1.y -= stiffness * s1 * (c.L1 + c.L2 - L) * d.y;
              // p2 += stiffness * s2 * (c.L1 + c.L2 - L) * d;
              p2.x += stiffness * s2 * (c.L1 + c.L2 - L) * d.x;
              p2.y += stiffness * s2 * (c.L1 + c.L2 - L) * d.y;
              this.m_ps[i1].Copy(p1);
              this.m_ps[i2].Copy(p2);
          }
      }
      SolveBend_PBD_Height() {
          const stiffness = this.m_tuning.bendStiffness;
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const p1 = this.m_ps[c.i1].Clone();
              const p2 = this.m_ps[c.i2].Clone();
              const p3 = this.m_ps[c.i3].Clone();
              // Barycentric coordinates are held constant
              const d = new b2Vec2();
              // b2Vec2 d = c.alpha1 * p1 + c.alpha2 * p3 - p2;
              d.x = c.alpha1 * p1.x + c.alpha2 * p3.x - p2.x;
              d.y = c.alpha1 * p1.y + c.alpha2 * p3.y - p2.y;
              const dLen = d.Length();
              if (dLen === 0.0) {
                  continue;
              }
              // b2Vec2 dHat = (1.0 / dLen) * d;
              const dHat = d.Clone().SelfMul(1.0 / dLen);
              // b2Vec2 J1 = c.alpha1 * dHat;
              const J1 = dHat.Clone().SelfMul(c.alpha1);
              // b2Vec2 J2 = -dHat;
              const J2 = dHat.Clone().SelfNeg();
              // b2Vec2 J3 = c.alpha2 * dHat;
              const J3 = dHat.Clone().SelfMul(c.alpha2);
              const sum = c.invMass1 * c.alpha1 * c.alpha1 + c.invMass2 + c.invMass3 * c.alpha2 * c.alpha2;
              if (sum === 0.0) {
                  continue;
              }
              const C = dLen;
              const mass = 1.0 / sum;
              const impulse = -stiffness * mass * C;
              // p1 += (c.invMass1 * impulse) * J1;
              p1.x += (c.invMass1 * impulse) * J1.x;
              p1.y += (c.invMass1 * impulse) * J1.y;
              // p2 += (c.invMass2 * impulse) * J2;
              p2.x += (c.invMass2 * impulse) * J2.x;
              p2.y += (c.invMass2 * impulse) * J2.y;
              // p3 += (c.invMass3 * impulse) * J3;
              p3.x += (c.invMass3 * impulse) * J3.x;
              p3.y += (c.invMass3 * impulse) * J3.y;
              this.m_ps[c.i1].Copy(p1);
              this.m_ps[c.i2].Copy(p2);
              this.m_ps[c.i3].Copy(p3);
          }
      }
      // M. Kelager: A Triangle Bending Constraint Model for PBD
      SolveBend_PBD_Triangle() {
          const stiffness = this.m_tuning.bendStiffness;
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const b0 = this.m_ps[c.i1].Clone();
              const v = this.m_ps[c.i2].Clone();
              const b1 = this.m_ps[c.i3].Clone();
              const wb0 = c.invMass1;
              const wv = c.invMass2;
              const wb1 = c.invMass3;
              const W = wb0 + wb1 + 2.0 * wv;
              const invW = stiffness / W;
              const d = new b2Vec2();
              d.x = v.x - (1.0 / 3.0) * (b0.x + v.x + b1.x);
              d.y = v.y - (1.0 / 3.0) * (b0.y + v.y + b1.y);
              const db0 = new b2Vec2();
              db0.x = 2.0 * wb0 * invW * d.x;
              db0.y = 2.0 * wb0 * invW * d.y;
              const dv = new b2Vec2();
              dv.x = -4.0 * wv * invW * d.x;
              dv.y = -4.0 * wv * invW * d.y;
              const db1 = new b2Vec2();
              db1.x = 2.0 * wb1 * invW * d.x;
              db1.y = 2.0 * wb1 * invW * d.y;
              b0.SelfAdd(db0);
              v.SelfAdd(dv);
              b1.SelfAdd(db1);
              this.m_ps[c.i1].Copy(b0);
              this.m_ps[c.i2].Copy(v);
              this.m_ps[c.i3].Copy(b1);
          }
      }
      ApplyBendForces(dt) {
          // omega = 2 * pi * hz
          const omega = 2.0 * b2_pi * this.m_tuning.bendHertz;
          for (let i = 0; i < this.m_bendCount; ++i) {
              const c = this.m_bendConstraints[i];
              const p1 = this.m_ps[c.i1].Clone();
              const p2 = this.m_ps[c.i2].Clone();
              const p3 = this.m_ps[c.i3].Clone();
              const v1 = this.m_vs[c.i1];
              const v2 = this.m_vs[c.i2];
              const v3 = this.m_vs[c.i3];
              // b2Vec2 d1 = p2 - p1;
              const d1 = p1.Clone().SelfSub(p1);
              // b2Vec2 d2 = p3 - p2;
              const d2 = p3.Clone().SelfSub(p2);
              let L1sqr, L2sqr;
              if (this.m_tuning.isometric) {
                  L1sqr = c.L1 * c.L1;
                  L2sqr = c.L2 * c.L2;
              }
              else {
                  L1sqr = d1.LengthSquared();
                  L2sqr = d2.LengthSquared();
              }
              if (L1sqr * L2sqr === 0.0) {
                  continue;
              }
              const a = b2Vec2.CrossVV(d1, d2);
              const b = b2Vec2.DotVV(d1, d2);
              const angle = b2Atan2(a, b);
              // b2Vec2 Jd1 = (-1.0 / L1sqr) * d1.Skew();
              // b2Vec2 Jd2 = (1.0 / L2sqr) * d2.Skew();
              // b2Vec2 J1 = -Jd1;
              // b2Vec2 J2 = Jd1 - Jd2;
              // b2Vec2 J3 = Jd2;
              // b2Vec2 Jd1 = (-1.0 / L1sqr) * d1.Skew();
              const Jd1 = new b2Vec2().Copy(d1).SelfSkew().SelfMul(-1.0 / L1sqr);
              // b2Vec2 Jd2 = (1.0 / L2sqr) * d2.Skew();
              const Jd2 = new b2Vec2().Copy(d2).SelfSkew().SelfMul(1.0 / L2sqr);
              // b2Vec2 J1 = -Jd1;
              const J1 = Jd1.Clone().SelfNeg();
              // b2Vec2 J2 = Jd1 - Jd2;
              const J2 = Jd1.Clone().SelfSub(Jd2);
              // b2Vec2 J3 = Jd2;
              const J3 = Jd2;
              let sum = 0.0;
              if (this.m_tuning.fixedEffectiveMass) {
                  sum = c.invEffectiveMass;
              }
              else {
                  sum = c.invMass1 * b2Vec2.DotVV(J1, J1) + c.invMass2 * b2Vec2.DotVV(J2, J2) + c.invMass3 * b2Vec2.DotVV(J3, J3);
              }
              if (sum === 0.0) {
                  continue;
              }
              const mass = 1.0 / sum;
              const spring = mass * omega * omega;
              const damper = 2.0 * mass * this.m_tuning.bendDamping * omega;
              const C = angle;
              const Cdot = b2Vec2.DotVV(J1, v1) + b2Vec2.DotVV(J2, v2) + b2Vec2.DotVV(J3, v3);
              const impulse = -dt * (spring * C + damper * Cdot);
              // this.m_vs[c.i1] += (c.invMass1 * impulse) * J1;
              this.m_vs[c.i1].x += (c.invMass1 * impulse) * J1.x;
              this.m_vs[c.i1].y += (c.invMass1 * impulse) * J1.y;
              // this.m_vs[c.i2] += (c.invMass2 * impulse) * J2;
              this.m_vs[c.i2].x += (c.invMass2 * impulse) * J2.x;
              this.m_vs[c.i2].y += (c.invMass2 * impulse) * J2.y;
              // this.m_vs[c.i3] += (c.invMass3 * impulse) * J3;
              this.m_vs[c.i3].x += (c.invMass3 * impulse) * J3.x;
              this.m_vs[c.i3].y += (c.invMass3 * impulse) * J3.y;
          }
      }
  }

  /*
   * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * A controller edge is used to connect bodies and controllers
   * together in a bipartite graph.
   */
  class b2ControllerEdge {
      constructor(controller, body) {
          this.prevBody = null; ///< the previous controller edge in the controllers's joint list
          this.nextBody = null; ///< the next controller edge in the controllers's joint list
          this.prevController = null; ///< the previous controller edge in the body's joint list
          this.nextController = null; ///< the next controller edge in the body's joint list
          this.controller = controller;
          this.body = body;
      }
  }
  /**
   * Base class for controllers. Controllers are a convience for
   * encapsulating common per-step functionality.
   */
  class b2Controller {
      constructor() {
          // m_world: b2World;
          this.m_bodyList = null;
          this.m_bodyCount = 0;
          this.m_prev = null;
          this.m_next = null;
      }
      /**
       * Get the next controller in the world's body list.
       */
      GetNext() {
          return this.m_next;
      }
      /**
       * Get the previous controller in the world's body list.
       */
      GetPrev() {
          return this.m_prev;
      }
      /**
       * Get the parent world of this body.
       */
      // GetWorld() {
      //   return this.m_world;
      // }
      /**
       * Get the attached body list
       */
      GetBodyList() {
          return this.m_bodyList;
      }
      /**
       * Adds a body to the controller list.
       */
      AddBody(body) {
          const edge = new b2ControllerEdge(this, body);
          //Add edge to controller list
          edge.nextBody = this.m_bodyList;
          edge.prevBody = null;
          if (this.m_bodyList) {
              this.m_bodyList.prevBody = edge;
          }
          this.m_bodyList = edge;
          ++this.m_bodyCount;
          //Add edge to body list
          edge.nextController = body.m_controllerList;
          edge.prevController = null;
          if (body.m_controllerList) {
              body.m_controllerList.prevController = edge;
          }
          body.m_controllerList = edge;
          ++body.m_controllerCount;
      }
      /**
       * Removes a body from the controller list.
       */
      RemoveBody(body) {
          //Assert that the controller is not empty
          if (this.m_bodyCount <= 0) {
              throw new Error();
          }
          //Find the corresponding edge
          /*b2ControllerEdge*/
          let edge = this.m_bodyList;
          while (edge && edge.body !== body) {
              edge = edge.nextBody;
          }
          //Assert that we are removing a body that is currently attached to the controller
          if (edge === null) {
              throw new Error();
          }
          //Remove edge from controller list
          if (edge.prevBody) {
              edge.prevBody.nextBody = edge.nextBody;
          }
          if (edge.nextBody) {
              edge.nextBody.prevBody = edge.prevBody;
          }
          if (this.m_bodyList === edge) {
              this.m_bodyList = edge.nextBody;
          }
          --this.m_bodyCount;
          //Remove edge from body list
          if (edge.nextController) {
              edge.nextController.prevController = edge.prevController;
          }
          if (edge.prevController) {
              edge.prevController.nextController = edge.nextController;
          }
          if (body.m_controllerList === edge) {
              body.m_controllerList = edge.nextController;
          }
          --body.m_controllerCount;
      }
      /**
       * Removes all bodies from the controller list.
       */
      Clear() {
          while (this.m_bodyList) {
              this.RemoveBody(this.m_bodyList.body);
          }
          this.m_bodyCount = 0;
      }
  }
  // #endif

  /*
   * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * Calculates buoyancy forces for fluids in the form of a half
   * plane.
   */
  class b2BuoyancyController extends b2Controller {
      constructor() {
          super(...arguments);
          /**
           * The outer surface normal
           */
          this.normal = new b2Vec2(0, 1);
          /**
           * The height of the fluid surface along the normal
           */
          this.offset = 0;
          /**
           * The fluid density
           */
          this.density = 0;
          /**
           * Fluid velocity, for drag calculations
           */
          this.velocity = new b2Vec2(0, 0);
          /**
           * Linear drag co-efficient
           */
          this.linearDrag = 0;
          /**
           * Angular drag co-efficient
           */
          this.angularDrag = 0;
          /**
           * If false, bodies are assumed to be uniformly dense, otherwise
           * use the shapes densities
           */
          this.useDensity = false; //False by default to prevent a gotcha
          /**
           * If true, gravity is taken from the world instead of the
           */
          this.useWorldGravity = true;
          /**
           * Gravity vector, if the world's gravity is not used
           */
          this.gravity = new b2Vec2(0, 0);
      }
      Step(step) {
          if (!this.m_bodyList) {
              return;
          }
          if (this.useWorldGravity) {
              this.gravity.Copy(this.m_bodyList.body.GetWorld().GetGravity());
          }
          for (let i = this.m_bodyList; i; i = i.nextBody) {
              const body = i.body;
              if (!body.IsAwake()) {
                  //Buoyancy force is just a function of position,
                  //so unlike most forces, it is safe to ignore sleeping bodes
                  continue;
              }
              const areac = new b2Vec2();
              const massc = new b2Vec2();
              let area = 0;
              let mass = 0;
              for (let fixture = body.GetFixtureList(); fixture; fixture = fixture.m_next) {
                  const sc = new b2Vec2();
                  const sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
                  area += sarea;
                  areac.x += sarea * sc.x;
                  areac.y += sarea * sc.y;
                  let shapeDensity = 0;
                  if (this.useDensity) {
                      //TODO: Expose density publicly
                      shapeDensity = fixture.GetDensity();
                  }
                  else {
                      shapeDensity = 1;
                  }
                  mass += sarea * shapeDensity;
                  massc.x += sarea * sc.x * shapeDensity;
                  massc.y += sarea * sc.y * shapeDensity;
              }
              areac.x /= area;
              areac.y /= area;
              //    b2Vec2 localCentroid = b2MulT(body->GetXForm(),areac);
              massc.x /= mass;
              massc.y /= mass;
              if (area < b2_epsilon) {
                  continue;
              }
              //Buoyancy
              const buoyancyForce = this.gravity.Clone().SelfNeg();
              buoyancyForce.SelfMul(this.density * area);
              body.ApplyForce(buoyancyForce, massc);
              //Linear drag
              const dragForce = body.GetLinearVelocityFromWorldPoint(areac, new b2Vec2());
              dragForce.SelfSub(this.velocity);
              dragForce.SelfMul((-this.linearDrag * area));
              body.ApplyForce(dragForce, areac);
              //Angular drag
              //TODO: Something that makes more physical sense?
              body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
          }
      }
      Draw(debugDraw) {
          const r = 100;
          const p1 = new b2Vec2();
          const p2 = new b2Vec2();
          p1.x = this.normal.x * this.offset + this.normal.y * r;
          p1.y = this.normal.y * this.offset - this.normal.x * r;
          p2.x = this.normal.x * this.offset - this.normal.y * r;
          p2.y = this.normal.y * this.offset + this.normal.x * r;
          const color = new b2Color(0, 0, 0.8);
          debugDraw.DrawSegment(p1, p2, color);
      }
  }
  // #endif

  /*
   * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * Applies a force every frame
   */
  class b2ConstantAccelController extends b2Controller {
      constructor() {
          super(...arguments);
          /**
           * The acceleration to apply
           */
          this.A = new b2Vec2(0, 0);
      }
      Step(step) {
          const dtA = b2Vec2.MulSV(step.dt, this.A, b2ConstantAccelController.Step_s_dtA);
          for (let i = this.m_bodyList; i; i = i.nextBody) {
              const body = i.body;
              if (!body.IsAwake()) {
                  continue;
              }
              body.SetLinearVelocity(b2Vec2.AddVV(body.GetLinearVelocity(), dtA, b2Vec2.s_t0));
          }
      }
      Draw(draw) { }
  }
  b2ConstantAccelController.Step_s_dtA = new b2Vec2();
  // #endif

  /*
   * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * Applies a force every frame
   */
  class b2ConstantForceController extends b2Controller {
      constructor() {
          super(...arguments);
          /**
           * The force to apply
           */
          this.F = new b2Vec2(0, 0);
      }
      Step(step) {
          for (let i = this.m_bodyList; i; i = i.nextBody) {
              const body = i.body;
              if (!body.IsAwake()) {
                  continue;
              }
              body.ApplyForce(this.F, body.GetWorldCenter());
          }
      }
      Draw(draw) { }
  }
  // #endif

  /*
   * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * Applies simplified gravity between every pair of bodies
   */
  class b2GravityController extends b2Controller {
      constructor() {
          super(...arguments);
          /**
           * Specifies the strength of the gravitiation force
           */
          this.G = 1;
          /**
           * If true, gravity is proportional to r^-2, otherwise r^-1
           */
          this.invSqr = true;
      }
      /**
       * @see b2Controller::Step
       */
      Step(step) {
          if (this.invSqr) {
              for (let i = this.m_bodyList; i; i = i.nextBody) {
                  const body1 = i.body;
                  const p1 = body1.GetWorldCenter();
                  const mass1 = body1.GetMass();
                  for (let j = this.m_bodyList; j && j !== i; j = j.nextBody) {
                      const body2 = j.body;
                      const p2 = body2.GetWorldCenter();
                      const mass2 = body2.GetMass();
                      const dx = p2.x - p1.x;
                      const dy = p2.y - p1.y;
                      const r2 = dx * dx + dy * dy;
                      if (r2 < b2_epsilon) {
                          continue;
                      }
                      const f = b2GravityController.Step_s_f.Set(dx, dy);
                      f.SelfMul(this.G / r2 / b2Sqrt(r2) * mass1 * mass2);
                      if (body1.IsAwake()) {
                          body1.ApplyForce(f, p1);
                      }
                      if (body2.IsAwake()) {
                          body2.ApplyForce(f.SelfMul(-1), p2);
                      }
                  }
              }
          }
          else {
              for (let i = this.m_bodyList; i; i = i.nextBody) {
                  const body1 = i.body;
                  const p1 = body1.GetWorldCenter();
                  const mass1 = body1.GetMass();
                  for (let j = this.m_bodyList; j && j !== i; j = j.nextBody) {
                      const body2 = j.body;
                      const p2 = body2.GetWorldCenter();
                      const mass2 = body2.GetMass();
                      const dx = p2.x - p1.x;
                      const dy = p2.y - p1.y;
                      const r2 = dx * dx + dy * dy;
                      if (r2 < b2_epsilon) {
                          continue;
                      }
                      const f = b2GravityController.Step_s_f.Set(dx, dy);
                      f.SelfMul(this.G / r2 * mass1 * mass2);
                      if (body1.IsAwake()) {
                          body1.ApplyForce(f, p1);
                      }
                      if (body2.IsAwake()) {
                          body2.ApplyForce(f.SelfMul(-1), p2);
                      }
                  }
              }
          }
      }
      Draw(draw) { }
  }
  b2GravityController.Step_s_f = new b2Vec2();
  // #endif

  /*
   * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
   *
   * This software is provided 'as-is', without any express or implied
   * warranty.  In no event will the authors be held liable for any damages
   * arising from the use of this software.
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   * 1. The origin of this software must not be misrepresented; you must not
   * claim that you wrote the original software. If you use this software
   * in a product, an acknowledgment in the product documentation would be
   * appreciated but is not required.
   * 2. Altered source versions must be plainly marked as such, and must not be
   * misrepresented as being the original software.
   * 3. This notice may not be removed or altered from any source distribution.
   */
  /**
   * Applies top down linear damping to the controlled bodies
   * The damping is calculated by multiplying velocity by a matrix
   * in local co-ordinates.
   */
  class b2TensorDampingController extends b2Controller {
      constructor() {
          super(...arguments);
          /// Tensor to use in damping model
          this.T = new b2Mat22();
          /*Some examples (matrixes in format (row1; row2))
          (-a 0; 0 -a)    Standard isotropic damping with strength a
          ( 0 a; -a 0)    Electron in fixed field - a force at right angles to velocity with proportional magnitude
          (-a 0; 0 -b)    Differing x and y damping. Useful e.g. for top-down wheels.
          */
          //By the way, tensor in this case just means matrix, don't let the terminology get you down.
          /// Set this to a positive number to clamp the maximum amount of damping done.
          this.maxTimestep = 0;
      }
      // Typically one wants maxTimestep to be 1/(max eigenvalue of T), so that damping will never cause something to reverse direction
      /**
       * @see b2Controller::Step
       */
      Step(step) {
          let timestep = step.dt;
          if (timestep <= b2_epsilon) {
              return;
          }
          if (timestep > this.maxTimestep && this.maxTimestep > 0) {
              timestep = this.maxTimestep;
          }
          for (let i = this.m_bodyList; i; i = i.nextBody) {
              const body = i.body;
              if (!body.IsAwake()) {
                  continue;
              }
              const damping = body.GetWorldVector(b2Mat22.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity(), b2Vec2.s_t0), b2Vec2.s_t1), b2TensorDampingController.Step_s_damping);
              //    body->SetLinearVelocity(body->GetLinearVelocity() + timestep * damping);
              body.SetLinearVelocity(b2Vec2.AddVV(body.GetLinearVelocity(), b2Vec2.MulSV(timestep, damping, b2Vec2.s_t0), b2Vec2.s_t1));
          }
      }
      Draw(draw) { }
      /**
       * Sets damping independantly along the x and y axes
       */
      SetAxisAligned(xDamping, yDamping) {
          this.T.ex.x = (-xDamping);
          this.T.ex.y = 0;
          this.T.ey.x = 0;
          this.T.ey.y = (-yDamping);
          if (xDamping > 0 || yDamping > 0) {
              this.maxTimestep = 1 / b2Max(xDamping, yDamping);
          }
          else {
              this.maxTimestep = 0;
          }
      }
  }
  b2TensorDampingController.Step_s_damping = new b2Vec2();
  // #endif

  const staticBody = exports.BodyType.b2_staticBody;
  const kinematicBody = exports.BodyType.b2_kinematicBody;
  const dynamicBody = exports.BodyType.b2_dynamicBody;
  const springAngleBendingModel = exports.BendingModel.b2_springAngleBendingModel;
  const pbdAngleBendingModel = exports.BendingModel.b2_pbdAngleBendingModel;
  const xpbdAngleBendingModel = exports.BendingModel.b2_xpbdAngleBendingModel;
  const pbdDistanceBendingModel = exports.BendingModel.b2_pbdDistanceBendingModel;
  const pbdHeightBendingModel = exports.BendingModel.b2_pbdHeightBendingModel;
  const pbdTriangleBendingModel = exports.BendingModel.b2_pbdTriangleBendingModel;
  const pbdStretchingModel = exports.StretchingModel.b2_pbdStretchingModel;
  const xpbdStretchingModel = exports.StretchingModel.b2_xpbdStretchingModel;

  exports.AABB = b2AABB;
  exports.Abs = b2Abs;
  exports.Acos = b2Acos;
  exports.Alloc = b2Alloc;
  exports.AngularStiffness = b2AngularStiffness;
  exports.AreaJoint = b2AreaJoint;
  exports.AreaJointDef = b2AreaJointDef;
  exports.Asin = b2Asin;
  exports.Assert = b2Assert;
  exports.Atan2 = b2Atan2;
  exports.BlockAllocator = b2BlockAllocator;
  exports.Body = b2Body;
  exports.BodyDef = b2BodyDef;
  exports.BroadPhase = b2BroadPhase;
  exports.BuoyancyController = b2BuoyancyController;
  exports.CalculateParticleIterations = b2CalculateParticleIterations;
  exports.ChainAndCircleContact = b2ChainAndCircleContact;
  exports.ChainAndPolygonContact = b2ChainAndPolygonContact;
  exports.ChainShape = b2ChainShape;
  exports.CircleContact = b2CircleContact;
  exports.CircleShape = b2CircleShape;
  exports.Clamp = b2Clamp;
  exports.ClipSegmentToLine = b2ClipSegmentToLine;
  exports.ClipVertex = b2ClipVertex;
  exports.CollideCircles = b2CollideCircles;
  exports.CollideEdgeAndCircle = b2CollideEdgeAndCircle;
  exports.CollideEdgeAndPolygon = b2CollideEdgeAndPolygon;
  exports.CollidePolygonAndCircle = b2CollidePolygonAndCircle;
  exports.CollidePolygons = b2CollidePolygons;
  exports.Color = b2Color;
  exports.ConstantAccelController = b2ConstantAccelController;
  exports.ConstantForceController = b2ConstantForceController;
  exports.Contact = b2Contact;
  exports.ContactEdge = b2ContactEdge;
  exports.ContactFactory = b2ContactFactory;
  exports.ContactFeature = b2ContactFeature;
  exports.ContactFilter = b2ContactFilter;
  exports.ContactID = b2ContactID;
  exports.ContactImpulse = b2ContactImpulse;
  exports.ContactListener = b2ContactListener;
  exports.ContactManager = b2ContactManager;
  exports.ContactPositionConstraint = b2ContactPositionConstraint;
  exports.ContactRegister = b2ContactRegister;
  exports.ContactSolver = b2ContactSolver;
  exports.ContactSolverDef = b2ContactSolverDef;
  exports.ContactVelocityConstraint = b2ContactVelocityConstraint;
  exports.Controller = b2Controller;
  exports.ControllerEdge = b2ControllerEdge;
  exports.Cos = b2Cos;
  exports.Counter = b2Counter;
  exports.DegToRad = b2DegToRad;
  exports.DestructionListener = b2DestructionListener;
  exports.Distance = b2Distance;
  exports.DistanceInput = b2DistanceInput;
  exports.DistanceJoint = b2DistanceJoint;
  exports.DistanceJointDef = b2DistanceJointDef;
  exports.DistanceOutput = b2DistanceOutput;
  exports.DistanceProxy = b2DistanceProxy;
  exports.Draw = b2Draw;
  exports.DynamicTree = b2DynamicTree;
  exports.EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.EdgeAndPolygonContact = b2EdgeAndPolygonContact;
  exports.EdgeShape = b2EdgeShape;
  exports.Filter = b2Filter;
  exports.Fixture = b2Fixture;
  exports.FixtureDef = b2FixtureDef;
  exports.FixtureParticleQueryCallback = b2FixtureParticleQueryCallback;
  exports.FixtureProxy = b2FixtureProxy;
  exports.Free = b2Free;
  exports.FrictionJoint = b2FrictionJoint;
  exports.FrictionJointDef = b2FrictionJointDef;
  exports.GearJoint = b2GearJoint;
  exports.GearJointDef = b2GearJointDef;
  exports.GetPointStates = b2GetPointStates;
  exports.GravityController = b2GravityController;
  exports.GrowableBuffer = b2GrowableBuffer;
  exports.GrowableStack = b2GrowableStack;
  exports.InvSqrt = b2InvSqrt;
  exports.IsPowerOfTwo = b2IsPowerOfTwo;
  exports.IsValid = b2IsValid;
  exports.Island = b2Island;
  exports.Jacobian = b2Jacobian;
  exports.Joint = b2Joint;
  exports.JointDef = b2JointDef;
  exports.JointEdge = b2JointEdge;
  exports.LinearStiffness = b2LinearStiffness;
  exports.Log = b2Log;
  exports.MakeArray = b2MakeArray;
  exports.MakeNullArray = b2MakeNullArray;
  exports.MakeNumberArray = b2MakeNumberArray;
  exports.Manifold = b2Manifold;
  exports.ManifoldPoint = b2ManifoldPoint;
  exports.MassData = b2MassData;
  exports.Mat22 = b2Mat22;
  exports.Mat33 = b2Mat33;
  exports.Max = b2Max;
  exports.Maybe = b2Maybe;
  exports.Min = b2Min;
  exports.MixFriction = b2MixFriction;
  exports.MixRestitution = b2MixRestitution;
  exports.MixRestitutionThreshold = b2MixRestitutionThreshold;
  exports.MotorJoint = b2MotorJoint;
  exports.MotorJointDef = b2MotorJointDef;
  exports.MouseJoint = b2MouseJoint;
  exports.MouseJointDef = b2MouseJointDef;
  exports.NextPowerOfTwo = b2NextPowerOfTwo;
  exports.Pair = b2Pair;
  exports.ParseInt = b2ParseInt;
  exports.ParseUInt = b2ParseUInt;
  exports.ParticleBodyContact = b2ParticleBodyContact;
  exports.ParticleContact = b2ParticleContact;
  exports.ParticleDef = b2ParticleDef;
  exports.ParticleGroup = b2ParticleGroup;
  exports.ParticleGroupDef = b2ParticleGroupDef;
  exports.ParticleHandle = b2ParticleHandle;
  exports.ParticlePair = b2ParticlePair;
  exports.ParticlePairSet = b2ParticlePairSet;
  exports.ParticleSystem = b2ParticleSystem;
  exports.ParticleSystemDef = b2ParticleSystemDef;
  exports.ParticleSystem_CompositeShape = b2ParticleSystem_CompositeShape;
  exports.ParticleSystem_ConnectionFilter = b2ParticleSystem_ConnectionFilter;
  exports.ParticleSystem_DestroyParticlesInShapeCallback = b2ParticleSystem_DestroyParticlesInShapeCallback;
  exports.ParticleSystem_FixedSetAllocator = b2ParticleSystem_FixedSetAllocator;
  exports.ParticleSystem_FixtureParticle = b2ParticleSystem_FixtureParticle;
  exports.ParticleSystem_FixtureParticleSet = b2ParticleSystem_FixtureParticleSet;
  exports.ParticleSystem_InsideBoundsEnumerator = b2ParticleSystem_InsideBoundsEnumerator;
  exports.ParticleSystem_JoinParticleGroupsFilter = b2ParticleSystem_JoinParticleGroupsFilter;
  exports.ParticleSystem_ParticleListNode = b2ParticleSystem_ParticleListNode;
  exports.ParticleSystem_ParticlePair = b2ParticleSystem_ParticlePair;
  exports.ParticleSystem_Proxy = b2ParticleSystem_Proxy;
  exports.ParticleSystem_ReactiveFilter = b2ParticleSystem_ReactiveFilter;
  exports.ParticleSystem_SolveCollisionCallback = b2ParticleSystem_SolveCollisionCallback;
  exports.ParticleSystem_UpdateBodyContactsCallback = b2ParticleSystem_UpdateBodyContactsCallback;
  exports.ParticleSystem_UserOverridableBuffer = b2ParticleSystem_UserOverridableBuffer;
  exports.ParticleTriad = b2ParticleTriad;
  exports.PolygonAndCircleContact = b2PolygonAndCircleContact;
  exports.PolygonContact = b2PolygonContact;
  exports.PolygonShape = b2PolygonShape;
  exports.Position = b2Position;
  exports.PositionSolverManifold = b2PositionSolverManifold;
  exports.Pow = b2Pow;
  exports.PrismaticJoint = b2PrismaticJoint;
  exports.PrismaticJointDef = b2PrismaticJointDef;
  exports.Profile = b2Profile;
  exports.PulleyJoint = b2PulleyJoint;
  exports.PulleyJointDef = b2PulleyJointDef;
  exports.QueryCallback = b2QueryCallback;
  exports.RadToDeg = b2RadToDeg;
  exports.Random = b2Random;
  exports.RandomRange = b2RandomRange;
  exports.RayCastCallback = b2RayCastCallback;
  exports.RayCastInput = b2RayCastInput;
  exports.RayCastOutput = b2RayCastOutput;
  exports.RevoluteJoint = b2RevoluteJoint;
  exports.RevoluteJointDef = b2RevoluteJointDef;
  exports.Rope = b2Rope;
  exports.RopeDef = b2RopeDef;
  exports.RopeTuning = b2RopeTuning;
  exports.Rot = b2Rot;
  exports.SeparationFunction = b2SeparationFunction;
  exports.Shape = b2Shape;
  exports.ShapeCast = b2ShapeCast;
  exports.ShapeCastInput = b2ShapeCastInput;
  exports.ShapeCastOutput = b2ShapeCastOutput;
  exports.Simplex = b2Simplex;
  exports.SimplexCache = b2SimplexCache;
  exports.SimplexVertex = b2SimplexVertex;
  exports.Sin = b2Sin;
  exports.SolverData = b2SolverData;
  exports.Sq = b2Sq;
  exports.Sqrt = b2Sqrt;
  exports.StackAllocator = b2StackAllocator;
  exports.StackQueue = b2StackQueue;
  exports.Swap = b2Swap;
  exports.Sweep = b2Sweep;
  exports.TOIInput = b2TOIInput;
  exports.TOIOutput = b2TOIOutput;
  exports.TensorDampingController = b2TensorDampingController;
  exports.TestOverlapAABB = b2TestOverlapAABB;
  exports.TestOverlapShape = b2TestOverlapShape;
  exports.TimeOfImpact = b2TimeOfImpact;
  exports.TimeStep = b2TimeStep;
  exports.Timer = b2Timer;
  exports.Transform = b2Transform;
  exports.TreeNode = b2TreeNode;
  exports.Vec2 = b2Vec2;
  exports.Vec2_zero = b2Vec2_zero;
  exports.Vec3 = b2Vec3;
  exports.Velocity = b2Velocity;
  exports.VelocityConstraintPoint = b2VelocityConstraintPoint;
  exports.Version = b2Version;
  exports.VoronoiDiagram = b2VoronoiDiagram;
  exports.VoronoiDiagram_Generator = b2VoronoiDiagram_Generator;
  exports.VoronoiDiagram_Task = b2VoronoiDiagram_Task;
  exports.WeldJoint = b2WeldJoint;
  exports.WeldJointDef = b2WeldJointDef;
  exports.WheelJoint = b2WheelJoint;
  exports.WheelJointDef = b2WheelJointDef;
  exports.World = b2World;
  exports.WorldManifold = b2WorldManifold;
  exports._180_over_pi = b2_180_over_pi;
  exports._pi_over_180 = b2_pi_over_180;
  exports.aabbExtension = b2_aabbExtension;
  exports.aabbMultiplier = b2_aabbMultiplier;
  exports.angularSleepTolerance = b2_angularSleepTolerance;
  exports.angularSlop = b2_angularSlop;
  exports.barrierCollisionTime = b2_barrierCollisionTime;
  exports.baumgarte = b2_baumgarte;
  exports.branch = b2_branch;
  exports.commit = b2_commit;
  exports.dynamicBody = dynamicBody;
  exports.epsilon = b2_epsilon;
  exports.epsilon_sq = b2_epsilon_sq;
  exports.get_g_blockSolve = get_g_blockSolve;
  exports.gjk_reset = b2_gjk_reset;
  exports.invalidParticleIndex = b2_invalidParticleIndex;
  exports.kinematicBody = kinematicBody;
  exports.lengthUnitsPerMeter = b2_lengthUnitsPerMeter;
  exports.linearSleepTolerance = b2_linearSleepTolerance;
  exports.linearSlop = b2_linearSlop;
  exports.maxAngularCorrection = b2_maxAngularCorrection;
  exports.maxFloat = b2_maxFloat;
  exports.maxLinearCorrection = b2_maxLinearCorrection;
  exports.maxManifoldPoints = b2_maxManifoldPoints;
  exports.maxParticleForce = b2_maxParticleForce;
  exports.maxParticleIndex = b2_maxParticleIndex;
  exports.maxParticlePressure = b2_maxParticlePressure;
  exports.maxPolygonVertices = b2_maxPolygonVertices;
  exports.maxRotation = b2_maxRotation;
  exports.maxRotationSquared = b2_maxRotationSquared;
  exports.maxSubSteps = b2_maxSubSteps;
  exports.maxTOIContacts = b2_maxTOIContacts;
  exports.maxTranslation = b2_maxTranslation;
  exports.maxTranslationSquared = b2_maxTranslationSquared;
  exports.maxTriadDistance = b2_maxTriadDistance;
  exports.maxTriadDistanceSquared = b2_maxTriadDistanceSquared;
  exports.minParticleSystemBufferCapacity = b2_minParticleSystemBufferCapacity;
  exports.minParticleWeight = b2_minParticleWeight;
  exports.minPulleyLength = b2_minPulleyLength;
  exports.particleStride = b2_particleStride;
  exports.pbdAngleBendingModel = pbdAngleBendingModel;
  exports.pbdDistanceBendingModel = pbdDistanceBendingModel;
  exports.pbdHeightBendingModel = pbdHeightBendingModel;
  exports.pbdStretchingModel = pbdStretchingModel;
  exports.pbdTriangleBendingModel = pbdTriangleBendingModel;
  exports.pi = b2_pi;
  exports.polygonRadius = b2_polygonRadius;
  exports.set_g_blockSolve = set_g_blockSolve;
  exports.springAngleBendingModel = springAngleBendingModel;
  exports.staticBody = staticBody;
  exports.timeToSleep = b2_timeToSleep;
  exports.toiBaumgarte = b2_toiBaumgarte;
  exports.toi_reset = b2_toi_reset;
  exports.two_pi = b2_two_pi;
  exports.version = b2_version;
  exports.xpbdAngleBendingModel = xpbdAngleBendingModel;
  exports.xpbdStretchingModel = xpbdStretchingModel;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
// -- //# sourceMappingURL=box2d.umd.js.map

/*!!
 *  Canvas 2 Svg v1.0.19
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */

;(function () {
    "use strict";

    var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;

    //helper function to format a string
    function format(str, args) {
        var keys = Object.keys(args), i;
        for (i=0; i<keys.length; i++) {
            str = str.replace(new RegExp("\\{" + keys[i] + "\\}", "gi"), args[keys[i]]);
        }
        return str;
    }

    //helper function that generates a random string
    function randomString(holder) {
        var chars, randomstring, i;
        if (!holder) {
            throw new Error("cannot create a random attribute name for an undefined object");
        }
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
        randomstring = "";
        do {
            randomstring = "";
            for (i = 0; i < 12; i++) {
                randomstring += chars[Math.floor(Math.random() * chars.length)];
            }
        } while (holder[randomstring]);
        return randomstring;
    }

    //helper function to map named to numbered entities
    function createNamedToNumberedLookup(items, radix) {
        var i, entity, lookup = {}, base10, base16;
        items = items.split(',');
        radix = radix || 10;
        // Map from named to numbered entities.
        for (i = 0; i < items.length; i += 2) {
            entity = '&' + items[i + 1] + ';';
            base10 = parseInt(items[i], radix);
            lookup[entity] = '&#'+base10+';';
        }
        //FF and IE need to create a regex from hex values ie &nbsp; == \xa0
        lookup["\\xa0"] = '&#160;';
        return lookup;
    }

    //helper function to map canvas-textAlign to svg-textAnchor
    function getTextAnchor(textAlign) {
        //TODO: support rtl languages
        var mapping = {"left":"start", "right":"end", "center":"middle", "start":"start", "end":"end"};
        return mapping[textAlign] || mapping.start;
    }

    //helper function to map canvas-textBaseline to svg-dominantBaseline
    function getDominantBaseline(textBaseline) {
        //INFO: not supported in all browsers
        var mapping = {"alphabetic": "alphabetic", "hanging": "hanging", "top":"text-before-edge", "bottom":"text-after-edge", "middle":"central"};
        return mapping[textBaseline] || mapping.alphabetic;
    }

    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    // entity mapping courtesy of tinymce
    namedEntities = createNamedToNumberedLookup(
        '50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
            '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
            '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
            '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
            '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
            '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
            '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
            '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
            '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
            '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
            'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
            'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
            't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
            'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
            'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
            '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
            '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
            '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
            '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
            '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
            'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
            'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
            'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
            '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
            '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);


    //Some basic mappings for attributes and default values.
    STYLES = {
        "strokeStyle":{
            svgAttr : "stroke", //corresponding svg attribute
            canvas : "#000000", //canvas default
            svg : "none",       //svg default
            apply : "stroke"    //apply on stroke() or fill()
        },
        "fillStyle":{
            svgAttr : "fill",
            canvas : "#000000",
            svg : null, //svg default is black, but we need to special case this to handle canvas stroke without fill
            apply : "fill"
        },
        "lineCap":{
            svgAttr : "stroke-linecap",
            canvas : "butt",
            svg : "butt",
            apply : "stroke"
        },
        "lineJoin":{
            svgAttr : "stroke-linejoin",
            canvas : "miter",
            svg : "miter",
            apply : "stroke"
        },
        "miterLimit":{
            svgAttr : "stroke-miterlimit",
            canvas : 10,
            svg : 4,
            apply : "stroke"
        },
        "lineWidth":{
            svgAttr : "stroke-width",
            canvas : 1,
            svg : 1,
            apply : "stroke"
        },
        "globalAlpha": {
            svgAttr : "opacity",
            canvas : 1,
            svg : 1,
            apply :  "fill stroke"
        },
        "font":{
            //font converts to multiple svg attributes, there is custom logic for this
            canvas : "10px sans-serif"
        },
        "shadowColor":{
            canvas : "#000000"
        },
        "shadowOffsetX":{
            canvas : 0
        },
        "shadowOffsetY":{
            canvas : 0
        },
        "shadowBlur":{
            canvas : 0
        },
        "textAlign":{
            canvas : "start"
        },
        "textBaseline":{
            canvas : "alphabetic"
        },
        "lineDash" : {
            svgAttr : "stroke-dasharray",
            canvas : [],
            svg : null,
            apply : "stroke"
        }
    };

    /**
     *
     * @param gradientNode - reference to the gradient
     * @constructor
     */
    CanvasGradient = function (gradientNode, ctx) {
        this.__root = gradientNode;
        this.__ctx = ctx;
    };

    /**
     * Adds a color stop to the gradient root
     */
    CanvasGradient.prototype.addColorStop = function (offset, color) {
        var stop = this.__ctx.__createElement("stop"), regex, matches;
        stop.setAttribute("offset", offset);
        if (color.indexOf("rgba") !== -1) {
            //separate alpha value, since webkit can't handle it
            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches = regex.exec(color);
            stop.setAttribute("stop-color", format("rgb({r},{g},{b})", {r:matches[1], g:matches[2], b:matches[3]}));
            stop.setAttribute("stop-opacity", matches[4]);
        } else {
            stop.setAttribute("stop-color", color);
        }
        this.__root.appendChild(stop);
    };

    CanvasPattern = function (pattern, ctx) {
        this.__root = pattern;
        this.__ctx = ctx;
    };

    /**
     * The mock canvas context
     * @param o - options include:
     * ctx - existing Context2D to wrap around
     * width - width of your canvas (defaults to 500)
     * height - height of your canvas (defaults to 500)
     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)
     * document - the document object (defaults to the current document)
     */
    ctx = function (o) {
        var defaultOptions = { width:500, height:500, enableMirroring : false}, options;

        //keep support for this way of calling C2S: new C2S(width,height)
        if (arguments.length > 1) {
            options = defaultOptions;
            options.width = arguments[0];
            options.height = arguments[1];
        } else if ( !o ) {
            options = defaultOptions;
        } else {
            options = o;
        }

        if (!(this instanceof ctx)) {
            //did someone call this without new?
            return new ctx(options);
        }

        //setup options
        this.width = options.width || defaultOptions.width;
        this.height = options.height || defaultOptions.height;
        this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;

        this.canvas = this;   ///point back to this instance!
        this.__document = options.document || document;

        // allow passing in an existing context to wrap around
        // if a context is passed in, we know a canvas already exist
        if (options.ctx) {
            this.__ctx = options.ctx;
        } else {
            this.__canvas = this.__document.createElement("canvas");
            this.__ctx = this.__canvas.getContext("2d");
        }

        this.__setDefaultStyles();
        this.__stack = [this.__getStyleState()];
        this.__groupStack = [];

        //the root svg element
        this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.__root.setAttribute("version", 1.1);
        this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        this.__root.setAttribute("width", this.width);
        this.__root.setAttribute("height", this.height);

        //make sure we don't generate the same ids in defs
        this.__ids = {};

        //defs tag
        this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
        this.__root.appendChild(this.__defs);

        //also add a group child. the svg element can't use the transform attribute
        this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
        this.__root.appendChild(this.__currentElement);
    };


    /**
     * Creates the specified svg element
     * @private
     */
    ctx.prototype.__createElement = function (elementName, properties, resetFill) {
        if (typeof properties === "undefined") {
            properties = {};
        }

        var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName),
            keys = Object.keys(properties), i, key;
        if (resetFill) {
            //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.
            element.setAttribute("fill", "none");
            element.setAttribute("stroke", "none");
        }
        for (i=0; i<keys.length; i++) {
            key = keys[i];
            element.setAttribute(key, properties[key]);
        }
        return element;
    };

    /**
     * Applies default canvas styles to the context
     * @private
     */
    ctx.prototype.__setDefaultStyles = function () {
        //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/
        var keys = Object.keys(STYLES), i, key;
        for (i=0; i<keys.length; i++) {
            key = keys[i];
            this[key] = STYLES[key].canvas;
        }
    };

    /**
     * Applies styles on restore
     * @param styleState
     * @private
     */
    ctx.prototype.__applyStyleState = function (styleState) {
        var keys = Object.keys(styleState), i, key;
        for (i=0; i<keys.length; i++) {
            key = keys[i];
            this[key] = styleState[key];
        }
    };

    /**
     * Gets the current style state
     * @return {Object}
     * @private
     */
    ctx.prototype.__getStyleState = function () {
        var i, styleState = {}, keys = Object.keys(STYLES), key;
        for (i=0; i<keys.length; i++) {
            key = keys[i];
            styleState[key] = this[key];
        }
        return styleState;
    };

    /**
     * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
     * @param type
     * @private
     */
    ctx.prototype.__applyStyleToCurrentElement = function (type) {
    	var currentElement = this.__currentElement;
    	var currentStyleGroup = this.__currentElementsToStyle;
    	if (currentStyleGroup) {
    		currentElement.setAttribute(type, "");
    		currentElement = currentStyleGroup.element;
    		currentStyleGroup.children.forEach(function (node) {
    			node.setAttribute(type, "");
    		})
    	}

        var keys = Object.keys(STYLES), i, style, value, id, regex, matches;
        for (i = 0; i < keys.length; i++) {
            style = STYLES[keys[i]];
            value = this[keys[i]];
            if (style.apply) {
                //is this a gradient or pattern?
                if (value instanceof CanvasPattern) {
                    //pattern
                    if (value.__ctx) {
                        //copy over defs
                        while(value.__ctx.__defs.childNodes.length) {
                            id = value.__ctx.__defs.childNodes[0].getAttribute("id");
                            this.__ids[id] = id;
                            this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                        }
                    }
                    currentElement.setAttribute(style.apply, format("url(#{id})", {id:value.__root.getAttribute("id")}));
                }
                else if (value instanceof CanvasGradient) {
                    //gradient
                    currentElement.setAttribute(style.apply, format("url(#{id})", {id:value.__root.getAttribute("id")}));
                } else if (style.apply.indexOf(type)!==-1 && style.svg !== value) {
                    if ((style.svgAttr === "stroke" || style.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
                        //separate alpha value, since illustrator can't handle it
                        regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                        matches = regex.exec(value);
                        currentElement.setAttribute(style.svgAttr, format("rgb({r},{g},{b})", {r:matches[1], g:matches[2], b:matches[3]}));
                        //should take globalAlpha here
                        var opacity = matches[4];
                        var globalAlpha = this.globalAlpha;
                        if (globalAlpha != null) {
                            opacity *= globalAlpha;
                        }
                        currentElement.setAttribute(style.svgAttr+"-opacity", opacity);
                    } else {
                        var attr = style.svgAttr;
                        if (keys[i] === 'globalAlpha') {
                            attr = type+'-'+style.svgAttr;
                            if (currentElement.getAttribute(attr)) {
                                 //fill-opacity or stroke-opacity has already been set by stroke or fill.
                                continue;
                            }
                        }
                        //otherwise only update attribute if right type, and not svg default
                        currentElement.setAttribute(attr, value);
                    }
                }
            }
        }
    };

    /**
     * Will return the closest group or svg node. May return the current element.
     * @private
     */
    ctx.prototype.__closestGroupOrSvg = function (node) {
        node = node || this.__currentElement;
        if (node.nodeName === "g" || node.nodeName === "svg") {
            return node;
        } else {
            return this.__closestGroupOrSvg(node.parentNode);
        }
    };

    /**
     * Returns the serialized value of the svg so far
     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
     *                           If true, we attempt to find all named entities and encode it as a numeric entity.
     * @return serialized svg
     */
    ctx.prototype.getSerializedSvg = function (fixNamedEntities) {
        var serialized = new XMLSerializer().serializeToString(this.__root),
            keys, i, key, value, regexp, xmlns;

        //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly
        xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
        if (xmlns.test(serialized)) {
            serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg','xmlns:xlink="http://www.w3.org/1999/xlink');
        }

        if (fixNamedEntities) {
            keys = Object.keys(namedEntities);
            //loop over each named entity and replace with the proper equivalent.
            for (i=0; i<keys.length; i++) {
                key = keys[i];
                value = namedEntities[key];
                regexp = new RegExp(key, "gi");
                if (regexp.test(serialized)) {
                    serialized = serialized.replace(regexp, value);
                }
            }
        }

        return serialized;
    };


    /**
     * Returns the root svg
     * @return
     */
    ctx.prototype.getSvg = function () {
        return this.__root;
    };
    /**
     * Will generate a group tag.
     */
    ctx.prototype.save = function () {
        var group = this.__createElement("g");
        var parent = this.__closestGroupOrSvg();
        this.__groupStack.push(parent);
        parent.appendChild(group);
        this.__currentElement = group;
        this.__stack.push(this.__getStyleState());
    };
    /**
     * Sets current element to parent, or just root if already root
     */
    ctx.prototype.restore = function () {
        this.__currentElement = this.__groupStack.pop();
        this.__currentElementsToStyle = null;
        //Clearing canvas will make the poped group invalid, currentElement is set to the root group node.
        if (!this.__currentElement) {
            this.__currentElement = this.__root.childNodes[1];
        }
        var state = this.__stack.pop();
        this.__applyStyleState(state);
    };

    /**
     * Helper method to add transform
     * @private
     */
    ctx.prototype.__addTransform = function (t) {
        //if the current element has siblings, add another group
        var parent = this.__closestGroupOrSvg();
        if (parent.childNodes.length > 0) {
        	if (this.__currentElement.nodeName === "path") {
        		if (!this.__currentElementsToStyle) this.__currentElementsToStyle = {element: parent, children: []};
        		this.__currentElementsToStyle.children.push(this.__currentElement)
        		this.__applyCurrentDefaultPath();
        	}

            var group = this.__createElement("g");
            parent.appendChild(group);
            this.__currentElement = group;
        }

        var transform = this.__currentElement.getAttribute("transform");
        if (transform) {
            transform += " ";
        } else {
            transform = "";
        }
        transform += t;
        this.__currentElement.setAttribute("transform", transform);
    };

    /**
     *  scales the current element
     */
    ctx.prototype.scale = function (x, y) {
        if (y === undefined) {
            y = x;
        }
        this.__addTransform(format("scale({x},{y})", {x:x, y:y}));
    };

    /**
     * rotates the current element
     */
    ctx.prototype.rotate = function (angle) {
        var degrees = (angle * 180 / Math.PI);
        this.__addTransform(format("rotate({angle},{cx},{cy})", {angle:degrees, cx:0, cy:0}));
    };

    /**
     * translates the current element
     */
    ctx.prototype.translate = function (x, y) {
        this.__addTransform(format("translate({x},{y})", {x:x,y:y}));
    };

    /**
     * applies a transform to the current element
     */
    ctx.prototype.transform = function (a, b, c, d, e, f) {
        this.__addTransform(format("matrix({a},{b},{c},{d},{e},{f})", {a:a, b:b, c:c, d:d, e:e, f:f}));
    };

    /**
     * Create a new Path Element
     */
    ctx.prototype.beginPath = function () {
        var path, parent;

        // Note that there is only one current default path, it is not part of the drawing state.
        // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path
        this.__currentDefaultPath = "";
        this.__currentPosition = {};

        path = this.__createElement("path", {}, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(path);
        this.__currentElement = path;
    };

    /**
     * Helper function to apply currentDefaultPath to current path element
     * @private
     */
    ctx.prototype.__applyCurrentDefaultPath = function () {
    	var currentElement = this.__currentElement;
        if (currentElement.nodeName === "path") {
			currentElement.setAttribute("d", this.__currentDefaultPath);
        } else {
			console.error("Attempted to apply path command to node", currentElement.nodeName);
        }
    };

    /**
     * Helper function to add path command
     * @private
     */
    ctx.prototype.__addPathCommand = function (command) {
        this.__currentDefaultPath += " ";
        this.__currentDefaultPath += command;
    };

    /**
     * Adds the move command to the current path element,
     * if the currentPathElement is not empty create a new path element
     */
    ctx.prototype.moveTo = function (x,y) {
        if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
        }

        // creates a new subpath with the given point
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("M {x} {y}", {x:x, y:y}));
    };

    /**
     * Closes the current path
     */
    ctx.prototype.closePath = function () {
        if (this.__currentDefaultPath) {
            this.__addPathCommand("Z");
        }
    };

    /**
     * Adds a line to command
     */
    ctx.prototype.lineTo = function (x, y) {
        this.__currentPosition = {x: x, y: y};
        if (this.__currentDefaultPath.indexOf('M') > -1) {
            this.__addPathCommand(format("L {x} {y}", {x:x, y:y}));
        } else {
            this.__addPathCommand(format("M {x} {y}", {x:x, y:y}));
        }
    };

    /**
     * Add a bezier command
     */
    ctx.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
            {cp1x:cp1x, cp1y:cp1y, cp2x:cp2x, cp2y:cp2y, x:x, y:y}));
    };

    /**
     * Adds a quadratic curve to command
     */
    ctx.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
        this.__currentPosition = {x: x, y: y};
        this.__addPathCommand(format("Q {cpx} {cpy} {x} {y}", {cpx:cpx, cpy:cpy, x:x, y:y}));
    };


    /**
     * Return a new normalized vector of given vector
     */
    var normalize = function (vector) {
        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
        return [vector[0] / len, vector[1] / len];
    };

    /**
     * Adds the arcTo to the current path
     *
     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
     */
    ctx.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        // Let the point (x0, y0) be the last point in the subpath.
        var x0 = this.__currentPosition && this.__currentPosition.x;
        var y0 = this.__currentPosition && this.__currentPosition.y;

        // First ensure there is a subpath for (x1, y1).
        if (typeof x0 == "undefined" || typeof y0 == "undefined") {
            return;
        }

        // Negative values for radius must cause the implementation to throw an IndexSizeError exception.
        if (radius < 0) {
            throw new Error("IndexSizeError: The radius provided (" + radius + ") is negative.");
        }

        // If the point (x0, y0) is equal to the point (x1, y1),
        // or if the point (x1, y1) is equal to the point (x2, y2),
        // or if the radius radius is zero,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        if (((x0 === x1) && (y0 === y1))
            || ((x1 === x2) && (y1 === y2))
            || (radius === 0)) {
            this.lineTo(x1, y1);
            return;
        }

        // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,
        // then the method must add the point (x1, y1) to the subpath,
        // and connect that point to the previous point (x0, y0) by a straight line.
        var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);
        var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);
        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
            this.lineTo(x1, y1);
            return;
        }

        // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,
        // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),
        // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).
        // The points at which this circle touches these two lines are called the start and end tangent points respectively.

        // note that both vectors are unit vectors, so the length is 1
        var cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);
        var theta = Math.acos(Math.abs(cos));

        // Calculate origin
        var unit_vec_p1_origin = normalize([
            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
        ]);
        var len_p1_origin = radius / Math.sin(theta / 2);
        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];

        // Calculate start angle and end angle
        // rotate 90deg clockwise (note that y axis points to its down)
        var unit_vec_origin_start_tangent = [
            -unit_vec_p1_p0[1],
            unit_vec_p1_p0[0]
        ];
        // rotate 90deg counter clockwise (note that y axis points to its down)
        var unit_vec_origin_end_tangent = [
            unit_vec_p1_p2[1],
            -unit_vec_p1_p2[0]
        ];
        var getAngle = function (vector) {
            // get angle (clockwise) between vector and (1, 0)
            var x = vector[0];
            var y = vector[1];
            if (y >= 0) { // note that y axis points to its down
                return Math.acos(x);
            } else {
                return -Math.acos(x);
            }
        };
        var startAngle = getAngle(unit_vec_origin_start_tangent);
        var endAngle = getAngle(unit_vec_origin_end_tangent);

        // Connect the point (x0, y0) to the start tangent point by a straight line
        this.lineTo(x + unit_vec_origin_start_tangent[0] * radius,
                    y + unit_vec_origin_start_tangent[1] * radius);

        // Connect the start tangent point to the end tangent point by arc
        // and adding the end tangent point to the subpath.
        this.arc(x, y, radius, startAngle, endAngle);
    };

    /**
     * Sets the stroke property on the current element
     */
    ctx.prototype.stroke = function () {
        if (this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "fill stroke markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("stroke");
    };

    /**
     * Sets fill properties on the current element
     */
    ctx.prototype.fill = function (apath = null) {
        const backupCurPath = this.__currentDefaultPath
        
        if (apath !== null) {
            this.beginPath()
            this.__currentDefaultPath = apath.__currentDefaultPath
        }
        if (this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "stroke fill markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("fill");
        this.__currentDefaultPath = backupCurPath
    };

    /**
     *  Adds a rectangle to the path.
     */
    ctx.prototype.rect = function (x, y, width, height) {
        if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
        }
        this.moveTo(x, y);
        this.lineTo(x+width, y);
        this.lineTo(x+width, y+height);
        this.lineTo(x, y+height);
        this.lineTo(x, y);
        this.closePath();
    };


    /**
     * adds a rectangle element
     */
    ctx.prototype.fillRect = function (x, y, width, height) {
        var rect, parent;
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("fill");
    };

    /**
     * Draws a rectangle with no fill
     * @param x
     * @param y
     * @param width
     * @param height
     */
    ctx.prototype.strokeRect = function (x, y, width, height) {
        var rect, parent;
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("stroke");
    };


    /**
     * Clear entire canvas:
     * 1. save current transforms
     * 2. remove all the childNodes of the root g element
     */
    ctx.prototype.__clearCanvas = function () {
        var current = this.__closestGroupOrSvg(),
            transform = current.getAttribute("transform");
        var rootGroup = this.__root.childNodes[1];
        var childNodes = rootGroup.childNodes;
        for (var i = childNodes.length - 1; i >= 0; i--) {
            if (childNodes[i]) {
                rootGroup.removeChild(childNodes[i]);
            }
        }
        this.__currentElement = rootGroup;
        //reset __groupStack as all the child group nodes are all removed.
        this.__groupStack = [];
        if (transform) {
            this.__addTransform(transform);
        }
    };

    /**
     * "Clears" a canvas by just drawing a white rectangle in the current group.
     */
    ctx.prototype.clearRect = function (x, y, width, height) {
        //clear entire canvas
        if (x === 0 && y === 0 && width === this.width && height === this.height) {
            this.__clearCanvas();
            return;
        }
        var rect, parent = this.__closestGroupOrSvg();
        rect = this.__createElement("rect", {
            x : x,
            y : y,
            width : width,
            height : height,
            fill : "#FFFFFF"
        }, true);
        parent.appendChild(rect);
    };

    /**
     * Adds a linear gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createLinearGradient = function (x1, y1, x2, y2) {
        var grad = this.__createElement("linearGradient", {
            id : randomString(this.__ids),
            x1 : x1+"px",
            x2 : x2+"px",
            y1 : y1+"px",
            y2 : y2+"px",
            "gradientUnits" : "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
    };

    /**
     * Adds a radial gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    ctx.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
        var grad = this.__createElement("radialGradient", {
            id : randomString(this.__ids),
            cx : x1+"px",
            cy : y1+"px",
            r  : r1+"px",
            fx : x0+"px",
            fy : y0+"px",
            "gradientUnits" : "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);

    };

    /**
     * Parses the font string and returns svg mapping
     * @private
     */
    ctx.prototype.__parseFont = function () {
        var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i;
        var fontPart = regex.exec( this.font );
        var data = {
            style : fontPart[1] || 'normal',
            size : fontPart[4] || '10px',
            family : fontPart[6] || 'sans-serif',
            weight: fontPart[3] || 'normal',
            decoration : fontPart[2] || 'normal',
            href : null
        };

        //canvas doesn't support underline natively, but we can pass this attribute
        if (this.__fontUnderline === "underline") {
            data.decoration = "underline";
        }

        //canvas also doesn't support linking, but we can pass this as well
        if (this.__fontHref) {
            data.href = this.__fontHref;
        }

        return data;
    };

    /**
     * Helper to link text fragments
     * @param font
     * @param element
     * @return {*}
     * @private
     */
    ctx.prototype.__wrapTextLink = function (font, element) {
        if (font.href) {
            var a = this.__createElement("a");
            a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
            a.appendChild(element);
            return a;
        }
        return element;
    };

    /**
     * Fills or strokes text
     * @param text
     * @param x
     * @param y
     * @param action - stroke or fill
     * @private
     */
    ctx.prototype.__applyText = function (text, x, y, action) {
        var font = this.__parseFont(),
            parent = this.__closestGroupOrSvg(),
            textElement = this.__createElement("text", {
                "font-family" : font.family,
                "font-size" : font.size,
                "font-style" : font.style,
                "font-weight" : font.weight,
                "text-decoration" : font.decoration,
                "x" : x,
                "y" : y,
                "text-anchor": getTextAnchor(this.textAlign),
                "dominant-baseline": getDominantBaseline(this.textBaseline)
            }, true);

        textElement.appendChild(this.__document.createTextNode(text));
        this.__currentElement = textElement;
        this.__applyStyleToCurrentElement(action);
        parent.appendChild(this.__wrapTextLink(font,textElement));
    };

    /**
     * Creates a text element
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.fillText = function (text, x, y) {
        this.__applyText(text, x, y, "fill");
    };

    /**
     * Strokes text
     * @param text
     * @param x
     * @param y
     */
    ctx.prototype.strokeText = function (text, x, y) {
        this.__applyText(text, x, y, "stroke");
    };

    /**
     * No need to implement this for svg.
     * @param text
     * @return {TextMetrics}
     */
    ctx.prototype.measureText = function (text) {
        this.__ctx.font = this.font;
        return this.__ctx.measureText(text);
    };

    /**
     *  Arc command!
     */
    ctx.prototype.arc = function (x, y, radius, startAngle, endAngle, counterClockwise) {
        // in canvas no circle is drawn if no angle is provided.
        if (startAngle === endAngle) {
            return;
        }
        startAngle = startAngle % (2*Math.PI);
        endAngle = endAngle % (2*Math.PI);
        if (startAngle === endAngle) {
            //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)
            endAngle = ((endAngle + (2*Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2*Math.PI);
        }
        var endX = x+radius*Math.cos(endAngle),
            endY = y+radius*Math.sin(endAngle),
            startX = x+radius*Math.cos(startAngle),
            startY = y+radius*Math.sin(startAngle),
            sweepFlag = counterClockwise ? 0 : 1,
            largeArcFlag = 0,
            diff = endAngle - startAngle;

        // https://github.com/gliffy/canvas2svg/issues/4
        if (diff < 0) {
            diff += 2*Math.PI;
        }

        if (counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
        } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
        }

        this.lineTo(startX, startY);
        this.__addPathCommand(format("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {rx:radius, ry:radius, xAxisRotation:0, largeArcFlag:largeArcFlag, sweepFlag:sweepFlag, endX:endX, endY:endY}));

        this.__currentPosition = {x: endX, y: endY};
    };

    /**
     * Generates a ClipPath from the clip command.
     */
    ctx.prototype.clip = function () {
        var group = this.__closestGroupOrSvg(),
            clipPath = this.__createElement("clipPath"),
            id =  randomString(this.__ids),
            newGroup = this.__createElement("g");

        this.__applyCurrentDefaultPath();
        group.removeChild(this.__currentElement);
        clipPath.setAttribute("id", id);
        clipPath.appendChild(this.__currentElement);

        this.__defs.appendChild(clipPath);

        //set the clip path to this group
        group.setAttribute("clip-path", format("url(#{id})", {id:id}));

        //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations
        // to this path
        group.appendChild(newGroup);

        this.__currentElement = newGroup;

    };

    /**
     * Draws a canvas, image or mock context to this canvas.
     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
     */
    ctx.prototype.drawImage = function () {
        //convert arguments to a real array
        var args = Array.prototype.slice.call(arguments),
            image=args[0],
            dx, dy, dw, dh, sx=0, sy=0, sw, sh, parent, svg, defs, group,
            currentElement, svgImage, canvas, context, id;

        if (args.length === 3) {
            dx = args[1];
            dy = args[2];
            sw = image.width;
            sh = image.height;
            dw = sw;
            dh = sh;
        } else if (args.length === 5) {
            dx = args[1];
            dy = args[2];
            dw = args[3];
            dh = args[4];
            sw = image.width;
            sh = image.height;
        } else if (args.length === 9) {
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        } else {
            throw new Error("Invalid number of arguments passed to drawImage: " + arguments.length);
        }

        parent = this.__closestGroupOrSvg();
        currentElement = this.__currentElement;
        var translateDirective = "translate(" + dx + ", " + dy + ")";
        if (image instanceof ctx) {
            //canvas2svg mock canvas context. In the future we may want to clone nodes instead.
            //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.
            svg = image.getSvg().cloneNode(true);
            if (svg.childNodes && svg.childNodes.length > 1) {
                defs = svg.childNodes[0];
                while(defs.childNodes.length) {
                    id = defs.childNodes[0].getAttribute("id");
                    this.__ids[id] = id;
                    this.__defs.appendChild(defs.childNodes[0]);
                }
                group = svg.childNodes[1];
                if (group) {
                    //save original transform
                    var originTransform = group.getAttribute("transform");
                    var transformDirective;
                    if (originTransform) {
                        transformDirective = originTransform+" "+translateDirective;
                    } else {
                        transformDirective = translateDirective;
                    }
                    group.setAttribute("transform", transformDirective);
                    parent.appendChild(group);
                }
            }
        } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            //canvas or image
            svgImage = this.__createElement("image");
            svgImage.setAttribute("width", dw);
            svgImage.setAttribute("height", dh);
            svgImage.setAttribute("preserveAspectRatio", "none");

            if (sx || sy || sw !== image.width || sh !== image.height) {
                //crop the image using a temporary canvas
                canvas = this.__document.createElement("canvas");
                canvas.width = dw;
                canvas.height = dh;
                context = canvas.getContext("2d");
                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
                image = canvas;
            }
            svgImage.setAttribute("transform", translateDirective);
            svgImage.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href",
                image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src"));
            parent.appendChild(svgImage);
        }
    };

    /**
     * Generates a pattern tag
     */
    ctx.prototype.createPattern = function (image, repetition) {
        var pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id = randomString(this.__ids),
            img;
        pattern.setAttribute("id", id);
        pattern.setAttribute("width", image.width);
        pattern.setAttribute("height", image.height);
        if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttribute("width", image.width);
            img.setAttribute("height", image.height);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href",
                image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src"));
            pattern.appendChild(img);
            this.__defs.appendChild(pattern);
        } else if (image instanceof ctx) {
            pattern.appendChild(image.__root.childNodes[1]);
            this.__defs.appendChild(pattern);
        }
        return new CanvasPattern(pattern, this);
    };

    ctx.prototype.setLineDash = function (dashArray) {
        if (dashArray && dashArray.length > 0) {
            this.lineDash = dashArray.join(",");
        } else {
            this.lineDash = null;
        }
    };

    /**
     * Not yet implemented
     */
    ctx.prototype.drawFocusRing = function () {};
    ctx.prototype.createImageData = function () {};
    ctx.prototype.getImageData = function () {};
    ctx.prototype.putImageData = function () {};
    ctx.prototype.globalCompositeOperation = function () {};
    ctx.prototype.setTransform = function () {};

    var path2d = function(doc) {
        this.__document = doc

        this.__currentDefaultPath = "";
        this.__currentPosition = {};
        this.__currentElement = {nodeName: "path"} // satisfy check in moveTo

        //this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
        //this.beginPath()
    }

   // path2d.prototype.__createElement = ctx.prototype.__createElement
   // path2d.prototype.__closestGroupOrSvg = ctx.prototype.__closestGroupOrSvg
    path2d.prototype.__addPathCommand = ctx.prototype.__addPathCommand
   // path2d.prototype.beginPath = ctx.prototype.beginPath
    path2d.prototype.closePath = ctx.prototype.closePath
    path2d.prototype.moveTo = ctx.prototype.moveTo
    path2d.prototype.lineTo = ctx.prototype.lineTo
    path2d.prototype.bezierCurveTo = ctx.prototype.bezierCurveTo
    path2d.prototype.quadraticCurveTo = ctx.prototype.quadraticCurveTo
    path2d.prototype.arc = ctx.prototype.arc
    path2d.prototype.arcTo = ctx.prototype.arcTo
    path2d.prototype.ellipse = ctx.prototype.ellipse
    path2d.prototype.rect = ctx.prototype.rect
    path2d.prototype.addPath = function() { throw new Error("unimplemented") }


    ctx.prototype.makePath2D = function() {
        return new path2d(this.__document)
    }


    //add options for alternative namespace
    if (typeof window === "object") {
        window.C2S = ctx;
    }

    // CommonJS/Browserify
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = ctx;
    }

}());

"use strict"
// inspired by https://github.com/PitPik/colorPicker

var ColorPicker = (function(){

function addTextChild(elem, txt) {
    let dummy = document.createElement("DIV")
    dummy.innerHTML = txt
    let ne = dummy.firstChild
    elem.appendChild(ne)
    return ne
}

function addSiblingAfter(elem, txt) {
    let dummy = document.createElement("DIV")
    dummy.innerHTML = txt
    let ne = dummy.firstChild
    elem.parentNode.insertBefore(ne, elem.nextSibling)
    return ne
}

function HSVtoRGBx(h, s, v, into) {
    let r, g, b, i, f, p, q, t;

    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    if (!into)
        into = {}
    into.r = Math.round(r * 255),
    into.g = Math.round(g * 255),
    into.b = Math.round(b * 255)
    return into
}


function RGBtoHSVx(r, g, b, into) {
    r = r / 255;
    g = g / 255;
    b = b / 255;

    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max, is_gray = false;

    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
        is_gray = true
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    into.h = h
    into.s = s
    into.v = v
    into.is_gray = is_gray;
}

// https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately/54024653#54024653
// input ranges [0-1] on all, output [0-255]
function HSVtoRGB(h,s,v, into) 
{              
    h *= 360                
    let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);     
    //return [f(5),f(3),f(1)];     
    if (!into)
        into = {}      
    into.r = Math.round(f(5)*255)
    into.g = Math.round(f(3)*255)
    into.b = Math.round(f(1)*255)
    return into
}   
// input range [0-255], output [0-1]
function RGBtoHSV(r,g,b, into) {
    r = r / 255;
    g = g / 255;
    b = b / 255;

    let v=Math.max(r,g,b), c=v-Math.min(r,g,b);
    let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); 
    //return [60*(h<0?h+6:h), v&&c/v, v];
    if (!into)
        into = {}      
    into.h = 60*(h<0?h+6:h)/360
    into.s = v&&c/v
    into.v = v
    into.is_gray = (r == g) && (g == b)
    return into
}


// from https://github.com/jmthompson2015/colors/blob/47a1d08d41c03ad2219459155d82bd7d9fcf0bfc/model/ColorUtilities.js
function HSLtoRGB(h0, s0, l0, into) {
    const h = h0 / 360;
    const s = s0 / 100;
    const l = l0 / 100;
    let r, g, b, is_gray;
  
    if (s === 0) {
      r = l; // achromatic
      g = l; // achromatic
      b = l; // achromatic
      is_gray = true
    } else {
      const hue2rgb = (p, q, t0) => {
        let t = t0;
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };
  
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
  
    into.r = Math.round(r * 255)
    into.g = Math.round(g * 255)
    into.b = Math.round(b * 255)
    into.is_gray = true
}
  

function RGBtoHSL(r0, g0, b0, into) {
    const r = r0 / 255;
    const g = g0 / 255;
    const b = b0 / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h;
    let s;
    const l = (max + min) / 2;
  
    if (max === min) {
      h = 0; // achromatic
      s = 0; // achromatic
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          throw new Error(`Unknown max: ${max}`);
      }
      h /= 6;
    }
  
    into.h = h * 360
    into.s = s * 100
    into.l = l * 100
}


const MARGIN = 10
const BAR_SZ = 18
const BAR_SPACE = 3 // space between bar and square
const ARROW_SZ = 5
const ALPHA_BAR_WIDTH = BAR_SZ + BAR_SPACE
const CHECKERS = { width:9, light:255, dark: 150 }

function draw_chart(ctx, cfg, sel_col, sel_pos, presets, options) {
    ctx.fillStyle = "#bbb"
    let width = cfg.sz, height = cfg.sz
    if (options.with_alpha)
        width += ALPHA_BAR_WIDTH
    ctx.fillRect(0, 0, width, height);
    
    let id = ctx.getImageData(0, 0, width, height)
    let d = id.data;
    
    let sq_sz = height - MARGIN - MARGIN - BAR_SZ - BAR_SPACE
    cfg.sq_sz = sq_sz
    
    // square
    for(let x = 0; x < sq_sz; ++x) {
        for(let y = 0; y < sq_sz; ++y) {
            let rgb = HSVtoRGB(sel_col.h, x/sq_sz, (sq_sz-y)/sq_sz)
            let i = ((x+MARGIN) + (y+MARGIN)*width)*4
            d[i] = rgb.r
            d[i+1] = rgb.g
            d[i+2] = rgb.b
        }
    }
    
    // hue bar
    cfg.bar_x = MARGIN+sq_sz+BAR_SPACE
    cfg.bar_y = MARGIN+sq_sz+BAR_SPACE
    for(let y = 0; y < sq_sz; ++y) {
        let rgb = HSVtoRGB(y/sq_sz, 1, 1)
        for(let x = 0; x < BAR_SZ; ++x) {
            let i = ((x+cfg.bar_x) + (y+MARGIN)*width)*4
            d[i] = rgb.r
            d[i+1] = rgb.g
            d[i+2] = rgb.b        
        }
    }
    
    // square of selected color
    for(let x = 0; x < BAR_SZ; ++x) {
        for(let y = 0; y < BAR_SZ; ++y) {
            let i = ((x+cfg.bar_x) + (y+cfg.bar_y)*width)*4
            d[i] = sel_col.r
            d[i+1] = sel_col.g
            d[i+2] = sel_col.b      
        }
    }

    if (options.with_alpha) {
        // alpha bar fill
        cfg.alpha_bar_x = MARGIN+sq_sz+BAR_SPACE+BAR_SZ+BAR_SPACE
        for(let y = 0; y < sq_sz; ++y) {
            let alpha = 1 - y/(sq_sz-1)
            let ch_y = Math.trunc(y / CHECKERS.width) % 2
            for(let x = 0; x < BAR_SZ; ++x) {
                let ch_x = Math.trunc(x / CHECKERS.width) % 2
                let checkers = (ch_y == ch_x) ? CHECKERS.light : CHECKERS.dark
                let i = ((x+cfg.alpha_bar_x) + (y+MARGIN)*width)*4
                d[i] = sel_col.r*alpha + checkers*(1-alpha)
                d[i+1] = sel_col.g*alpha + checkers*(1-alpha)
                d[i+2] = sel_col.b*alpha + checkers*(1-alpha)
            }
        }        
    }

    if (options.with_null) {

    }

    ctx.putImageData(id, 0, 0)
        
    // circle selector in square   
    ctx.lineWidth = 1
    ctx.strokeStyle = sel_col.is_dark ? "#ffffff" : "#000000"
    ctx.beginPath()
    ctx.arc( sel_pos.sq_x * sq_sz + MARGIN, sel_pos.sq_y * sq_sz + MARGIN, 5, 0, 2*Math.PI)
    ctx.stroke();
    
    // arrow selector in bar
    let saturated_rgb = HSVtoRGB(sel_col.h, 1, 1)
    ctx.fillStyle = is_dark(saturated_rgb) ? "#ffffff" : "#000000"
    ctx.beginPath()
    let mid_y = sel_pos.bar_y * sq_sz + MARGIN
    ctx.moveTo(cfg.bar_x + ARROW_SZ, mid_y) // center
    ctx.lineTo(cfg.bar_x, mid_y - ARROW_SZ) // up
    ctx.lineTo(cfg.bar_x, mid_y + ARROW_SZ) // down
    ctx.fill();

    if (options.with_alpha) {
        // alpha arrow
        let alpha_mid_y = sel_pos.alpha_y * sq_sz + MARGIN
        ctx.beginPath()
        ctx.moveTo(cfg.alpha_bar_x + ARROW_SZ, alpha_mid_y) // center
        ctx.lineTo(cfg.alpha_bar_x, alpha_mid_y - ARROW_SZ) // up
        ctx.lineTo(cfg.alpha_bar_x, alpha_mid_y + ARROW_SZ) // down
        ctx.fill();
    }

    // preset squares
    ctx.lineWidth = 1
    ctx.strokeStyle = '#000'

    cfg.preset_count = Math.trunc(sq_sz/BAR_SZ)
    for(let i = 0; i < cfg.preset_count; ++i) {
        let x = MARGIN + i*BAR_SZ + 1
        let y = cfg.bar_y
        if (presets[i] !== undefined) {
            ctx.fillStyle = presets[i].hex
            ctx.fillRect(x, y, BAR_SZ, BAR_SZ-1)
        }
        ctx.strokeRect(x + 0.5, y + 0.5, BAR_SZ, BAR_SZ-1)
    }
    
    // border of square of selected color
    ctx.strokeRect(cfg.bar_x + 0.5, cfg.bar_y + 0.5, BAR_SZ - 1, BAR_SZ-1)

    // icon for capture (droper)
    if (options.with_alpha) { // otherwise there's no place for it
        const icon_x = cfg.alpha_bar_x + BAR_SZ/2, icon_y = cfg.bar_y + BAR_SZ/2
        const crosshair_hlen = BAR_SZ*0.5
        ctx.beginPath()
        ctx.arc(icon_x+0.5, icon_y+0.5, BAR_SZ*0.35, 0, Math.PI*2)
        ctx.moveTo(icon_x+0.5, icon_y-crosshair_hlen)
        ctx.lineTo(icon_x+0.5, icon_y+crosshair_hlen+1)
        ctx.moveTo(icon_x-crosshair_hlen, icon_y+0.5)
        ctx.lineTo(icon_x+crosshair_hlen+1, icon_y+0.5)
        ctx.stroke()
    }
}

function clamp(x) {
    if (x < 0)
        return 0;
    if (x > 1)
        return 1;
    return x;
}

// from https://github.com/antimatter15/rgb-lab/blob/master/color.js
function lab_L(c) {
    let r = c.r / 255, g = c.g / 255, b = c.b / 255
    r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  
    let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
    y = (y > 0.008856) ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
    y = (116 * y) - 16

    return y
}

function is_dark(c) {
    return lab_L(c) < 50
}

function make_hex(c, force_no_alpha) {
    console.assert(!isNaN(c.r) && !isNaN(c.g) && !isNaN(c.b) && !isNaN(c.alpha), "NaN color")
    if (c.alpha == 1 || force_no_alpha)
        return "#" + (Number(c.r).toString(16).padStart(2,'0') + Number(c.g).toString(16).padStart(2,'0') + Number(c.b).toString(16).padStart(2,'0')).toUpperCase()
    else
        return "rgba(" + c.r + "," + c.g + "," + c.b + "," + ((c.alpha==null)?null:c.alpha.toFixed(2)) + ")"
}

function parse_hex(s) {
    let ret = null
    if (s === null)
        return null
    s = s.trim()
    if (s[0] == 'r') {
        const with_alpha = s.substr(0,5) == 'rgba('
        if (s.substr(0,4) == 'rgb(' || with_alpha) {
            const sp = s.substr(4 + (with_alpha?1:0)).split(',')
            ret = { r: parseInt(sp[0]), g: parseInt(sp[1]), b: parseInt(sp[2]), alpha:1, alphai:255 }
            if (with_alpha) {
                const a = parseFloat(sp[3])
                ret.alpha  = a, ret.alphai = Math.round(a*255)
            }
        }
    }
    else if (s[0] == 'h') {
        ret = {}
        // doesn't need the `%` at the end of the s and l
        const with_alpha = s.substr(0,5) == 'hsla('
        if (s.substr(0,4) == 'hsl(' || with_alpha) {
            const sp = s.substr(4 + (with_alpha?1:0)).split(',')
            HSLtoRGB(parseInt(sp[0]), parseInt(sp[1]), parseInt(sp[2]), ret)
            if (with_alpha) {
                const a = parseFloat(sp[3])
                ret.alpha = a; ret.alphai = Math.round(a*255)
            }
            else {
                ret.alpha = 1; ret.alphai = 255;
            }
        }
    }
    else {
        if (s[0] == '#') // can do without it
            s = s.substr(1)
        if (s.length == 6)
            ret = { r: parseInt(s.substr(0,2), 16), g: parseInt(s.substr(2,2), 16), b: parseInt(s.substr(4,2), 16), alpha:1, alphai:255 }
        else if (s.length == 3) {
            ret =  { r: parseInt(s[0]+s[0], 16), g: parseInt(s[1]+s[1], 16), b: parseInt(s[2]+s[2], 16), alpha:1, alphai:255 }
        }
    }
    if (ret != null && (isNaN(ret.r) || isNaN(ret.g) || isNaN(ret.b) || isNaN(ret.alpha)))
        return null
    return ret
}

function parse_hex_user(s) {
    let r = parse_hex(s)
    if (r === null)
        return null
    r.hex = make_hex(r)
    return r
}

function create_after(elem, sz, visible, onchange, options, start_value) {
    return create_at(elem, addSiblingAfter, sz, visible, onchange, options, start_value)
}
function create_as_child(elem, sz, visible, onchange, options, start_value) {
    return create_at(elem, addTextChild, sz, visible, onchange, options, start_value)
}

var CHECKERS_IMAGE = null

function create_checkers_image(canvas, ctx) {
    let orig_width = canvas.width, orig_height = canvas.height
    let w = CHECKERS.width, l = CHECKERS.light, d = CHECKERS.dark
    canvas.width = w*2
    canvas.height = w*2
    ctx.fillStyle = "rgb(" + l + "," + l + "," + l + ")"
    ctx.fillRect(0,0,w*2,w*2)
    ctx.fillStyle = "rgb(" + d + "," + d + "," + d + ")"
    ctx.fillRect(0,0,w,w)
    ctx.fillRect(w+1,w+1,w,w)
    CHECKERS_IMAGE = canvas.toDataURL('PNG')
    canvas.width = orig_width
    canvas.height = orig_height
}
function get_checkers_image() {
    return CHECKERS_IMAGE
}

var GLOBAL_PRESETS = {}

// options: { with_alpha:true/false, with_null:true/false, global_presets:true/false }
function create_at(elem, add_func, sz, visible, onchange, options, start_color) 
{
    if (options === undefined)
        options = {}
    let width=sz, height=sz
    if (options.with_alpha) 
        width += ALPHA_BAR_WIDTH
    if (options.global_presets !== false)
        options.global_presets = true
    if (!options.myAddEventListener)
        options.myAddEventListener = function(elem, name, func) { elem.addEventListener(name, func) }
    
    let txt = '<canvas width="WIDTH" height="HEIGHT" STYLE></canvas>'.replace(/WIDTH/g, width).replace(/HEIGHT/g, height)
                .replace(/STYLE/g, visible ? '' : 'style="display:none;"')
    let canvas = add_func(elem, txt)
    canvas.style.borderRadius = "7px"
    canvas.tabIndex = 0  // make it focusable so that the interfaction with the edit box works
    canvas.style.outline = "none"  // but don't put a focus border on it
    canvas.style.zIndex = 100  // don't allow other stuff from around to change the cursor
    let ctx = canvas.getContext("2d")

    //if (options.with_alpha && CHECKERS_IMAGE === null) 
    //    create_checkers_image(canvas, ctx) // for use in the html input element
    
    let cfg = { sz:sz }
    let sel_col = { h:0, s:0, v:0, r:null, g:null, b:null, alpha:1, alphai:255, hex:"", copy: function() {
        return { r:this.r, g:this.g, b:this.b, hex:this.hex, alpha:this.alpha, alphai:this.alphai }
    }}
    let sel_pos = { sq_x: 0, sq_y: 0, bar_y: 0, alpha_y: 0 } // range:0-1
    let presets = options.global_presets ? GLOBAL_PRESETS : {}

    let do_draw_chart = function() {
        draw_chart(ctx, cfg, sel_col, sel_pos, presets, options)
    }
    
    let col_from_pos = function() {
        sel_col.h = sel_pos.bar_y
        sel_col.s = sel_pos.sq_x
        sel_col.v = 1-sel_pos.sq_y
        sel_col.alphai = Math.round((1-sel_pos.alpha_y)*255)
        sel_col.alpha = sel_col.alphai/255
        HSVtoRGB(sel_col.h, sel_col.s, sel_col.v, sel_col)
        sel_col.is_dark = is_dark(sel_col);
        sel_col.hex = make_hex(sel_col)
        sel_col.hex_no_alpha = make_hex(sel_col, true)
        if (onchange)
            onchange(sel_col)
    }

    let get_color = function() {
        return sel_col
    }
    
    let set_color = function(c, trigger_level1=true, trigger_level2=true) {
        if (c === sel_col)
            return  // avoid infinite recursion though user code
        if (typeof c == "string")
            c = parse_hex(c)
        if (c === undefined || c == null)
            return
        console.assert(c.r !== undefined && !isNaN(c.r) && c.g !== undefined && !isNaN(c.g) && c.b !== undefined && !isNaN(c.b))
        if (!is_first_change) // the following can happen on the first change if the input is nulls, we still want to draw the chart though
            if (c.r == sel_col.r && c.g == sel_col.g && c.b == sel_col.b && (c.alpha == sel_col.alpha || c.alphai == sel_col.alphai))
                return
        RGBtoHSV(c.r, c.g, c.b, sel_col)
        sel_col.r = c.r
        sel_col.g = c.g
        sel_col.b = c.b
        if (c.alpha !== undefined) {
            console.assert(!isNaN(c.alpha))
            sel_col.alpha = c.alpha
            sel_col.alphai = (c.alpha==null)?null:Math.round(c.alpha * 255)
        }
        else { // alphai is integer alpha in the range of [0-255]
            console.assert(c.alphai !== undefined && !isNaN(c.alphai))
            sel_col.alpha = (c.alphai==null)?null:(c.alphai / 255)
            sel_col.alphai = c.alphai
        }

        sel_col.is_dark = is_dark(sel_col);
        sel_col.hex = make_hex(sel_col)
        sel_col.hex_no_alpha = make_hex(sel_col, true)
        
        sel_pos.sq_x = sel_col.s
        sel_pos.sq_y = 1-sel_col.v
        if (!sel_col.is_gray)  // if it doesn't have hue, don't move the hue bar
            sel_pos.bar_y = sel_col.h 
        else  // get the hue value from the UI instead
            sel_col.h = sel_pos.bar_y
        sel_pos.alpha_y = 1-sel_col.alpha
        if (visible)
            do_draw_chart()
        if (trigger_level1 && onchange)
            onchange(sel_col, trigger_level2)
    }

    let is_first_change = true
    set_color(start_color || "#cccccc", true, false) // need to_change in order to update the attached edit input
    is_first_change = false

    // handle color change by draggin gand clicking
    let square_capture = false;
    let bar_capture = false;
    let alpha_capture = false;
    let mouse_act = function(e, isondown) {
        // if pressed, make sure it's pressed in us. If moving, make sure we're capturing it
        //console.log(canvas.id + "  capt=" + square_capture)
        if (!( (e.buttons == 1 && e.target === canvas) || square_capture || bar_capture))
            return false
        //console.log(canvas.id + " INNNN")
        let rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        let changed = false
        // square
        if (!bar_capture && !alpha_capture && (square_capture || (x > MARGIN && y > MARGIN && x < cfg.sq_sz+MARGIN && y < cfg.sq_sz+MARGIN))) {
            if (isondown)
                square_capture = true
            sel_pos.sq_x = clamp((x - MARGIN)/cfg.sq_sz)
            sel_pos.sq_y = clamp((y - MARGIN)/cfg.sq_sz)
            changed = true
        } // hue
        else if (bar_capture || (x > cfg.bar_x && y > MARGIN && x < cfg.bar_x + BAR_SZ && y < cfg.sq_sz+MARGIN)) {
            if (isondown)
                bar_capture = true
            sel_pos.bar_y = clamp((y - MARGIN)/cfg.sq_sz)
            changed = true
        } // alpha
        else if (alpha_capture || (options.with_alpha && x > cfg.alpha_bar_x && y > MARGIN && x < cfg.alpha_bar_x + BAR_SZ && y < cfg.sq_sz+MARGIN)) {
            if (isondown)
                alpha_capture = true
            sel_pos.alpha_y = clamp((y - MARGIN)/cfg.sq_sz)
            changed = true
        } // droper icon 
        else if (options.with_alpha && options.dropper && x > cfg.alpha_bar_x && x < cfg.alpha_bar_x + BAR_SZ && y > cfg.bar_y && y < cfg.bar_y + BAR_SZ) {
            options.dropper(set_color)
        }

        if (changed) {
            col_from_pos()
            do_draw_chart()
        }
        return changed
    }
    
    let mouse_move = function(e) {
        mouse_act(e)
    }
    options.myAddEventListener(document, "mouseup", function(e) {
        square_capture = false;
        bar_capture = false;
        alpha_capture = false;
        document.removeEventListener("mousemove", mouse_move)
        return true
    })
    
    options.myAddEventListener(canvas, "mousedown", function(e) {
        let do_capture = mouse_act(e, true)
        if (do_capture) {
            options.myAddEventListener(document, "mousemove", mouse_move)
        }                
    })

    // handle presets click
    options.myAddEventListener(canvas, "mouseup", function(e) {
        if (e.which != 1)
            return
        let rect = e.target.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
    
        // on selected color
        if (x > cfg.bar_x && y > cfg.bar_y && x < cfg.bar_x + BAR_SZ && y < cfg.bar_y + BAR_SZ) {
            if (presets.next_to_set === undefined)
                presets.next_to_set = 0
            presets[presets.next_to_set] = { hex:sel_col.hex, r:sel_col.r, g:sel_col.g, b:sel_col.b, alpha:sel_col.alpha }
            presets.next_to_set = (presets.next_to_set + 1) % cfg.preset_count
            do_draw_chart()
        }
        // presets bar
        if (x > MARGIN && y > cfg.bar_y && x < cfg.sq_sz && y < cfg.bar_y + BAR_SZ) {
            let xi = Math.trunc((x - MARGIN)/BAR_SZ)
            set_color(presets[xi], true)
        }
    })
    
    let set_visible = function(v) {
        canvas.style.display = v ? 'initial':'none'
        if (v && !visible)
            do_draw_chart()
        visible = v
    }
    
    return { set_color:set_color, get_color:get_color, set_visible:set_visible, elem:canvas }
}

return { create_as_child:create_as_child, 
         create_after:create_after, 
         parse_hex:parse_hex_user, 
         make_hex:make_hex,
         get_checkers_image:get_checkers_image, 
         CHECKERS: CHECKERS,
         get_presets:()=>{ return GLOBAL_PRESETS }, set_presets:(v)=>{ GLOBAL_PRESETS=v},
         HSVtoRGB: HSVtoRGB, RGBtoHSV: RGBtoHSV, HSLtoRGB:HSLtoRGB }

})();


var ColorEditBox = (function(){
var DEBUG_NO_BLUR = false
var OPEN_POS_LEFTOF_BOTTOM_LEFT = 1
function create_at(edit_elem, sz, onchange, options, start_value) 
{
    let picker = ColorPicker.create_after(edit_elem, sz, false, function(c, trigger_level2=true) { 
        if (document.activeElement != edit_elem)
            edit_elem.value = c.hex  // change the text only if we're not editing
        edit_elem.style.backgroundColor = c.hex_no_alpha
        edit_elem.style.color = c.is_dark ? "#fff" : "#000"
        if (onchange && trigger_level2)
            onchange(c)
    }, options, start_value)
    picker.elem.style.position = "fixed"
    edit_elem.spellcheck = false
    let position_to_edit_elem
    if (options.open_pos === OPEN_POS_LEFTOF_BOTTOM_LEFT) {
        position_to_edit_elem = ()=>{
            let ed_rect = edit_elem.getBoundingClientRect()
            picker.elem.style.top = ed_rect.bottom - sz + "px"
            picker.elem.style.left = ed_rect.right + window.scrollX + 2 + "px"
        }
    }
    else { // where to open the picker, default, top-left corner is below element
        position_to_edit_elem = ()=>{
            let ed_rect = edit_elem.getBoundingClientRect()
            picker.elem.style.top = ed_rect.bottom + window.scrollY + 2 + "px"
            picker.elem.style.left = ed_rect.left + window.scrollX + "px"
        }
    }

    // opt.focus_func can be set by the user to get events when thee picker and edit go in and out of focus
    let picker_set_color = picker.set_color
    picker.set_color = function(c, trigger=true) {
        picker_set_color(c, true, trigger) 
        // the edit box update always need to be updated, and the boolean actuall says if the outside onchange is triggered
    }
    
    options.myAddEventListener(edit_elem, "input", function() {
        picker.set_color(edit_elem.value, true)
    })
    
    options.myAddEventListener(edit_elem, "focus", function() { 
        position_to_edit_elem(); 
        picker.set_visible(true) 
        if (options.focus_func)
            options.focus_func(true)
    })
    if (!DEBUG_NO_BLUR) {
        options.myAddEventListener(edit_elem, "blur", function(e) { 
            if (e.relatedTarget !== picker.elem) { // if focus moved from the edit to something not the canvas, hide it
                picker.set_visible(false) 
                if (options.focus_func)
                    options.focus_func(false)
            }
        })
    }
    
    options.myAddEventListener(picker.elem, "focus", function() { 
        //console.log("canvas-focus") 
    })
    if (!DEBUG_NO_BLUR) {
        options.myAddEventListener(picker.elem, "blur", function(e) { 
            if (e.relatedTarget !== edit_elem) {
                picker.set_visible(false) 
                if (options.focus_func)
                    options.focus_func(false)                
            }
        })
    }
    
    return picker
}

return { create_at:create_at }
})();







"use strict"

var selected_nodes = []
function add_selected_node(n) {
    selected_nodes.push(n)
}
function remove_selected_node(n) {
    arr_remove_is(selected_nodes, n)
}


const TERM_RADIUS = 8
const TERM_MARGIN_X = 20
const TERM_MARGIN_Y = 2
const VAR_TERM_MARGIN = 8

const NODE_WIDTH = 120
const NODE_HEIGHT = 30

const TEMPLATE_LINE_COLOR = "#de77f1"
const TEMPLATE_LINE_COLOR_V = [0xde, 0x77, 0xf1]


// https://github.com/gdenisov/cardinal-spline-js/blob/master/curve_func.min.js
//function curve(d,j,u,g,c){u=(typeof u==="number")?u:0.5;g=g?g:25;var k,e=1,f=j.length,o=0,n=(f-2)*g+2+(c?2*g:0),m=new Float32Array(n),a=new Float32Array((g+2)*4),b=4;k=j.slice(0);if(c){k.unshift(j[f-1]);k.unshift(j[f-2]);k.push(j[0],j[1])}else{k.unshift(j[1]);k.unshift(j[0]);k.push(j[f-2],j[f-1])}a[0]=1;for(;e<g;e++){var p=e/g,q=p*p,s=q*p,r=s*2,t=q*3;a[b++]=r-t+1;a[b++]=t-r;a[b++]=s-2*q+p;a[b++]=s-q}a[++b]=1;h(k,a,f);if(c){k=[];k.push(j[f-4],j[f-3],j[f-2],j[f-1]);k.push(j[0],j[1],j[2],j[3]);h(k,a,4)}function h(H,A,C){for(var B=2,I;B<C;B+=2){var D=H[B],E=H[B+1],F=H[B+2],G=H[B+3],J=(F-H[B-2])*u,K=(G-H[B-1])*u,L=(H[B+4]-D)*u,M=(H[B+5]-E)*u;for(I=0;I<g;I++){var v=I<<2,w=A[v],x=A[v+1],y=A[v+2],z=A[v+3];m[o++]=w*D+x*F+y*J+z*L;m[o++]=w*E+x*G+y*K+z*M}}}f=c?0:j.length-2;m[o++]=j[f];m[o]=j[f+1];for(e=0,f=m.length;e<f;e+=2){d.lineTo(m[e],m[e+1])}return m}
// maybe better: https://github.com/Raymond-C/CubicHermite

/*
function connector_line_s(fx, fy, tx, ty) { // from, to
    ctx_nodes.beginPath()
    ctx_nodes.moveTo(fx, fy)
    ctx_nodes.lineTo(tx, ty)
    ctx_nodes.strokeStyle = "#000"
    ctx_nodes.lineWidth = 2
    ctx_nodes.stroke()    
}
*/

function draw_curve(ctx, cpnts) {
    ctx.moveTo(cpnts[0], cpnts[1])
    for(let i=2; i<cpnts.length; i+=2)
        ctx.lineTo(cpnts[i], cpnts[i+1])
}

const LINE_ARROW = {out:7, back:14}

function connector_line(fx, fy, fxoffset, tx, ty, txoffset, free, uid, kind) { // from, to
    let dy = ty - fy, dx = tx - fx
    let cpnts;
    if (ty - 2*TERM_RADIUS -5 > fy || Math.sqrt(dx*dx+dy*dy) < 70 || free || kind == KIND_VARS) {// going down or very short        
        cpnts = getCurvePoints([fx,fy, 
                                    fx+dx*0.16, fy+dy*0.3, 
                                    tx-dx*0.16, ty-dy*0.3,  
                                    tx, ty])
    }
    else {
        if (tx > fx) {
            // go over the upper left corner of destination and under lower right corner of source
            let pnts = [fx, fy, fx + NODE_WIDTH-fxoffset, fy + TERM_RADIUS, tx-txoffset, ty - TERM_RADIUS - 5, tx, ty]
            cpnts = getCurvePoints(pnts, 0.5)
        }
        else {
            let pnts = [fx, fy, fx - fxoffset, fy + TERM_RADIUS, tx+NODE_WIDTH-txoffset, ty - TERM_RADIUS - 5, tx, ty]
            cpnts = getCurvePoints(pnts)
        }
        
    }

    nodes_draw_start()
    ctx_nodes.beginPath()
    draw_curve(ctx_nodes, cpnts)

    {
        let arrow_at = Math.round(cpnts.length*0.6*0.5)*2
        let ac1_x = cpnts[arrow_at], ac1_y = cpnts[arrow_at+1], ac2_x = cpnts[arrow_at+2], ac2_y = cpnts[arrow_at+3]
        let dx = ac2_x-ac1_x, dy=ac2_y-ac1_y
        let len = Math.sqrt(dx*dx+dy*dy)
        dx /= len; dy /= len
        let pdx = -dy, pdy = dx
        let p1_x = ac2_x - pdx*LINE_ARROW.out -dx*LINE_ARROW.back
        let p1_y = ac2_y - pdy*LINE_ARROW.out -dy*LINE_ARROW.back
        let p2_x = ac2_x + pdx*LINE_ARROW.out -dx*LINE_ARROW.back
        let p2_y = ac2_y + pdy*LINE_ARROW.out -dy*LINE_ARROW.back

        ctx_nodes.moveTo(p1_x, p1_y)
        ctx_nodes.lineTo(ac2_x, ac2_y)
        ctx_nodes.lineTo(p2_x, p2_y)
    }

    if (kind === KIND_VARS)
        ctx_nodes.strokeStyle = LINE_COLOR_VARS
    else if (kind === KIND_FLOW_ANIM)
        ctx_nodes.strokeStyle = LINE_COLOR_ANIM_FLOW
    else
        ctx_nodes.strokeStyle = "#aaa"
    ctx_nodes.lineWidth = 1.5
    ctx_nodes.stroke()

    if (uid !== null) {
        //draw_curve_crisp(ctx_nd_shadow, cpnts, 5, "#ffff00") //color_from_uid(uid)) 
        ctx_nd_shadow.beginPath()
        draw_curve(ctx_nd_shadow, cpnts)
        ctx_nd_shadow.lineWidth = 11
        ctx_nd_shadow.strokeStyle = color_from_uid(uid)
        ctx_nd_shadow.stroke()
    }

    nodes_draw_end()
}

function zero_pad_hex2(n) {
    if (n <= 0xf)
        return '0' + n.toString(16)
    return n.toString(16)
}
function color_from_uid(uid) {
    if (typeof uid != 'number') {
        console.assert(uid[0] == 'e') // ephemeral id
        uid = parseInt(uid.substr(1)) | 0x80000;
    }
    console.assert(uid < 0xfffff)
    return "#" + zero_pad_hex2(uid & 0xff) + zero_pad_hex2((uid >> 8) & 0xff) + 'f' + ((uid >> 16) & 0xf)
}
// lines are antialiased and that can't be changed. this method works fine with with a single line antialiased with the background
// but breaks for multiple lines converging in the same point
function uid_from_color(c) {
    if ((c & 0xf00000) !== 0xf00000)
        return null // result of antialiasing, not a real color
    const id = c & 0xfffff
    if ((c & 0x80000) !== 0)
        return "e" + (id & 0x7ffff)
    return id
}

function round_to(x, v) {
    return Math.round(x / v) * v
}

// https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas/3368118
function rounded_rect_f(ctx, x, y, width, height, rtl, rbl, rtr, rbr) {
    ctx.moveTo(x + rtl, y);
    ctx.lineTo(x + width - rtr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + rtr);
    ctx.lineTo(x + width, y + height - rbr);
    ctx.quadraticCurveTo(x + width, y + height, x + width - rbr, y + height);
    ctx.lineTo(x + rbl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - rbl);
    ctx.lineTo(x, y + rtl);
    ctx.quadraticCurveTo(x, y, x + rtl, y);
    ctx.closePath();
}
function rounded_rect(ctx, x, y, width, height, r) {
    rounded_rect_f(ctx, x, y, width, height, r,r,r,r);
}

class Line {
    constructor(from_term, to_term, uid) {
        console.assert(to_term.is_input !== undefined, "unexpected undefined")
        this.uid = null
        if (!to_term.is_input) {
            this.from_term = to_term
            this.to_term = from_term
        }
        else {
            this.from_term = from_term
            this.to_term = to_term
        }
    }
    
    draw() {
        connector_line(this.from_term.center_x(), this.from_term.center_y(), this.from_term.center_offset(),
                       this.to_term.center_x(), this.to_term.center_y(), this.to_term.center_offset(), false, this.uid, this.from_term.kind)
    }

    ctx_menu_opts() {
        return [{text:"Delete Line", func:()=>{ program.delete_line(this, true)} }]       
    }
}

const KIND_OBJ = 0   // terminal that passes renderable objects
const KIND_VARS = 1  // terminal that passes variable packs
const KIND_FLOW_ANIM = 2 // terminal for animation flow

// does just the graphics
class TerminalBase {
    constructor(name, in_node, is_input, conn_ev=null) {
        this.name = name
        console.assert(is_input !== undefined, "don't instantiate TerminalBase")
        this.owner = in_node // Node object
        this.line_pending = null
        this.lines = []
      //  this.node = in_node
        this.is_input = is_input
        this.tuid = null // set in add_node
        this.kind = KIND_OBJ
        this.color = "#aaa"
        this.tvisible = true // inheriting Node can set to false and set something to the terminal

        this.xoffset = null // will be set again in Node
        this.connection_event = conn_ev

        if (is_input) {
            in_node.inputs.push(this)
            this.yoffset = - TERM_RADIUS - TERM_MARGIN_Y
        }
        else {
            in_node.outputs.push(this)
            this.yoffset = this.owner.height + TERM_RADIUS + TERM_MARGIN_Y   
        }
    }

    tpost_init() { // need to happen after the entire ctor of cls is done
        if (this.connection_event)
            this.connection_event(false) // initialized disconnected, later load may connect or not
    }

    px() { return this.owner.x + this.xoffset }
    py() { return this.owner.y + this.yoffset }
    center_x() { return this.owner.x + this.xoffset }
    center_y() { return this.owner.y + this.yoffset }
    center_offset() { return this.xoffset }

    is_out_term() { return false } // can't just use instanceof to find this since that would not work for ProxyTerminal

    is_connected_to(other_term) {
        for(let l of this.lines) {
            if (l.from_term === other_term || l.to_term === other_term)
                return true;
        }
        return false;
    }
    gender_match(other_term) {
        return ((this.is_input && !other_term.is_input) || (!this.is_input && other_term.is_input)) && (this.kind == other_term.kind)
    }
    
    get_attachment() { return this }// useful in multi
    get_attachee() { return this }
    connect_events_dest() { return owner.cls }

    tdid_connect(line) {
        if (this.connection_event)
            this.connection_event(true)
        this.owner.cls.did_connect(this, line)
    }
    tdoing_disconnect(line) {
        this.owner.cls.doing_disconnect(this, line)
    }
    tdid_disconnect(line) {
        if (this.connection_event)
            this.connection_event(false) // call this only after the line was removed from lines so that if we check has_connection it will be correct
        this.owner.cls.did_disconnect(this, line)
    }
    has_connection() {
        return this.lines.length > 0
    }

    draw(force=false) { // force needed for drawing the vars terminal when just hovering a line
        if (!this.tvisible)
            return
        nodes_draw_start() // can be drawn outside draw_node when just connecting vars line
        ctx_nodes.beginPath();
        this.draw_path(ctx_nodes, force)
        ctx_nodes.fillStyle = this.color
        ctx_nodes.fill()
        ctx_nodes.strokeStyle = "#000"
        ctx_nodes.lineWidth = 1
        ctx_nodes.stroke()
        nodes_draw_end()
    }
    draw_nshadow() {
        ctx_nd_shadow.beginPath();
        this.draw_path(ctx_nd_shadow)
        ctx_nd_shadow.fillStyle = color_from_uid(this.tuid)
        ctx_nd_shadow.fill()        
    }
    
    mousemove(e) {
        let linkto = find_node_obj(e)
        this.line_pending = null
        draw_nodes()
        if (linkto === this) { // should not connect to itself
            return
        }
        if (linkto !== null && linkto.owner === undefined && this.kind == KIND_VARS && linkto.cls !== undefined) {
            // when linking a vars line, target the whole node
            linkto = linkto.cls.vars_in
        }
        if (linkto === null || linkto.owner === undefined || linkto.owner === this.owner || 
            !this.gender_match(linkto) || this.is_connected_to(linkto)) 
        {
            // free line
            connector_line(this.center_x(), this.center_y(), 0, e.vx, e.vy, 0, true, null, this.kind)
        }
        else {
            this.line_pending = new Line(this.get_attachment(), linkto.get_attachment())
            if (this.kind == KIND_VARS) // draw the terminal that is normally invisible
                linkto.draw(true)
            this.line_pending.draw()
        }        
    }

    pre_add_line_hook() { // used for flow terminal that need to disconnect other outputs
    }
    mouseup() {
        if (this.line_pending !== null) {
            this.pre_add_line_hook()
            program.add_line(this.line_pending, null, true)
            this.line_pending = null
        }

        draw_nodes()  // erase temp line
    }
    mousedown() {}
    hover(wx, wy) {
        hover_box.innerHTML = this.name
        hover_box.style.display = "initial"
        hover_box.style.left = nodes_view.rect.left + (nodes_view.pan_x + this.center_x())*nodes_view.zoom + "px"
        let y_offset = 0
        if (this.is_input)
            y_offset = -30;
        hover_box.style.top = nodes_view.rect.top + (nodes_view.pan_y + this.center_y())*nodes_view.zoom + y_offset + "px"
    }

    // default impl for InTerminal and InTerminalMulti
    collect_terminal() {
        // go over all lines coming into this input terminal
        for(let line of this.lines) {
            collect_line(line)
        }
    }
    
}

function canvas_transform(ctx, m) {
    ctx.transform(m[0], m[1], m[3], m[4], m[6], m[7])
}
function canvas_setTransform(ctx, m) {
    ctx.setTransform(m[0], m[1], m[3], m[4], m[6], m[7])
}


// rules for PObjects (for clone)
// - should have no-arg constructor
// - should not have more than one reference to the same object
// - should not have cycles
class PObject {
    constructor() {
        this.refcount = 0
    }
    get_disp_params(disp_values) { return null }

    // do any work that requires async, before doing any actual drawing to avoid having drawn half a frame
    async pre_draw(m, disp_values) {
    }

    transform(m) {
        throw new Error("not implemented transform")
    }

    // this is the default that just sets the transform and calls draw_m which doesn't need to worry about it
    draw(m, disp_values) {
        ctx_img.save()
        try {
            canvas_setTransform(ctx_img, m)
            this.draw_m(m, disp_values)
        }
        finally {
            ctx_img.restore()
        }
    } 
    draw_selection(m, select_vindices) {
        ctx_img.save()
        try {
            canvas_setTransform(ctx_img, m)
            this.draw_selection_m(m, select_vindices)
        }
        finally {
            ctx_img.restore()
        }        
    }

    draw_template(m) {
        ctx_img.save()
        try {
            canvas_setTransform(ctx_img, m)
            this.draw_template_m(m)
        }
        finally {
            ctx_img.restore()
        }
    }

    draw_border() {} // called in NodeTransform

    can_draw_shadow() {
        return false
    }
    draw_shadow(m) {
        ctx_img_shadow.save()
        try {
            canvas_setTransform(ctx_img_shadow, m)
            this.draw_shadow_m(m)
        }
        finally {
            ctx_img_shadow.restore()
        }
    }

    describe(parent, dlg) {
        dlg.clear_desc()
        add_div_text(parent, "obj_inf_none", "No description available")
    }
}

// every object has a single CtrlBlock (like the control block of a shared-ptr)
// the handle in the terminal points to a CtrlBlock which points to the object 
// used for non-caching output terminals to steal the object for better performance
class CtrlBlock
{
    constructor(obj, is_caching) {
        dassert(obj.constructor !== CtrlBlock, "bug nested CtrlBlock")
        // true means it is caching and object should not be stolen
        // false means it's non caching and the object can be stolen
        // null means it's was created in a InTerminal by get_mutable and should be asked about this
        this.caching_ref = is_caching
        this.po = obj // can be null
    }
}

class PHandle {
    constructor(obj, is_caching) {
        if (obj === null)
            this.p = null
        else if (obj.constructor === CtrlBlock)
            this.p = obj
        else
            this.p = new CtrlBlock(obj, is_caching)

        if (this.p !== null)
            this.p.po.refcount += 1
    }
    get_const() {
        if (this.p === null)
            return null
        return this.p.po
    }
    get_mutable() {
        if (this.p === null)
            return null
        if (this.p.po === null || this.p.po.refcount == 1)
            return this.p.po
        if (this.p.caching_ref == true) { // if this is a caching ref we must clone, can't steal from it
            const copy = clone(this.p.po)
            copy.refcount = 1
            this.p.po.refcount -= 1
            this.p = new CtrlBlock(copy, null)
        }
        else {  
            dassert(this.p.caching_ref === false, "caching_ref shouldn't be null here")
            // steal from the non-caching CtrlBlock pointer 
            // communicate to all PHandles that hold this object that we're stealing it
            const obj = this.p.po
            const oldCtrl = this.p
            oldCtrl.po = null
            const newCtrl = new CtrlBlock(obj, null)
            this.p = newCtrl
            obj.refcount = 1
        }
        return this.p.po
    }
    clear() {
        if (this.p === null)
            return
        if (this.p.po !== null) {
            this.p.po.refcount -= 1
            if (this.p.po.refcount == 0 && this.p.po.destructor)
                this.p.po.destructor()
        }
        this.p = null
    }

}

function isTypedArray(obj) {
    return (obj.BYTES_PER_ELEMENT !== undefined)
}

function clone(obj) {
    if (obj === null || typeof (obj) !== 'object')
        return obj;    
    if (isTypedArray(obj) || obj.constructor == Path2D) { 
        // it's a typed array or Path2D (that have copy ctor)
        return new obj.constructor(obj)
    }
    if (obj.constructor === WebGLBuffer ||  
        obj.constructor === CanvasGradient || obj.constructor == ImageBitmap) {
        return null // gl buffers can't be cloned, cached objects
    }
    if (obj.constructor === HTMLImageElement || obj.constructor === WebGLTexture) {
        // I think nowa days all WebGLTexture should be immutable
        return obj // immutable object (once it's loaded) so it's ok for several clones to reference it
    }
    if (obj.constructor === ObjConstProxy) {
        return obj // this is a proxy that wraps another object that is going to remain const so we don't need to copy it further
    }
    if (obj._class !== undefined)
        return null // paper.js object, can be discarded, it will be regenerated since it's a cache

    if (obj.oclone !== undefined)
        return obj.oclone() // class implements its own method

    // it's ok for a PObject constructor to take arguments
    // as long as it's fine with getting them as undefined and later being assigned the same
    // values as properties
    let n = new obj.constructor()
    for(let k in obj) {
        if (k.startsWith("p_"))  {
            n[k] = null // don't clone private field of the object
            continue
        }
        n[k] = clone(obj[k])
    }
    return n
}

class PWeakHandle {
    constructor(ctrl_block) {
        this.p = ctrl_block
    }
    get_const() {
        return this.p.po
    }
    clear() {
        this.p = null
    }
 
}


// normal circle terminal taking a single value
class Terminal extends TerminalBase
{
    draw_path(ctx) {
        ctx.arc(this.px(), this.py() , TERM_RADIUS, 0, 2*Math.PI)
    }

    hit_test(px, py) {
        return px >= this.center_x() - TERM_RADIUS && px <= this.center_x() + TERM_RADIUS && 
               py >= this.center_y() - TERM_RADIUS && py <= this.center_y() + TERM_RADIUS
    }
}


function make_weak_handle(v) {
    if (v.constructor === CtrlBlock)
        return new PWeakHandle(v)
    else if (v.constructor === PHandle)
        return new PWeakHandle(v.p)
    else if (v.constructor === PWeakHandle)
        return new PWeakHandle(v.p) // copy ctor
    else            
        return new PWeakHandle(new CtrlBlock(v, null)) // happens on force_set?
}

// inputs by default have a weak handle that can be upgraded to a counting handle
// if a mutable object is needed
class InTerminal extends Terminal {
    constructor(in_node, name, conn_ev=null) {
        super(name, in_node, true, conn_ev)
        this.h = null
        // an input terminal gets dirty when it's being set a new value.
        // this may be the only indication that a node is dirty if we changed a upper node when it was not visible
        // and the dirtyness did not propogate down
        //   unset when cleaning the entire node
        this.dirty = true
        this.last_uver_seen = null
    }

    intr_set(v, uver) {
        assert(this.lines.length <= 1, this.owner.cls, "too many lines connected to input " + this.name)
        const dirty = (this.last_uver_seen === null || uver === null || uver !== this.last_uver_seen)
        this.last_uver_seen = uver
        this.h = make_weak_handle(v)
        this.tset_dirty(dirty)  // see design_concepts
    }

    get_const() {
        if (this.h === null)
            return null        
        return this.h.get_const()
    }
    get_mutable() {
        if (this.h === null)
            return null        
        if (this.h.constructor === PWeakHandle) // need upgrade
            this.h = new PHandle(this.h.p, null)
        return this.h.get_mutable()
    }
    clear() {
        if (this.h !== null)
            this.h.clear()
    }
    force_set(v) { // generated object into internal nodes
        this.clear()
        this.intr_set(v, null)
    }
    tset_dirty(v) {
        this.dirty = v
    }
    is_dirty() {
        if (this.dirty)
            return true

        assert(this.lines.length <= 1, this.owner.cls, "too many lines connected to input " + this.name)
        if (this.lines.length > 0) {
            const from_uver = this.lines[0].from_term.get_cur_uver()
            const to_uver = this.last_uver_seen
            if (from_uver === null || to_uver === null || from_uver !== to_uver)
                return true;
        }
        return false
    }
    get_last_seen_uver() {
        return this.last_uver_seen;
    }
}

function draw_polygon(ctx, x, y, r, n) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);          
    for (let i = 1; i <= n; ++i) 
      ctx.lineTo(x + r * Math.cos(i * 2 * Math.PI / n), y + r * Math.sin(i * 2 * Math.PI / n))
}

// outputs are by default owning because they are going to need this object
// as a cache for the next frame
class OutTerminal extends Terminal {
    constructor(in_node, name, conn_ev=null) {
        super(name, in_node, false, conn_ev)
        this.h = null
        this.cur_ver = 1 
        // incremented every set()
        this.update_subscriber = null
        this.caching = true // default
    }
    is_out_term() { return true }
    is_caching() {
        return this.caching
    }
    set_caching(v) {
        this.caching = v
    }
    draw_path(ctx) {
        if (this.caching)
            super.draw_path(ctx)
        else
            draw_polygon(ctx, this.px(), this.py() , TERM_RADIUS, 4)
    }
    set(v) {
        // and also save a wear-ref to it so that display would work 
        if (v.constructor === PHandle || v.constructor === PWeakHandle)
            this.h = new PHandle(v.p, this.caching) // copy ctor
        else            
            this.h = new PHandle(v, this.caching)
        ++this.cur_ver;    

        if (this.update_subscriber !== null)
            this.update_subscriber.obj_updated(this.get_const())
    }
    get_const() {
        if (this.h === null)
            return null
        return this.h.get_const()
    }
    get_ctrl_block() {
        if (this.h === null || this.h.p === null)
            return null
        return this.h.p
    }
    get_mutable() { //not ever being called
        dassert("shouldn't even be called")
       /* if (this.h === null)
            return null        
        return this.h.get_mutable()*/
    }    
    clear() {
        if (this.h !== null)
            this.h.clear()
    }
    get_cur_uver() {
        return this.tuid + "_" + this.cur_ver
    }

    subscribe_inf_update(prev_dest, new_dest) {
        console.assert(this.update_subscriber === prev_dest, "unexpected non-null subscriber")
        this.update_subscriber = new_dest
    }
}

const TERM_MULTI_HWIDTH = 30


class InAttachMulti {
    constructor(owner_term) {
        this.owner_term = owner_term
        this.lines = owner_term.lines  // needed by add_line
        this.is_input = owner_term.is_input // needed by Line ctor
        //this.owner = owner_term.owner
        this.h = null
        this.last_uver_seen = null
    }
    get_attachee() {
        return this.owner_term
    }
    center_x() {
        return this.owner_term.center_x()
    }
    center_y() {
        return this.owner_term.center_y()
    }
    center_offset() {
        return this.owner_term.xoffset
    }
    intr_set(v, uver) {
        const dirty = (this.last_uver_seen === null || uver !== this.last_uver_seen) // dirty also if the incoming and prev are null
        this.last_uver_seen = uver
        this.h = make_weak_handle(v)
        this.tset_dirty(dirty)  //  this is needed to give the correct is_dirty indication to the node if it queries about it
    }
    force_set(v) { // generated object into internal nodes
        this.clear()
        this.intr_set(v, null)
    }
    get_const() {
        if (this.h === null)
            return null     
        return this.h.get_const()
    }
    get_mutable() {
        if (this.h === null)
            return null        
        if (this.h.constructor === PWeakHandle) // need upgrade
            this.h = new PHandle(this.h.p, null)
        return this.h.get_mutable()
    }
    clear() {
        if (this.h !== null)
            this.h.clear()
    }
    tset_dirty(v) {
        this.owner_term.tset_dirty(v)
    }
    is_dirty() {
        return this.owner_term.is_dirty()
    }
}
// elongated
class InTerminalMulti extends TerminalBase
{
    constructor(in_node, name, conn_ev=null) {
        super(name, in_node, true, conn_ev)
        this.dirty = true
        this.width = TERM_MULTI_HWIDTH
    }

    draw_path(ctx) {
        rounded_rect(ctx, this.px() - this.width, this.py() - TERM_RADIUS, this.width*2, 2*TERM_RADIUS, TERM_RADIUS)
    }

    hit_test(px, py) {
        return px >= this.center_x() - this.width && px <= this.center_x() + this.width && 
               py >= this.center_y() - TERM_RADIUS && py <= this.center_y() + TERM_RADIUS
    } 
    get_attachment() {
        return new InAttachMulti(this)
    }
    clear() {
        for(let line of this.lines)
            line.to_term.clear()
    }
    tset_dirty(v) {
        this.dirty = v
    }
    is_dirty() {
        if (this.dirty)
            return true

        for(let line of this.lines) {
            const from_uver = line.from_term.get_cur_uver()
            const to_uver = line.to_term.last_uver_seen // the attachment
            if (from_uver === null || to_uver === null || from_uver !== to_uver)
                return true;
        }
        return false
    }

    get_input_consts() {
        let ret = []
        for(let line of this.lines)
            ret.push(line.to_term.get_const())
        return ret
    }

}


const NODE_NAME_PROPS = { font:"14px Verdana", margin_top:3, margin_left:5, height:15}
const NODE_FLAG_DISPLAY = {offset: 105, color: "#00A1F7" }
const NODE_FLAG_TEMPLATE = {offset: 90, color: "#de77f1" }
const NODE_FLAG_INPUT = { width: 15, color: "#8AE600" }
const NODE_ENABLE_GLOB_FLAG = { offset: 60, color: "#339933" }
const NODE_ENABLE_ANIM_FLAG = { offset: 90, color: "#339933" }


function wrapText(context, text, x, center_y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';
    let lines = []
    let y = 0
    for(let n = 0; n < words.length; n++) {
      let testLine = line + words[n] + ' ';
      let metrics = context.measureText(testLine);
      let testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        lines.push({y:y,l:line})  
        line = words[n] + ' ';
        y += lineHeight;
      }
      else {
        line = testLine;
      }
    }
    lines.push({y:y,l:line})  
    let start_y = center_y - lines.length * 0.5 * lineHeight
    for(let l of lines)
        context.fillText(l.l, x, start_y + l.y);
}




// bit field
const EXPR_CONST = 0  // didn't lookup anything
const EXPR_NEED_INPUT = 1  //  looked up a value that does change depend on input
const EXPR_NEED_VAR = 2  // looked up a variable
const EXPR_GLSL_ONLY = 4 // Is this an exression that's supposed to get to_glsl() only and never eval()?

class StateAccess {
    constructor(state_evaluators) {
        this.state_evaluators = state_evaluators // from the node, map name to evaluator type
        this.known_objrefs = {}
        // have a store of objrefs so that these will always be the same ones, no matter which expression is calling for them
        // reset between expressions in the same node doesn't create a new set of objrefs
        for(let name in state_evaluators)
            this.known_objrefs[name] = new ObjRef(name)
        //keep track of what the currently parsed expression was looking up
        this.reset_check()
    }
    // called right before parsing an expression
    reset_check() {
        this.score = EXPR_CONST
        this.need_inputs = {} // map name of input to its ObjRef, gets taken away right after parsing is done
        this.need_variables = {} // list of VariableEvaluator in the currently parsing expr
    }
    get_evaluator(name, line_num) { // called from parser
        const sp = name.split('.')
        const varname = sp[0]
        // did we already create it?
        let top_level = this.need_inputs[varname]
        if (top_level === undefined) {
            let known_obj = this.known_objrefs[varname]
            if (known_obj === undefined)  { 
                // name is not in needed and not in known (which comes from state_evaluators) so it something we know nothing about
                return null
            }
            top_level = this.need_inputs[varname] = this.known_objrefs[varname]
        }
        let evaluator_factory = this.state_evaluators[varname] // as specified by the node_cls
        if (evaluator_factory !== undefined) {
            let e = evaluator_factory(top_level, sp.slice(1))
            this.score |= EXPR_NEED_INPUT // base flag that needs to be there always when there's an evaluator
            if (e.additional_score_flags !== undefined)
                this.score |= e.additional_score_flags() // used for adding EXPR_GLSL_ONLY
            e.line_num = line_num
            return e
        }

        // shouldn't reach here
        throw new ExprErr("Don't know what to do with identifier " + name + " at " + line_num + " (bug?)")        
    }
}

class Node {    
    constructor(x, y, name, cls, id, of_prog) {
        this.of_program = of_prog
        this.rename_observers = []
        this.is_selected_inf = null // if this node is selected, this contains a object with stuff { elem: , popups_dismiss: }. 
        this.subnodes = null // in case this node has parceled noded

        this.x = x
        this.y = y
        this.width = NODE_WIDTH
        this.height = NODE_HEIGHT
        this.set_name(name)
        this.color = "#ccc"
        this.id = id  // used for identification in the program and serialization

        this.can_display = true // vars nodes can't display, set in cls ctor
        this.can_input = false  // vars node can get mouse input
        this.can_enable = false // NodeVarCls: vars node sets variables to global namespace, same as template display, only in the first flag place
                                // NodeAnimCls: start animation flow enable
        this.can_run_on_select = true     // should run when selected? false for flow nodes

        // depends on can_enable 
        // for NodeVarCls this flags if its global variables
        // for AnimEventFlow this flags if the node is enabled
        this.enable_active = false 

        this.follow_target = null // for Flow nodes (NodeAnimCls) instance of FollowTarget, if this is null, node can't be followed
        this.snap_suggest = null // null or {x:,y:} of where to draw the snap suggestion block
        this.can_follow = false // Flow node, can this node follow another
        this.followed_by_node = null // who follows me
        this.following_node = null // who am I following 

        this.name_xmargin = 0   // distance of name from node, use for var input node
        this.nkind = KIND_OBJ

        // calculated data members
        this.parameters = []
        this.param_aliases = {} // map old name of a parameter to its new Parameter object
        this.online_params = [] // for physics
        this.terminal_aliases = {} // same for terminals
        this.inputs = []
        this.outputs = [] 
        this.state_evaluators = {} // map variable name to its evaluator type. Evaluator instance will be created with its subscripts when the expression is parsed
        this.state_access = null
        this.cls = new cls(this)
        this.call_params_change() // set the enables or other changes that functions attached to params do
        this.make_term_offset(this.inputs)
        this.make_term_offset(this.outputs)
        this.terminals = this.inputs.concat(this.outputs)
        for(let t of this.terminals)
            t.tpost_init()  // for calling the initial connected/disconnected that can affect param enable (ScatterFunc)

        // controls caching
        // means it needs a call to run() to refresh its output according to updated parameters and inputs
        // this member is managed by the engine in its scan for dirty subtrees. should not be set by the node itself        
        this._node_dirty = true 
        // indication for the engine traversal of this node.
        this._last_visited_fv = 0 // frame_ver
        // should be set by the node if anything happened that dirtied its state (that is not a parameter)
        // used for global vars enable flag
        this.self_dirty = false
        // key-value of parameters for displaying any sort of object.
        // kept per-node since every node can want something different
        this.display_values = {}

        this.disp_template = false
        this.receives_input = false // depends on can_input


        if (this.state_access === null)
            this.set_state_evaluators([]) // if cls ctor did not call it
    }

    set_self_dirty() {
        this.self_dirty = true
        trigger_frame_draw(true)
    }

    set_enable_active_dirty(v) {
        this.enable_active = v
        this.set_self_dirty()
    }

    set_state_evaluators(d) { // called in cls ctor to configure how StateAccess accesses state
        this.state_evaluators = d
        // evaluators created in the cls ctor
        this.state_access = new StateAccess(this.state_evaluators) 
        return this.state_access
    }

    follow(node) {
        node.followed_by_node = this
        this.following_node = node
    }
    unfollow() {
        if (this.following_node === null)
            return
        this.following_node.followed_by_node = null
        this.following_node = null
    }
    is_following() {
        return this.following_node !== null
    }

    make_term_offset(lst) {
        if (lst.length == 0)
            return;
        let count = 0
        for(let t of lst)
            if (t.kind != KIND_VARS && t.tvisible)
                ++count

        const step = (this.width - TERM_MARGIN_X*2) / (count - 1)
        let cidx = 0
        for(let i = 0; i < lst.length; ++i) {
            let term = lst[i]
            if (term.kind === KIND_VARS || !term.tvisible)
                continue
            if (term.xoffset === null) {
                if (count == 1)
                    term.xoffset = this.width / 2
                else
                    term.xoffset = TERM_MARGIN_X + cidx * step
            }
            ++cidx;    
        }

        //  for(let t of lst) {
      //      t.owner = this
      //  }        
    }
    
    px() { 
        return this.x
    }
    py() {
        return this.y
    }

    namex() {
        return this.px() + this.width + this.name_xmargin + NODE_NAME_PROPS.margin_left
    }
    namey() {
        return this.py() + NODE_NAME_PROPS.margin_top
    }
    
    draw() {
        //ctx_nodes.fillStyle = "#550000"
        //ctx_nodes.fillRect(this.tx, this.ty, this.twidth, this.theight)

        let px = this.px(), py = this.py()
        if (this.snap_suggest !== null) {
            ctx_nodes.beginPath();
            rounded_rect(ctx_nodes, this.snap_suggest.x, this.snap_suggest.y, this.width, this.height, 5)
            ctx_nodes.fillStyle = "rgba(200,200,200,0.4)"
            ctx_nodes.fill()
        }

        if (this.cls.get_error() !== null) {
            ctx_nodes.beginPath();
            ctx_nodes.arc(px, py + this.height*0.5, 40, 0, 2*Math.PI)
            ctx_nodes.fillStyle = "#B10005"
            ctx_nodes.fill()
            ctx_nodes.strokeStyle = "#900000"
            ctx_nodes.lineWidth = 5
            ctx_nodes.stroke()
            ctx_nodes.lineWidth = 1
            ctx_nodes.font = "16px Verdana"
            ctx_nodes.fillStyle = "#ffA0A0"
            ctx_nodes.textAlign = "end"
            wrapText(ctx_nodes, this.cls.get_error().message, px, py + this.height*0.5, 150, 18)
            ctx_nodes.textAlign = "start"
        }
        // main rect
        ctx_nodes.beginPath();
        ctx_nodes.strokeStyle = "#000"
        rounded_rect(ctx_nodes, px, py, this.width, this.height, 5)
        ctx_nodes.fillStyle = this.color
        ctx_nodes.fill()
        ctx_nodes.stroke() 

        // selection border
        if (this.is_selected_inf !== null) {
            ctx_nodes.beginPath();            
            ctx_nodes.lineWidth = 1.5
            ctx_nodes.strokeStyle = "#FFEE00"
            rounded_rect(ctx_nodes, px-2, py-2, this.width+4, this.height+4, 7)
            ctx_nodes.stroke() 
            
            ctx_nodes.strokeStyle = "#000"
            ctx_nodes.lineWidth = 1
        }
        
        if (this.can_display) 
        {
            // display flag
            if (this.of_program.display_node === this) {
                ctx_nodes.beginPath();
                rounded_rect_f(ctx_nodes, px + NODE_FLAG_DISPLAY.offset, py, this.width - NODE_FLAG_DISPLAY.offset, this.height, 0, 0, 5, 5)
                ctx_nodes.fillStyle = NODE_FLAG_DISPLAY.color
                ctx_nodes.fill()
                ctx_nodes.stroke()  // looks bad without this
            }        

            // template flag
            if (this.disp_template) {
                ctx_nodes.fillStyle = NODE_FLAG_TEMPLATE.color
                ctx_nodes.fillRect(px + NODE_FLAG_TEMPLATE.offset, py, NODE_FLAG_DISPLAY.offset - NODE_FLAG_TEMPLATE.offset, this.height)
                ctx_nodes.strokeRect(px + NODE_FLAG_TEMPLATE.offset, py, NODE_FLAG_DISPLAY.offset - NODE_FLAG_TEMPLATE.offset, this.height)
            }
            
            // flags lines
            ctx_nodes.beginPath();
            ctx_nodes.moveTo(px + NODE_FLAG_DISPLAY.offset, py)
            ctx_nodes.lineTo(px + NODE_FLAG_DISPLAY.offset, py+this.height)
            ctx_nodes.moveTo(px + NODE_FLAG_TEMPLATE.offset, py)
            ctx_nodes.lineTo(px + NODE_FLAG_TEMPLATE.offset, py+this.height)
            ctx_nodes.stroke()
        }
        if (this.can_input)  // variable
        {
            if (this.receives_input) {
                ctx_nodes.fillStyle = NODE_FLAG_INPUT.color
                ctx_nodes.beginPath();
                rounded_rect_f(ctx_nodes, px, py, NODE_FLAG_INPUT.width, this.height, 5, 5, 0, 0)
                ctx_nodes.fill()
                ctx_nodes.stroke()
            }
            ctx_nodes.beginPath();
            ctx_nodes.moveTo(px + NODE_FLAG_INPUT.width, py)
            ctx_nodes.lineTo(px + NODE_FLAG_INPUT.width, py+this.height)
            ctx_nodes.stroke()
        }
        if (this.can_enable) // variable
        {
            const shape = (this.cls instanceof NodeVarCls) ? NODE_ENABLE_GLOB_FLAG : NODE_ENABLE_ANIM_FLAG
            if (this.enable_active) { // place of display flag but controlled by the enable flag
                ctx_nodes.beginPath();
                rounded_rect_f(ctx_nodes, px + shape.offset, py, this.width - shape.offset, this.height, 0, 0, 5, 5)
                ctx_nodes.fillStyle = shape.color
                ctx_nodes.fill()
                ctx_nodes.stroke()  // looks bad without this
            }
            ctx_nodes.beginPath();
            ctx_nodes.moveTo(px + shape.offset, py)
            ctx_nodes.lineTo(px + shape.offset, py+this.height)
            ctx_nodes.stroke()
        }

        for(let t of this.terminals) {
            t.draw()
        }        
        ctx_nodes.fillStyle = "#fff"
        ctx_nodes.font = NODE_NAME_PROPS.font;
        ctx_nodes.fillText(this.name, this.namex(), this.namey())
    }

    draw_nshadow() {
        for(let t of this.terminals) {
            t.draw_nshadow()
        }
        if (this.follow_target !== null)
            this.follow_target.draw_nshadow()
    }

    set_selected_inf(obj) {
        this.is_selected_inf = obj
        if (this.subnodes !== null) {
            for(let subnode of this.subnodes)
                subnode.set_selected_inf(obj)
        }
    }
    
    select() {
        if (this.is_selected_inf !== null) 
            return // already selected
        add_selected_node(this)
        this.set_selected_inf({}) // be filled in show_params_of
        draw_nodes() // need to paint the previous selected one        
        show_params_of(this)
        trigger_frame_draw(false) // if there was image display of the selected node, remove/update it (selected point)
    }
    unselect(redraw = true) {
        if (this.is_selected_inf === null)
            return
        remove_selected_node(this)
        remove_param_of(this)

        this.set_selected_inf(null)
        if (redraw) {
            draw_nodes()
            trigger_frame_draw(false)
        }
    }

    
    set_name(name) {
        this.name = name
        ctx_nodes.font = NODE_NAME_PROPS.font
        this.name_measure = ctx_nodes.measureText(this.name)
        for(let ob of this.rename_observers)
            ob(this.name)
        
        this.recalc_bounding_box() 
    }
    register_rename_observer(func) {
        this.rename_observers.push(func)
    }
    remove_rename_observer(func) {
        let idx = this.rename_observers.findIndex((v)=>{ return v === func })
        if (idx !== -1)
            this.rename_observers.splice(idx, 1)
    }

    // geom including terminals and name
    recalc_bounding_box() {
        this.tx = this.x - VAR_TERM_MARGIN
        this.ty = this.y - TERM_RADIUS*2 - 2
        this.twidth = this.width + this.name_measure.width + this.name_xmargin + VAR_TERM_MARGIN + NODE_NAME_PROPS.margin_left
        this.theight = this.height + TERM_RADIUS * 4 + TERM_MARGIN_Y*2
    }

    mousemove(ev, is_cascading = false) {
        this.x += ev.dx / nodes_view.zoom
        this.y += ev.dy / nodes_view.zoom
        this.recalc_bounding_box()
        if (this.cls.node_move_hook !== undefined)
            this.cls.node_move_hook(ev, is_cascading)
        if (this.followed_by_node !== null)
            this.followed_by_node.mousemove(ev, true)
        if (!is_cascading)
            draw_nodes(false)
    }
    
    mouseup(ev) {
        if (this.cls.node_mouse_up_hook !== undefined) 
            this.cls.node_mouse_up_hook(ev)
        save_state() // since we didn't save on mousemove
    }
    
    mousedown(ev) {
        if (!ev.ctrlKey) {
            nodes_unselect_all(false, false) // update will happen next
        }
        if (this.is_selected_inf === null)
            this.select()
        else
            this.unselect()
    }

    has_cached_output() {
        return this.outputs[0].get_const() !== null
    }
    has_anything_dirty(parent_dirty) { // checks if the node wants to run
        if (this.cls.is_dirty_override) {
            const ovrd = this.cls.is_dirty_override(parent_dirty) // anim change filter
            if (ovrd !== null)
                return ovrd
        }
        if (parent_dirty)
            return true
        if (this.self_dirty || this.cls.is_internal_dirty()) // shader
            return true
        for(let p of this.parameters)
            if (p.pis_dirty())
                return true
        // terminals get dirty when something is connected or disconnected from them or when the input object changes
        for(let t of this.inputs)
            if (t.is_dirty())
                return true
        return false
    }
    clear_dirty() {
        this._node_dirty = false
        this.self_dirty = false
        for(let p of this.parameters)
            p.pclear_dirty()
        for(let t of this.inputs) 
            t.tset_dirty(false)
        this.cls.cclear_dirty()
    }
    
    // from Node ctor
    call_params_change() {
        for(let p of this.parameters)
            if (p.call_change)
                p.call_change()
    }
    reeval_all_exprs() {
        for(let p of this.parameters)
            if (p.pis_active())
                p.reeval_all_exprs()
    }

    check_params_errors() {
        for(let p of this.parameters)
            if (p.pis_active())
                if (p.get_last_error() !== null) {
                    set_error(this.cls, "Parameter expression error")
                    return false
                }
        return true
    }

    remove_param(prm) {
        arr_remove_is(this.parameters, prm)
    }

    param_alias(name, prm) {
        this.param_aliases[name] = prm
    }
    terminal_alias(name, terminal) {
        this.terminal_aliases[name] = terminal
    }
    rename_param(prm, name) {
        let exname = null
        for(let name in parameters) {
            if (this.parameters[name] === prm) {
                exname = name
                break
            }
        }
        if (exname !== null) {
            delete this.parameters[exname]
            this.parameters[name] = prm
        }
    }
}

function arr_remove_is(arr, obj) {
    const i = arr.findIndex(function(p) { return Object.is(obj, p) })
    console.assert(i !== -1,"did not find object in array")
    arr.splice(i, 1)
}
function arr_remove_eq(arr, val) {
    const ni = arr.findIndex(function(lid) { return lid === val })
    console.assert(ni !== -1)
    arr.splice(ni, 1)    
}


class NodeCls {
    constructor(node) {
        this.error = null
        this.node = node
        node.cls = this // parameters in the initialization may need it
        // any node can have a variables in
        this.vars_in = new VarsInTerminal(node, "vars_in")
    }
    // mouse interaction in image_view
    image_find_obj() { return null } // called on image click when node is selected
    draw_selection() {}  // when node is selected, draw the dials for image_find_obj()
    img_hit_find_obj() { return null } // node was found using the shadow hit, get the hit object

    image_click() {} // for adding, selecting points
    clear_selection() {} 
    selected_obj_name() { return null } // for menu
    // rect_select(min_x, min_y, max_x, max_y) {} if it's not defined, rect doesn't even show

    // nodes that depends on the viewport should implement and dirty themselves
    dirty_viewport() {}

    get_error() { return this.error }
    clear_error() { this.error = null }
    nset_error(e) { this.error = e }
    did_connect(to_term, line) {}
    doing_disconnect(to_term, line) {}
    did_disconnect(to_term, line) {}
    cclear_dirty() {} // clear the dirty things in a NodeCls that are not exposed to the outside via proxies (used in variable)

    is_internal_dirty() { return false } // for nodes with internal nodes
    is_picking_lines() { return false } // should the engine run and collect all inputs before run(), if not the node decides which inputs to run using select_lines
    pick_lines() { assert(false, this, "not selecting lines") }
    should_clear_out_before_run() { return true }
    toggle_enable_flag(do_draw, to_value) { dassert(false, "unexpected enable") }

    nresolve_variables(do_globals) {
        try {
            for(let p of this.node.parameters) {
                p.resolve_variables(this.vars_in.my_vsb, do_globals, !do_globals) // variables already have the vars_box referenced
            }
        } 
        catch(err) {
            assert(false, this, "Parameter variables error")
        }
    }

    run() {  // for normal kind node (nkind=KIND_OBJ)
        assert(false, this, "run() not implemented")
    }

}

function nodes_unselect_all(redraw=true, trig_frame=true) {
    if (selected_nodes.length === 0)
        return
    let lst_copy = [...selected_nodes] // going to modify it while iterating
    for(let sn of lst_copy)
        sn.unselect(false)
    if (redraw)
        draw_nodes()
    if (trig_frame)
        trigger_frame_draw(false) // if there was something selected, undisplay it's selection in the image
}

// by how much to move the textarea to align with the canvas text
// this is for chrome but not for firefox, too bad
let Y_OFFSET_BY_FONT_SIZE = {11:5, 12:6, 13:6, 14:6, 16:6, 18:7, 20:7, 24:8, 30:9, 36:11, 48:13, 60:16, 72:18 }

class NV_TextNote
{
    static name() { return "Text" }
    constructor(x = null, y = null, text = "") {
        this.x = x
        this.y = y
        this.set_text(text)
        this.uid = null  // set when creating
        this.color = "#ffffff"
        this.font_size = 16
        
        this.width = null // from y to down
        this.height = null // from x to left
        this.lineWidth = null
        this.edit_elem = null
    }
    save() {
        return { x:this.x, y:this.y, text:this.text, font_size:this.font_size, color:this.color }
    }
    load(v) {
        this.x = v.x; this.y = v.y; this.set_text(v.text); this.font_size = v.font_size; this.color = v.color
        this.measure()
    }
    set_text(v) {
        this.text = v
        this.lines = this.text.split('\n');
    }
    px() { return this.x }
    py() { return this.y } 
    draw() {
        const px = this.px(), py = this.py()
        ctx_nodes.font = this.font_size + "px Verdana"
        ctx_nodes.fillStyle = this.color
        ctx_nodes.textAlign = "start"
        ctx_nodes.textBaseline = "top"

        if (this.width === null) {
            this.measure()
        }
        for (let i = 0; i < this.lines.length; ++i)
            ctx_nodes.fillText(this.lines[i], px, py + i*this.lineHeight);
    }
    measure() {
        const elem = add_div(main_view, "measure_hidden")
        elem.style.font = this.font_size + "px Verdana"
        elem.innerText = this.text
        this.height = elem.clientHeight
        this.width = elem.clientWidth
        elem.innerText = this.lines[0]
        this.lineHeight = elem.clientHeight
        elem.parentElement.removeChild(elem)
        this.resize_edit()
    }
    resize_edit() {
        if (this.edit_elem === null)
            return
        this.edit_elem.style.width = Math.max(this.width + 10, 200) + "px"
        this.edit_elem.style.height = this.height + this.lineHeight + 5 + "px"
        this.elem_input.setAttribute("rows", this.lines.length)           
    }
    draw_nshadow() {
        const px = this.px(), py = this.py()
        ctx_nd_shadow.beginPath();
        ctx_nd_shadow.fillStyle = color_from_uid(this.uid)
        ctx_nd_shadow.fillRect(px, py, this.width, this.height)        
    }

    ctx_menu_opts() {
        return [{text:"Delete Text", func:()=>{ program.delete_decor(this, true)} }]       
    }

    mousedown(ev) {
        ev.e.stopPropagation() // don't want it to dismiss the NameInput we just opened
        const ti = pop_nodes_text_input(this.px(), this.py(), this.text, (v)=>{
            this.set_text(v)
            this.measure()
        }, {multiline:true, yoffset:Y_OFFSET_BY_FONT_SIZE[this.font_size] });
        ti.input.style.fontSize = this.font_size + "px"
        this.edit_elem = ti.elem
        this.elem_input = ti.input
        this.resize_edit()

        // buttons container
        const button_cont = add_div(ti.elem, "nodes_text_buttons_cont")

        // move button
        const move_elem = add_div(button_cont, ["nodes_text_button","nodes_text_move_grip"])
        add_move_handlers(move_elem, (dx, dy)=>{
            this.x += dx/nodes_view.zoom
            this.y += dy/nodes_view.zoom
            draw_nodes()
            ti.move_to(this.px(), this.py())
        }, (ex, ey, e)=> {
            e.stopPropagation() // prevent dismiss of the edit
        })

        // color button
        const color_elem = add_div(button_cont, ["nodes_text_color_pick","nodes_text_button"])
        color_elem.setAttribute("tabindex", 1) // make it get focus and blur events for the picker to work
        const picker = ColorEditBox.create_at(color_elem, 200, (v)=>{
            this.color = v.hex
            draw_nodes()
        }, {...colorEdit_default_opt(), open_pos:1, focus_func: (v)=>{
            ti.input.style.display = v?"none":"" // when picking color, show canvas the text and not the input box
        }}, this.color)
        const e_stopProp = (e)=>{
            e.stopPropagation() // prevent dismiss of the edit
        }
        myAddEventListener(color_elem, "mousedown", e_stopProp)
        myAddEventListener(picker.elem, "mousedown", e_stopProp)
        

        // font-size buttons        
        const font_sizes = [11,12,13,14,16,18,20,24,30,36,48,60,72]
        const font_size_change = (dir)=>{
            let i = 0
            while(font_sizes[i] < this.font_size)
                ++i;
            i = Math.min(font_sizes.length-1, Math.max(0, i + dir))
            this.font_size = font_sizes[i]
            ti.input.style.fontSize = this.font_size + "px"
            console.log("font-size=", this.font_size)
            this.measure()
            draw_nodes()
        }
        const fup_elem = add_div(button_cont, ["nodes_text_font_up", "nodes_text_button"])        
        const fdown_elem = add_div(button_cont, ["nodes_text_font_down", "nodes_text_button"])
        myAddEventListener(fup_elem, "mousedown", e_stopProp)
        myAddEventListener(fdown_elem, "mousedown", e_stopProp)
        myAddEventListener(fup_elem, "click", ()=>{font_size_change(1)})
        myAddEventListener(fdown_elem, "click", ()=>{font_size_change(-1)})

    }
    mouseup() {
    }
    mousemove() {
    }
}


// pass along the messages to the node and just flip the display flag
class NodeFlagProxy
{
    constructor(node, func, notifyNode=true) {
        this.node = node
        this.func = func
        this.notifyNode = notifyNode
    }
    mousedown(e) {
        this.func(this.node) 
        draw_nodes()
        if (this.notifyNode)
            this.node.mousedown(e) // selects node
    }
    mouseup() {
        if (this.notifyNode)
            this.node.mouseup()
    }
    mousemove(ev) {
        if (this.notifyNode)
            this.node.mousemove(ev)
    }
}

function nodes_find_obj_shadow(e) {
    if (e.cvs_x < 0 || e.cvs_y < 0 || e.cvs_x > canvas_nd_shadow.width || e.cvs_y > canvas_nd_shadow.height)
        return null

    // TBD cache the data, don't sample each time
    const shadow_col = ctx_nd_shadow.getImageData(e.cvs_x, e.cvs_y, 1, 1).data
    const shadow_val = new Uint32Array(shadow_col.buffer)[0]
    const obj_id = uid_from_color(shadow_val)
    //console.log("obj",obj_id)
    if (obj_id != 0 && obj_id !== null) {
        const obj = program.obj_map[obj_id]
        if (obj === undefined) // can still happen in the aliasing between two colors
            return null
        // the right way to do this is to take a majority vote between the pixels around
        return obj
    }
    return null
}

function find_node_obj(e) {
    const px = e.vx, py = e.vy
    for (let ni = program.nodes.length - 1; ni >= 0; --ni) {  // iterate in reverse order so that we get the front nodes first
        const n = program.nodes[ni] 
        // in this node (including terminals and name input) ?
        if (px < n.tx || px > n.tx + n.twidth || py < n.ty || py >  n.ty + n.theight) {
            continue;
        }
        
        for(let t of n.terminals) {
            if (t.hit_test(px, py))
                return t
        }
        if (py >= n.y && py <= n.y + n.height && px <= n.x + n.width) {
            if (n.can_display) {
                if (px >= n.x + NODE_FLAG_DISPLAY.offset)
                    return new NodeFlagProxy(n, (n)=>{ program.set_display_node(n) })
                if (px >= n.x + NODE_FLAG_TEMPLATE.offset)
                    return new NodeFlagProxy(n, (n)=>{ program.set_template_node(n) })
            }
            if (n.can_input) {
                if (px <= n.x + NODE_FLAG_INPUT.width)
                    return new NodeFlagProxy(n, (n)=>{ program.set_input_node(n) }, false) // don't select node since that's only annoying most of the time, also means node can't be moved from the input flag
            }
            if (n.can_enable) {
                const shape = (n.cls instanceof NodeVarCls) ? NODE_ENABLE_GLOB_FLAG : NODE_ENABLE_ANIM_FLAG
                if (px >= n.x + shape.offset) {
                    return new NodeFlagProxy(n, (n)=>{ n.cls.toggle_enable_flag(true, null) })
                }
            }
            if (px >= n.x)                
                return n
        }

        const name_xstart = n.x + n.width + n.name_xmargin
        if (px > name_xstart && px < name_xstart + n.name_measure.width + NODE_NAME_PROPS.margin_left && 
            py >= n.y && py <= n.y + NODE_NAME_PROPS.height) {
            return new NameInput(n, edit_nodes)
        }
    }

    return nodes_find_obj_shadow(e)
}

var ask_clear_dlg = null
function ask_clear_program() {
    if (ask_clear_dlg !== null)
        ask_clear_dlg.dset_visible(false)
    ask_clear_dlg = message_box("Clear", "Are you sure you want\nto clear everything?", [{text: "Cancel"}, {text:"Clear", func:()=>{
        clear_program()
        draw_nodes()
        ask_clear_dlg = null
    }}])
}

class ObjInfDlg 
{
    constructor() {
        this.rect = { visible: true }
        this.dlg = create_dialog(main_view, "", true, this.rect, (v)=>{
            // visibility changed
            // if it's being closed, unsubscribe. if it's going to be open again, there's going to be a new subscription in open_object_info_dlg
            if (!v)
                this.unsubscribe_current()
        })
        this.dlg.elem.classList.add("obj_inf_dlg")
        this.name_elem = add_div(this.dlg.client, "obj_inf_class")
        this.desc_elem = add_div(this.dlg.client, "obj_inf_desc")

        this.subscribed_on_out_term = null
        this.do_make_title = (name)=>{this.make_title() }
        this.eobj = null
    }

    recreate_if_needed(obj) {
        const b = (this.eobj === null || this.eobj.name !== obj.constructor.name())
        if (b) {
            this.clear_desc()
            this.eobj = { name: obj.constructor.name() }
        }
        return b
    }

    // functions used by describe
    clear_desc() { 
        obj_inf_dlg.desc_elem.innerText = "" 
        // temp state while running describe        
        this.max_line_width = 0
        this.added_labels = []
        this.eobj = null  // used by the object describe() impl to store elements so that it won't need to recreate everything from scratch every frame
    }

    add_line(label, multi_line=false) {
        const line = add_div(obj_inf_dlg.desc_elem, "obj_inf_line")
        const label_e = add_span(line, 'obj_inf_label')
        label_e.innerText = label
        this.max_line_width = Math.max(this.max_line_width, label_e.offsetWidth)
        this.added_labels.push(label_e)
        const val = add_div(line, multi_line ? "obj_inf_value_multi":"obj_inf_value")
        return {value_elem: val, line: line}
    }
    adjust_labels() {
        const width = this.max_line_width + 10 + "px"
        for(let line of this.added_labels)
            line.style.width = width
    }

    obj_updated(obj) {
        if (obj === null) {
            this.name_elem.innerText = "null"
            this.clear_desc()
            return
        }
        obj_inf_dlg.name_elem.innerText = obj.constructor.name()
        obj.describe(this.desc_elem, this)
    }

    make_title() {
        this.dlg.set_title("Output Info: " + this.subscribed_on_out_term.owner.name + " : " + this.subscribed_on_out_term.name)
    }

    unsubscribe_current() {
        if (this.subscribed_on_out_term !== null) {
            this.subscribed_on_out_term.subscribe_inf_update(this, null)  // object updates
            this.subscribed_on_out_term.owner.remove_rename_observer(this.do_make_title)  // node name update
            this.subscribed_on_out_term = null
        }
    }

    subscribe_on(out_term) {
        this.unsubscribe_current()

        out_term.subscribe_inf_update(null, this)
        out_term.owner.register_rename_observer(this.do_make_title)
        this.subscribed_on_out_term = out_term

        // first update
        const obj = out_term.get_const()
        this.obj_updated(obj)    
        this.make_title()
    }

    node_deleted(node) {
        if (this.subscribed_on_out_term === null || this.subscribed_on_out_term.owner !== node)
            return
        this.dlg.dset_visible(false)
        this.unsubscribe_current()
    }
}

var obj_inf_dlg = null


function open_object_info_dlg(out_term)
{
    if (obj_inf_dlg === null)
        obj_inf_dlg = new ObjInfDlg()
    obj_inf_dlg.dlg.dset_visible(true)
    obj_inf_dlg.subscribe_on(out_term)
}

function nodes_menu_color(ncls)
{
    if (ncls.prototype instanceof NodeVarCls)
        return "ctx_menu_opt_var"
    if (ncls.prototype instanceof NodeAnimCls)
        return "ctx_menu_opt_anim"
    return undefined 
}

function nodes_context_menu(e) {
    let obj = find_node_obj(e)
    
    let opt = null, node = null, out_term = null;
    if (obj != null) {
        if (obj.constructor === Node)
            node = obj
        else if (obj.constructor === NodeFlagProxy)  // display,template flags
            node = obj.node
        else if (obj.constructor === NameInput)
            obj = null // treat it like we pressed the background
        else if (obj instanceof TerminalBase) {
            node = obj.owner
            if (obj.is_out_term())
                out_term = obj
        }
        else if (obj.ctx_menu_opts !== undefined)
            opt = obj.ctx_menu_opts()
        else
            return null
    }
    const dismiss_func =  ()=>{nodes_view.dismiss_ctx_menu()}
    if (node !== null) {
        opt = [{text:"Delete Node", func:function() { program.delete_node(node, true)} }]
        if (out_term !== null) 
        {
            opt.push({text:"Output Info", func:function() { open_object_info_dlg(out_term) }})
            if (out_term.set_caching !== undefined) // not defined for ProxyTerminal
            {
                const add_cache_term_checkbox = (parent)=>{
                    const ec_line = add_div(parent, 'prm_ctx_bexpr_line')
                    add_param_checkbox(ec_line, "Caching Terminal", out_term.is_caching(), (v)=>{ 
                        out_term.set_caching(v)
                        dismiss_func()
                        draw_nodes()
                    })
                }
                opt.push({cmake_elems: add_cache_term_checkbox})
            }
        }
    }
    else if (opt === null) {
        opt = [{text:"Clear", func:ask_clear_program }, {text:"-"}]
        const add_node = function(into, cn) { 
            into.push( {text: cn.name(), func:function() { program.add_node(e.vx, e.vy, null, cn); draw_nodes() }, cls: nodes_menu_color(cn)} ) 
        }
        for(let c of nodes_classes) {
            if (c.group_name === undefined)
                add_node(opt, c)
            else {
                const nodes = []
                for(let cn of c.nodes)
                    add_node(nodes, cn)
                opt.push( {text: c.group_name, sub_opts: nodes })
            }
        }
        opt.push({text:"-"}, {text:"Text Note", func:()=>{ program.nodes_add_decor(new NV_TextNote(e.vx, e.vy, "text")); draw_nodes() }})
        opt.push({text:"Reset view", func:function() { nodes_view.reset_view() }})
    }

    nodes_view.last_ctx_menu = open_context_menu(opt, e.ex, e.ey, main_view, dismiss_func)    
    return nodes_view.last_ctx_menu
}

let last_nodes_hover_obj = null
function nodes_hover(e) {
    if (e.buttons !== 0)
        return // nothing to find really if we're draging a node
    let obj = nodes_find_obj_shadow(e)
    if (obj !== null && obj.hover !== undefined) {
        if (obj !== last_nodes_hover_obj)
            obj.hover(e.ex, e.ey)
    }
    else {        
        hover_box.style.display = "none"
        obj = null
    }
    last_nodes_hover_obj = obj
}


const NODES_GRID_SIZE = 50

let g_draw_nodes_rec = 0 // draw_connection is called from draw_nodes and from outside as well
function nodes_draw_start() {
    ++g_draw_nodes_rec;
    if (g_draw_nodes_rec != 1)
        return
    ctx_nodes.save()
    const z = nodes_view.zoom
    ctx_nodes.transform(z, 0, 0, z, nodes_view.pan_x*z, nodes_view.pan_y*z)
    ctx_nd_shadow.save()
    ctx_nd_shadow.transform(z, 0, 0, z, nodes_view.pan_x*z, nodes_view.pan_y*z)
}

function nodes_draw_end() {
    --g_draw_nodes_rec;
    if (g_draw_nodes_rec != 0)
        return
    ctx_nodes.restore()
    ctx_nd_shadow.restore()
}

function draw_nodes(and_save = true)
{   
    if (and_save)
        save_state()
    ctx_nodes.lineWidth = 1
    ctx_nodes.fillStyle = '#312F31'
    ctx_nodes.fillRect(0, 0, canvas_nodes.width, canvas_nodes.height)
    ctx_nodes.textBaseline = "top"

    ctx_nd_shadow.fillStyle = "#000"
    ctx_nd_shadow.fillRect(0, 0, canvas_nd_shadow.width, canvas_nd_shadow.height)
    
    nodes_draw_start()

    const left = -nodes_view.pan_x, top = -nodes_view.pan_y
    const right = canvas_nodes.width / nodes_view.zoom - nodes_view.pan_x
    const bottom = canvas_nodes.height / nodes_view.zoom - nodes_view.pan_y

    // grid
    ctx_nodes.beginPath();
    for(let x = round_to(left, NODES_GRID_SIZE); x < right; x += NODES_GRID_SIZE) {
        ctx_nodes.moveTo(x, top)
        ctx_nodes.lineTo(x, bottom)
    }
    for(let y = round_to(top, NODES_GRID_SIZE); y < bottom; y += NODES_GRID_SIZE) {
        ctx_nodes.moveTo(left, y)
        ctx_nodes.lineTo(right, y)
    }    
    ctx_nodes.strokeStyle = "#444"
    ctx_nodes.stroke()

    // nodes

    for(let n of program.nodes_decor) {
        n.draw()        
    }   
    for(let n of program.nodes) {
        n.draw();
    }
    for(let l of program.lines) {
        l.draw()
    }

    // in the shadow canvas nodes should be above lines so that the lines don't obscure the terminals
    for(let n of program.nodes_decor) {
        n.draw_nshadow()        
    }   
    for(let n of program.nodes) {
        n.draw_nshadow()
    }

    nodes_draw_end()
}



"use strict"

const GRIP_WIDTH = 5
const MIN_PANEL_SIZE = 10



function recalc_canvases_rects() {
    nodes_view.rect = canvas_nodes.getBoundingClientRect();
    image_view.rect = canvas_image.getBoundingClientRect();
   // canvas_webgl.width = canvas_image.width  no reason to do that
   // canvas_webgl.height = canvas_image.height
}

var main_view_state = {
    split_1_h: 0.6,
    split_2_v: 0.35,

    save: function() { return { split_1_h: this.split_1_h, split_2_v: this.split_2_v } },
    load: function(v) { this.split_1_h = parseFloat(v.split_1_h) || 0.6; this.split_2_v = parseFloat(v.split_2_v) || 0.35}
}

function setup_horz_splitter(container, grip, resize1, resize2) //p1, , p2, c2)
{    
    let p1_height = Math.trunc(container.offsetHeight * main_view_state.split_2_v) - GRIP_WIDTH
    const resize = function() {
        resize1(null, p1_height)
        let p2_height = container.offsetHeight - p1_height - GRIP_WIDTH
        resize2(null, p2_height)
        recalc_canvases_rects()
    }
    resize()
    myAddEventListener(window, 'resize', resize);
 
    add_move_handlers(grip, (dx, dy, pageX, pageY)=>{
        if (pageY > MIN_PANEL_SIZE && pageY < container.offsetHeight - MIN_PANEL_SIZE) {
            p1_height += dy
            resize1(null, p1_height)
            let p2_height = container.offsetHeight - p1_height - GRIP_WIDTH
            resize2(null, p2_height)
            main_view_state.split_2_v = (p1_height + GRIP_WIDTH) / container.offsetHeight
            recalc_canvases_rects()
        }
    })

}


function setup_vert_splitter(container, grip, resize1, resize2) //p1, c1, grip, p2, c2)
{
    let p1sz = Math.trunc(container.offsetWidth * main_view_state.split_1_h) - GRIP_WIDTH
    
    const resize = function() {
        resize1(p1sz, container.offsetHeight, 0, 0)

        let p2sz = container.offsetWidth - p1sz - GRIP_WIDTH
        resize2(p2sz, null, 0, p1sz + GRIP_WIDTH)

        recalc_canvases_rects()
    }
    resize()
    myAddEventListener(window, 'resize', resize);

    add_move_handlers(grip, (dx, dy, pageX, pageY)=>{
        if (pageX > MIN_PANEL_SIZE && pageX < container.offsetWidth - MIN_PANEL_SIZE) {
            p1sz += dx
            resize1(p1sz, null, 0, 0)
            let p2sz = container.offsetWidth - p1sz - GRIP_WIDTH
            resize2(p2sz, null, 0, p1sz + GRIP_WIDTH)
            main_view_state.split_1_h = (p1sz + GRIP_WIDTH) / container.offsetWidth
            recalc_canvases_rects()
        }
    })
    
}

class ViewBase 
{
    constructor() {
        this.pan_x = null
        this.pan_y = null
        this.zoom = 1
        this.rect = null
        this.viewport_zoom = 1

        this.last_ctx_menu = null
    }

    view_x(pageX) {
        return (pageX - this.rect.left)/this.zoom - this.pan_x
    }
    view_y(pageY) {
        return (pageY - this.rect.top)/this.zoom - this.pan_y
    }
    save() {
        return { pan_x:this.pan_x, pan_y:this.pan_y, zoom:this.zoom }
    }
    load(s) {
        this.pan_x = (s.pan_x === undefined || s.pan_x === null) ? 0 : parseInt(s.pan_x)
        this.pan_y = (s.pan_y === undefined || s.pan_y === null) ? 0 : parseInt(s.pan_y)
        this.zoom =  (s.zoom === undefined  || s.zoom === null) ? 1 : parseFloat(s.zoom)
    }

    dismiss_ctx_menu() {
        if (this.last_ctx_menu != null) {
            main_view.removeChild(this.last_ctx_menu)
        }
        this.last_ctx_menu = null
    }

    nodes_inputevent(name, e) {
        return false
    }
    check_rect_select() {
        return false
    }

    reset_view() {
        this.pan_x = 0
        this.pan_y = 0
        this.zoom = 1
        this.pan_redraw()
    }
}

class NodesView extends ViewBase
{
    constructor(canvas) {
        super()
        this.pan_x = Math.round(canvas.width/2) // default before load from state
        this.pan_y = Math.round(canvas.height/2)

        this.find_obj = find_node_obj
        this.unselect_all = nodes_unselect_all
        this.context_menu = nodes_context_menu
        this.pan_redraw = draw_nodes
        this.hover = nodes_hover
    }

    dismiss_popups() {
        nodes_dismiss_text_input()
        param_dismiss_popups()
        dismiss_top_menus()
    }
}

let nodes_view = null

class ImageView extends ViewBase
{
    constructor() {
        super()
        this.pan_x = 0
        this.pan_y = 0
        this.dismiss_popups = function() {}

        // viewport transform. don't use the canvas transform since we want stuff like vertex markers to remain the same size no matter what
        this.t_viewport = null
        this.t_inv_viewport = null  
        this.viewport_zoom = null // effective zoom of both the viewport transform and the mouse zoom
        // distance from the top or from the left of a the largest square that fits in the canvas. only one of these would be non-zero
        // used for centering the viewport
        this.margin_x = 0
        this.margin_y = 0
    }

    pan_redraw() {
        calc_img_viewport()
        trigger_frame_draw(false) // false since we don't want animation to advance when zooming and panning
    }
    resize_redraw() {
        this.pan_redraw()
    }
    click(x, y) {
        for(let sn of selected_nodes)
            sn.cls.image_click(x, y)
    }
    find_obj(e) {
        for(let sn of selected_nodes) {
            const hit = sn.cls.image_find_obj(e)
            if (hit !== null)
                return hit
        }
        return image_shadow_find_obj(e)
    }
    // check if any of the currently selected node supports multiple selection in the image view
    check_rect_select() {
        for(let sn of selected_nodes)
            if (sn.cls.rect_select !== undefined)
                return true
        return false
    }
    rect_select(min_x, min_y, max_x, max_y) {
        for(let sn of selected_nodes)
            if (sn.cls.rect_select !== undefined)
                sn.cls.rect_select(min_x, min_y, max_x, max_y)
    }
    epnt_to_model(ex, ey) { // takes coord from mouse event
        let ti = vec2.create()
        vec2.transformMat3(ti, vec2.fromValues(ex,ey), this.t_inv_viewport)        
        return ti
    }
    unselect_all() {
        for(let sn of selected_nodes)
            if (sn.cls.clear_selection !== undefined)
                sn.cls.clear_selection()        
    }

    context_menu(e) {
        let opt = []
        let obj_names = []
        for(let sn of selected_nodes)
            if (sn.cls.selected_obj_name !== undefined) {
                const name = sn.cls.selected_obj_name()
                if (name)
                    obj_names.push(name)
            }
        if (obj_names.length > 0) {
            opt.push({text:"Delete " + obj_names.join(", "), func:function() { 
                for(let sn of selected_nodes)
                    sn.cls.delete_selection()} 
            })
        }
        opt.push({text:"Reset view", func:function() { image_view.reset_view() }})
        
        this.last_ctx_menu = open_context_menu(opt, e.ex, e.ey, main_view, ()=>{ this.dismiss_ctx_menu() } )    
        return this.last_ctx_menu
    }


    nodes_inputevent(name, e) {
        let capture = false
        for(let node of program.input_nodes) {
            console.assert(node.cls.inputevent !== undefined, "Node does not declare inputevent func")
            if (node.cls.inputevent(name, e))
                capture = true
        }
        return capture
    }
    
}

function image_shadow_find_obj(e)
{
    if (e.cvs_x < 0 || e.cvs_y < 0 || e.cvs_x > canvas_image.width || e.cvs_y > canvas_image.height)
        return null

    const disp_obj = get_display_object()
    if (disp_obj === null || !disp_obj.can_draw_shadow())
        return null
    if (canvas_img_shadow.width !== canvas_image.width)
        canvas_img_shadow.width = canvas_image.width
    if (canvas_img_shadow.height != canvas_image.height)
        canvas_img_shadow.height = canvas_image.height
    
    disp_obj.draw_shadow(image_view.t_viewport)

    const shadow_col = ctx_img_shadow.getImageData(e.cvs_x, e.cvs_y, 1, 1).data
    const shadow_val = new Uint32Array(shadow_col.buffer)[0]
    const node_id = uid_from_color(shadow_val)
    if (node_id === null)
        return null
    const node = program.obj_map[node_id]
    if (node === undefined || node.constructor !== Node)  // can happen due to antialiasing
        return null
    return node.cls.img_hit_find_obj()
}


function is_point_in_rect(x, y, rect) {
    return (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom)
}

let image_view = null

function panel_mouse_control(view, canvas) 
{    
    let panning = false
    let prev_x, prev_y, down_x, down_y
    let hit = null
    let did_move = false  // used for detecting unselect
    let active_rect = null
    let node_capture = false
    
    myAddEventListener(canvas, 'mousedown', function(e) {
        if (e.target === canvas_image && view.nodes_inputevent('mousedown', {e:e, ex:e.pageX, ey: e.pageY, buttons:e.buttons})) {
            node_capture = true // variable-node mouse move
            return
        }
        if (e.buttons == 1) {
            if (e.ctrlKey && view.check_rect_select()) {
                active_rect = { x1:e.pageX, y1:e.pageY }
                return
            }
            prev_x = e.pageX; prev_y = e.pageY
            down_x = e.pageX; down_y = e.pageY
            const vx=view.view_x(e.pageX), vy=view.view_y(e.pageY)
            const cvs_x = e.pageX - view.rect.left, cvs_y = e.pageY - view.rect.top
            const ev = { vx:vx, vy:vy, ex:e.pageX, ey: e.pageY, cvs_x:cvs_x, cvs_y:cvs_y, e:e, ctrlKey:e.ctrlKey }
            hit = view.find_obj(ev);
            if (hit != null && hit.mousedown !== undefined) {
                //console.log("hit ", hit)
                // passing e to potentiall stop propogation
                hit.mousedown(ev)
                if (is_mousemovable(hit))
                    return  // if it can move, don't pan
            }
            did_move = false
            panning = true
            //console.log("down ", panning)
        }
    });
    myAddEventListener(canvas, 'mouseup', function(e) {
        if (panning) { // means there was no hit
            let dx = Math.abs(e.pageX - down_x)
            let dy = Math.abs(e.pageY - down_y)
            if (dx + dy < 5) { // moved only a little
                if (view.click) {
                    // don't use view_x,view_y since the panning is already take into consideration in t_inv_viewport
                    view.click(e.pageX, e.pageY) 
                }
            }
        }
    });
    myAddEventListener(document, 'mouseup', function(e) {
        panning = false;
        //console.log("up ", panning)
        if (hit !== null && hit.mouseup !== undefined)
            hit.mouseup()  // commit line pending
        else if (!did_move)
            view.unselect_all(true) // click anywhere empty, without panning, just unselects the current selection (for nodes_view)
        hit = null
        if (active_rect) {
            view.rect_select(undefined)
            active_rect = null
        }
        if (node_capture) {
            node_capture = false
            view.nodes_inputevent('mouseup', e)
        }
    });
    myAddEventListener(document, 'mousemove', function(e) {
        let dx = e.pageX - prev_x
        let dy = e.pageY - prev_y
        prev_x = e.pageX, prev_y = e.pageY
        if (dx == 0 && dy == 0) 
            return
        if (active_rect !== null) {
            let x2 = e.pageX, y2 = e.pageY
            view.rect_select(Math.min(active_rect.x1, x2), Math.min(active_rect.y1, y2),
                             Math.max(active_rect.x1, x2), Math.max(active_rect.y1, y2))
            return
        }
        did_move = true
        const edx = dx / view.viewport_zoom, edy = dy / view.viewport_zoom
        dx /= view.zoom
        dy /= view.zoom
        //console.log("move ", panning)
        if (panning) {
            view.pan_x += dx
            view.pan_y += dy
            view.pan_redraw()
        }
        else if (hit !== null && is_mousemovable(hit)) {
            let cvs_x = e.pageX - view.rect.left, cvs_y = e.pageY - view.rect.top
            const ev = {vx:view.view_x(e.pageX), vy:view.view_y(e.pageY), ex:e.pageX, ey:e.pageY, cvs_x:cvs_x, cvs_y:cvs_y,
                        shiftKey: e.shiftKey, ctrlKey:e.ctrlKey,
                        dx: edx, dy: edy}
            hit.mousemove(ev)
        }
        
        if (view.hover !== undefined) {
            let cvs_x = e.pageX - view.rect.left, cvs_y = e.pageY - view.rect.top // relative to canvas
            if (cvs_x >= 0 && cvs_y >= 0 && cvs_x < view.rect.width && cvs_y < view.rect.height) { // only if it's inside the canvas
                const ev = {vx:0, vy:0, ex:e.pageX, ey:e.pageY, cvs_x:cvs_x, cvs_y:cvs_y, buttons:e.buttons}
                view.hover(ev)
            }
        }

        if (node_capture || is_point_in_rect(e.pageX, e.pageY, view.rect) && e.target === canvas_image) {
            const ev = { ex:e.pageX, ey:e.pageY, dx:edx, dy:edy, img_canvas_capture: node_capture, buttons:e.buttons }
            view.nodes_inputevent('mousemove', ev)
        }
    })
    
    myAddEventListener(canvas, "contextmenu", function(e) {
        view.dismiss_ctx_menu()
        const cvs_x = e.pageX - view.rect.left, cvs_y = e.pageY - view.rect.top // relative to canvas
        const ev = { vx:view.view_x(e.pageX), vy:view.view_y(e.pageY), ex:e.pageX, ey:e.pageY, cvs_x:cvs_x, cvs_y:cvs_y }
        let ctx = view.context_menu(ev)
        if (ctx !== null)
            e.preventDefault()
        return false;
    })
    myAddEventListener(document, 'mousedown', function(e) {
        view.dismiss_ctx_menu()
        view.dismiss_popups()
    })

    myAddEventListener(document, 'mousewheel', function(e) { // don't keep boxes one while zooming
        view.dismiss_ctx_menu()
        view.dismiss_popups()
    })
}

function is_mousemovable(hit) {
    if (hit.mousemovable !== undefined)
        return hit.mousemovable()
    return hit.mousemove !== undefined
}

// https://github.com/jackmoore/wheelzoom/blob/master/wheelzoom.js
function panel_mouse_wheel(view, canvas)
{
    const zoom_factor = 1.10

    function onWarCanvasWheel(e) 
    {
        let bgPosX = view.pan_x * view.zoom
        let bgPosY = view.pan_y * view.zoom

        e.preventDefault();
        let deltaY = 0;
        if (e.deltaY) { // FireFox 17+ (IE9+, Chrome 31+?)
            deltaY = e.deltaY;
        } else if (e.wheelDelta) {
            deltaY = -e.wheelDelta;
        }

        let rect = canvas.getBoundingClientRect();
        let offsetX = e.pageX - rect.left - window.pageXOffset;
        let offsetY = e.pageY - rect.top - window.pageYOffset;
        // Record the offset between the bg edge and cursor:
        //  from corner to cursor
        let bgCursorX = offsetX - bgPosX;
        let bgCursorY = offsetY - bgPosY;
        // Use the previous offset to get the percent offset between the bg edge and cursor:
        let bgRatioX = bgCursorX/view.zoom;
        let bgRatioY = bgCursorY/view.zoom;
        // Update the bg size:
        if (deltaY < 0) {
            view.zoom *= zoom_factor;
        } else {
            view.zoom /= zoom_factor;
        }

        // Take the percent offset and apply it to the new size:
        //  from cursor back to corner
        bgPosX = offsetX - (view.zoom * bgRatioX);
        bgPosY = offsetY - (view.zoom * bgRatioY);

        view.pan_x = bgPosX / view.zoom // don't know...
        view.pan_y = bgPosY / view.zoom

        view.pan_redraw()

    }
    myAddEventListener(canvas, "wheel", onWarCanvasWheel)    
}


function addTextChild(elem, txt) {
    let dummy = document.createElement("DIV")
    dummy.innerHTML = txt
    let ne = dummy.firstChild
    elem.appendChild(ne)
    return ne
}



function open_context_menu(options, wx, wy, parent_elem, dismiss_func, sub_menu_of=null)
{
    let menu_elem = add_div(parent_elem, "ctx_menu")
    let open_sub = {opt:null, elem:null}
    for(let opt of options) {
        let e = null
        if (opt.cmake_elems)
            e = opt.cmake_elems(menu_elem)
        else if (opt.text == '-') 
            e = add_elem(menu_elem, 'HR', "ctx_menu_sep")
        else if (opt.type === "file-in") {
            const [fin,btn] = add_upload_btn(menu_elem, 'ctx_menu_opt', opt.text, opt.func)
            e = fin
        }
        else {
            e = add_div(menu_elem, 'ctx_menu_opt')
            e.innerText = opt.text
            if (opt.cls !== undefined)
                e.classList.add(opt.cls)
        }
        
        if (e === undefined || e === null)
            continue
        if (opt.sub_opts !== undefined) {
            e.classList.toggle('ctx_menu_sub')
            myAddEventListener(e, 'mousemove', function() {
                if (open_sub.opt === opt)
                    return // this is already open
                if (open_sub.elem !== null)
                    open_sub.elem.parentElement.removeChild(open_sub.elem)
                open_sub.opt = opt
                const rect = e.getBoundingClientRect();
                open_sub.elem = open_context_menu(opt.sub_opts, Math.trunc(rect.right)-wx-4, Math.trunc(rect.top)-wy-3, menu_elem, dismiss_func, menu_elem)
            })
        }
        else { // normal option, dismiss open sub if exists
            myAddEventListener(e, 'mousemove', function() {
                if (open_sub.elem !== null)
                    open_sub.elem.parentElement.removeChild(open_sub.elem)
                open_sub.elem = null; open_sub.opt = null
            })
        }
        stop_propogation_on("mousedown", e)
        if (opt.func === undefined)
            continue
        myAddEventListener(e, 'click', function() {
            if (opt.type !== "file-in")
                opt.func()
            dismiss_func()
        })        

    }

    stop_propogation_on("mousedown", menu_elem) // stop it from dismissing on click due to other handlers in the document

    let main_width = main_view.offsetWidth, main_height = main_view.offsetHeight
    let menu_width = menu_elem.offsetWidth, menu_height = menu_elem.offsetHeight
    const parentRect = parent_elem.getBoundingClientRect()
    let rx = Math.trunc(parentRect.left) + wx, ry = Math.trunc(parentRect.top) + wy
    
    if (rx + menu_width > main_width) {  // x overflow
        if (sub_menu_of === null)
            rx = main_width - menu_width
        else // show on the other side of the parent menu
            rx = sub_menu_of.getBoundingClientRect().left - menu_width + 3 // a little overlap
    }
    if (ry + menu_height > main_height) { // y overflow
        ry = main_height - menu_height
    }
    wx = rx - parentRect.left // needs to be relative to parent
    wy = ry - parentRect.top
    
    menu_elem.style.left = wx + "px"
    menu_elem.style.top = wy + "px"
    return menu_elem
}

var last_name_input_elem = null
function nodes_dismiss_text_input() {
    if (last_name_input_elem != null) {
        main_view.removeChild(last_name_input_elem)
        last_name_input_elem = null
    }
}
function pop_nodes_text_input(x, y, startv, func, opt) {
    // TBD a better way to do it is to hide the text area altogether instead oftrying to align it to the canvas text
    nodes_dismiss_text_input()
    const multi = opt && opt.multiline
    const elem = add_div(main_view, "node_name_edit")
    let input, yoffset = 0
    if (!multi) {
        input = add_elem(elem, "input", "node_name_input")
        input.setAttribute("type", "text")
        yoffset = 5
    }
    else {
        input = add_elem(elem, "textarea", ["node_name_input", "node_text_area"])
        yoffset = (opt.yoffset !== undefined) ? opt.yoffset : 6  // depends on font size
    }
    if (nodes_view.zoom !== 1.0) {
        // make the scale move the box to the right and not to both ways
        input.style.transform = "translate(-50%,-50%) scale(" + nodes_view.zoom + ") translate(50%,50%)"
    }
    yoffset *= nodes_view.zoom
    input.setAttribute("spellcheck", false)
    const move_to = (to_x, to_y)=>{
        elem.style.left = ((to_x + nodes_view.pan_x)*nodes_view.zoom + nodes_view.rect.left) + "px"
        elem.style.top = ((to_y + nodes_view.pan_y)*nodes_view.zoom + nodes_view.rect.top - yoffset) + "px"
    }
    move_to(x, y)
    input.value = startv
    stop_propogation_on("mousedown", input)
    myAddEventListener(input, 'input', ()=>{
        func(input.value)
        draw_nodes()
    })
    if (!multi) {
        myAddEventListener(input, "keypress", function(e) {
            if (e.keyCode == 13)
                nodes_dismiss_text_input()
        })
    }
    last_name_input_elem = elem

    return {elem:elem, input:input, move_to:move_to}
}

class NameInput
{
    constructor(node, parent_elem) {
        this.node = node
        this.elem = null
    }
    mousedown(ev) {
        ev.e.stopPropagation() // don't want it to dismiss the NameInput we just opened
        pop_nodes_text_input(this.node.namex(), this.node.namey(), this.node.name, (v)=>{
            this.node.set_name(v)
        });
    }
    mouseup() {
    }
    mousemove() {
    }
}



function setup_key_bindings()
{
    myAddEventListener(document, "keypress", function(e) {
        if (e.key == ' ') {
            // if ctrl is pressed, do a full clear and run, otherwise do a normal run with caches
            // ctrl+space stopped working?
            trigger_frame_draw(true, e.ctrlKey || e.shiftKey) 
        }
    })
}


function create_dialog(parent, title, resizable, rect, visible_changed, size_changed=null)
{
    const dlg = add_div(parent, "dlg")
    if (!rect)
        rect = {left:null, top:null, width:null, height:null, visible:false}
    dlg.style.display = 'none'

    const title_line = add_div(dlg, "dlg_title")
    const title_text = add_elem(title_line, 'span', 'dlg_title_text')
    title_text.innerText = title
    const close_btn = add_div(title_line, "dlg_close_btn")

    const set_visible = (v) => {
        if (v == rect.visible)
            return
        rect.visible = v;
        if (visible_changed)
            visible_changed(rect.visible)
        repos()
    }
    myAddEventListener(close_btn, 'click', () => {
        set_visible(false)
    })
    const client = add_div(dlg, "dlg_client")


    const set_title = (v) => {
        title_text.innerText = v
    }

    const repos = () => {
        if (rect.left) {
            dlg.style.left = rect.left + "px"
            dlg.style.top =  rect.top + "px"
        }
        if (rect.width) {
            rect.width = Math.max(rect.width, 150)
            rect.height = Math.max(rect.height, 150)
            dlg.style.width = rect.width + "px"
            dlg.style.height = rect.height + "px"
        }
        dlg.style.display = rect.visible ? '' : 'none'
    }
    repos()

    const move_coord_limited = (rect, curstyle, name, d, max_v, min_v) => {
        if (rect[name] === null || rect[name] === undefined || isNaN(rect[name]))
            rect[name] = parseInt(curstyle[name])
        const track_name = "track_" + name
        if (rect[track_name] === null || rect[track_name] === undefined || isNaN(rect[track_name]))
            rect[track_name] = rect[name]
        rect[track_name] = rect[track_name] + d  // tracking the mouse even if it goes negative
        rect[name] = Math.min(Math.max(rect[track_name], min_v), max_v)
    }

    const move_func = (dx, dy) => {
        const curstyle = window.getComputedStyle(dlg)
        move_coord_limited(rect, curstyle, "left", dx, window.innerWidth - 40, 0)       
        move_coord_limited(rect, curstyle, "top", dy, window.innerHeight - 40, 0)
        repos()
    }
    const start_move_func = ()=>{
        rect.track_top = null
        rect.track_left = null
        rect.track_width = null
        rect.track_height = null
    }
    add_move_handlers(title_line, move_func, start_move_func)


    if (resizable) {
        let r_resize = add_div(dlg, "dlg_resize_r")
        let l_resize = add_div(dlg, "dlg_resize_l")
        let b_resize = add_div(dlg, "dlg_resize_b")

        let rb_resize = add_div(dlg, "dlg_resize_rb")
        let lb_resize = add_div(dlg, "dlg_resize_lb")

        let resize_func =  (dx,dy) => {
            let curstyle = window.getComputedStyle(dlg)
            move_coord_limited(rect, curstyle, "width", dx, window.innerWidth - 40, 150)
            move_coord_limited(rect, curstyle, "height", dy, window.innerWidth - 40, 150)       
            repos()
            if (size_changed !== null)
                size_changed()            
        }
        add_move_handlers(rb_resize, resize_func)
        add_move_handlers(lb_resize, (dx, dy)=>{resize_func(-dx,dy); move_func(dx,0)})
        add_move_handlers(r_resize, (dx, dy)=>{resize_func(dx, 0)})
        add_move_handlers(l_resize, (dx, dy)=>{resize_func(-dx, 0); move_func(dx, 0)})
        add_move_handlers(b_resize, (dx, dy)=>{resize_func(0, dy)})
        if (size_changed !== null)
            size_changed()        
    }

    return {elem:dlg, client:client, rect:rect, dset_visible:set_visible, set_title:set_title}
}

// generic function to handle all cases of dragging some UI element
function add_move_handlers(grip, movefunc, downfunc=null) {
    let moving = false;
    let prevx, prevy;

    const moveHandler = function(e) {
        if (!moving) 
            return
        e.preventDefault(); // prevent selection action from messing it up
        let dx = e.pageX - prevx, dy = e.pageY - prevy
        if (dx == 0 && dy == 0)
            return
        movefunc(dx, dy, e.pageX, e.pageY)
        prevx = e.pageX; prevy = e.pageY
    }
    const ev = {move:null, up:null}
    const upHandler = function() {
        moving = false;
        document.removeEventListener('mousemove', ev.move)
        document.removeEventListener('mouseup', ev.up)
        ev.move = null
        ev.up = null
    }
    myAddEventListener(grip, 'mousedown', function(e) {
        if (e.buttons != 1)
            return
        moving = true;
        if (downfunc)
            downfunc(e.pageX, e.pageY, e)
        prevx = e.pageX; prevy = e.pageY
        ev.move = myAddEventListener(document, 'mousemove', moveHandler);
        ev.up = myAddEventListener(document, 'mouseup', upHandler);
    });
}

// an input dialog with input fields
function fields_input_dlg(parent, caption, text, on_save_func)
{
    let rect = {visible:true}
    let close_action = ()=> { parent.removeChild(dlg.elem)}
    let dlg = create_dialog(parent, caption, false, rect, close_action)
    dlg.elem.classList.add("dlg_size_save_as")
    let label = add_div(dlg.client, "dlg_label")
    label.innerText = text
    const center_elem = add_div(dlg.client)

    let buttons = add_div(dlg.client, "dlg_buttons_group")
    const sb = add_push_btn(buttons, "Save", ()=>{ on_save_func(); close_action(); })
    sb.classList.add("dlg_button")
    const cb = add_push_btn(buttons, "Cancel", close_action)    
    cb.classList.add("dlg_button")
    return {dlg:dlg, center_elem:center_elem}
}

function input_dlg(parent, caption, text, on_save_func) 
{
    let name_input = null
    let [dlg, center_elem] = fields_input_dlg(parent, caption, text, ()=>{on_save_func(name_input.value)})
    name_input = add_elem(center_elem, "input", "dlg_text_input")
    name_input.type = "text"
    name_input.spellcheck = false
}

function message_box(title, text, opts) 
{
    const rect = {visible:true}
    const close_action = ()=> { main_view.removeChild(dlg.elem)}
    const dlg = create_dialog(main_view, title, false, rect, close_action)
    const label = add_div(dlg.client, "dlg_label")
    label.innerText = text
    
    const buttons = add_div(dlg.client, "dlg_buttons_group")
    for(let opt of opts) {
        const sb = add_push_btn(buttons, opt.text, ()=>{ 
            if (opt.func)
                opt.func()
            close_action();
        })
        sb.classList.add("dlg_button")
    }
    return dlg
}

function save_as(parent) {
    input_dlg(parent, "Save As...", "Select a name to save as:", (name)=>{
        if (name.length == 0) {
            console.error("Can't save with empty name")
            return
        }
        if (user_saved_programs[name]) {
            console.error("Name already exists " + name)
            return
        }
        user_saved_programs[name] = save_program_json()
        save_saved_progs()
    })
}


var downloadLink = null

function saveFile(name, type, data) {
    if (downloadLink === null) {
        downloadLink = document.createElement('a');
        downloadLink.style.display = 'none'
        main_view.appendChild(downloadLink)
    }
    var url = window.URL.createObjectURL(new Blob([data], {type: type}));
    downloadLink.setAttribute("href", url);
    downloadLink.setAttribute("download", name);
    downloadLink.click();
    window.URL.revokeObjectURL(url);
}

function export_entire_state(parent) {
    const json = make_state(true)
    saveFile("entire_state.json", "application/json", json)
}

function export_prog() {
    const obj = save_program()
    const text = jsyaml.safeDump(obj, {noCompatMode:true, lineWidth:-1, _flowArrLevel:3}) // don't want lines to be flow (single line)
    saveFile("program.yaml", "application/x-yaml", text)
}

function import_prog(file) {
    console.log("import!", file)
    let reader = new FileReader();
    myAddEventListener(reader, "load", function(e) {
        try {
            const obj = jsyaml.safeLoad(e.target.result)
            load_prog_obj(obj)
        }
        catch(e) {
            console.error(e)
            return
        }
    })
    myAddEventListener(reader, "error", function(e) {
        console.error(e)
    })
    reader.readAsText(file)
}

function export_png() {
    let dl_lnk = null
    const on_save = ()=>{
        const make_file = ()=>{
            dl_lnk.download = "image.png"
            dl_lnk.href = canvas_image.toDataURL('image/png')
            dl_lnk.click()            
        }
        if (width_input.value != canvas_image.width || height_input.value != canvas_image.height) {
            const rel_pan_x = image_view.pan_x / image_view.viewport_zoom
            const rel_pan_y = image_view.pan_y / image_view.viewport_zoom
            canvas_image.width = width_input.value
            canvas_image.height = height_input.value
            calc_img_viewport()
            image_view.pan_x = rel_pan_x * image_view.viewport_zoom
            image_view.pan_y = rel_pan_y * image_view.viewport_zoom
            //image_view.resize_redraw()
            call_frame_draw(false, false, ()=>{
                make_file()
            })
        }
        else {
            make_file()
        }

    }
    const ratio = canvas_image.width / canvas_image.height
    const d = fields_input_dlg(main_view, "Export PNG", "Image size:", on_save)

    const width_div = add_div(d.center_elem, "dlg_input_line")
    add_elem(width_div, "span", "dlg_input_label").innerText = "Width:"
    const width_input = add_elem(width_div, "input", "dlg_text_input")
    width_input.type = "number"
    width_input.addEventListener('input', ()=>{
        height_input.value = Math.round(width_input.value / ratio)
    })

    const height_div = add_div(d.center_elem, "dlg_input_line")    
    add_elem(height_div, "span", "dlg_input_label").innerText = "Height:"
    const height_input = add_elem(height_div, "input", "dlg_text_input")
    height_input.type = "number"
    height_input.addEventListener('input', ()=>{
        width_input.value = Math.round(height_input.value * ratio)
    })
    dl_lnk = add_elem(d.center_elem, "a", "dl_lnk_hidden")
    width_input.value = canvas_image.width
    height_input.value = canvas_image.height
}


function export_svg()
{
    if (program.display_node === null) {
        message_box("Error", "No display node selected", {text:"OK"})
        return
    }
    const disp_obj = program.display_node.outputs[0].get_const()
    if (disp_obj === null) {
        message_box("Error", "No output object generated", {text:"OK"})
        return
    }
    const backup = ctx_img
    const ctx_svg = new C2S(canvas_image.width, canvas_image.height);
    ctx_svg.need_antialias_gap_fill = false
    ctx_img = ctx_svg
    try {
        if (disp_obj.invalidate_pos !== undefined)
            disp_obj.invalidate_pos() // force paths to be recreated
        canvas_transform(ctx_svg, image_view.t_viewport)
        disp_obj.draw_m(image_view.t_viewport, program.display_node.display_values)
    }
    catch(e) {
        message_box("Error", e.message, [{text:"OK"}])
        return
    }
    finally {
        if (disp_obj.invalidate_pos !== undefined)
            disp_obj.invalidate_pos() // force paths to be recreated
        ctx_img = backup
    }
    const text = ctx_svg.getSerializedSvg(true)
    const dl_lnk = add_elem(main_view, "a", "dl_lnk_hidden")
    saveFile("image.svg", "image/svg+xml", text)
}



var open_top_menus = []


function create_top_menu(parent) {
    let menu_btn = add_div(parent, ['top_menu', 'top_menu_file'])
    menu_btn.innerText = "File"
    let cs = window.getComputedStyle(menu_btn)

    myAddEventListener(menu_btn, 'click', ()=> {
        let opt = [//{text:"Save As...", func:function() { save_as(parent) }},
                   {text:"Export Program...", func:export_prog },
                   {text:"Import Program...", func:import_prog, type:"file-in" },
                   {text:"Export PNG...", func:export_png },
                   {text:"Export SVG...", func:export_svg }
                   //{text:"Export State...", func: ()=>{ export_entire_state(parent) }},
                   //{text:"Export SVG...", func: ()=>{ export_svg(parent) }},
                   //{text:'-'}
                   ]
       /* for(let up_name in user_saved_programs) {
            let up = user_saved_programs[up_name]
            opt.push({text:up_name, func:function() { load_prog_json(up) }})
        }*/
        let menu = open_context_menu(opt, parseInt(cs.left), menu_btn.offsetHeight, parent, ()=>{ dismiss_top_menus() } )
        open_top_menus.push(menu)     
    })
}

function dismiss_top_menus() {
    for(let m of open_top_menus)
        m.parentElement.removeChild(m)
    open_top_menus.length = 0
}


var fps_disp = null

function create_anim_bar()
{
    main_view.style.bottom = "35px"
    const anim_bar = add_div(body, "anim_bar")
    const back_btn = add_div(anim_bar, ["anim_btn", "anim_back_btn"])
    myAddEventListener(back_btn, "click", function() {
         g_anim.rewind()
    })

    const play_in = add_elem(anim_bar, 'input', 'param_checkbox_input')
    play_in.type = 'checkbox'
    play_in.id = 'play_btn_check'
    const play_btn = add_elem(anim_bar, 'label', ["anim_btn", 'anim_play_btn'])
    play_btn.setAttribute("for", play_in.id)
    
    myAddEventListener(play_in, 'change', function() { 
        if (play_in.checked)
            g_anim.start()
        else
            g_anim.pause()
    })

    const one_next = add_div(anim_bar, ["anim_btn", "anim_one_next_btn"])
    myAddEventListener(one_next, "click", function() {
         g_anim.one_next()
    })

    const frame_disp_wrap = add_div(anim_bar, 'anim_frame_disp_wrap') // needed for the tooltip
    const frame_disp = add_elem(frame_disp_wrap, 'input', "anim_frame_disp")
    frame_disp.type = 'text'
    frame_disp.spellcheck = false
    frame_disp.value = "0"

    myAddEventListener(frame_disp, 'input', function() {
        const num = parseInt(frame_disp.value)
        g_anim.set_frame_num(num - 1) // setting it to -1 so that next time we run we run the frame requested
    })

    const edit_hover = add_div(frame_disp_wrap, ["hover_box", "anim_fn_hover_box"])
    edit_hover.innerText = "frame_num"

    fps_disp = add_div(anim_bar, 'anim_fps_disp')
    fps_disp.innerText = "0"

    g_anim.reg_pre_draw( (frame_num, frame_time, running)=>{
        frame_disp.value = frame_num
        if (!running)
            play_in.checked = false
    })
}

let frame_count = 0  // since last print    
let last_update_time = 0

function fps_counter_update()
{
    const frame_time = performance.now()
    const dt = frame_time - last_update_time 
    if (dt > 500) {
        const fps = frame_count / (dt / 1000)
        fps_disp.innerText = fps.toFixed(1) + " fps"
        last_update_time = frame_time
        frame_count = 0
        //console.log("erm ", last_update_time, " ", frame_count)
    }
    ++frame_count
}


"use strict"

class Parameter
{
    constructor(node, label) {
        if (typeof label === "string") {
            this.label = label
            this.label_display = label
        }
        else { // for cases we want the serialized label different from the text displayed
            this.label = label[1] + label[0]
            this.label_display = label[0] 
        }
        this.label_elem = null  // use for changing the label 
        this.line_elem = null  // used for enable
        this.enable = true
        this.visible = true
        if (node !== null) { // will be null in DispParams
            // check the name is not already there (key for serialization)
            for(let p of node.parameters)
                if (p.label === label)
                    throw new Error("Can't have two parameters with the same label " + label)
            node.parameters.push(this)
        }
        this.owner = node
        this.dirty = true  // was it changed since the last run?
        this.change_func = null
        this.shares_line_from = null  // to have more than one param in the same line
        this.group_param = null  // member of a group? used for param aggregation
        this.my_expr_items = []  // ExpressionItem objects in me
        this.shader_generated = false  // for knowing if to create proxies 
    }
    set_label(text) { //never used
        this.label = text
        if (this.label_elem !== null) // can be null if we call this before displaying elements
            this.label_elem.innerText = text
        this.owner.rename_param(this, text)
    }
    set_enable(v) {
        if (this.enable == v)
            return
        this.enable = v
        if (this.line_elem !== null)
            elem_set_enable(this.line_elem, this.enable)
    }
    pis_enable() {
        return this.enable 
    }
    set_visible(v) {
        if (this.visible == v)
            return
        this.visible = v
        if (this.line_elem !== null)
            elem_set_visible(this.line_elem, this.visible)
    }
    pis_visible() {
        return this.visible
    }
    pis_active() {
        return this.visible && this.enable
    }
    init_enable_visible() {
        if (this.line_elem !== null) {
            if (!this.enable)
                elem_set_enable(this.line_elem, false) 
            if (!this.visible)
                elem_set_visible(this.line_elem, false)
        }
    }
    pset_dirty(draw=true) { // p for parameter to differentiate it from the others
        this.dirty = true
        if (draw)
            trigger_frame_draw(true)
    }
    pclear_dirty() {
        this.dirty = false
    }
    pis_dirty() {
        return this.dirty
    }
    call_change() { // reimplemet this if this.v is not the value
        if (this.change_func) 
            this.change_func(this.v)
    }
    get_value() { // reimplement if this.v is not ther value
        // checked get_value instead of referencing .v directly, to check if the expression that made this was actually evaluated fully
        dassert(this.v !== null, "value of expr not set")
        return this.v
    }
    share_line_elem_from(param) {
        this.shares_line_from = param   
    }
    is_sharing_line_elem() {
        if (this.shares_line_from === null)
            return false
        // if we're sharing the same visibility state, it measn we're probably related so anyway put us in the same line
        if (this.visible == this.shares_line_from.visible)
            return this.shares_line_from !== null
        // if we don't have the same visibility, add me to him only if he's visible, otherwise, I'm on my own
        return this.shares_line_from.visible
    }
    set_group(group_param) {
        this.group_param = group_param
    }

    reg_expr_item(expr) {
        this.my_expr_items.push(expr)
    }
    resolve_variables(vars_box, do_globals, do_locals) { // each param that has expr_items implements this to its exprs
        let any_changed = false
        for(let expr of this.my_expr_items)  // TBD only active
            any_changed |= expr.eresolve_variables(vars_box, do_globals, do_locals)
        if (any_changed)
            this.call_change()
    }
    reeval_all_exprs() {
        for(let expr of this.my_expr_items)
            if (expr.eis_active())
                expr.peval_self()
    }

    set_shader_generated(v) { this.shader_generated = v }  // mark param automatically generated from shader code
    is_shader_generated() { return this.shader_generated }

    get_last_error() {
        return null // implemented by params that have items
    }
}

// if the text of one of the labels is too long, fix the length of all of them
function fix_label_lengths(parameters) {
    let max_width = 0
    for(let p of parameters) {
        if (p.label_elem) {
            // TBD doesn't deal with invisible parameters
            if (p.label_elem.scrollWidth > p.label_elem.offsetWidth) // it's bigger that the space for it
                max_width = Math.max(max_width, p.label_elem.scrollWidth + 5)
            else if (p.label_elem.style.width !== '')  // we previosly set a width to it (needed for groups readding params)
                max_width = Math.max(max_width, p.label_elem.scrollWidth)
        }
    }
    if (max_width != 0) {
        for(let p of parameters) {
            if (p.label_elem !== null)
                p.label_elem.style.width = max_width + "px"
        }
    }
}

function elem_set_visible(e, v) {
    e.classList.toggle("param_invisible", !v)
}
function elem_set_enable(e, v) {
    e.classList.toggle("param_disabled", !v)
}

function clear_elem_byid(id) {
    let e = document.getElementById(id)
    return clear_elem(e)
}
function clear_elem(e) {
    let cNode = e.cloneNode(false);
    e.parentNode.replaceChild(cNode, e);
    return cNode    
}


function show_params_of(node, with_elem=null) 
{
    param_dismiss_popups()

    const node_params_elem = (with_elem !== null) ? with_elem : add_div(div_params_list, "params_node")

    const title = add_div(node_params_elem, "param_title")
    const title_cls = add_elem(title, "span", "param_title_cls")
    title_cls.innerText = node.cls.constructor.name() 
    const title_name = add_elem(title, "span", "param_title_name")
    title_name.innerText += " : " + node.name
    const rename_func = (s)=>{ title_name.innerText = " : " + s }
    node.register_rename_observer(rename_func)

    const dismiss_list = new PopupsDismissList()
    node.is_selected_inf.popups_dismiss = dismiss_list // needs to be there before calling add_elems since add_elems does the registering
    node.is_selected_inf.param_elem = node_params_elem
    node.is_selected_inf.rename_func = rename_func
    g_params_popups.push(dismiss_list)

    for(let p of node.parameters) {
        if (p.group_param !== null)
            continue // the group will call add_elems
        p.add_elems(node_params_elem)
        p.init_enable_visible()
    }
    fix_label_lengths(node.parameters)
}

function remove_param_of(node)
{
    node.is_selected_inf.param_elem.parentElement.removeChild(node.is_selected_inf.param_elem)
    param_dismiss_popups()
    arr_remove_is(g_params_popups, node.is_selected_inf.popups_dismiss)
    node.remove_rename_observer(node.is_selected_inf.rename_func)
}

function reshow_params_of(node)
{
    // add a new elem instead of the existing one so that show_param_of won't add it at the end
    const e = node.is_selected_inf.param_elem
    const new_elem = create_div("params_node")
    e.parentNode.insertBefore(new_elem, e.nextSibling);

    remove_param_of(node)
    show_params_of(node, new_elem)
}


class PopupsDismissList {
    constructor() {
        this.lst = [] // list of functions
    }
    dismiss_list() {
        for(let callback of this.lst)
            callback()
    }
}
let g_params_popups = [] // list of PopupsDismissList of the selected nodes

function param_dismiss_popups() {
    for(let plst of g_params_popups)
        plst.dismiss_list()
    
}

// call this only after the thing to dismiss is displayed
function param_reg_for_dismiss(node, callback) {
    dassert(node !== null && node.is_selected_inf !== null && node.is_selected_inf.popups_dismiss !== null, "Unexpected null registering popup dismiss")
    node.is_selected_inf.popups_dismiss.lst.push(callback)
}

// this is used to identify when the param-set is changed so it needs to be re-displayed
function get_param_list_labels_key(params) {
    let ret = ""
    if (params.constructor === PGroupDispPrms) {
        for(let pkey in params.v) {
            ret += pkey + "::"
            const parr = params.v[pkey]
            for(let p of parr)
                if (p !== null)
                    ret += p.label + "_"
        }
    }
    else {
        for(let p of params)
            if (p !== null)
                ret += p.label + "_"
    }
    return ret
}
// display_values is held per-node and is a map of string to value
// disp_params is produced by the object and holds how to display the params and it's default value
//  TBD don't really need to do this every frame
var g_prev_disp_node = null, g_prev_param_labels_key = null
function show_display_params(obj, disp_node) {
    let params = null
    if (disp_node && obj)
        params = obj.get_disp_params(disp_node.display_values) // sets defaults if needed
    // params can have nulls or objects that don't have disp_params
    if (obj === null || params === null || disp_node === null || disp_node.is_selected_inf === null) {
        div_display_params_cont.innerHTML = ""
        g_prev_disp_node = null
        return
    }
    const labels_key = get_param_list_labels_key(params)
    if (disp_node === g_prev_disp_node && labels_key === g_prev_param_labels_key)
        return // same thing as before, don't need to recreate it. This is needed so that the scale ParamFloat there would be recreated while it is edited
    div_display_params_cont.innerHTML = "" // = clear_elem(div_display_params)

    const add_single_obj_params = (parr)=>{
        const so_prms = add_div(div_display_params_cont, "div_display_params")
        for(let p of parr) {
            if (p !== null && p.add_elems !== undefined) // the params of a group is an aggregate of it's members, it's not going to have that. FrameBuffer has null disp_params
                p.add_elems(so_prms)
        }
    }

    if (params.constructor === PGroupDispPrms) { // from PObjGroup
        for(let pkey in params.v) {
            const parr = params.v[pkey]
            add_single_obj_params(parr)
        }
    }
    else { // it's an array of params
        add_single_obj_params(params)
    }
    g_prev_disp_node = disp_node
    g_prev_param_labels_key = labels_key
}

function create_elem(elem_type, cls) {
    let e = document.createElement(elem_type);
    if (cls !== undefined && cls !== null) {
        if (!Array.isArray(cls))
            cls = [cls]
        e.classList = cls.join(" ")
    }
    return e
}
function add_elem(parent, elem_type, cls) {
    let e = create_elem(elem_type, cls)
    parent.appendChild(e)
    return e
}
function add_elem_id(parent, elem_type, cls, id) {
    let e = create_elem(elem_type, cls)
    parent.appendChild(e)
    e.setAttribute("id", id)
    return e
}
function create_div(cls) {
    return create_elem('div', cls)
}

function add_div(parent, cls) {
    let e = create_div(cls)
    parent.appendChild(e)
    return e
}
function add_span(parent, cls) {
    return add_elem(parent, "span", cls)
}
function add_div_id(parent, cls, id) {
    let e = create_div(cls)
    parent.appendChild(e)
    e.setAttribute("id", id)
    return e
}
function add_div_text(parent, cls, text) {
    let e = create_div(cls)
    parent.appendChild(e)
    e.innerText = text
    return e
}
function add_param_line(parent, param=null, cls='param_line') { 
    if (param !== null) {
        if (param.is_sharing_line_elem()) {
            let e;
            if (param.shares_line_from.shared_line_elem !== undefined)
                e = param.shares_line_from.shared_line_elem  // if it's a multiline, the param defines what it wants to share
            else
                e = param.shares_line_from.line_elem
            // if adding to a multi-line, mark it as shared so that it could flex
            // ignore adding a multi-line in a multi-line
            if (e.classList.contains("param_multi_line") && cls !== "param_multi_line") {
                e.classList.add("param_multi_line_shared")
                e = add_div(e, "param_line") // multi-line should only include param_lines children (due to top padding and good measure)
            }
            return e
        }
        // line_elem of the group may be null if the group is not displayed since it's an internal node    
        if (param.group_param !== null && param.group_param.line_elem !== null)
            parent = param.group_param.line_elem
    }
    return add_div(parent, cls) 
}
function add_param_multiline(parent, param=null) { 
    return add_param_line(parent, param, 'param_multi_line') 
}
function add_param_block(parent) { return add_div(parent, 'param_block') } // for multi-line params

function add_param_label(line, text, cls) {
    let e = document.createElement('span')
    if (text != null) {
        e.innerText = text
        e.className = 'param_label_pre'
    }
    else
        e.className = 'param_label_pre_empty'
    if (cls !== undefined)
        e.classList.add(cls)

    line.appendChild(e)
    if (text != null) {
        let colon = document.createElement('span')
        colon.className = 'param_label_colon'    
        colon.innerText = ':'  // can't just concatenate this above since the label may change
        line.append(colon)
    }
    return e
}
function add_upload_btn(parent, cls, text, change_func) {
    let fin = add_elem(parent, "input", "param_file_input")
    fin.type = "file"
    fin.id = "p_fl_" + g_input_ids++  // for the "for"
    let btn = add_elem(parent, "label", cls)
    btn.innerText = text
    btn.setAttribute("for", fin.id)
    myAddEventListener(fin, "change", ()=>{
        change_func(fin.files[0]) 
        fin.value = "" // make the input forget about this file so that the same filename can be uploaded again
    })
    return [fin, btn]
}

function formatType(value, type) {
    if (value == true || value == false)
        return value // hack for when FloatParam gets a bool in SetAttr, TBD fix this
    if (type == ED_FLOAT || type == ED_FLOAT_OUT_ONLY)
        return toFixedMag(value)
    if (type == ED_INT)
        return Math.round(value)
    return value
}

const ED_FLOAT=0
const ED_INT=1    // "not float" - not formatted as float
const ED_STR=2
const ED_FLOAT_OUT_ONLY=3  // when parsing ParamFloat, don't pass it throu parseFloat because it's an expression
const ED_COLOR_EXPR=4 // used for expression type check
const ED_VEC2=5 // for code expression type check
const ED_BOOL=6
const ED_TRANSFORM=7

function add_param_edit(line, value, type, set_func, cls=null, enter_func=null) {
    let e = document.createElement('input')
    if (cls === null)
        cls = "param_editbox"
    e.classList = ['param_input', cls].join(" ")
    e.type = 'text'
    e.spellcheck = false
    e.value = formatType(value, type)
    // TBD parse error
    myAddEventListener(e, "input", function() { 
        set_func( (type == ED_FLOAT)? parseFloat(e.value) : e.value); 
    })
    if (enter_func !== null) {
        myAddEventListener(e, "keyup", function(e) {
            if (e.keyCode === 13) {
                enter_func()
            }
        })
    }
    /*if (is_float) {
        myAddEventListener(e, "mousedown", function(ev) {
            console.log("~~", ev.buttons, ev.button)
        })
    }*/
    line.appendChild(e)
    return e
}
function add_param_slider(line, min_val, max_val, start_value, type, set_func) {
    const center = add_div(line, "slider_line")
    const fill = add_div(center, "slider_fill")
    const thumb = add_div(center, "slider_thumb")
    const cfg = { min_val: min_val, max_val: max_val, v: null } // v is always in normal units
    const set_len = (len)=>{
        thumb.style.left = len * 100 + "%"
        fill.style.width = len * 100 + "%"
    }
    const r01_to_range = (v)=>{
        return v*(cfg.max_val - cfg.min_val) + cfg.min_val
    }
    const range_to_r01 = (exv)=>{
        if (type === ED_INT)
            exv = Math.round(exv)
        if (cfg.max_val === cfg.min_val)
            exv = 0
        return (exv - cfg.min_val)/(cfg.max_val - cfg.min_val)
    }
    const update = (value, disabled=false)=>{
        if (value === null || disabled) {
            thumb.classList.toggle('slider_thumb_disabled', true)
            return
        }
        thumb.classList.toggle('slider_thumb_disabled', false)
        cfg.v = value
        let norm_v = range_to_r01(value)
        norm_v = clamp(0, norm_v, 1)
        // cfg.v can be outside [min,max] right now but for display, we clamp it for the thump positioning to no go overboard
        set_len(norm_v)
    }    
    update(start_value)

    add_move_handlers(thumb, (dx, dy, pageX, pageY)=>{
        const crect = center.getBoundingClientRect()
        let norm_v = (pageX - crect.left)/crect.width
        norm_v = clamp(0, norm_v, 1) // don't let drag outside the visible range
        const new_v = r01_to_range(norm_v)
        if (new_v == cfg.v)
            return
        cfg.v = new_v
        //set_len(norm_v)
        set_func(cfg.v)  // eventually calls update so the above is set_len is not needed
    })


    const update_range = (min,max)=>{
        cfg.min_val = min; cfg.max_val = max        
        update(cfg.v)
    }

    return { update: update, elem: center, update_range: update_range }
    // TBD refactor capture
}

function colorEdit_default_opt() { // can't be const var since function below is still not defined
    return {with_alpha:true, myAddEventListener:myAddEventListener, dropper:start_color_dropper}
}

function add_param_color(line, value, cls, set_func) {
    let e = document.createElement('input')
    e.className = cls
    line.appendChild(e) // must have parent
    let ce = ColorEditBox.create_at(e, 200, function(c) { set_func(c) }, colorEdit_default_opt(), value)
    return [ce.get_color().copy(), e, ce]
}
let g_input_ids = 1
function add_param_checkbox(line, label, value, set_func) {
    let ein = add_elem(line, 'input', 'param_checkbox_input')
    ein.type = 'checkbox'
    ein.id = 'p_chb_' + g_input_ids++
    ein.checked = value
    myAddEventListener(ein, 'change', function() { set_func(ein.checked); })
    let edisp = add_elem(line, 'label', 'param_checkbox_disp')
    edisp.setAttribute("for", ein.id)
    let etext = add_elem(line, 'label', 'param_checkbox_text')
    etext.setAttribute("for", ein.id)
    etext.innerText = label
    return [ein, etext, edisp]
}
function add_push_btn(parent, label, onclick, cls=null) {
    if (cls === null)
        cls = "param_btn"
    else
        cls = cls.concat(["param_btn"])
    let btn = add_div(parent, cls)
    btn.innerText = label
    myAddEventListener(btn, "click", onclick)
    return btn
}
function add_checkbox_btn(parent, label, value, onchange) {
    let ein = add_elem(parent, 'input', 'param_checkbox_input')
    ein.type = 'checkbox'
    ein.id = 'p_chb_' + g_input_ids++
    ein.checked = value
    myAddEventListener(ein, 'change', function() { onchange(ein.checked); })
    let btn = add_elem(parent, 'label', 'param_btn')
    btn.setAttribute("for", ein.id)
    btn.innerText = label
    return [ein, btn, null] // null to be compat with add_param_checkbox
}
function add_combobox(parent, opts, sel_idx, onchange) {
    let se = add_elem(parent, 'select', ['param_select', 'param_input'])
    for(let s of opts) {
        let o = add_elem(se, 'option')
        o.innerText = s
    }
    se.selectedIndex = sel_idx
    myAddEventListener(se, 'change', function() { onchange(se.selectedIndex); })
    return se
}

function start_color_dropper(set_color)
{
    const id = ctx_img.getImageData(0, 0, canvas_image.width, canvas_image.height)
    const back_elem = add_div(main_view, "color_dropper_back");
    myAddEventListener(back_elem, "mousemove", (e)=>{
        const rect = image_view.rect
        if (e.pageX > rect.left && e.pageX < rect.right && e.pageY > rect.top && e.pageY < rect.bottom) {
            const relX = e.pageX - rect.left, relY = e.pageY - rect.top // this is actually the same since rect is in 0,0 but just for good measure
            const idx = (relX + relY * id.width) * 4
            const col = { r: id.data[idx], g: id.data[idx+1], b: id.data[idx+2], alpha: id.data[idx+3]/255 }
            set_color(col)
        }
    })
    myAddEventListener(back_elem, "mouseup", (e)=>{
        main_view.removeChild(back_elem)
    })

}

class ParamSeparator extends Parameter {
    constructor(node, label=null, cls="param_separator") {
        super(node, label)
        this.cls = cls
    }
    save() { return null }
    load(v) {}
    add_elems(parent) {
        this.line_elem = add_param_line(parent, this, "param_line_sep")  // don't want the min-height
        add_elem(this.line_elem, "hr", this.cls)
    }
}

// not a real param, just a way to store objects with the params save/load mechanism
// usually stores some other param depending on a SelectParam
class ParamObjStore extends Parameter {
    constructor(node, label, start_v, change_func=null) {
        super(node, label)
        this.v = start_v
        this.change_func = change_func // to get load event
    }
    save() { return {v:this.v}}
    load(v) { this.v = v.v }
    add_elems(parent) {}
    st_set(k, v) {
        this.v[k] = v
        this.pset_dirty() 
    }
    st_get(k) {
        dassert(this.v[k] !== undefined, "Unknown store index " + k)
        return this.v[k]
    }
    st_get_all() {
        return this.v
    }
}



class ParamStr extends Parameter {
    constructor(node, label, start_v, change_func) {
        super(node, label)
        this.v = start_v
        this.change_func = change_func
        this.elem = null
    }
    save() { return {v:this.v}}
    load(v) { this.v = v.v }
    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        this.label_elem = add_param_label(this.line_elem, this.label_display)
        this.elem = add_param_edit(this.line_elem, this.v, ED_STR, (v)=>{ 
            this.v = v; 
            this.call_change()
            this.pset_dirty() 
        }) 
    }
    modify(v) {
        if (this.v === v)
            return
        this.v = v
        if (this.elem !== null)
            this.elem.value = v
        this.pset_dirty() 
    }
}

function normalize_bool_opt(opt) {
    if (opt === null)
        return {allow_expr:true, expr_visible:false, as_btn:false, pulse_btn:false}
    if (opt.allow_expr === undefined)
        opt.allow_expr = true
    if (opt.expr_visible === undefined)
        opt.expr_visible = false
    if (opt.as_btn === undefined)
        opt.as_btn = false
    if (opt.pulse_btn === undefined)
        opt.pulse_btn = false
    dassert(!(opt.as_btn && opt.pulse_btn), "can't have both as_btn and pulse_btn")
    return opt
}

class ParamBool extends Parameter {
    constructor(node, label, start_v, change_func=null, opt=null) {
        super(node, label)
        this.v = start_v
        this.change_func = change_func
        this.elem_input = null
        this.opt = normalize_bool_opt(opt)

        if (this.opt.allow_expr) {
            this.make_checkbox_ctx_menu()
            this.item = new ExpressionItem(this, "v", ED_BOOL, 
                (v)=>{ 
                    if (!this.opt.expr_visible) 
                        return
                    this.v = (v == null)?null:(v > 0)
                    if (this.opt.pulse_btn)
                        this.pulse_need_reset = true
                }, 
                ()=>{ return this.v?1:0 }, 
                {allowed:false})

            this.item.set_eactive(this.opt.expr_visible)
            if (this.opt.expr_visible) {
                this.item.peval("" + start_v)
            }
        }
        else {
            this.ctx_menu = null
            this.item = null
        }
        this.checkbox_line = null
        this.expr_line = null
        this.pulse_need_reset = false
    }

    set_show_expr(v) {
        if (v === this.opt.expr_visible)
            return
        this.opt.expr_visible = v
        if (this.single_line !== null) { // displayed?
            elem_set_visible(this.checkbox_line, !v)
            elem_set_visible(this.expr_line, v)
        }
        this.item.set_eactive(v)

        if (v)  // in case it's a const, set this.v to a value from the right source
            this.item.peval_self()
        else
            this.non_code_peval_self()
        this.pset_dirty()
    }

    non_code_peval_self() {
        if (this.elem_input !== null)  // will be null with pulse button
            this.v = this.elem_input.checked
    }

    make_checkbox_ctx_menu() {
        this.ctx_menu = new CustomContextMenu(this.owner) // for checkbox elem
        const add_expr_checkbox = (parent, dismiss_func)=>{
            const ec_line = add_div(parent, 'prm_ctx_bexpr_line')
            let [ein,etext,edisp] = add_param_checkbox(ec_line, "Expression", this.opt.expr_visible, (v)=>{ 
                this.set_show_expr(v)
                dismiss_func()
            })
        }
        this.ctx_menu.add_to_context_menu(add_expr_checkbox)
    }
    save() { 
        const d =  {v:this.v}
        if (this.opt.expr_visible)
            d.expr_visible = true
        if (this.item !== null)
            this.item.save_to(d)
        return d
    }
    load(v) { 
        if (!this.opt.pulse_btn) // for pulse, the long term value is always false but the saved might be true so we don't want it
            this.v = v.v; 
        this.opt.expr_visible = v.expr_visible || false
        this.opt = normalize_bool_opt(this.opt) // Temp fix
        if (this.opt.allow_expr && this.item !== null) {
            this.item.load(v)
            this.item.set_eactive(this.opt.expr_visible)
        }
        this.call_change()  
    }
    add_elems(parent) {
        if (this.opt.allow_expr) {
            this.line_elem = add_param_multiline(parent, this)
            this.checkbox_line = add_param_line(this.line_elem) // don't pass this since it's in the line_elem
        }
        else {  // no code needed, simplify the dom to allow sharing
            this.line_elem = this.checkbox_line = add_param_line(parent, this)
        }
        elem_set_visible(this.checkbox_line, !this.opt.expr_visible)

        let label_cls_add = null
        if (!this.is_sharing_line_elem()) 
            add_param_label(this.checkbox_line, null)
        else if (!this.opt.as_btn)
            label_cls_add = "param_checkbox_inline" // for margin

        if (!this.opt.pulse_btn)
        {
            const add_func = this.opt.as_btn ? add_checkbox_btn : add_param_checkbox
            const [ein,label,edisp] = add_func(this.checkbox_line, this.label_display, this.v, (v) => {
                this.v = v; 
                this.call_change()
                this.pset_dirty()
            })
            if (label_cls_add && edisp !== null)
                edisp.classList.toggle(label_cls_add, true)
            this.elem_input = ein
        }
        else {
            const btn = add_push_btn(this.checkbox_line, this.label_display, ()=>{
                this.v = true
                this.pulse_need_reset = true
                this.pset_dirty()
            })
        }

        this.label_elem = null // doesn't need to be adjusted if it's a normal checkbox
        // ----- expr elements ------
        if (this.opt.allow_expr) {
            this.expr_line = add_param_line(this.line_elem) // don't pass this since it's in the line_elem
            elem_set_visible(this.expr_line, this.opt.expr_visible)        
            this.label_elem = add_param_label(this.expr_line, this.label_display)
            const code_elem = this.item.add_editbox(this.expr_line, true)

            this.ctx_menu.add_context_menu(this.line_elem)
        }
    }
    modify(v) {
        if (v === this.v)
            return
        this.v = v
        if (this.elem_input !== null)
            this.elem_input.checked = v
        this.call_change()
        this.pset_dirty()
    }
    get_value() {
        dassert(this.v !== undefined, "value of bool not set")
        return this.v
    }
    gl_set_value(loc) {
        gl.uniform1i(loc, this.get_value())
    }  

    pclear_dirty() {
        super.pclear_dirty()
        if (this.pulse_need_reset) {
            this.v = false
            this.pulse_need_reset = false
            this.pset_dirty(false)
        }
    }

}

function get_default(m, k, d) {
    if (m[k] === undefined)
        m[k] = d
    return m[k]
}

class DispParamBool extends ParamBool {
    constructor(disp_values, label, prop_name, start_v) {
        super(null, label, get_default(disp_values, prop_name, start_v), 
              (v)=>{disp_values[prop_name]=v; trigger_frame_draw()},{allow_expr:false, expr_visible:false})
    }
    pset_dirty() {} // this override is needed to avoid draw triggers that mess with the controls
}

function arr_equals(a, b) {
    if ( (a == null) != (b == null) )
        return false
    if (a == null)
        return true
    if ( (a == undefined) != (b == undefined) )
        return false
    if (a == undefined)
        return true
    if (a.length === undefined || b.length === undefined)
        return a == b
    if (a.length !== b.length)
        return false
    for(let i = 0; i < a.length; ++i)
        if (a[i] !== b[i])
            return false;
    return true
}

// it's also being used for show_code from Param ctor
function normalize_slider_conf(sc) {
    if (sc === null || sc === undefined)
        return {min:0, max:1, visible:false, allowed:true} // allowed false means there's no option to activate it
    else if (sc.min === undefined && sc.allowed === undefined && Array.isArray(sc)) // it's just an array of two nums
        return {min:sc[0], max:sc[1], visible:true, allowed:true }
    if (sc.allowed === undefined)
        sc.allowed = true
    if (sc.visible === undefined)
        sc.visible = sc.allowed
    if (sc.min === undefined)
        sc.min = 0
    if (sc.max === undefined)
        sc.max = 1
    return sc
}
function is_default_slider_conf(sc) {
    return (sc.min === 0 && sc.max === 1 && sc.visible === false && sc.allowed === true)
}
function slider_conf_equal(a, b) {
    return (a.min === b.min && a.max === b.max && a.visible === b.visible && a.allowed === b.allowed)
}

class CustomContextMenu  // custom since it has it's own adders
{
    constructor(node) {
        this.ctx_menu_elem = null // when the context menu is visible, otherwise null
        this.ctx_menu_adders = [] // list of add_elem(parent) function to populate the context menu
        this.owner_node = node
    }
    add_to_context_menu(add_elems_func) {
        this.ctx_menu_adders.push(add_elems_func)
    }

    add_context_menu(line) {
        if (this.ctx_menu_adders.length === 0)
            return
        const dismiss_menu = ()=>{
            if (this.ctx_menu_elem) {
                this.ctx_menu_elem.parentNode.removeChild(this.ctx_menu_elem);   
                this.ctx_menu_elem = null
            }
        }
        const call_adders = (parent)=>{
            for(let adder of this.ctx_menu_adders)
                adder(parent, dismiss_menu)
        }
        myAddEventListener(line, "contextmenu", (e)=>{
            this.ctx_menu_elem = open_context_menu([{cmake_elems: call_adders}], e.pageX, e.pageY, main_view, ()=>{ dismiss_menu() } )
            param_reg_for_dismiss(this.owner_node, ()=>{dismiss_menu()})          
            e.preventDefault()
        })

    }

}


function element_context_menu(node, parent, opts) {
    const menu = {ctx_menu_elem:null}
    const dismiss_menu = ()=>{
        if (menu.ctx_menu_elem) {
            menu.ctx_menu_elem.parentNode.removeChild(menu.ctx_menu_elem);   
            menu.ctx_menu_elem = null
        }
    }
    myAddEventListener(parent, "contextmenu", (e)=>{
        menu.ctx_menu_elem = open_context_menu(opts, e.pageX, e.pageY, main_view, ()=>{ dismiss_menu() } )
        param_reg_for_dismiss(node, ()=>{dismiss_menu()})          
        e.preventDefault()
    })
}


function round_or_null(v) {
    if (v === null) 
        return null
    return Math.round(v) 
}

// represents a single value (item in a single edit box) that can be an expression and everything it needs to do
class ExpressionItem {
    constructor(in_param, prop_name, prop_type, set_prop=null, get_prop=null, slider_conf=null) {
        this.in_param = in_param
        //this.prop_name = prop_name // name of property to set in the containing param ("v", "r") kept for save,load
        this.prop_name_ser = prop_name // can be changed manually if the saved name need to be different (to avoid collision)
        // when implementing set_prop, get_prop, make sure they preseve setting and getting null from the object, needed for variables
        this.set_prop = (set_prop !== null) ? set_prop : (v)=>{ this.in_param[prop_name] = v }
        this.get_prop = (get_prop !== null) ? get_prop : ()=>{ return this.in_param[prop_name] }
        this.prop_type = prop_type  // constant like ED_FLOAT used for formatting the value
        this.editor = null
        this.e = null  // expression AST, can call eval() on this or null of the value is just a number
        this.se = "" + this.get_prop() // expression string
        this.elast_error = null // {line: msg:} of the error if there was one or null
        this.need_inputs = null // map string names of the inputs needed, already verified that they exist to the ObjRef that needs filling
        this.err_elem = null

        this.override_create_elem = null
        this.parse_opt = PARSE_EXPR
        
        this.slider_conf = normalize_slider_conf(slider_conf)
        this.initial_slider_conf = clone(this.slider_conf)
        this.slider = null // object returned by add_param_slider (has funcs to control slider)
        this.ctx_menu = new CustomContextMenu(in_param.owner)
        if (this.slider_conf.allowed) {
            this.add_slider_ctx_menu()
        }
        this.param_line = null
        this.etype = null
        this.etype_undecided = false // these are flags since the expression can be both, not actually read, for debugging
        this.etype_depend_var = false
        this.in_param.reg_expr_item(this)
        this.expr_score = null
        this.variable_evaluators = {}
        // changed for code/non-code expression distinction. expr might be visible but the param might not be
        // used for knowing if the expression must be resolved
        this.eactive = true  
        this.last_resolve_varbox = null
    }
    set_eactive(v) {
        this.eactive = v
    }
    eis_active() {
        // with color, it may still be active since it's the only one but not visible
        return this.in_param.pis_active() && this.eactive
    }
    save_to(r) {
        if (this.e !== null && this.e.get_const_value() !== null)
            r["e_" + this.prop_name_ser] = this.e.get_const_value()
        else {
            const s = this.se.replace(/\r\n/g, '\n') // might have been pasted from windows
            r["se_" + this.prop_name_ser] = s
        }
        if (!slider_conf_equal(this.slider_conf, this.initial_slider_conf)) // don't need to litter
            r["sldcfg_" + this.prop_name_ser] = this.slider_conf
    }
    load(v) {
        const ve = v["e_" + this.prop_name_ser]
        if (ve !== undefined) { // has exact number value
            this.set_to_const(ve)
        }
        else { // parse string
            let vk = v["se_" + this.prop_name_ser]
            if (vk !== undefined && vk !== null) 
                this.peval(vk) 
            else {
                let lv = v[this.prop_name_ser]
                if (lv === undefined) {
                    // old save with no code?
                    //console.error(lv !== undefined, "failed load value")
                    return;
                }
                this.do_set_prop(lv)
            }
        }
        const sldv = v["sldcfg_" + this.prop_name_ser]
        if (sldv !== undefined) // otherwise keep with the one from the ctor
            this.slider_conf = normalize_slider_conf(sldv)
    }
    do_set_prop(v, do_slider_update=true) {
        // v is going to be null if the value is not known yet, due to yet needed objects or yet missing variables
        if (this.prop_type == ED_INT)
            v = round_or_null(v)
        if (do_slider_update && this.slider !== null)
            this.slider.update(v, this.expr_score !== EXPR_CONST) // slider needs to know if it's disabled or not, called on add_elem
        const ov = this.get_prop()
        if (this.prop_type == ED_COLOR_EXPR) {
            if (arr_equals(v, ov))
                return false
        } else {
            if (v === ov)
                return false
        }
        try {
            this.set_prop(v)     
        }
        catch(e) {
            this.eset_error(e)
            throw e
        }
        return true
    }

    eset_error(ex) {
        if (this.elast_error !== null)
            return
        this.elast_error = {line:ex.line, msg:ex.message}
        if (this.editor) {
            this.editor.show_err(this.elast_error)
        }

        // this was just in the peval catch but probably a good idea to do it in any error
        if (this.in_param.owner.cls !== undefined) // this can be undefined if there's an exception in the node initialization value, before cls was assigned to
            set_error(this.in_param.owner.cls, "Parameter expression error")

    }
    eclear_error() {
        if (this.elast_error === null) 
            return
        this.elast_error = null
        if (this.editor)
            this.editor.clear_err()
    }
    do_check_type(expect_vars_resolved=false) {
        const etype = ExprParser.check_type(this.e, expect_vars_resolved)        
        if (etype === TYPE_UNDECIDED) {
            this.etype = null
            this.etype_undecided = true
            return etype
        }
        if (etype == TYPE_DEPEND_ON_VAR) {
            this.etype = null
            this.etype_depend_var = true
            return etype // can't do it now, will be called again when we have the mesh
        }
        this.etype = etype
        this.etype_depend_var = false  // we know it's neither of these if we got a real type, it can be both of them added at two invocations of this function
        this.etype_undecided = false
        if (this.prop_type === ED_COLOR_EXPR)
            eassert(this.etype === TYPE_VEC3 || this.etype === TYPE_VEC4, "Wrong type, expected a vec3/4, got " + typename(this.etype))
        else if (this.prop_type === ED_VEC2)
            eassert(this.etype === TYPE_VEC2, "Wrong type, expected vec2, got " + typename(this.etype))
        else if (this.prop_type === ED_BOOL)
            eassert(this.etype === TYPE_BOOL || this.etype === TYPE_NUM, "Wrong type, expected bool or number, got " + typename(this.etype))
        else if (this.prop_type === ED_TRANSFORM)
            eassert(this.etype === TYPE_MAT3, "Wrong type, expected mat3, got " + typename(this.etype))
        else
            eassert(this.etype === TYPE_NUM, "Wrong type, expected a number, got " + typename(this.etype)) 
        return etype
    }

    peval_self() {
        this.peval(this.se)
    }
    peval(se) { // parse-eval
        eassert(se !== null && se !== undefined, "unexpected null string-expr")
        this.se = se // might be a plain number as well
        this.eclear_error()
        let state_access = null
        if (this.in_param.owner !== null) {
            state_access = this.in_param.owner.state_access  // all nodes should have this
            if (state_access === null) {
                // if the NodeCls was going to call this it should have done it before creating any Params. We need it now
                // for variables parsing so we create it on demand
                state_access = this.in_param.owner.set_state_evaluators([])
            }
        }
        else  // disp_params have this null
            state_access = new StateAccess([]) 

        let state_access_need_inputs = null
        try {
            state_access.reset_check()
            this.e = ExprParser.parse(se, state_access, this.parse_opt)
            this.variable_evaluators = state_access.need_variables
            state_access_need_inputs = state_access.need_inputs
            this.expr_score = state_access.score  // score determines if the expression depends on anything
            this.etype_undecided = false  // TBD can be refactored to not be members?
            this.etype_depend_var = false
            // if it contains reference to variables try to resolve them now, before type-check, do both global and locals
            this.eresolve_evaluators(this.last_resolve_varbox, true, true, true) // can fail, we'll have another chance before run
            this.do_check_type() // sets etype_undecided, etype_depend_var
        }
        catch(ex) { // TBD better show the error somewhere
            this.eset_error(ex)
            return
        }
        finally {
            state_access.need_variables = null // reset it immediately so it won't be used
            state_access.need_inputs = null
            state_access.score = EXPR_CONST
        }

        if (this.expr_score === EXPR_CONST) { // depends on anything?
            if (this.do_set_prop(this.call_eval()))  // returns false if it's the same value
                this.in_param.pset_dirty() 
            this.need_inputs = null
        }
        else {
            // if it depends on external input, don't do anything since eval would throw
            // if etype_depend_var is true it means we're still dependent on a variable that's not in the last box (maybe last-box is null), eval would throw
            if (this.etype_undecided || this.etype_depend_var)
                this.do_set_prop(null)
            else { // it depends only in variables so can try to eval (will succeed if all variables are there)
                if ((this.expr_score & EXPR_GLSL_ONLY) == 0) // don't want to eval expression that is glsl only
                    this.do_set_prop(this.call_eval())
            }
            this.in_param.pset_dirty() // TBD maybe expression didn't change?           
            if ((this.expr_score & EXPR_NEED_INPUT) != 0) {
                this.need_inputs = state_access_need_inputs
            }
        }      

        // needs to be after we possibly did set_prop so it gets the current value
        this.in_param.call_change() // need to do this even if it's not const for glsl in FuncFill
    }


    display_slider(is_first)  // on first display, always add the element if enabled
    {
        if (this.slider_conf.visible && (this.slider == null || is_first)) {
            this.slider = add_param_slider(this.param_line, this.slider_conf.min, this.slider_conf.max, null, this.prop_type, (v)=>{
                if (this.set_to_const(v)) { // might not have changed (with int)
                    this.in_param.call_change()
                    this.in_param.pset_dirty() 
                }
            })
            this.slider.update(this.get_prop(), this.expr_score !== EXPR_CONST)
           // this.peval_self() // Old lazy- this will set the slider position and enablement (but not do pset_dirty since nothing changed)
        }
        else if (!this.slider_conf.visible && this.slider != null) {
            this.slider.elem.parentNode.removeChild(this.slider.elem)
            this.slider = null
        }
    }
    
    add_slider_ctx_menu() {
        let update_range = ()=>{
            if (this.slider === null)
                return
            this.slider.update_range(this.slider_conf.min, this.slider_conf.max)
            save_state()
        }

        let enable_slider_checkbox = (parent)=>{ 
            let sld_line = add_div(parent, 'prm_slider_ctx_line')
            let [ein,etext,edisp] = add_param_checkbox(sld_line, "Slider", this.slider_conf.visible, (v)=>{ 
                this.slider_conf.visible = v; 
                this.display_slider(false)
                toggle_en(v)
                save_state() // nothing else save the state since this is just a GUI change
            })
            //etext.classList.add('ctx_menu_opt')
            let min_line = add_div(parent, 'prm_slider_ctx_line')
            add_elem(min_line, 'SPAN', 'prm_slider_ctx_label').innerText = "Min:"
            add_param_edit(min_line, this.slider_conf.min, ED_FLOAT, (v)=>{ this.slider_conf.min=v; update_range() })
            let max_line = add_div(parent, 'prm_slider_ctx_line')
            add_elem(max_line, 'SPAN', 'prm_slider_ctx_label').innerText = "Max:"
            add_param_edit(max_line, this.slider_conf.max, ED_FLOAT, (v)=>{ this.slider_conf.max=v; update_range() })
            let toggle_en = (v)=>{
                min_line.classList.toggle('param_disabled', !v)
                max_line.classList.toggle('param_disabled', !v)
            }
            toggle_en(this.slider_conf.visible)
        }
        this.ctx_menu.add_to_context_menu(enable_slider_checkbox)
        
    }

    // is_single_value is false for things like vec2 that have multiple values in the same line
    add_editbox(line) {
        this.param_line = line
        // this.e can be null if it stayed null from ctor and there was an error in peval
        //console.assert(this.e !== null && this.e !== undefined, "missing e, should not happen, you need to peval() after ctor") 

        const str_change_callback = (se)=>{
            try {
                this.peval(se)
            }
            catch(e) {} // eval of constfailed during typing
        }
        if (this.override_create_elem === null) {
            this.editor = new EditBoxEditor(add_param_edit(line, this.se, ED_STR, str_change_callback))
            if (this.slider_conf.allowed)
                this.display_slider(true)
        }
        else {            
            this.editor = this.override_create_elem(line, this.se, str_change_callback, this.in_param.label.replace('\n', ' '))
        }

        if (this.elast_error !== null) {
            this.editor.show_err(this.elast_error)
        }

        this.ctx_menu.add_context_menu(line)

        return this.editor
    }
    set_to_const(v) { // return true if value actually changed
        this.eclear_error()  // when moving slider clear any error that might have been there before
        this.e = ExprParser.make_num_node(v)
        this.se = formatType(v, this.prop_type)
        this.expr_score = EXPR_CONST
        this.need_inputs = null
        this.variable_evaluators = {} // need for forget about the previous expression
        if (this.editor !== null)
            this.editor.set_value(this.se)
        return this.do_set_prop(v) // in color, need it the picker style to not be italic
        // pset_dirty done in caller
    }
    dyn_eval() {
        this.eclear_error()
        if (this.etype === null) { // either undecided or depend on var, doesn't matter since we need to run this anyway
            try {
                this.do_check_type() // in case we need to do it now, after there was a mesh set
            }
            catch(ex) {
                this.eset_error(ex)
                throw ex // will be caught by do_run
            }                     
        }
        if (this.e === null)  // error in expr or const
            return this.get_prop()
        // the state_input was put there using the evaler before the call to here
        return this.call_eval()
    }

    call_eval() {
        try {
            return ExprParser.do_eval(this.e) // the state_input was put there using the evaler before the call to here
        }
        catch(ex) {
            this.eset_error(ex)
            if (ex.node_cls === undefined)
                ex.node_cls = this.in_param.owner.cls            
            throw ex // will be caught by the node and node error set by caller          
        }
    }

    eto_glsl(emit_ctx) {
        this.eclear_error()
        try {
            return ExprParser.do_to_glsl(this.e, emit_ctx, this.parse_opt) 
        }
        catch(ex) {
            this.eset_error(ex)
            if (ex.node_cls === undefined)
                ex.node_cls = this.in_param.owner.cls            
            throw ex 
        }                     
    }

    // returns null or the ObjRef of this name
    need_input_evaler(input_name) {
        if (this.need_inputs === undefined || this.need_inputs === null)
            return null
        let ev = this.need_inputs[input_name]
        if (ev === undefined)
            return null
        return ev
    }
    get_last_error() {
        if (this.elast_error === null)
            return null
        return this.elast_error.msg
    }

    // assign the evaluators from the current expression values according to the given box or the global box
    eresolve_evaluators(in_vars_box, allow_not_found, do_globals, do_locals) {
        let vis_dirty = false
        // go over the variables in the expr and set values to them
        for(let vename in this.variable_evaluators) 
        {
            const ve = this.variable_evaluators[vename]
            if (!ve.is_valid())
                continue
            if (do_globals)
                ve.var_box = null //unbind it in the first stage
            let from_in = undefined
            if (do_locals && in_vars_box !== null)
                from_in = in_vars_box.lookup(ve.varname)  // VariablesObj
            if (do_globals && from_in === undefined)
                from_in = g_anim.globals_vars_box.lookup(ve.varname) // for frame_num
            
            if (from_in === null) {
                if (ve.var_box !== null)
                    continue // it was already bound in the globals call
                // when called from peval it may not be able to resolve since the variables are not there yet
                if (allow_not_found)
                    continue
                // when called with do_globals, we don't want to raise an error for something that would resolve for a local, 
                // we want to make sure though that local is called so marking as dirty (changing the global variable to make it not visible to here is what made this node "dirty")
                //    do_locals is just before run so it needs to make this check
                if (do_globals) {
                    this.in_param.pset_dirty()
                    continue
                }
                throw new ExprErr("Unknown variable " + ve.varname, ve.line_num) // TBD add what line                
            }
            ve.var_box = from_in
            vis_dirty = vis_dirty || from_in.vis_dirty()
        }
        return vis_dirty
    }

    eresolve_variables(in_vars_box, do_globals, do_locals) {
        this.last_resolve_varbox = in_vars_box
        if ((this.expr_score & EXPR_NEED_VAR) == 0)
            return
        if (!this.eis_active())
            return // if it's not the active param, don't need to do anything, when its getting activate it's going to get peval and resolve
                   // also, resolve can be allowed to fail if this is not a active expression
        try {
            const vis_dirty = this.eresolve_evaluators(in_vars_box, false, do_globals, do_locals) // should not fail, failure means the node fails
            // if ov (old-v) is null, don't even bother checking if it's dirty since we need to eval anyway
            // this can happen when peval() is called (sometimes not even for parsing new expr)
            const ov = this.get_prop()
            if (!vis_dirty && ov !== null)
                return // don't need to do anything since nothing changed

            this.eclear_error() // clear the errors only if we're going to run check_type again              
            ExprParser.clear_types_cache(this.e) // some variable change, it's possible we need to change the type of everything
            const etype = this.do_check_type(do_locals) // expect_vars_resolved only when we do locals since that's the last chance. When we do_globals there's still a chance it will be resolved from locals
            if (etype === TYPE_DEPEND_ON_VAR)
                return // nothing more to do, it will be resolved in the locals call, can't call eval

            let did_change = false
            // similar to what is done at the end of peval
            if ((this.expr_score & EXPR_NEED_INPUT) != 0) { // && this.in_param.owner.cls.needed_inputs_are_varying()) {
                this.do_set_prop(null) // it's dynamic so best if it doesn't have a proper value from before
                this.in_param.pset_dirty() // it's a parameter that needs input from the node, assume that it's going to change always, unless the node says otherwise
                did_change = true
            }
            else {
                if (this.do_set_prop(this.call_eval(), false)) {// don't do slider-update since we know the it's non-const expr and slider need to remain transparent
                    this.in_param.pset_dirty()
                    did_change = true
                }
            }
            return did_change // for call_change in caller
        }
        catch(ex) {
            this.eset_error(ex)
            throw ex // will be caught by do_run
        }            
    }
}

// abstract setting the error and value into an editor object so that it can be interchanged with Ace Editor for code
// this just wraps a normal edit-box
class EditBoxEditor {
    constructor(elem) {
        this.elem = elem
        this.err_elem = null
    }

    show_err(err_text) {
        //let edit_rect = this.elem.getBoundingClientRect(), line_rect = this.this.elem.parentElement.getBoundingClientRect()
        this.err_elem = create_div("param_edit_err_box")
        this.err_elem.innerText = err_text.msg
        this.err_elem.style.left = Math.round(this.elem.offsetLeft) + "px"
        this.err_elem.style.top = Math.round(this.elem.offsetHeight) + "px"
        this.elem.parentElement.insertBefore(this.err_elem, this.elem.nextSibling)

        this.elem.classList.toggle("param_input_error", true)
    }
    clear_err() {
        this.elem.classList.toggle("param_input_error", false) 
        if (this.err_elem) {
            this.err_elem.parentElement.removeChild(this.err_elem)
            this.err_elem = null
        }  
    }

    set_value(v) {
        this.elem.value = v
    }

    get_elem() { return this.elem }
}

// used by all params that have code option
let CodeItemMixin = (superclass) => class extends superclass {
    constructor(node, label, conf) {
        super(node, label)
        this.allowed_code = true
        if (conf !== null && conf.allowed_code === false) {
            this.allowed_code = false
            this.show_code = false
        }
        else {
            this.show_code = (conf !== null && conf.show_code === true) ? true : false  // show code or show line editbox
        }
        // dlg_rect - position and size of dialog, panel_rect - size of editor in panel
        // needs extra indirection so that Editor set into into on popout (saves pos and size of dialog)
        this.dlg_rect_wrap = {dlg_rect: null, panel_rect: null} 
        
    }

    // called from derived constructor
    make_code_item(code_expr, start_v) {
        this.code_item = code_expr
        this.code_item.prop_name_ser = "cv"
        this.code_item.override_create_elem = (line, show_v, change_func, prop_name)=>{          
            const ed = new Editor(line, show_v, change_func, {lang:"glsl", dlg_title:prop_name, dlg_rect_wrap:this.dlg_rect_wrap, with_popout:true});
            return ed
        }
        this.code_item.parse_opt = PARSE_CODE
        this.populate_code_ctx_menu(this.code_item.ctx_menu)
        // initial code string, done even if code is not selected since this is the only place we can do this initialization
        this.code_item.peval("return " + start_v)  
        this.do_set_eactives()

        this.code_line = null
        this.single_line = null  // set in the subclass add_elems
        this.show_code_callback = null    
    }

    add_code_elem() {
        if (!this.allowed_code)
            return
        if (this.line_elem === null) // add_elem was never called
            return
        if (this.code_line !== null) {
            this.line_elem.appendChild(this.code_line) // was already created and its test should be up to date with the item
            return
        }
        if (!this.show_code)
            return // will be created when needed on set_show_code()
        this.code_line = add_param_line(this.line_elem)  // don't pass this since it's in the line_elem
        elem_set_visible(this.code_line, this.show_code)
        add_param_label(this.code_line, this.label_display)
        const code_elem = this.code_item.add_editbox(this.code_line, true)
    }

    save_code(r) {
        delete r.show_code // remove old
        if (this.show_code)
            r.show_code = true // default false, don't add to save space
        if (this.dlg_rect_wrap.dlg_rect !== null)
            r.dlg_rect = this.dlg_rect_wrap.dlg_rect
        if (this.dlg_rect_wrap.panel_rect !== null)
            r.panel_rect = this.dlg_rect_wrap.panel_rect
        this.code_item.save_to(r); 
    }
    load_code(v) {
        this.show_code = v.show_code || false; 
        this.dlg_rect_wrap.dlg_rect = v.dlg_rect || null
        this.dlg_rect_wrap.panel_rect = v.panel_rect || null
        this.code_item.load(v)
        this.do_set_eactives()
    }

    do_set_eactives() {
        this.code_item.set_eactive(this.show_code)
        this.non_code_eactive(!this.show_code) 
    }

    set_show_code(v) {
        if (v === this.show_code)
            return
        this.show_code = v
        if (v && this.code_line === null) // need it and didn't add it
            this.add_code_elem()
        if (this.single_line !== null) { // displayed?
            elem_set_visible(this.single_line, !v)
            if (this.code_line !== null)
                elem_set_visible(this.code_line, v)
        }
        this.do_set_eactives()

        if (v)  // in case it's a const, set this.v to a value from the right source
            this.code_item.peval_self()
        else
            this.non_code_peval_self()
        if (this.show_code_callback)
            this.show_code_callback(v)  // for updating SetAttr param external checkbox
        this.pset_dirty() 
    }

    
    populate_code_ctx_menu(ctx_menu) {
        if (!this.allowed_code)
            return
        const add_code_checkbox = (parent, dismiss_func)=>{
            let chk_line = add_div(parent, 'prm_slider_ctx_line')
            let [ein,etext,edisp] = add_param_checkbox(chk_line, "Code", this.show_code, (v)=>{ 
                this.set_show_code(v)
                dismiss_func()
            })            
        }
        ctx_menu.add_to_context_menu(add_code_checkbox)
    }
};

// used by single-value params that have expression and code ability
// conf: show_code: bool 
//       allowed_code: bool
//       allowed: bool  (for slider)
class ParamBaseExpr extends CodeItemMixin(Parameter)
{
    constructor(node, label, start_v, ed_type, conf=null, change_func=null) {
        super(node, label, conf)
        dassert(start_v !== undefined, "start value should not be undefined");
        //this.v = start_v  // numerical value in case of const
        let set_prop_neg, set_prop_pos
        if (conf === null || conf.validate === undefined) {
            set_prop_neg = (v)=>{ if (!this.show_code) this.v = v }
            set_prop_pos = (v)=>{ if (this.show_code) this.v = v }
        }
        else {
            set_prop_neg = (v)=>{ if (!this.show_code) { conf.validate(v); this.v = v } } // prevent negative in physics
            set_prop_pos = (v)=>{ if (this.show_code) { conf.validate(v); this.v = v } }
        }
        this.v = null
        this.item = new ExpressionItem(this, "v", ed_type, set_prop_neg, null, conf)
        this.populate_code_ctx_menu(this.item.ctx_menu)
        this.single_line = null
        this.item.peval(start_v)  // if it's a param that can be either code or non-code, it's start_v should be a single expression
        
        const code_expr = new ExpressionItem(this, "v", ed_type, set_prop_pos, null, {allowed:false})
        this.make_code_item(code_expr, start_v)
        this.change_func = change_func // set change_func after peval so that it won't be called in this initial peval (and the one in the code item), before all the other params were created (it will be called after load)
    }

    non_code_peval_self() {
        this.item.peval_self()
    }
    non_code_eactive(v) {
        this.item.set_eactive(v)
    }

    save() { 
        let r = {}; 
        this.item.save_to(r); 
        this.save_code(r)
        return r
    }
    load(v) { 
        this.item.load(v); 
        this.load_code(v)
    }

    add_elems(parent) {
        this.line_elem = add_param_multiline(parent, this)

        this.single_line = add_param_line(this.line_elem) // don't pass this here since we passed it for line_elem
        elem_set_visible(this.single_line, !this.show_code)
        this.label_elem = add_param_label(this.single_line, this.label_display)

        if (this.is_sharing_line_elem() && this.allowed_code) //  if it's sharing a line, clearly it wasn't meant to be code
            throw new Error("param that shares line doesn't work with allowed_code")

        this.item.add_editbox(this.single_line, true)
        this.add_code_elem()
    }

    get_active_item() {
        return this.show_code ? this.code_item : this.item
    }

    dyn_eval() {
        return this.get_active_item().dyn_eval()
    }
    need_input_evaler(input_name) {
        return this.get_active_item().need_input_evaler(input_name)
    }
    get_last_error() {
        return this.get_active_item().get_last_error()
    }
    modify(v, dirtyify=true) {  // dirtify false used in NodeFuncFill (when called from within run())
        if (this.show_code)
            return // code item should not be modified since that would erase the code
        if (this.item.set_to_const(v) && dirtyify)
            this.pset_dirty()
    }
    increment(dv) {
        if (this.show_code)
            return
        this.item.set_to_const(this.v + dv)
        this.pset_dirty() 
    }
}


class ParamFloat extends ParamBaseExpr {
    constructor(node, label, start_v, conf=null, change_func=null) {
        super(node, label, start_v, ED_FLOAT, conf, change_func)
    }
    gl_set_value(loc) {
        gl.uniform1f(loc, this.get_value())
    }    
}
class ParamInt extends ParamBaseExpr {
    constructor(node, label, start_v, conf=null, change_func=null) {
        super(node, label, start_v, ED_INT, conf, change_func)
        this.item.set_prop = (v)=>{ this.v = round_or_null(v)  }
    }
    gl_set_value(loc) {
        gl.uniform1i(loc, this.get_value())
    }      
}


class DispParamFloat extends ParamFloat {
    constructor(disp_values, label, prop_name, start_v) {
        const slider_values = disp_values[prop_name + "_slider"]
        let conf = { allowed_code:false }
        if (slider_values !== undefined)
            conf = {...conf, ...slider_values}
        const real_start_v = toFixedMag(get_default(disp_values, prop_name, start_v))  // avoid long float tail
        super(null, label, real_start_v, conf, (v)=>{
            disp_values[prop_name] = v
            // reference the slider_conf object and not just copy it so that changes to it made by the ui be saved even if this function is not called
            disp_values[prop_name + "_slider"] = this.item.slider_conf
            trigger_frame_draw()
        })
    }
    pset_dirty() {} // this override is needed to avoid draw triggers that mess with the controls
}


class ParamVec2 extends CodeItemMixin(Parameter) {
    constructor(node, label, start_x, start_y, conf=null, change_func) {
        super(node, label, conf)
        dassert(start_x !== undefined && start_y !== undefined, "start value should not be undefined")
        this.x = start_x
        this.item_x = new ExpressionItem(this, "x", ED_FLOAT, (v)=>{ if (!this.show_code) this.x = v }, null, {allowed:false})
        this.y = start_y
        this.item_y = new ExpressionItem(this, "y", ED_FLOAT, (v)=>{ if (!this.show_code) this.y = v }, null, {allowed:false})
        this.dial = null
        this.single_line = null
        this.item_x.peval_self()
        this.item_y.peval_self()
        this.dial = null // set and used by the Node

        this.populate_code_ctx_menu(this.item_x.ctx_menu) // need to add only on one of them since it's added on the line

        const code_expr = new ExpressionItem(this, "-unused-", ED_VEC2,  
            (v)=>{ 
                if (!this.show_code) 
                    return 
                if (v === null) { this.x = null; this.y = null; } // happens when doing dynamic eval
                else { this.x = v[0]; this.y = v[1] }
            }, 
            ()=>{ 
                if (this.x === null)
                    return null
                return [this.x,this.y] 
            }, 
            {allowed:false})
        this.make_code_item(code_expr, "vec2(" + start_x + ", " + start_y + ")")
        this.size_dial = null // if was ever created
        this.change_func = change_func
    }

    call_change() { 
        if (this.change_func) 
            this.change_func([this.x, this.y])
    }

    non_code_peval_self() {
        this.item_x.peval_self()
        this.item_y.peval_self()
    }
    non_code_eactive(v) {
        this.item_x.set_eactive(v)
        this.item_y.set_eactive(v)
    }
    save() { 
        let r = { }; 
        this.item_x.save_to(r); 
        this.item_y.save_to(r); 
        this.save_code(r)
        return r 
    }
    load(v) { 
        this.item_x.load(v)
        this.item_y.load(v) 
        this.load_code(v)
    }
    add_elems(parent) {
        this.line_elem = add_param_multiline(parent, this)

        this.single_line = add_param_line(this.line_elem)  // don't pass this since it's in the line_elem
        elem_set_visible(this.single_line, !this.show_code)
        this.label_elem = add_param_label(this.single_line, this.label_display)
        this.item_x.add_editbox(this.single_line)
        this.item_y.add_editbox(this.single_line)
        this.shared_line_elem = this.single_line

        this.add_code_elem()
    }
    get_value() {
        dassert(this.x !== null && this.x !== undefined, "value of vec2 expr not set")
        return [this.x, this.y]
    }
    increment(dv) {
        if (this.show_code)
            return
        this.item_x.set_to_const(this.x + dv[0])
        this.item_y.set_to_const(this.y + dv[1])
        this.pset_dirty() 
    }
    modify(v, dirtyify=true, force_change=false) { // force for mouse-delta that doesn't change much but still wants to dirty
        this.modify_e(v[0], v[1], dirtyify, force_change)
    }
    modify_e(x, y, dirtyify=true, force_change=false) {
        if (this.show_code)
            return
        let changed = force_change
        changed |= this.item_x.set_to_const(x)
        changed |= this.item_y.set_to_const(y)
        if (changed && dirtyify)
            this.pset_dirty() 
    }
    dyn_eval() {
        if (this.show_code)
            return this.code_item.dyn_eval()
        const x = this.item_x.dyn_eval()
        const y = this.item_y.dyn_eval()
        return vec2.fromValues(x, y)
    }
    need_input_evaler(input_name) {
        if (this.show_code)
            return this.code_item.need_input_evaler(input_name)
        // the first one that has it is good since all who has it have the same one (objref)
        return this.item_x.need_input_evaler(input_name) || this.item_y.need_input_evaler(input_name)
    }
    get_last_error() {
        if (this.show_code)
            return this.code_item.get_last_error()
        return this.item_x.get_last_error() || this.item_y.get_last_error()
    }

    gl_set_value(loc) {
        dassert(this.x !== undefined, "value of vec2 expr not set (gl_set)")  // instead of going through get_value()
        gl.uniform2f(loc, this.x, this.y)
    }

    size_dial_draw(transform_v, m) {
        if (this.size_dial === null)
            this.size_dial = new SizeDial(this)
        this.size_dial.draw(transform_v, m)
    }
    size_dial_find_obj(e) {
        if (this.size_dial === null)
            return // it is first drawn, then clicked
        return this.size_dial.find_obj(e)
    }

}

class ParamVec2Int extends Parameter {
    constructor(node, label, start_x, start_y) {
        super(node, label)
        this.x = start_x
        this.y = start_y
        this.elem_x = null; this.elem_y = null
    }
    save() { return {x:this.x, y:this.y} }
    load(v) { this.x=v.x; this.y=v.y }
    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        this.label_elem = add_param_label(this.line_elem, this.label_display)
        this.elem_x = add_param_edit(this.line_elem, this.x, ED_INT, (v) => { this.x = parseInt(v); this.pset_dirty() }) // NOTE with expr v can be null!
        this.elem_y = add_param_edit(this.line_elem, this.y, ED_INT, (v) => { this.y = parseInt(v); this.pset_dirty() })
    }
    set(x, y) { 
        this.x = Math.round(x); this.y = Math.round(y); 
        this.pset_dirty() 
        if (this.elem_x === null)
            return
        this.elem_x.value = this.x
        this.elem_y.value = this.y
    }
    get_value() {
        return [this.x, this.y]
    }
}

function color_comp_clamp(v) {
    return clamp(0, v, 255)
}
function make_rgb_str(c) {
    const s = "(" + c.r + ", " + c.g + ", " + c.b
    if (c.alpha === 1)
        return "rgb" + s + ")"
    return "rgba" + s + ", " + c.alpha + ")"

}

// doesn't support expression in the non-code input
class ParamColor extends CodeItemMixin(Parameter) 
{
    constructor(node, label, start_c_str, conf=null) {
        super(node, label, conf)
        if (!Array.isArray(start_c_str)){
            this.v = ColorPicker.parse_hex(start_c_str)
            start_c_str = [start_c_str, make_rgb_str(this.v)]
        }
        else {
            this.v = ColorPicker.parse_hex(start_c_str[0])
        }
        this.picker = null
        this.picker_elem = null
        this.picker_v = clone(this.v)  // basically the same as v, as if there's no code so that the picker state would be saved
        this.picker_ctx_menu = new CustomContextMenu(this.owner)
        this.populate_code_ctx_menu(this.picker_ctx_menu)

        const code_expr = new ExpressionItem(this, "-unused-", ED_COLOR_EXPR, 
            (v)=>{
                if (!this.show_code) 
                    return
                return this._set_value_from_arr(v)
            }, 
            ()=>{ 
                if (this.v.r === null)
                    return null
                return vec4.fromValues(this.v.r, this.v.g, this.v.b, this.v.alphai) 
            }, 
            {allowed:false})
        this.make_code_item(code_expr, start_c_str[1])
    }

    // returns true if it did something
    _set_value_from_arr(v) {
        if (v === null) { 
            if (this.v.r === null)
                return false
            this.v.r = null; this.v.g = null; this.v.b = null; this.v.alpha = null; this.v.alphai = null
            return true
        }
        const r = color_comp_clamp(v[0])
        const g = color_comp_clamp(v[1])
        const b = color_comp_clamp(v[2])
        let alpha, alphai
        if (v.length === 3) { // expr result can be either vec3 or vec4
            alphai = 255
            alpha = 1
        }
        else {
            alphai = color_comp_clamp(v[3])
            alpha = this.v.alphai/255
        }        
        if (this.v.r == r && this.v.g == g && this.v.b == b && this.v.alphai == alphai)
            return false
        this.v.r = r; this.v.g = g; this.v.b = b; this.v.alpha = alpha; this.v.alphai = alphai
        return true
    }

    non_code_peval_self() {
        this.v = clone(this.picker_v)
        this.pset_dirty()
    }
    non_code_eactive(v) {
    }
    get_value() { // reimplement if this.v is not ther value
        dassert(this.v.r !== null, "value of color expr not set")
        return this.v
    }
    save() { 
        let r = {}
        if (this.picker_v !== null)
            r.hex = this.picker_v.hex
        this.save_code(r)  // dirty it abit but it doesn't really matter
        return r 
    }
    load(v) { 
        this.load_code(v)
        this.picker_v = ColorPicker.parse_hex(v.hex) // modify picker state, might not be the same as .v due to code
        if (!this.show_code)
            this.v = clone(this.picker_v)
    }
    add_elems(parent) {
        this.line_elem = add_param_multiline(parent, this)

        this.single_line = add_param_line(this.line_elem);  // don't pass this since it's in the line_elem
        elem_set_visible(this.single_line, !this.show_code)

        this.label_elem = add_param_label(this.single_line, this.label_display)
        let [iv, elem, picker] = add_param_color(this.single_line, this.picker_v, 'param_input', (v)=>{ 
            if (this.v !== null && this.v.hex == v.hex) 
                return;
            if (v === null)
                this.v = null
            else {
                this.v = v.copy() // make a copy so that this.v will be different object than the internal object
            }
            this.picker_v = clone(this.v)
            this.pset_dirty()
        })
        this.v = iv; 
        this.picker_elem = elem; 
        this.picker = picker
        this.picker_ctx_menu.add_context_menu(this.picker_elem)

        this.add_code_elem()
    }
    dyn_eval() {        
        if (this.show_code) {
            let v = this.code_item.dyn_eval()
            v[0] = color_comp_clamp(v[0])
            v[1] = color_comp_clamp(v[1])
            v[2] = color_comp_clamp(v[2])            
            if (v.length == 3)
                v = vec4.fromValues(v[0], v[1], v[2], 255)
            else
                v[3] = color_comp_clamp(v[3])
            return v
        }
        return vec4.fromValues(this.v.r, this.v.g, this.v.b, this.v.alphai) // constant
    }
    need_input_evaler(input_name) {
        if (this.show_code)
            return this.code_item.need_input_evaler(input_name)
        return null
    }
    get_last_error() {
        if (this.show_code)
            return this.code_item.get_last_error()
        return null
    }
    modify(v, dirtify=true) {
        if (this.show_code)
            return // when in code, modify doesn't work, see ParamBaseExpr
        if (this._set_value_from_arr(v) && dirtify)
            this.pset_dirty(true)
    }
    gl_set_value(loc) {
        dassert(this.v.r !== null, "value of color expr not set (gl)")
        gl.uniform4f(loc, this.v.r/255, this.v.g/255, this.v.b/255, this.v.alpha)
    }   
}



function toFixedMag(f) {
    if (Math.abs(f) < 1e-13)
        return "0"
    let af = Math.min(Math.round(Math.log10(Math.abs(f)))-2, -3)
    return f.toFixed(-af)
}


class ParamTransform extends CodeItemMixin(Parameter) {
    constructor(node, label, start_values={}, opts=null, change_func=null) {
        super(node, label, opts)
        this.translate = [0,0] // coords here are not vec2.fromValues since they need to be nullable
        this.rotate = 0
        this.scale = [1,1]
        this.v = mat3.create()
        this.rotate_pivot = [0,0]   
        
        this.b2_style = (opts !== null && opts.b2_style === true) ? true : false
        this.elems = {tx:null, ty:null, r:null, sx:null, sy:null, pvx:null, pvy:null }
        this.dial = new TransformDial(this)
        this.single_line = null
        
        const sld_conf = {allowed:false}
        this.item_tx = new ExpressionItem(this, "tx", ED_FLOAT, (v)=>{ if (this.show_code) return; this.translate[0] = v; this.calc_mat()}, ()=>{ return this.translate[0]}, sld_conf)
        this.item_ty = new ExpressionItem(this, "ty", ED_FLOAT, (v)=>{ if (this.show_code) return; this.translate[1] = v; this.calc_mat()}, ()=>{ return this.translate[1]}, sld_conf)
        this.item_r = new ExpressionItem(this,   "r", ED_FLOAT, (v)=>{ if (this.show_code) return; this.rotate = v; this.calc_mat()},       ()=>{ return this.rotate}, {min:0, max:360})
        this.item_pvx = new ExpressionItem(this, "pvx", ED_FLOAT, (v)=>{ if (this.show_code) return; this.calc_pivot_counter(v, 0)  }, ()=>{ return this.rotate_pivot[0]}, sld_conf)
        this.item_pvy = new ExpressionItem(this, "pvy", ED_FLOAT, (v)=>{ if (this.show_code) return; this.calc_pivot_counter(v, 1)  }, ()=>{ return this.rotate_pivot[1]}, sld_conf)
        this.item_sx = new ExpressionItem(this, "sx", ED_FLOAT, (v)=>{ if (this.show_code) return; this.scale[0] = v; this.calc_mat()}, ()=>{ return this.scale[0]}, sld_conf)
        this.item_sy = new ExpressionItem(this, "sy", ED_FLOAT, (v)=>{ if (this.show_code) return; this.scale[1] = v; this.calc_mat()}, ()=>{ return this.scale[1]}, sld_conf)

        this.items = [this.item_tx, this.item_ty, this.item_r, this.item_pvx, this.item_pvy, this.item_sx, this.item_sy]
        this.item_dict = {"tx":this.item_tx, "ty":this.item_ty, "r":this.item_r, "pvx":this.item_pvx, "pvy":this.item_pvy, "sx":this.item_sx, "sy":this.item_sy }        
        
        this.populate_code_ctx_menu(this.item_tx.ctx_menu) // needed only for x since x,y share the param_line
        this.populate_code_ctx_menu(this.item_r.ctx_menu)
        this.populate_code_ctx_menu(this.item_pvx.ctx_menu)
        this.populate_code_ctx_menu(this.item_sx.ctx_menu)

        for(let name in start_values) {
            const item = this.item_dict[name]
            dassert(item !== undefined, "unknown name: " + name)
            item.peval(start_values[name])
        }
        for(let name in this.item_dict) {
            if (start_values[name] === undefined)
                this.item_dict[name].peval_self()
        }

        const code_expr = new ExpressionItem(this, "v", ED_TRANSFORM, 
            (v)=>{
                if (!this.show_code) 
                    return 
                if (v === null) 
                    this.v[0] = NaN // mark as invalid
                else 
                    mat3.copy(this.v, v)
            },
            ()=>{
                if (!this.show_code) 
                    return 
                return this.v
            }, null, {allowed:false})
        this.make_code_item(code_expr, "mat3()")
        this.change_func = change_func // reason this is here see ParamBaseExpr
    }
    non_code_peval_self() {
        // take values from items
        this.calc_mat() // TBD check after load
    }
    non_code_eactive(v) {
        for(let it of this.items)
            it.set_eactive(v)
    }
    save() { 
        let r = {} 
        this.item_tx.save_to(r); this.item_ty.save_to(r)
        this.item_r.save_to(r)
        this.item_pvx.save_to(r); this.item_pvy.save_to(r)
        this.item_sx.save_to(r); this.item_sy.save_to(r)
        this.save_code(r)
        return r
    }
    load(v) { 
        this.item_tx.load(v); this.item_ty.load(v)
        this.item_r.load(v)
        this.item_pvx.load(v); this.item_pvy.load(v)
        this.item_sx.load(v); this.item_sy.load(v)
        this.calc_mat() 
        this.load_code(v)
    }
    calc_mat() {
        mat3.identity(this.v)
        mat3.translate(this.v, this.v, this.translate)
        if (!this.b2_style)
            mat3.translate(this.v, this.v, this.rotate_pivot)
        mat3.rotate(this.v, this.v, glm.toRadian(this.rotate))
          mat3.translate(this.v, this.v, vec2.fromValues(-this.rotate_pivot[0],-this.rotate_pivot[1]))
        mat3.scale(this.v, this.v, this.scale)
        this.call_change()
        this.pset_dirty()
    }
    is_valid() {
        return !isNaN(this.v[0]) && !isNaN(this.v[1]) && !isNaN(this.v[2]) && 
               !isNaN(this.v[3]) && !isNaN(this.v[4]) && !isNaN(this.v[5]) &&
               !isNaN(this.v[6]) && !isNaN(this.v[7]) && !isNaN(this.v[8])
    }
     // calculate the translation that needs to happen to counter the change in pivot in order for the object not to move
    calc_pivot_counter(v, vind) {
        if (v === null) {
            this.rotate_pivot[vind] = null
            return
        }
        v = parseFloat(v)
        if (isNaN(v))
            return;
        let dv = v - this.rotate_pivot[vind]; 
        this.rotate_pivot[vind] = v

        if (this.b2_style) {
            this.calc_mat() // b2 objects don't need counter translate
            return
        }
        
        let dp = vec2.create()
        dp[vind] = -dv
        
        let tt = mat3.create()
        mat3.translate(tt, tt, dp)
        mat3.rotate(tt, tt, glm.toRadian(this.rotate))
        dp[vind] = -dp[vind]
        mat3.translate(tt, tt, dp)

        let dt = vec2.create()
        vec2.transformMat3(dt, dt, tt)
        this.item_tx.set_to_const(this.translate[0] + dt[0]) // TBD does extra calc_mats
        this.item_ty.set_to_const(this.translate[1] + dt[1])
        this.calc_mat()
    }
    add_elems(parent) { 
        this.line_elem = add_param_multiline(parent, this)
        this.single_line = add_param_multiline(this.line_elem)
        elem_set_visible(this.single_line, !this.show_code)

        add_elem(this.single_line, "hr", "param_separator")
        let line_t = add_param_line(this.single_line)
        add_param_label(line_t, "Translate")
        this.item_tx.add_editbox(line_t); this.item_ty.add_editbox(line_t)

        let line_r = add_param_line(this.single_line)
        add_param_label(line_r, "Rotate")
        this.item_r.add_editbox(line_r)

        let line_pv = add_param_line(this.single_line)
        add_param_label(line_pv, "Pivot")
        this.item_pvx.add_editbox(line_pv); this.item_pvy.add_editbox(line_pv)

        if (!this.b2_style) {
            let line_s = add_param_line(this.single_line)
            add_param_label(line_s, "Scale")
            this.item_sx.add_editbox(line_s); this.item_sy.add_editbox(line_s)
        }

        this.add_code_elem()
    }
    move(dx, dy) {
        this.item_tx.set_to_const(this.translate[0] + dx); 
        this.item_ty.set_to_const(this.translate[1] + dy); 
    }
    move_pivot(dx, dy) {
        let v
        if (this.b2_style)
            v = vec2.fromValues(-dx, -dy)
        else
            v = vec2.fromValues(dx, dy)
        const rt = mat3.create()
        mat3.rotate(rt, rt, glm.toRadian(-this.rotate))
        vec2.transformMat3(v, v, rt)

        this.item_pvx.set_to_const(this.rotate_pivot[0] + v[0]); 
        this.item_pvy.set_to_const(this.rotate_pivot[1] + v[1]); 
    }
    set_translate(x, y) {
        this.item_tx.set_to_const(x); 
        this.item_ty.set_to_const(y); 
    }
    do_rotate(d_angle) {
        let r = this.rotate + d_angle;
        if (r > 360) r -= 360
        if (r < 0) r += 360
        this.item_r.set_to_const(r)
    }
    set_scale(sx, sy) {
        this.item_sx.set_to_const(sx)
        this.item_sy.set_to_const(sy)
    }
    draw_dial_at_obj(obj, m) {
        if (this.show_code)
            return  // dial disabled if we're in code
        //if (obj === null)
       //     return // might be it's not connected so it doesn't have output - not used
        // this was replaced with pivot thing. TBD - button for starting pivot should be the center of the bbox instead of 0,0
        let center = vec2.clone(this.translate)

        if (!this.b2_style) {
            center[0] += this.rotate_pivot[0]
            center[1] += this.rotate_pivot[1]
        }
        vec2.transformMat3(center, center, m) // to canvas coords

        this.dial.set_center(center[0], center[1])
        this.dial.draw()
    }

    dyn_eval() {
        let m = mat3.create(), v = vec2.create()
        mat3.identity(m)
        v[0] = this.item_tx.dyn_eval(); v[1] = this.item_ty.dyn_eval()
        mat3.translate(m, m, v)
          // seemingly this does the wrong thing since the translation is not recalculated when the pivot moves but it does seem to work as intended
          v[0] = this.item_pvx.dyn_eval(); v[1] = this.item_pvy.dyn_eval()
          mat3.translate(m, m, v)
        mat3.rotate(m, m, glm.toRadian(this.item_r.dyn_eval()))
          v[0] = -v[0]; v[1] = -v[1]  
          mat3.translate(m, m, v)
        v[0] = this.item_sx.dyn_eval(); v[1] = this.item_sy.dyn_eval()   
        mat3.scale(m, m, v)
        return m
    }
    need_input_evaler(input_name) {
        for(let item of this.items) {
            const ev = item.need_input_evaler(input_name)
            if (ev)
                return ev
        }
        return null
    }
    get_last_error() {
        for(let item of this.items) {
            const er = item.get_last_error()
            if (er)
                return er
        }
        return null
    }
    get_value() { // reimplement if this.v is not ther value
        dassert(this.v !== null, "value of transform expr not set")
        return this.v
    }
    modify(v, dirtyify=true) { 
        // TBD right now this just bypasses the calc_mat logic and does direct setting of the matrix
        // need that for NodeFuncFill where there's no display to this Param so there's no need for all that
        //if (this.show_code)
        //    return // code item should not be modified since that would erase the code
        if (mat3.exactEquals(v, this.v))
            return
        mat3.copy(this.v, v)
        if (dirtyify)
            this.pset_dirty()
    } 
    gl_set_value(loc) {
        gl.uniformMatrix3fv(loc, false, this.get_value())
    }    
}

class PointDial {
    constructor(on_move, on_start_drag=null, get_translate=null) {
        this.on_move = on_move
        this.on_start_drag = on_start_drag || ( ()=>{return null} )
        this.zc = null
        // a callback to get an offset between the param coordinates and the world coordinates, used by physics joints
        this.get_translate = get_translate 
    }
    draw(x, y, obj_t_mat, m) {
        if (obj_t_mat === null)
            obj_t_mat = mat3.create()
        this.obj_t_mat = obj_t_mat
        if (this.get_translate !== null) {
            const v = this.get_translate()
            x += v[0]
            y += v[1]
        }
        let p = vec2.fromValues(x, y)
        vec2.transformMat3(p, p, obj_t_mat)
        vec2.transformMat3(p, p, m)

        const SZ = 10
        this.zc = {x:p[0]-SZ, y:p[1]-SZ, w:2*SZ, h:2*SZ}

        ctx_img.beginPath()
        closed_line(ctx_img, rect_coords(this.zc))
        double_line(ctx_img)
    }
    find_obj(ev) {
        if (this.zc === null || !rect_hit(ev.ex, ev.ey, this.zc)) 
            return null
        const start_ctx = this.on_start_drag()
        return new DialMoveHandle(null, true, true, (e)=>{
            // dx,dy is not oriented with the object
            let iv = mat3.clone(this.obj_t_mat)
            iv[6] = 0; iv[7] = 0  // make a normals matrix to get the dv vector in the proper orientation. TBD good for shear?
            mat3.invert(iv, iv)
            let dv = vec2.fromValues(e.dx, e.dy)
            vec2.transformMat3(dv, dv, iv)
            this.on_move(dv[0], dv[1], start_ctx, e)  
        })
    }
}

class SizeDial extends PointDial {
    constructor(size_param) {
        super((dx, dy, ctx, e)=>{
            if (!e.shiftKey) {
                size_param.increment(vec2.fromValues(dx*2, dy*2))
            }
            else {  // if shift is pressed, maintain the ratio from when the mouse was pressed
                ctx.shadow_x = ctx.shadow_x + dx*2
                ctx.shadow_y = ctx.shadow_y + dy*2
                let nx, ny
                if (ctx.shadow_x < ctx.shadow_y) { // go by the minimum and calc the other one
                    nx = ctx.shadow_x
                    ny = nx * ctx.start_yx_ratio
                }
                else {
                    ny = ctx.shadow_y
                    nx = ny / ctx.start_yx_ratio
                }
                size_param.modify(vec2.fromValues(nx, ny))
            }
        }, ()=>{ // on start
            return { shadow_x: size_param.x, shadow_y: size_param.y, start_yx_ratio: (size_param.y/size_param.x) }
        })
        this.size_param = size_param
    }
    draw(transform, m) {
        //  /2 since size is the full object and we go from 0 to the corner
        super.draw(this.size_param.x/2, this.size_param.y/2, transform, m)
    }
}

class DialMoveHandle {
    constructor(param, do_x, do_y, callback=null) {
        this.param = param
        this.callback = callback
        this.do_x = do_x; this.do_y = do_y
    }
    mousedown() {}
    mouseup() {}
    mousemove(ev) {
        let dx = ev.dx, dy = ev.dy
        if (!this.do_x)
            dx = 0
        if (!this.do_y)
            dy = 0
        if (this.param !== null) {
            if (ev.ctrlKey)
                this.param.move_pivot(dx, dy)
            else
                this.param.move(dx, dy)
        }
        else
            this.callback(ev)
        trigger_frame_draw(true)
    }
}

class DialRotHandle {
    constructor(param, cx,cy) {
        this.param = param
        this.cx = cx; this.cy = cy
    }
    mousedown(e) {
        this.prev_angle = Math.atan2(e.ey-this.cy, e.ex-this.cx) * 180 / Math.PI
        //console.log("start-angle", this.start_angle, this.cx, this.cy, '--', vx, vy)
    }
    mouseup() {}
    mousemove(e) {
        let angle = Math.atan2(e.ey-this.cy, e.ex-this.cx) * 180 / Math.PI
        let d_angle = angle - this.prev_angle
        if (d_angle > 180) d_angle -= 360
        if (d_angle < -180) d_angle += 360
        //console.log("angle", angle - this.prev_angle, this.cx, this.cy, '--', ex, ey)
        this.param.do_rotate(d_angle)
        this.prev_angle = angle
        trigger_frame_draw(true)
    }
}

function closed_line(ctx, ln) {
    ctx.moveTo(ln[0], ln[1])
    for(let i = 2; i < ln.length; i += 2)
        ctx.lineTo(ln[i], ln[i+1])
    ctx.lineTo(ln[0], ln[1])
}

function double_line(ctx) {
    ctx.strokeStyle = '#ffff00'
    ctx.lineWidth = 3
    ctx.stroke()
    ctx.lineWidth = 1
    ctx.strokeStyle = '#ff0000'
    ctx.stroke()
}

const SQ_HALF = 0.70710678118

function rect_coords(c) {
    return [c.x,c.y, c.x+c.w,c.y, c.x+c.w,c.y+c.h, c.x,c.y+c.h]
}
function rect_hit(ex, ey, c) {
    return ex >= c.x && ey >= c.y && ex <= c.x + c.w && ey <= c.y + c.h
}

class TransformDial {
    constructor(param) {
        this.param = param
        this.cx = null; this.cy = null
        this.with_resize = false
        this.mv = null
    }
    set_center(cx, cy) { 
        this.cx = cx; this.cy = cy
        this.mv = {x:cx - 20, y:cy - 20, w:40, h:40}
        // up arrow
        this.uab = {x:this.cx-8, y:this.cy-25, bw:16, bh:20, tw:10, th:40} // bw=baseWidth, bh=baseHeight, tw=topWidth, th=topHeight
        // right arrow
        this.rab = {x:this.cx+25, y:this.cy-8, bw:16, bh:20, tw:10, th:40}
        this.rot = {r0:60, r1:75, a0:-0.4*Math.PI, a1:-0.1*Math.PI}
    }

    // called from image_find_obj
    find_obj(e) { // event coords
        if (this.param.show_code)
            return null
        if (this.mv === null)
            return null // not displayed yet
        const mv = this.mv, uab = this.uab, rab = this.rab, rot = this.rot, ex = e.ex, ey = e.ey
        if (rect_hit(ex, ey, mv))
            return new DialMoveHandle(this.param, true, true)
        if (ex >= uab.x && ex <= uab.x+uab.bw && ey >= uab.y-uab.th && ey <= uab.y)
            return new DialMoveHandle(this.param, false, true)
        if (ex >= rab.x && ex < rab.x+rab.th && ey >= rab.y && ey <= rab.y+rab.bw)
            return new DialMoveHandle(this.param, true, false)
        const tcx = ex-this.cx, tcy = ey-this.cy
        const de = Math.sqrt(tcx*tcx + tcy*tcy), ang = Math.atan2(ey-this.cy, ex-this.cx)
        if (de >= rot.r0 && de <= rot.r1 && ang >= rot.a0 && ang <= rot.a1)
            return new DialRotHandle(this.param, this.cx, this.cy)
        return null
    }
    // called from draw_selection
    draw() { 
        ctx_img.beginPath()
        // square
        const uab = this.uab, rab = this.rab, rot=this.rot
        closed_line(ctx_img, rect_coords(this.mv))
        // up arrow
        closed_line(ctx_img, [uab.x,uab.y, uab.x,uab.y-uab.bh, uab.x-uab.tw,uab.y-uab.bh, this.cx,uab.y-uab.th,
                              uab.x+uab.tw+uab.bw,uab.y-uab.bh, uab.x+uab.bw,uab.y-uab.bh, uab.x+uab.bw,uab.y])
        // right arrow
        closed_line(ctx_img, [rab.x,rab.y, rab.x+rab.bh,rab.y, rab.x+rab.bh,rab.y-rab.tw, rab.x+rab.th,this.cy,
                              rab.x+rab.bh,rab.y+rab.tw+rab.bw, rab.x+rab.bh,rab.y+rab.bw, rab.x,rab.y+rab.bw])
        // rotate circle
        ctx_img.moveTo(this.cx+rot.r1*Math.cos(rot.a0),this.cy+rot.r1*Math.sin(rot.a0))
        ctx_img.arc(this.cx,this.cy, rot.r0, rot.a0, rot.a1)
        ctx_img.arc(this.cx,this.cy, rot.r1, rot.a1, rot.a0, true)

        double_line(ctx_img)

    }
}

function cull_list(lst) {
    let newlst = new lst.constructor()
    for(let v of lst) 
        if (v !== undefined)
            newlst.push(v) // don't want a list with holes    
    return newlst
}

class ListParam extends Parameter {
    constructor(node, label, values_per_entry, in_table, lst_type, def_val=null) {
        super(node, label)
        //this.elem_prm = elem_prm
        this.values_per_entry = values_per_entry
        this.lst_type = lst_type
        this.lst = new lst_type()  // flat list
        this.elem_lst = null
        this.table = in_table
        this.column_key = in_table.register(this)  // columns are vertical, rows are horizontal
        this.def_val = (def_val !== null) ? def_val : get_default_value(label, values_per_entry) // kept here since it's the best place to keep it although it's not used by the class
        this.allow_title_edit = false
    }
    add_elems(parent) {}
    save() { return {lst:this.lst} }
    load(v) { 
        if (Array.isArray(this.lst)) // not a typed array
            this.lst = v.lst
        else
            this.lst = new this.lst_type(v.lst) 
    }

    get_def_val() {
        return this.def_val
    }

    add(v) { // for multiple lists in a table, needs to be called in the right order of the columns
        let av = v
        if (Array.isArray(v) || ArrayBuffer.isView(v) || typeof(v) == 'number') {
            if (v.length === undefined)  // support single value and list of values for vec
                av = [v]
            console.assert(av.length == this.values_per_entry, "Unexpected number of values")
            let newlst = new this.lst_type(this.lst.length + av.length)
            newlst.set(this.lst)
            newlst.set(av, this.lst.length)
            this.lst = newlst
        }
        else {
            this.lst.push(v)
        }
        this.pset_dirty(this.table === null) // if we're in a table, don't draw yet since not all the columns are set

        let vindex = (this.lst.length - this.values_per_entry)
        let col_elem = this.table.get_column_elem(this.column_key)
        if (col_elem !== null) // might not be displayed
            this.create_entry_elems(v, col_elem, vindex)
    }
    count() { return this.lst.length / this.values_per_entry }
    get_value(vindex) {
        dassert(vindex !== undefined, "unexpected vindex undefined")
        let v = []
        if (this.values_per_entry > 1)
            for(let vi = 0; vi < this.values_per_entry; ++vi)
                v[vi] = this.lst[vindex + vi]            
        else
            v = this.lst[vindex]
        return v
    }
    for_values(func) {
        for(let vindex = 0; vindex < this.lst.length; vindex += this.values_per_entry) {
            func(this.get_value(vindex), vindex)
        }
    }
    // called by ParamTable
    add_column_elems(column_elem) {
        this.elem_lst = []
        this.for_values((v, vindex)=>{ this.create_entry_elems(v, column_elem, vindex) })
    }
    // called by ParamTable
    get_column_title() {
        return this.label
    }
    set_column_title(v) {
        this.label = v
    }

    create_entry_elems(v, parent, vindex) {
        let e
        if (this.create_elem !== undefined) {
            let idx = vindex / this.values_per_entry
            e = this.create_elem(parent, v, idx, (v, ch_index, elem_idx=undefined) => {
                // change that come from the input element in the list
                let ch_vindex = ch_index * this.values_per_entry
                if (elem_idx === undefined) { // given a list
                    console.assert(v.length == this.values_per_entry, "unexpected length of value")
                    for(let vi = 0; vi < this.values_per_entry; ++vi)
                        this.lst[ch_vindex + vi] = v[vi]
                }
                else { // given just one number of a list
                    console.assert(v.length === undefined, "unexpected length existing")
                    this.lst[ch_vindex + elem_idx] = v
                }
                this.pset_dirty()
                trigger_frame_draw(true)
            }, 
            // get_cur_val
            (index)=>{ return this.get_value(index*this.values_per_entry) }) 
        }
        else {
            let clss = this.get_clss ? this.get_clss(vindex / this.values_per_entry) : [this.elem_prm.cls]
            e = create_div(clss)
            e.innerText = this.to_string(v)
            parent.appendChild(e)
        }
        this.elem_lst.push(e)
        return e
    }

    remove(index_lst) { // need to remove a list since the indices will change if we remove one by one
        let tmplst = Array.from(this.lst) // for removing put it in a normal array (can't remove from typed array or set to undefined in there)
        let tmplen = tmplst.length
        for(let index of index_lst) {
            let vindex = index * this.values_per_entry
            console.assert(vindex < this.lst.length, "remove out of range")
            for(let i = 0; i < this.values_per_entry; ++i)
                delete tmplst[vindex+i]
            tmplen -= this.values_per_entry
            if (this.elem_lst !== null) { // displayed even?
                this.elem_lst[index].remove() // remove from DOM tree
                delete this.elem_lst[index]  // make it undefined for later cull
            }
        }

        this.lst = new this.lst.constructor(tmplen)
        let addi = 0
        for(let v of tmplst) 
            if (v !== undefined)
                this.lst[addi++] = v
        this.pset_dirty()

        if (this.elem_lst !== null) {
            this.elem_lst = cull_list(this.elem_lst)
            this.reprint_all_lines()
            console.assert(this.lst.length == this.elem_lst.length * this.values_per_entry, "unexpected number of elements")
        }
    }
    clear() {
        this.lst = new this.lst.constructor()
        if (this.elem_lst !== null) // otherwise keep it null
            this.elem_lst = [] 
    }

    reprint_line(vidx, v) {
        if (this.elem_lst === null || this.elem_lst.length == 0)
            return // happens if the table is not visible (Gradient with function)
        let idx = vidx / this.values_per_entry
        let elem = this.elem_lst[idx]
        if (this.external_update) {
            this.external_update(elem, v, idx)
        }
        else {
            if (this.get_clss)
                elem.classList = this.get_clss(idx).join(" ")
            elem.innerText = this.to_string(v)
        }
    }

    reprint_all_lines() {  // voffset needed for gradient that has its list items shifted in index space
        this.for_values((v, vindex)=>{ this.reprint_line(vindex, v) })
    }

    // for changes that come from user interaction in the image canvas
    modify(index, v) { // index is already multiplied by values_per_entry
        if (this.values_per_entry > 1) {
            console.assert(v.length == this.values_per_entry, "Unexpected number of values")
            let vindex = index * this.values_per_entry
            console.assert(vindex < this.lst.length, "modify out of range")
            for(let vi = 0; vi < v.length; ++vi)
                this.lst[vindex + vi] = v[vi]
            this.reprint_line(vindex, v)
        }
        else {
            console.assert(v.length === undefined, "Unexpected list")
            this.lst[index] = v
            this.reprint_line(index, this.lst[index])
        }        
        this.pset_dirty()
    }
    increment(index, dv) {
        if (this.values_per_entry > 1) {
            console.assert(dv.length == this.values_per_entry, "Unexpected number of values")
            let vindex = index * this.values_per_entry
            console.assert(vindex < this.lst.length, "modify out of range")
            for(let vi = 0; vi < dv.length; ++vi) 
                this.lst[vindex + vi] += dv[vi]
            this.reprint_line(vindex, this.lst.slice(vindex, vindex + this.values_per_entry))
        }
        else {
            console.assert(v.length === undefined, "Unexpected list")
            this.lst[index] += dv
            this.reprint_line(index, this.lst[index])
        }
        this.pset_dirty()
    }    
}



// a list for a column for a numerical value with an editor that pops up when its clicked. for float and vec2
class ParamEditableValueList extends ListParam {
    constructor(node, label, table, lst_type, selected_indices, values_per_entry, changed_func_to_node=null) 
    {
        super(node, label, values_per_entry, table, lst_type)
        this.edit_wrap = null
        this.selected_indices = selected_indices
        this.changed_func_to_node = changed_func_to_node
    }

    external_update(text_elem, value, index) {
        let clss = "param_monospace param_lst_clickable"
        let mark_sel = false;
        if (this.selected_indices !== null) {
            if (this.selected_indices.includes_shifted !== undefined)
                mark_sel = this.selected_indices.includes_shifted(index) // see Gradient points
            else
                mark_sel = this.selected_indices.includes(index)
        }
        if (mark_sel)
            clss += " param_list_selected_line"
        text_elem.classList = clss
        text_elem.innerText = this.to_string(value)
        text_elem.p_lst_index = index // elem remembers it's index in the list for when its edited
    }

    create_elem(parent, start_val, index, change_func, get_cur_val) {
        let text_elem = add_div(parent, "") // create elem for a single cell in the column of this list
        this.external_update(text_elem, start_val, index)
        // handle click for edit
        myAddEventListener(text_elem, "click", ()=>{ // open input edits on click
            // index should not be used inside here becase removals might have changed this elem index. instead use the 
            // index saved in the text_elem which is kept up to date with removals
            let cur_val = get_cur_val(text_elem.p_lst_index)
            if (this.edit_wrap !== null) {
                this.edit_wrap.parentNode.removeChild(this.edit_wrap)
            }
            this.edit_wrap = create_div("param_lst_coord_edit_wrap")
            for(let i = 0; i < this.values_per_entry; ++i) {
                add_param_edit(this.edit_wrap, (this.values_per_entry == 1)?cur_val:cur_val[i], ED_FLOAT, (v)=> { 
                    change_func(v, text_elem.p_lst_index, i); // do the change in the lst
                    this.external_update(text_elem, get_cur_val(text_elem.p_lst_index), text_elem.p_lst_index) 
                    if (this.changed_func_to_node) // redo_sort in Gradient
                        this.changed_func_to_node()
                }, "param_lst_edit_popup_input", ()=>{ // Enter handler
                    this.dismiss_edit_wrap()
                })
            }
            stop_propogation_on("mousedown", this.edit_wrap)
            text_elem.parentNode.insertBefore(this.edit_wrap, text_elem.nextSibling) // re-parent
            param_reg_for_dismiss(this.owner, ()=>{ this.dismiss_edit_wrap() }) // needs to be here since the list is reset every add_elem
        })
        return text_elem
    }
    dismiss_edit_wrap() {
        if (this.edit_wrap === null)
            return
        this.edit_wrap.parentNode.removeChild(this.edit_wrap);   
        this.edit_wrap = null
    }


    add_elems(parent) {
        super.add_elems(parent) 
    }
}

window.ParamCoordList = class ParamCoordList extends ParamEditableValueList {
    constructor(node, label, table, selected_indices=null) {
        super(node, label, table, TVtxArr, selected_indices, 2)
        this.pneed_normalize = false  // not really needed for coordinates but just for remembering    
    }
    to_string(v)  { return "(" + v[0].toFixed(3) + "," + v[1].toFixed(3) + ")" }
}

window.ParamFloatList = class ParamFloatList extends ParamEditableValueList {
    constructor(node, label, table, selected_indices=null, changed_func_to_node=null) {
        super(node, label, table, Float32Array, selected_indices, 1, changed_func_to_node)
        this.pneed_normalize = false
    }
    to_string(v) { return v.toFixed(3) }
}

function uint8arr_to_color(arr) {
    return {r:arr[0], g:arr[1], b:arr[2], alpha:arr[3]/255, alphai:arr[3]}
}
function color_to_uint8arr(c) {
    return [c.r, c.g, c.b, c.alphai]
}
window.ParamColorList = class ParamColorList extends ListParam {
    constructor(node, label, table) {
        super(node, label, 4, table, TColorArr, DEFAULT_VTX_COLOR.arr)
        this.pneed_normalize = true
    }
    external_update(elem,value,index) { 
        elem.p_lst_index = index 
    } 
    create_elem(parent, start_val, index, changed_func) { 
        let wdiv = add_div(parent, "col_elem_wrap") // needed so that the input+canvas would be a in single elem for reorder on gradient
        let [col,elem,ce] = add_param_color(wdiv, uint8arr_to_color(start_val), "param_table_input_color", function(c) {
            changed_func(color_to_uint8arr(c), elem.p_lst_index)
        })
        elem.p_lst_index = index
        return elem
    }
}



class ParamTable extends Parameter {
    constructor(node, label, sorted_order=null) {
        super(node, label)
        this.list_params = {}  // registered ListParams, this is a map and not a list so that keys are allocated using next_key to facilitate erase without shifting
        this.elem_cols = null
        this.elem_visible = true  // for when we don't want to render the table because it's not visible (Gradient with function)
        this.with_index_column = false
        this.with_column_sep = true
        this.with_column_title = false // don't set this and with_index_column together
        this.on_remove_column = null // adds a context menu to the title

        this.sorted_order = sorted_order // list of the indices in the sorted order they are supposed to be displayed in
        this.title_edit_wrap = null // the div that wraps the edit input for the editable titles
        this.next_key = 0  // used for indexing columns
    }
    register(list_param) {
        const mykey = this.next_key++
        this.list_params[mykey] = list_param
        return mykey
    }
    get_column_elem(column_key) {
        if (this.elem_cols === null || !this.visible)
            return null
        console.assert(this.list_params[column_key] !== undefined, "column index too high")
        return this.elem_cols[column_key]
    }
    del_column(column_key, remake_table) {
        delete this.list_params[column_key]
        if (this.elem_cols !== null)
            delete this.elem_cols[column_key]
        if (remake_table)
            this.remake_table()
    }

    save() { return null }
    load(v) { } 

    add_elems(parent) {
        this.line_elem = add_param_block(parent)
        if (this.with_index_column) {
            // if we have and index column add a standard label that will be flush with the index column
            add_param_label(this.line_elem, this.label_display)
        }
        else {
            // otherwise, add a title that will be left aligned
            this.label_elem = add_div(this.line_elem, "param_list_title")
            this.label_elem.innerText = this.label_display + ":"
        }
        this.table_elem = add_div(this.line_elem, "param_list_body")

        if (!this.visible)
            return

        this.make_table()
    }

    remake_table() {
        if (this.line_elem === null || !this.visible)
            return
        this.table_elem = clear_elem(this.table_elem)
        this.make_table()
    }

    make_table() {
        this.elem_cols = {} // keys are the same as in list_params
        const column_clss = this.with_column_sep ? ["param_table_column", "param_table_col_line"] : "param_table_column"
        // index column (1., 2. etc)
        if (this.with_index_column && Object.keys(this.list_params).length > 0) {
            let column = create_div(column_clss)
            const len = Object.values(this.list_params)[0].count()  // checked above there's atleast one...
            for(let i = 0; i < len; ++i)
                add_div(column, 'param_lst_order_idx').innerText = i + "."
            this.table_elem.appendChild(column)
        }
        
        for(let lst_prm_key in this.list_params) {
            const lst_prm = this.list_params[lst_prm_key]
            let column = create_div(column_clss)
            this.elem_cols[lst_prm_key] = column
            lst_prm.add_column_elems(column)

            if (this.sorted_order !== null) { // sort by the given order if needed
                let unsorted = column
                column = create_div(column_clss)
                let childs_copy = []
                for(let c of unsorted.childNodes)
                    childs_copy.push(c)
                for(let from_idx of this.sorted_order) {
                    column.appendChild(childs_copy[from_idx])
                }
            }

           // const columnWrap = create_div("param_table_col_wrap")
            if (this.with_column_title)
                this.add_column_title(column, lst_prm)
            //columnWrap.appendChild(column)
            this.table_elem.appendChild(column)
            let grip = add_div(column, "param_table_grip")
            add_grip_handlers(grip, column)
        }
    }

    add_column_title(column, lst_prm) {
        const e = create_div("param_table_col_title")
        e.innerText = lst_prm.get_column_title()
        column.insertBefore(e, column.firstChild)

        // context menu
        if (this.on_remove_column !== null) {
            element_context_menu(this.owner, e, [{text:"Remove Column", func:()=>{
                this.on_remove_column(lst_prm)
            } }])
        }
    
        if (!lst_prm.allow_title_edit)
            return        
        myAddEventListener(e, "click", ()=>{ // title edit
            if (this.title_edit_wrap !== null)
                this.title_edit_wrap.parentNode.removeChild(this.title_edit_wrap)
            this.title_edit_wrap = create_div("param_table_title_edit_wrap")
            add_param_edit(this.title_edit_wrap, lst_prm.get_column_title(), ED_STR, (v)=>{
                lst_prm.set_column_title(v)
                e.innerText = v  // directly change it instead of remaking the table
                this.pset_dirty()
            }, "param_table_title_edit_input", ()=>{ // enter handler
                this.dismiss_title_edit() //
            })
            this.title_edit_wrap.style.width = e.getBoundingClientRect().width + "px"
            stop_propogation_on("mousedown", this.title_edit_wrap) // allow user to click the edit box to edit
            column.insertBefore(this.title_edit_wrap, e.nextSibling)
            param_reg_for_dismiss(this.owner, ()=>{ this.dismiss_title_edit() })
        })
    }
    dismiss_title_edit() {
        if (this.title_edit_wrap === null)
            return
        this.title_edit_wrap.parentNode.removeChild(this.title_edit_wrap);   
        this.title_edit_wrap = null
    }

}



function add_grip_handlers(grip, cell) {
    let startOffset = null;
    let column_width = null;

    add_move_handlers(grip, (dx, dy, pageX, pageY)=>{
        column_width = startOffset + pageX
        cell.style.width = column_width + "px"
    }, (pageX, pageY)=>{
        startOffset = parseFloat(window.getComputedStyle(cell)["width"]) - pageX;
    })
}

const AceRange = ace.require('ace/range').Range;

function create_code_dlg(parent, dlg_rect, title, start_v, change_func, visible_changed_func, opt)
{
    let editor = null
    const dlg = create_dialog(parent, title, true, dlg_rect, visible_changed_func, ()=>{
        if (editor) // first call inside create_dialog, before editor was created
            editor.resize()
    })
    dlg.elem.classList.add("dlg_size_shader_edit")
    const ed_elem = add_div(dlg.client, ["dlg_param_text_area"])
    editor = new Editor(ed_elem, start_v, change_func, opt)
    editor.dlg = dlg
    return editor
}

const EDITOR_MIN_HEIGHT = 35

class Editor
{
    constructor(line, start_v, change_func, opt)
    {
        this.elem_wrapper = add_div(line, "panel_param_editor_wrap") // needed so that the popout btn would have a parent        
        const ed_elem = add_div(this.elem_wrapper, "panel_param_text_area")

        this.elem = ed_elem  // moves from panel to dialog
        this.opt = opt
        this.parentElem = ed_elem.parentElement
        this.editor = ace.edit(ed_elem);
        this.editor.setShowPrintMargin(false)
        if (opt.lang == "glsl") {
            const GlslMode = ace.require("ace/mode/glsl").Mode;
            this.editor.session.setMode(new GlslMode());
        }
        this.editor.setTheme("ace/theme/tomorrow_night_bright");
        this.editor.setBehavioursEnabled(false) // no auto-pairing of brackets
        this.editor.commands.removeCommand('find');
        this.editor.setValue(start_v, 1) // 1: cursorPos end
        //editor.setHighlightGutterLine(true)

        this.editor.on("change", eventWrapper((e)=>{ 
            // added my hack into ace to indicate a change that comes from a remove that is part of an insert
            // in this case ace fires two event without allowing micro-tasks. this causes the second event draw to not happen since there's 
            // a draw in progress due to the first change and that causes the variables in the expr that was parsed the second time to not be resolved
            if (e.add_inf === "remove_in_insert")
                return
            change_func(this.editor.getValue())
        }), "editor-change")

        this.editor.on("paste", (e)=>{
            e.text = e.text.replace(/\t/g, "    ") // don't want tabs in there since they don't behave well in Yaml output
        })

        this.err_elem = add_div(ed_elem, "prm_text_err")
        this.err_elem.style.display = "none"
        this.err_elem_visible = false
        this.errors = null

        // show error only when on the line
        //  don't need event wrapper for this, don't want it to cause spurious draws
        this.editor.getSelection().on("changeCursor", ()=>{this.update_err_elem()})
        this.marker_ids = []
        this.show_errors()

        this.dlg = null
        this.popout_elems = null

        // panel resize
        this.ppgrip = add_div(this.elem_wrapper, "panel_param_editor_resize_grip")
        add_move_handlers(this.ppgrip, (dx, dy, pageX, pageY)=>{
            const curstyle = window.getComputedStyle(this.elem_wrapper)
            const newh = Math.max(parseInt(curstyle.height) + dy, EDITOR_MIN_HEIGHT)
            this.elem_wrapper.style.height = newh + "px"
            if (this.opt.dlg_rect_wrap !== undefined) {
                if (this.opt.dlg_rect_wrap.panel_rect === null)
                    this.opt.dlg_rect_wrap.panel_rect = { height: null }
                this.opt.dlg_rect_wrap.panel_rect.height = newh
            }
            this.editor.resize()
        })
        if (this.opt.dlg_rect_wrap !== undefined && this.opt.dlg_rect_wrap.panel_rect !== null)
            this.elem_wrapper.style.height = this.opt.dlg_rect_wrap.panel_rect.height + "px"

        if (opt.with_popout) {
            const [ein,btn,_dummy] = add_checkbox_btn(this.elem_wrapper, "[]", false, (v)=>{ 
                this.pop_out(v)
            })
            btn.classList.add("prm_code_popout_btn")
            this.popout_elems = {ein:ein, btn:btn}

            if (this.opt.dlg_rect_wrap !== undefined && this.opt.dlg_rect_wrap.dlg_rect !== null && this.opt.dlg_rect_wrap.dlg_rect.visible == true)
                this.pop_out(true)
        }
        

    }

    pop_out(out_v) {
        if (this.dlg === null) {
            this.dlg = create_dialog(this.parentElem, this.opt.dlg_title, true, this.opt.dlg_rect_wrap.dlg_rect, (v)=>{ this.pop_out(v) }, ()=>{ this.resize() })
            this.dlg.elem.classList.add("dlg_size_shader_edit")
            this.opt.dlg_rect_wrap.dlg_rect = this.dlg.rect
            //this.dlg.ed_elem = add_div(this.dlg.client, ["dlg_param_text_area"])
        }
        if (out_v) {
            this.dlg.dset_visible(true)
            this.dlg.client.appendChild(this.elem)
        }
        else {
            this.dlg.dset_visible(false)
            this.parentElem.appendChild(this.elem)
        }

        this.elem.classList.toggle("dlg_param_text_area", out_v)
        this.elem.classList.toggle("panel_param_text_area", !out_v)

        this.elem_wrapper.classList.toggle("panel_param_ed_minimized", out_v)
        this.ppgrip.classList.toggle("panel_param_editor_resize_grip_hidden", out_v)
        
        this.popout_elems.btn.classList.toggle('prm_code_popout_btn', !out_v)
        this.popout_elems.btn.classList.toggle('prm_code_popin_btn', out_v)
        this.popout_elems.ein.checked = out_v

        this.editor.resize(true) // needs to be after all DOM changes
    }

    set_title(v) {
        if (this.dlg !== null)
            this.dlg.set_title(v)
        this.opt.dlg_title = v
    }

    update_err_elem()
    {
        const line = this.editor.getSelection().getCursor().row + 1
        if (this.errors !== null) {
            const e = this.errors[line]
            if (e !== undefined) {
                this.err_elem.innerText = e.text
                this.err_elem.style.display = ""
                this.err_elem_visible = true
                return
            }
        }
        if (this.err_elem_visible) {
            this.err_elem.innerText = ""
            this.err_elem.style.display = "none"
            this.err_elem_visible = false
        }
    }

    show_errors() { // from glsl
        for(let marker_id of this.marker_ids)
            this.editor.session.removeMarker(marker_id)
        if (this.errors === null || this.errors.length == 0) {
            //editor.session.setAnnotations([])
        }
        else {
            for(let eline in this.errors) {
                const e = this.errors[eline]
                e.row = eline-1 // line is 1 based
                e.type = "error"
                this.marker_ids.push(this.editor.session.addMarker( new AceRange(e.row, 0, e.row, 1), "editor_error_marker", "fullLine"))
            }
            //editor.session.setAnnotations(Object.values(this.errors))
        }
        this.update_err_elem()
    }
        
    set_errors(err_lst) { // list of {line:, text:}
        this.errors = err_lst
        this.show_errors()
    }

    set_value(v) {
        this.editor.setValue(v, 1)
    }

    show_err(err) { // from expr
        this.set_errors({[err.line]:{text:err.msg}})
    }
    clear_err() { // from expr
        this.set_errors({})
    }

    get_elem() { return this.elem }
    resize() { this.editor.resize() }
}

// used for glsl
class ParamTextBlock extends Parameter 
{
    constructor(node, label, start_v, change_func) {
        super(node, label)
        this.dlg = null

        this.text_input = null
        this.dlg_rect_wrap = {dlg_rect:null, panel_rect:null} // state of the dialog display
        this.v = start_v
        this.change_func = change_func
        node.register_rename_observer((name)=>{
            this.editor.set_title(this.title())
        })
        this.editor = null
        this.last_errors = null
    }
    save() { 
        const r = { text:this.v }
        if (this.dlg_rect_wrap.dlg_rect !== null)
            r.dlg_rect = this.dlg_rect_wrap.dlg_rect
        if (this.dlg_rect_wrap.panel_rect !== null)
            r.panel_rect = this.dlg_rect_wrap.panel_rect     
        return r 
    }
    load(v) { 
        this.v = v.text; 
        this.dlg_rect_wrap.dlg_rect = v.dlg_rect || null
        this.dlg_rect_wrap.panel_rect = v.panel_rect || null 
    } // dlg_rect saved only if text is saved
    
    title() { return this.owner.name + " - " + this.label.replace('\n', ' ') }

    set_text(v, do_draw=true) { // when calling this from run(), set to false to avoid endless loop of draws
        if (this.v === v)
            return
        this.v = v; 
        this.pset_dirty(do_draw); 
        this.call_change()

        if (this.editor !== null)
            this.editor.set_value(this.v)
    }

    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        this.label_elem = add_param_label(this.line_elem, this.label_display)

        this.editor = new Editor(this.line_elem, this.v, (v)=>{
            this.v = v
            this.pset_dirty(); 
            this.call_change() 
        }, {lang:"glsl", dlg_title:this.title(), dlg_rect_wrap:this.dlg_rect_wrap, with_popout:true});
        this.editor.set_errors(this.last_errors) 
    }

    set_errors(errors) {
        this.last_errors = errors
        if (this.editor !== null)
            this.editor.set_errors(errors)
    }
    get_errors() {
        return this.last_errors
    }
    
}


class ParamSelect extends Parameter
{
    // opts can be ["A", "B", "C"] or [["A",0.1], ["B", 0.2], ["C", 0.3]]
    constructor(node, label, selected_idx, opts, change_func=null) {
        super(node, label)
        if (Array.isArray(opts[0])) { // has values
            this.opts = []
            this.opt_vals = []
            for(let o of opts) {
                this.opts.push(o[0])
                this.opt_vals.push(o[1])
            }
        }
        else {
            this.opts = opts
            this.opt_vals = null
        }
        this.init_sel = selected_idx
        this.sel_idx = selected_idx
        this.change_func = change_func
    }

    save() { return { sel_str: this.opts[this.sel_idx] } }
    load(v) { 
        this.sel_idx = this.opts.indexOf(v.sel_str); 
        if (this.sel_idx === -1) // happens if the option name changed
            this.sel_idx = this.init_sel
    }
    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        this.label_elem = add_param_label(this.line_elem, this.label_display)
        add_combobox(this.line_elem, this.opts, this.sel_idx, (v)=>{ 
            this.sel_idx = v; 
            this.call_change()
            this.pset_dirty() 
        })
    }
    call_change() { // reimplemet this if this.v is not the value
        if (this.change_func) 
            this.change_func(this.sel_idx)
    }        
    get_sel_name() {
        return this.opts[this.sel_idx].toLowerCase() // low case more appropriate for values
    }
    get_sel_val() {
        if (this.opt_vals === null)
            return null
        return this.opt_vals[this.sel_idx]
    }
}


const MAGIC_HDR = 0x616263ff
const MIME_TYPE_LEN = 30
const MIME_TYPE_LEN_PX = 40

// imgur doesn't support anything not PNG or JPG so I hide the data ina png by simply concatenating it to its end
function encodeIntoPng(data_bin, mime_type)
{
    const len = data_bin.byteLength + 8 + MIME_TYPE_LEN_PX
    if (mime_type.length > MIME_TYPE_LEN)
        return null
    const width = 128
    const height = Math.round((len / width) / 3) + 2  // 3 bytes per pixel
    canvas_img_shadow.width = width
    canvas_img_shadow.height = height 
    const id = ctx_img_shadow.getImageData(0, 0, width, height)
    const dst = id.data
    const dv = new DataView(dst.buffer)
    dv.setUint32(0, MAGIC_HDR)
    dv.setUint32(4, (data_bin.byteLength << 8) | 0xff)
    let dst_i = 8, src_i = 0
    while(src_i < MIME_TYPE_LEN) {
        dst[dst_i++] = mime_type.charCodeAt(src_i++)
        if ((dst_i % 4) == 3)
            dst[dst_i++] = 0xff
    }
    const bin_len = data_bin.byteLength
    const src = new Uint8Array(data_bin)
    src_i = 0;
    while(src_i < bin_len) {
        dst[dst_i++] = src[src_i++]
        dst[dst_i++] = src[src_i++]
        dst[dst_i++] = src[src_i++]
        dst[dst_i++] = 0xff // don't mess with alpha, that messes the colors for some reason
    }
    ctx_img_shadow.putImageData(id, 0, 0)
    // to PNG
    const durl = canvas_img_shadow.toDataURL('image/png') // don't use toBlob since it's asyncronous
    const comma = durl.indexOf(',')
    const dbase = durl.substr(comma+1)
    const dbin = atob(dbase)

    const dlen = dbin.length;
    const bytes = new Uint8Array(dlen);
    for (let i = 0; i < dlen; i++) {
        bytes[i] = dbin.charCodeAt(i);
    }
    console.log("data-len=", len, " encodede-len=", dlen)
    return bytes
}

function tryDecodeFromPng(image)
{
    canvas_img_shadow.width = image.width
    canvas_img_shadow.height = image.height
    ctx_img_shadow.drawImage(image, 0, 0)
    const id = ctx_img_shadow.getImageData(0, 0, image.width, image.height)
    const dv = new DataView(id.data.buffer)
    const magic = dv.getUint32(0)
    if (magic !== MAGIC_HDR)
        return null
    const dlen = (dv.getUint32(4) >> 8) + MIME_TYPE_LEN
    //const dst = new Uint8Array(dlen)
    let dst = '';
    const src = id.data
    const src_len = src.byteLength
    let src_i = 8, dst_i = 0;
    let debug = ''
    while(dst_i < dlen) {
        //debug += src[src_i].toString(16) + ' ' + src[src_i+1].toString(16) + ' ' + src[src_i+2].toString(16) + ' '
        dst += String.fromCharCode(src[src_i++]); 
        dst += String.fromCharCode(src[src_i++]); 
        dst += String.fromCharCode(src[src_i++]); 
        ++src_i  // skip alpha
        dst_i += 3
    }
    let mime_type = dst.substr(0, MIME_TYPE_LEN)
    while (mime_type.charCodeAt(mime_type.length-1) == 0)
        mime_type = mime_type.substr(0, mime_type.length-1)
    dst = dst.substr(MIME_TYPE_LEN, dlen-MIME_TYPE_LEN) // might have added a 1 or 2 extra bytes
    const png_url = "data:" + mime_type + ";base64," + btoa(dst)

    return png_url
}
    

class ParamFileUpload extends Parameter
{
    constructor(node, label) {
        super(node, label)
        this.file = null // file from file input, null if file came from a url
        this.remote_url = null
        this.remote_url_elem = null
        this.upload_progress_elem = null
    }
    save() { return {rurl:this.remote_url} }
    load(v) { 
        this.remote_url = v.rurl 
        if (this.remote_url !== null && this.remote_url.trim() != "")
            this.load_url(this.remote_url)
    }
    add_elems(parent) {
        this.line_elem = add_param_line(parent)
        this.label_elem = add_param_label(this.line_elem, this.label_display)
        add_upload_btn(this.line_elem, ["param_btn", "param_file_choose_btn"], "Choose File...", (in_file)=>{ 
            this.file = in_file
            filename_show.textContent = this.file.name 
            this.read_file(this.file, true, (file, url)=>{ this.load_url(url) })
            upload_btn.style.display = ""
            // pset_dirty() done only when everything is loaded
        })
        let upload_btn = add_push_btn(this.line_elem, "Upload", ()=>{ // onclick 
            this.read_file(this.file, false, (file, data)=> { this.upload_to_imgur(file.type, data)} ) 
        })
        let show_div = add_div(this.line_elem, "param_file_show_parent")
        let filename_show = add_div(show_div, "param_file_show")
        if (this.file !== null)
            filename_show.textContent = this.file.name
        else
            upload_btn.style.display = "none"
        this.upload_progress_elem = add_elem(show_div, "progress", "param_file_progress")
        this.upload_progress_elem.max = 100
        this.upload_progress_elem.value = 0

        let line2_elem = add_param_line(parent)
        add_param_label(line2_elem, "Url")
        this.remote_url_elem = add_param_edit(line2_elem, this.remote_url, ED_STR, (v)=>{ 
            this.remote_url = v; 
            this.file = null // the file in the file input is no longer relevant if we changed the url manually
            this.filename_show = ""
            this.load_url(v) 
        })
        this.remote_url_elem.classList.add("param_input_long")
    }

    read_file(file, asurl, onload) {
        let reader = new FileReader();
        reader.onload = (e)=>{
            onload(file, e.target.result)
        }
        reader.onerror = (e)=>{
            console.error(e)
        }
        if (asurl)
            reader.readAsDataURL(file);
        else
            reader.readAsArrayBuffer(file)
    }

    upload_to_imgur(file_type, data, is_second_try=false) {
        const req = new XMLHttpRequest();
        
        req.onload = ()=>{
            console.log(req.responseText)
            this.upload_progress_elem.style.display = "none"
            let re = JSON.parse(req.responseText)
            if (re.success != true || re.status != 200) {
                if (re.status === 400 && !is_second_try) { // can try to encode it as PNG
                    const encoded = encodeIntoPng(data, file_type)
                    this.upload_to_imgur("image/png", encoded, true)
                }
                console.error("Failed upload, " + re.status)
                return
            }
            this.remote_url = re.data.link
            this.remote_url_elem.value = this.remote_url
            save_state()
        }
        req.onprogress = (e)=>{
            if (e.total == 0)
                return
            let percentComplete = (e.loaded / e.total)*100; 
            this.upload_progress_elem.value = percentComplete
        }
        if (req.upload) // in chrome there's a different progress listener
            req.upload.onprogress = req.onprogress
        req.onerror = (e)=>{
            console.error("Failed req ", e)
            this.upload_progress_elem.style.display = "none"
        }
    
        this.upload_progress_elem.value = 0
        this.upload_progress_elem.style.display = "initial"

        req.open("POST", 'https://api.imgur.com/3/image', true)
        req.setRequestHeader("Authorization", "Client-ID 559401233d3e1e6")
        req.setRequestHeader("Accept", 'application/json')
        req.setRequestHeader("Content-Type", file_type)
        console.log("Uploading ", file_type, " len:", data.byteLength)
        req.send(data)
    }
    
}


class ParamImageUpload extends ParamFileUpload
{
    constructor(node, label) {
        super(node, label)
        this.image = null  
        this.ilast_error = null
    }
    load_url(url) {
        this.ilast_error = null
        this.image = null
        let newimage = new Image()
        myAddEventListener(newimage, "load", (e)=>{
            this.ilast_error = null
            const decoded_url = tryDecodeFromPng(newimage)
            if (decoded_url !== null) {
                newimage.src = decoded_url
                return
            }
            this.image = newimage
            this.pset_dirty()
        }, FLAG_DONT_SAVE)
        myAddEventListener(newimage, "error", (e)=>{
            this.ilast_error = "Failed download image from URL"
            console.error("Failed to download image", e)
            this.image = null
            this.pset_dirty() // trigger a draw that will show this error
        }, FLAG_DONT_SAVE)
        newimage.crossOrigin = ''
        newimage.src = url
        // first time after load will be an empty image but then the load even is going to refresh the display   
        // empty image is preferable to null since it can still pass through stuff
        // it will become null if there's an error which needs to be visible
        this.image = newimage 
    }

    get_image() {
        assert(this.image !== null, this.owner.cls, (this.ilast_error !== null) ? this.ilast_error : "Image not loaded yet")
        return this.image
    }
    try_get_image() {  // may return null
        return this.image
    }
}

// not really a parameter that holds a value. it's a button that shows in the parameters panel
class ParamButton extends Parameter 
{
    constructor(node, label, onclick, cls=null) {
        super(node, label)
        this.onclick = onclick
        this.cls = cls
    }
    save() { return null }
    load(v) { }
    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        if (!this.is_sharing_line_elem()) 
            add_param_label(this.line_elem, null)  // empty space
        add_push_btn(this.line_elem, this.label_display, this.onclick, this.cls)
    }
}

// doesn't hold any data, just container of other parameters for order
class ParamGroup extends Parameter
{
    constructor(node, label) {
        super(node, label)
    }
    save() { return null }
    load(v) { }
    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        this.line_elem.classList.toggle('param_line_group', true)
        this.add_sub_params()
    }

    add_sub_params() {
        let my_params = []
        for(let p of this.owner.parameters) { 
            if (p.group_param !== null && Object.is(p.group_param, this)) {
                my_params.push(p)
            }
        }

        if (this.owner.cls.get_sorted_labels !== undefined) {
            const sorted_order = this.owner.cls.get_sorted_labels(this) // for vars
            if (sorted_order !== null) {
                dassert(sorted_order.length === my_params.length, "wrong size of sorted_order")
                const prm_by_label = {}
                for(let p of my_params)
                    prm_by_label[p.label] = p
                for(let pi of sorted_order) {
                    const p = prm_by_label[pi]
                    dassert(p !== undefined, "can't find param label " + pi)
                    p.add_elems(null) 
                    p.init_enable_visible()
                }
                my_params = null // indicate it's done
            }
        }
        if (my_params !== null) {
            for(let p of my_params) {
                p.add_elems(null) // null since they will get their parent from the group they have set
                p.init_enable_visible()
            }
        }
    }

    update_elems() { // will still work (and do nothing visible) if the node is not selected
        // remove all previous children
        if (this.line_elem === null)
            return
        while (this.line_elem.firstChild) {
            this.line_elem.removeChild(this.line_elem.firstChild);
        }
        // re-add up to date children
        this.add_sub_params()
        fix_label_lengths(this.owner.parameters)
    }
}

class ParamMenuBtn extends Parameter 
{
    constructor(node, label, opts, make_elem_func, set_selected_func, cls_menu, cls_item) {
        super(node, label)
        this.opts = opts
        this.make_elem_func = make_elem_func
        this.set_selected_func = set_selected_func
        this.cls_menu = cls_menu
        this.cls_item = cls_item

        this.menu_elem = null
    }
    save() { return null }
    load(v) {}

    add_elems(parent) {
        this.line_elem = add_param_line(parent, this)
        if (!this.is_sharing_line_elem()) 
            add_param_label(this.line_elem, null) 
        const dismiss_menu = ()=>{
            if (this.menu_elem !== null) {
                this.menu_elem.parentElement.removeChild(this.menu_elem)
                this.menu_elem = null
            }
            ein.checked = false
        }
        const [ein,btn,_dummy] = add_checkbox_btn(this.line_elem, this.label, false, (v)=>{
            if (!v) {
                dismiss_menu()
                return
            }
            this.menu_elem = add_div(this.line_elem, this.cls_menu)
            this.menu_elem.style.top = btn.offsetTop + btn.offsetHeight + 2 + "px"
            this.menu_elem.style.left = btn.offsetLeft + "px"
            let idx = 0;
            for(let o of this.opts) {
                const img_div = add_div(this.menu_elem, this.cls_item)
                this.make_elem_func(o, img_div)
                const midx = idx
                myAddEventListener(img_div, "mousedown", ()=>{
                    this.set_selected_func(o, midx)
                    dismiss_menu()
                })
                ++idx;
            }
            param_reg_for_dismiss(this.owner, ()=>{dismiss_menu()})
        })
        // prevent two calls to dismiss when pressing the button
        btn.addEventListener("mousedown", (ev)=>{ ev.stopPropagation() })
    }
}


// not a proper combo-box, more line a combo-box of buttons, each with an image
class ParamImageSelectBtn extends ParamMenuBtn
{
    constructor(node, label, opts, get_img_func, set_selected_func) {
        super(node, label, opts, get_img_func, set_selected_func,
              "param_img_menu", "param_img_item")
    }
}


class ParamTextMenuBtn extends ParamMenuBtn
{
    constructor(node, label, opts, set_selected_func) {
        super(node, label, opts, (opt, parent)=>{
            parent.innerText = opt
        }, set_selected_func, "param_text_menu", "param_text_item")
    }
}


"use strict"


const MESH_NOT_SET = 0
const MESH_QUAD = 1
const MESH_TRI = 2
const MESH_POINTS = 3

const MESH_DISP = { vtx_radius: 5, vtx_sel_radius: 7, sel_color:"#FFBB55", line_width:0.5 }
const DEFAULT_VTX_COLOR = { hex: "#cccccc", rgb: "rgb(204,204,204)", rgba: "rgba(204,204,204,1.0)", arr:[204,204,204,255] }

let TVtxArr = Float32Array
let TIdxArr = Uint32Array  // all indices are 32 bit, too much hassle to keep 16 bit indices around
let TColorArr = Uint8Array

function normalize_attr_name(s) {
    let r = s.toLowerCase().replace(/\s/g, '_')
    if (r == "point_color")
        return "vtx_color"
    if (r == "coord")
        return "vtx_pos"
    return r
}

function meshTypeName(t) {
    switch(t) {
    case MESH_NOT_SET: return "Not-Set";
    case MESH_QUAD: return "Quads";
    case MESH_TRI: return "Triangles";
    case MESH_POINTS: return "Points";
    default: return "<unknown:" + t + ">"
    }
}

class BBox {
    constructor(min_x, min_y, max_x, max_y) {
        this.min_x = min_x
        this.min_y = min_y
        this.max_x = max_x
        this.max_y = max_y
    }
    width() {
        return this.max_x - this.min_x
    }
    height() {
        return this.max_y - this.min_y
    }
    center() {
        return [(this.min_x + this.max_x)/2, (this.min_y + this.max_y)/2]
    }
}

class FillObj {
    constructor(obj_proxy) {
        this.obj_proxy = obj_proxy // ObjConstProxy which is not cloned
        this.clip_path = null
    }
}

// coping list of fill objs need to clone the FillObj as well since it's part of the state of the original object
// (the clip_path)
function clone_fill_objs(from_fill_objs) {
    const ret = []
    for(let f of from_fill_objs) {
        if (f === null)
            ret.push(null)
        else 
            ret.push(new FillObj(f.obj_proxy)) // the reference of the proxy is the only thing remaining shared
    }
    return ret
}
function init_fill_objs() {
    return [null]
}

// used in SetAttr to get the center of a face in an expression
class PropCallProxy {
    constructor(mesh, name, type) {
        this.mesh = mesh
        this.name = name
        this.type = type
    }
    computed_value(index) {
        return this.mesh[this.name](index)
    }
    computed_type() {
        return this.type
    }
}

class Mesh extends PObject
{
    static name() { return "Mesh" }
    constructor() {
        super()

        this.type = MESH_NOT_SET
        this.paths = null // list of Path2D, each corresponding to a tri/quad
        // vtx_color : Uint8Array
        // idx can be null if it's just a points mesh
        this.arrs = { vtx_pos:null, idx:null }
        this.meta = { vtx_pos:null, idx:null } // metadata objects for every array in arrs (instead of setting properties in the array object itself which can't be cloned reasonably)
        this.consts = {} // attributes that are constant, don't have meta

        this.tcache = { vtx_pos:null, m:null }  // transformed cache (to display coords)
        //this.lines_cache = null  // cache lines for stroke (so that every line be repeated twice
        this.glbufs = { vtx_pos:null, idx:null }
        this.fill_objs = init_fill_objs()  // list of FillObj, used for face_fill attribute
                             // it's the nodes responsibility that there would not be left objects that are not needed
                             // first entry is null so ids start with 1. 0 is reserved to nothing
        this.paper_obj = null
        this.clipper_obj = null
        this.effective_vtx_pos = null // if there is vtx_transform/face_transform, this is already transformed vertices, otherwise just equal to vtx_pos
        this.points_idx_cache = null // used for shuffle, if not null: {idx_buf: index array, seed: seed used to generate }
    }
    destructor() {
        for(let bi in this.glbufs) {
            let b = this.glbufs[bi]
            if (b) {
                //console.log("~~",b.buf_id)
                gl.deleteBuffer(b)
            }
        }
    }

    oclone() {
        const m = new Mesh()
        m.type = this.type
        m.paths = null  // will be created as needed
        m.arrs = clone(this.arrs)
        m.meta = clone(this.meta)
        m.consts = clone(this.consts)

        m.tcache = { vtx_pos:null, m:null } // will be created as needed
        m.glbufs = { vtx_pos:null, idx:null }
        m.fill_objs = clone(this.fill_objs)
        m.paper_obj = null
        m.clipper_obj = null
        if (this.effective_vtx_pos === this.arrs.vtx_pos)
            m.effective_vtx_pos = m.arrs.vtx_pos
        else
            m.effective_vtx_pos = clone(this.effective_vtx_pos)
        m.points_idx_cache = null

        return m
    }

    forVec2Arrs(func) {
        for(let name in this.arrs) {
            if (!name.startsWith('vtx_') || name === "vtx_pos")
                continue
            const arr = this.arrs[name]
            if (this.meta[name].num_elems !== 2)
                continue
            func(name, arr)
        }        
    }

    // API
    get_disp_params(disp_values) {
        const d =  [ new DispParamBool(disp_values, "Show Vertices", 'show_vtx', true) ]
        if (this.arrs.idx !== undefined && this.arrs.idx !== null && this.arrs.idx.length > 0)
            d.push(new DispParamBool(disp_values, "Show Lines", 'show_lines', true))
        if (this.arrs.face_color !== undefined || this.consts.face_color !== undefined || this.arrs.face_fill !== undefined)
            d.push(new DispParamBool(disp_values, "Show Faces", 'show_faces', true))
        this.forVec2Arrs((name, arr)=>{
            const b = new DispParamBool(disp_values, "Show " + name, 'show_' + name, true)
            const sc = new DispParamFloat(disp_values, "Scale", "scale_" + name, 1.0)
            sc.share_line_elem_from(b)
            d.push(b, sc)

        })
        return d
    }



    invalidate_pos() {
        this.tcache.vtx_pos = null  // invalidate
        if (this.meta.vtx_pos !== null)
            this.meta.vtx_pos.made_glbuf = false
        this.paths = null
        this.paper_obj = null
        this.clipper_obj = null
        this.points_idx_cache = null
        this.make_effective_vtx_pos()
        this.invalidate_fill()
    }
    invalidate_fill() {
        for(let fo of this.fill_objs)
            if (fo !== null)
                fo.clip_path = null
    }

    make_effective_vtx_pos() {
        this.effective_vtx_pos = this.arrs.vtx_pos // in case non of the below
        if (this.arrs.vtx_transform !== undefined) 
            this.transform_per_vtx()
        if (this.arrs.face_transform !== undefined)
            this.transform_per_face()  // transforms effective_vtx_pos      
    }

    set(name, arr, num_elems, need_normalize) {
        name = normalize_attr_name(name)        
        this.arrs[name] = arr
        this.meta[name] = { made_glbuf: false,  // not really used for anything right now
                            num_elems: num_elems || 1, // count of numbers for each element. will be undefined for indices
                            need_normalize: need_normalize || false // true for color that needs to go from int to float [0,1]
                           }
        if (name == "vtx_pos") 
            this.invalidate_pos()
        else if (name == "face_transform") 
            this.unshare_vertices_between_faces()
        else if (name == "vtx_transform")
            this.make_effective_vtx_pos()
        else if (name == "face_fill") 
            this.invalidate_fill()
    }

    set_const(name, v) {
        this.consts[name] = v
    }

    set_type(v) { 
        this.type = v 
        this.invalidate_pos()
    }
    vtx_count() { return this.arrs.vtx_pos.length / 2 } // 2 for (x,y)
    face_count() {
        if (this.arrs.idx === null || this.arrs.idx === undefined) {
            if (this.type == MESH_POINTS)
                return this.vtx_count() // this actually counts how many ranges in a MultiPath this would take, for Merge
            dassert(false, "expected idx")
        }
        // can have mesh of points with idx (to repeat the points)
        return this.arrs.idx.length / this.face_size()
    }
    face_size() {
        switch(this.type) {
        case MESH_TRI: return 3
        case MESH_QUAD: return 4
        case MESH_POINTS: return 1;
        default: dassert(false, "face_size: type not set")
        }
    }

    has_idx() {
        return this.arrs.idx !== null && this.arrs.idx !== undefined
    }

    static transform_arr(m, from, to) {
        for(let i = 0; i < from.length; i += 2) {
            let x = from[i], y = from[i+1]
            to[i]   = m[0] * x + m[3] * y + m[6];
            to[i+1] = m[1] * x + m[4] * y + m[7];            
        }
    }
    
    // API
    transform(m) {
        Mesh.transform_arr(m, this.arrs.vtx_pos, this.arrs.vtx_pos)
        this.invalidate_pos()
    }

    transform_per_vtx() 
    {
        const vtx_pos = this.arrs.vtx_pos, vtx_transform = this.arrs.vtx_transform
        dassert(vtx_transform.length / 6 === vtx_pos.length / 2, "unexpect length of vtx_transform")

        if (this.effective_vtx_pos === null || this.effective_vtx_pos === this.arrs.vtx_pos || this.effective_vtx_pos.length != vtx_pos.length)
            this.effective_vtx_pos = new TVtxArr(vtx_pos.length)
        const vtx_new = this.effective_vtx_pos

        for(let vi = 0, ti = 0; vi < vtx_new.length; vi += 2, ti += 6) {
            let x = vtx_pos[vi], y = vtx_pos[vi+1]
            vtx_new[vi]   = vtx_transform[ti] * x + vtx_transform[ti+2] * y + vtx_transform[ti+4];
            vtx_new[vi+1] = vtx_transform[ti+1] * x + vtx_transform[ti+3] * y + vtx_transform[ti+5];                  
        }
    }

    transform_per_face() 
    { // assume vertices are unshared
        const vtx_pos = this.effective_vtx_pos, face_transform = this.arrs.face_transform
        dassert(face_transform.length / 6 === this.face_count(), "unexpect length of face_transform")

        if (this.effective_vtx_pos === null || this.effective_vtx_pos === this.arrs.vtx_pos || this.effective_vtx_pos.length != vtx_pos.length)
            this.effective_vtx_pos = new TVtxArr(vtx_pos.length)
        const vtx_new = this.effective_vtx_pos
        
        const face_size = this.face_size()
        const idx = this.arrs.idx
        for(let ii = 0, ti = 0; ii < idx.length; ii += face_size, ti += 6) {
            for(let ei = 0; ei < face_size; ++ei) {
                const vi = idx[ii+ei]*2
                let x = vtx_pos[vi], y = vtx_pos[vi+1]
                vtx_new[vi]   = face_transform[ti] * x + face_transform[ti+2] * y + face_transform[ti+4];
                vtx_new[vi+1] = face_transform[ti+1] * x + face_transform[ti+3] * y + face_transform[ti+5];                      
            }
        }
    }

    // make every vertex be referenced only by a single polygon. needed if we want to move polys individually with face_transform
    // there's two ways to do this, the easy way 
    //   1. just recreate all the vtx_ arrays without sharing - advantage: index is remains localized
    //   2. the slightly harder way - find sharing and only change only that - advantage - original vertex order is not changed (not really important?)
    // I do 1. here because it's easier and there's no reason to do 2. 
    unshare_vertices_between_faces()
    {
        const idx = this.arrs.idx
        for(let name in this.arrs) {
            if (!name.startsWith('vtx_'))
                continue
            const prop = this.arrs[name]
            const num_elems = this.meta[name].num_elems
            const new_prop = new prop.constructor(idx.length * num_elems)
            let nidx = 0
            for(let i = 0; i < idx.length; ++i) {
                const oidx = idx[i]
                for(let ei = 0; ei < num_elems; ++ei)
                    new_prop[nidx*num_elems + ei] = prop[oidx*num_elems + ei]
                //idx[i] = nidx;
                ++nidx;
            }
            this.arrs[name] = new_prop;
        }
        // now fix idx
        let nidx = 0
        for(let i = 0; i < idx.length; ++i) {
            idx[i] = nidx++;
        }
        this.invalidate_pos()
    }

    computed_prop(name) {
        if (name === "face_center")
            return new PropCallProxy(this, name, TYPE_VEC2)
        return null
    }
    // called from PropCallProxy, from SetAttr
    face_center(face_index) {
        const face_size = this.face_size()
        const idx = this.arrs.idx
        let vtx = this.effective_vtx_pos
        let sx = 0, sy = 0
        for(let i = 0; i < face_size; ++i) {
            const vi = idx[face_index*face_size + i]*2
            sx += vtx[vi]
            sy += vtx[vi+1]
        }
        return vec2.fromValues(sx / face_size, sy / face_size)
    }


    // API
    get_bbox() { // TBD can cache this
        let vtx = this.effective_vtx_pos
        if (vtx.length == 0)
            return null
        let min_x = Number.MAX_VALUE, max_x = -Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_y = -Number.MAX_VALUE
        for(let i = 0; i < vtx.length; i += 2) { 
            let x = vtx[i], y = vtx[i+1]
            if (x < min_x) min_x = x
            if (x > max_x) max_x = x
            if (y < min_y) min_y = y
            if (y > max_y) max_y = y
        }
        return new BBox(min_x, min_y, max_x, max_y)
    }

    is_point_inside(x, y) {
        this.ensure_paths_created()
        for(let p of this.paths) {
            if (ctx_img.isPointInPath(p, x, y))
                return true
        }
        return false
    }

    draw_border(m) {
        let bbox = this.get_bbox()
        ctx_img.save()
        canvas_setTransform(ctx_img, m)
        ctx_img.strokeStyle = "#000"
        ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        ctx_img.strokeRect(bbox.min_x, bbox.min_y, bbox.max_x - bbox.min_x, bbox.max_y - bbox.min_y)
        ctx_img.restore()
    }

    draw_vertices(lines_color="#000", do_fill=true, disp_params=null) 
    {
        let vtx = this.effective_vtx_pos
        if (vtx === null)
            return
        let vtx_radius = null
        if (this.arrs.vtx_radius !== undefined) {
            vtx_radius = this.arrs.vtx_radius
            dassert(vtx_radius.length == this.arrs.vtx_pos.length / 2, "unexpected size of vtx_radius")
        }
        const const_radius = (this.consts.vtx_radius !== undefined) ? this.consts.vtx_radius : MESH_DISP.vtx_radius
        const has_arr_col = this.arrs.vtx_color !== undefined
        const has_const_col = this.consts.vtx_color !== undefined

        // circle fills
        if (do_fill && (has_arr_col || has_const_col)) {
            let vcol
            if (has_arr_col) { 
                vcol = this.arrs.vtx_color
                dassert(vcol.length / 4 == this.arrs.vtx_pos.length / 2, "unexpected size of vtx_color")
            }
            else 
                vcol = this.consts.vtx_color
 
            for(let i = 0, vi = 0, icol = 0; vi < vtx.length; ++i, vi += 2) {
                // radius shouldn't be negative
                let radius = Math.max(0, (vtx_radius !== null) ? vtx_radius[i] : const_radius)
                radius /= image_view.viewport_zoom // radius is given in pixels, need to scale it back
                ctx_img.beginPath();
                ctx_img.arc(vtx[vi], vtx[vi+1], radius, 0, 2*Math.PI)
                ctx_img.fillStyle = "rgba(" + vcol[icol] + "," + vcol[icol+1] + "," + vcol[icol+2] + "," + (vcol[icol+3]/255) + ")"
                ctx_img.fill()
                if (has_arr_col)
                    icol += 4
            }
            ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        }
        else {
            ctx_img.lineWidth = 1/image_view.viewport_zoom
        }

        // circle stroke
        ctx_img.beginPath();
        for(let i = 0, vi = 0; vi < vtx.length; ++i, vi += 2) {
            let radius = Math.max(0, (vtx_radius !== null) ? vtx_radius[i] : const_radius)
            radius /= image_view.viewport_zoom
            let x = vtx[vi], y = vtx[vi+1]
            ctx_img.moveTo(x + radius, y)
            ctx_img.arc(x, y, radius, 0, 2*Math.PI)
        }
        ctx_img.strokeStyle = lines_color
        ctx_img.stroke()       

        // normals
        if (disp_params !== null)
        {
            this.forVec2Arrs((name, arr)=>{
                if (!disp_params["show_" + name])
                    return
                const scale = disp_params["scale_" + name]
                dassert(arr.length == this.arrs.vtx_pos.length, "unexpected size of attribute " + name)
                ctx_img.beginPath();
                for(let vi=0; vi < vtx.length; vi += 2) {
                    ctx_img.moveTo(vtx[vi], vtx[vi+1])
                    ctx_img.lineTo(vtx[vi] + arr[vi] * scale, vtx[vi+1] + arr[vi+1] * scale)
                }
                ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
                ctx_img.strokeStyle = "#ff0000"
                ctx_img.stroke()
            })
        }
    }

    ensure_paths_created() {
        if (this.arrs.idx === null) {
            this.paths = []
            return // no paths to create
        }
        if (this.paths !== null && this.paths.length*this.face_size() == this.arrs.idx.length) 
            return
        let vtx = this.effective_vtx_pos

        let idxs = this.arrs.idx    
        this.paths = []
        let i = 0
        if (this.type == MESH_QUAD) {
            while(i < idxs.length) {
                let p = ctx_img.makePath2D()
                let idx = idxs[i++]<<1; p.moveTo(vtx[idx], vtx[idx+1])
                idx = idxs[i++]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                idx = idxs[i++]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                idx = idxs[i++]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                p.closePath()
                this.paths.push(p)
            }
        }
        else if (this.type == MESH_TRI) {
            while(i < idxs.length) {
                let p = ctx_img.makePath2D()
                let idx = idxs[i++]<<1; p.moveTo(vtx[idx], vtx[idx+1])
                idx = idxs[i++]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                idx = idxs[i++]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                p.closePath()
                this.paths.push(p)      
            }
        }            
    }

    draw_poly_stroke(lines_color = "#000") {
        this.ensure_paths_created()       
        ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        ctx_img.strokeStyle = lines_color
        for(let p of this.paths) {
            ctx_img.stroke(p)        
        }        
    }

    draw_poly_fill_color() {
        this.ensure_paths_created()
        let fcol
        const has_arr = this.arrs.face_color !== undefined
        if (has_arr) {
            fcol = this.arrs.face_color
            dassert(fcol.length === this.paths.length * 4, "Wrong size of face_color: " + fcol.length + " expected: " + this.paths.length * 4)
        }
        else
            fcol = this.consts.face_color

        ctx_img.lineWidth = 1 / image_view.viewport_zoom
        let vidx = 0, style
        for(let p of this.paths) {
            style = "rgba(" + fcol[vidx] + "," + fcol[vidx+1] + "," + fcol[vidx+2] + "," + (fcol[vidx+3]/255) + ")"

            ctx_img.fillStyle = style
            ctx_img.fill(p)
            ctx_img.strokeStyle = style
            ctx_img.stroke(p) // need to stroke as well as as fill to fix the stupid stitching bug caused by per-poly antialiasing 
                             // https://stackoverflow.com/questions/15631426/svg-fill-not-filling-boundary/15638764#comment22224474_15638764
                             // This is wrong if the fill has alpha lower than 1 or ==1
            if (has_arr)                             
                vidx += 4
        }
    }

    make_clip_path(face_fill, foi) {
        let vtx = this.effective_vtx_pos
        let idxs = this.arrs.idx        
        let p = ctx_img.makePath2D(), idx
        if (this.type == MESH_QUAD) {
            for(let vi = 0, i = 0; vi < idxs.length; vi += 4, ++i) {
                if (face_fill[i] != foi)
                    continue
                idx = idxs[vi]<<1; p.moveTo(vtx[idx], vtx[idx+1])
                idx = idxs[vi+1]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                idx = idxs[vi+2]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                idx = idxs[vi+3]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                p.closePath()
            }
        }
        else if (this.type == MESH_TRI) {
            for(let vi = 0, i = 0; vi < idxs.length; vi += 3, ++i) {
                if (face_fill[i] != foi)
                    continue
                idx = idxs[vi]<<1; p.moveTo(vtx[idx], vtx[idx+1])
                idx = idxs[vi+1]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                idx = idxs[vi+2]<<1; p.lineTo(vtx[idx], vtx[idx+1])
                p.closePath()
            }
        }       
        return p
    }

    draw_poly_fill_clip(m) 
    {
        for(let foi in this.fill_objs) 
        {
            const fo = this.fill_objs[foi]
            if (fo === null)
                continue
            if (fo.clip_path === undefined || fo.clip_path === null)  // it's going to be undefined at the first time, null if it's invalidated?
                fo.clip_path = this.make_clip_path(this.arrs.face_fill, foi)
            ctx_img.save()
            ctx_img.clip(fo.clip_path, "nonzero"); // "evenodd" is not what we usually want
            try {
                fo.obj_proxy.draw(m)
            } finally {
                ctx_img.restore()
            }
        }
    }

    async pre_draw_poly_fill_clip(m) 
    {
        for(let foi in this.fill_objs) {
            const fo = this.fill_objs[foi]
            if (fo === null)
                continue
            await fo.obj_proxy.pre_draw(m)       
        }        
    }
    
    ensure_tcache(m) {  // used for gl_draw and setattr node transform
        let do_trans = false
        if (this.tcache.vtx_pos === null) {
            this.tcache.vtx_pos = new Float32Array(this.arrs.vtx_pos.length)
            do_trans = true
        }
        else if (this.tcache.m === null || !mat3.equals(m, this.tcache.m)) {
            do_trans = true
        }
        if (do_trans) {
            Mesh.transform_arr(m, this.effective_vtx_pos, this.tcache.vtx_pos)
            this.meta.vtx_pos.made_glbuf = false
        }
    }

    vidxs_of_face(i) { // get the vertices indices (of x) of face i
        let face_sz = this.face_size()
        let idxi = i * face_sz
        console.assert(idxi < this.arrs.idx.length, "Out of bound index")
        let r = []
        for(let fi = 0; fi < face_sz; ++fi) {
            let vidx = this.arrs.idx[idxi++] * 2
            r.push(vidx)
        }
        return r
    }

    // API
    async pre_draw(m, disp_values) {
        if (disp_values.show_faces) {
            if (!this.arrs.face_color && this.arrs.face_fill) {
                await this.pre_draw_poly_fill_clip(m)
            }
        }
    }

    // API
    draw_m(m, disp_values) {
        //console.log("Mesh ", this.face_size(), " vtx:", this.arrs.vtx_pos.length/2, " faces:", this.face_count()) 
        if (!disp_values)
            disp_values = { show_faces:true, show_lines:true, show_vtx:true } // hack for group to work
        //this.ensure_tcache(m)

        if (disp_values.show_faces) {
            if (this.arrs.face_color || this.consts.face_color)
                this.draw_poly_fill_color()
            else if (this.arrs.face_fill) 
                this.draw_poly_fill_clip(m)
        }
        if (disp_values.show_lines)
            this.draw_poly_stroke()
        if (disp_values.show_vtx)
            this.draw_vertices("#000", true, disp_values)
    }

    draw_selection_m(m, select_indices) {
        //this.ensure_tcache(m)
        let vtx = this.effective_vtx_pos
        ctx_img.beginPath();
        let radius = MESH_DISP.vtx_sel_radius/image_view.viewport_zoom
        for(let idx of select_indices) {
            let vidx = idx * 2
            let x = vtx[vidx], y = vtx[vidx+1]
            ctx_img.moveTo(x + radius, y)
            ctx_img.arc(x, y, radius, 0, 2*Math.PI)
        }
        ctx_img.lineWidth = 2/image_view.viewport_zoom
        ctx_img.strokeStyle = MESH_DISP.sel_color
        ctx_img.stroke()
    }

    draw_template_m(m) {
        this.draw_poly_stroke(TEMPLATE_LINE_COLOR)
        this.draw_vertices(TEMPLATE_LINE_COLOR, false)
    }

    make_buffers() {
        for(let name in this.arrs) {
            if (this.arrs[name] === null)
                continue // happens for idx array when rendering just points
            if (!this.glbufs[name]) {
                this.glbufs[name] = gl.createBuffer()
                //this.glbufs[name].buf_id = g_buf_id++
                //console.log("++",this.glbufs[name].buf_id)
                this.meta[name].made_glbuf = false
            }
            dassert(this.meta[name] !== null && this.meta[name] !== undefined, "Missing meta for array " + name)
            if (!this.meta[name].made_glbuf) {
                let data_from = (name == "vtx_pos") ? this.tcache : this.arrs
                let bind_point = (name == 'idx') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER
                    
                gl.bindBuffer(bind_point, this.glbufs[name]);
                gl.bufferData(bind_point, data_from[name], gl.STATIC_DRAW);
                this.meta[name].made_glbuf = true
            }
        }     
    }

    make_point_suffle(seed, len) 
    {
        // it makes sense to generate the shuffle and cache it in the mesh since that's when we can create the gl buffer as well
        if (this.points_idx_cache !== null && this.points_idx_cache.seed === seed && this.points_idx_cache.len === len)
            return this.points_idx_cache.idx_buf
        const idx = new TIdxArr(len)
        for(let i = 0; i < len; ++i)
            idx[i] = i;
        // Fisher–Yates shuffle
        const prng = new RandNumGen(seed)
        for (let i = len - 1; i > 0; i--) {
            const j = Math.floor(prng.next() * (i + 1));
            [idx[i], idx[j]] = [idx[j], idx[i]];
        }

        let idx_buf = null
        if (this.points_idx_cache !== null) // if it's not null, it has idx_buf
            idx_buf = this.points_idx_cache.idx_buf 
        else
            idx_buf = gl.createBuffer()
                    
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idx_buf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
        this.points_idx_cache = { idx_buf:idx_buf, seed:seed, len:len } 

        return idx_buf 
    }

    // program_attr maps attribute name to index (location)
    gl_draw(m, program_attr, opt={}) 
    { 
        dassert(this.type === MESH_TRI || this.type === MESH_POINTS || opt.override_just_points, "can't gl_draw non triangle mesh")
        this.ensure_tcache(m)  // TBD another cache?
        this.make_buffers()

        for(let attr_name in program_attr) {
            console.assert(!attr_name.startsWith('face_'), "Face attributes can't be drawen with webgl")
            let attr_buf = this.glbufs[attr_name]
            if (!attr_buf) {
                if (attr_name.substr(0,2) == 'a_') {
                    attr_name = attr_name.substr(2)
                    attr_buf = this.glbufs[attr_name]
                }
            }
            let attr_idx = program_attr[attr_name]
            dassert(attr_idx !== -1, "Can't find program attribute `" + attr_name + "`")
            let arr = this.arrs[attr_name]
            let meta = this.meta[attr_name]
            if (!attr_buf) {
                gl.disableVertexAttribArray(attr_idx)
            }
            else {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.glbufs[attr_name]);
                gl.enableVertexAttribArray(attr_idx);
                gl.vertexAttribPointer(attr_idx, meta.num_elems, arr_gl_type(arr), meta.need_normalize, 0, 0); 
            }
        }

        if (this.type === MESH_TRI && !opt.override_just_points) {
            dassert(this.glbufs.idx !== null, "Tri mesh without indices")
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.glbufs.idx);
            gl.drawElements(gl.TRIANGLES, this.arrs.idx.length, arr_gl_type(this.arrs.idx), 0);
        }
        else {  // just points
            const count = this.arrs.vtx_pos.length / this.meta.vtx_pos.num_elems
            if (opt.shuffle_points_seed !== null) {
                const idx_buf = this.make_point_suffle(opt.shuffle_points_seed, count)
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idx_buf)
                gl.drawElements(gl.POINTS, count, arr_gl_type(this.arrs.idx), 0);
            }
            else {
                gl.drawArrays(gl.POINTS, 0, count)
            }
        }

        // disable everything we just enabled for the future other programs running
        for(let attr_name in program_attr) {
            let attr_idx = program_attr[attr_name]
            gl.disableVertexAttribArray(attr_idx)
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, null)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
    }

    add_fillobj(proxy) {
        const id = this.fill_objs.length
        this.fill_objs.push(new FillObj(proxy))
        return id
    }

    make_single_object_calls(p) {
        let vtx = this.effective_vtx_pos
        let idxs = this.arrs.idx        
        let idx, vidx
        if (this.type == MESH_QUAD) {
            for(let vi = 0, i = 0; vi < idxs.length; vi += 4, ++i) {
                vidx = idxs[vi];   idx = vidx<<1; p.moveTo(vtx[idx], vtx[idx+1], vidx)
                vidx = idxs[vi+1]; idx = vidx<<1; p.lineTo(vtx[idx], vtx[idx+1], vidx)
                vidx = idxs[vi+2]; idx = vidx<<1; p.lineTo(vtx[idx], vtx[idx+1], vidx)
                vidx = idxs[vi+3]; idx = vidx<<1; p.lineTo(vtx[idx], vtx[idx+1], vidx)
                p.closePath()
            }
        }
        else if (this.type == MESH_TRI) {
            for(let vi = 0, i = 0; vi < idxs.length; vi += 3, ++i) {
                vidx = idxs[vi];   idx = vidx<<1; p.moveTo(vtx[idx], vtx[idx+1], idx)
                vidx = idxs[vi+1]; idx = vidx<<1; p.lineTo(vtx[idx], vtx[idx+1], idx)
                vidx = idxs[vi+2]; idx = vidx<<1; p.lineTo(vtx[idx], vtx[idx+1], idx)
                p.closePath()
            }
        }       
        return p        
    }

    ensure_paper() {
        if (this.paper_obj !== null && this.paper_obj.children.length*this.face_size() == this.arrs.idx.length) 
            return this.paper_obj
        const p = new paper.CompoundPath()
        p.remove()  // avoid having it drawing to nowhere
        this.make_single_object_calls(p)
        this.paper_obj = p
        return this.paper_obj        
    }

    ensure_clipper() {
        if (this.clipper_obj !== null)
            return this.clipper_obj
        const b = new ClipperPathsBuilder()
        this.make_single_object_calls(b)
        this.clipper_obj = b.d
        //ClipperLib.JS.ScaleUpPaths(this.clipper_obj, CLIPPER_SCALE);
        return this.clipper_obj
    }

    add_vertex_props(p, props)
    {
        for (let name in props) {
            if (this.arrs[name] !== undefined)
                continue
            const num_elems = props[name].length || 1  // if there's no length, it's a value
            this.set(name, [], num_elems, false)
            const v_count = this.vtx_count()
            if (v_count > 0) { // adding to a property that doesn't exist
                const v = (this.consts[name] !== undefined) ? this.consts[name] : get_default_value(name, num_elems)
                const arr = []
                if (num_elems === 1)
                    for(let i = 0; i < v_count; ++i)
                        arr.push(v)
                else
                    for(let i = 0; i < v_count; ++i)
                        arr.push(...v)
                this.set(name, arr, num_elems, false) // TBD test existing, TBD OpenGL
            }
        }
        for (let name in this.arrs) {
            if (name === "idx")
                continue
            dassert(is_per_vertex_prop_name(name), "mesh with face attributes not supported " + name)
            if (isTypedArray(this.arrs[name]))
                this.arrs[name] = [...this.arrs[name]]  // change it to an array that can be pushed to
            if (name == "vtx_pos") {
                this.arrs.vtx_pos.push(p[0], p[1])
                this.effective_vtx_pos = this.arrs.vtx_pos
            }
            else {
                let v = props[name]
                if (v === undefined) {
                    v = get_default_value(name, this.meta[name].num_elems)
                }
                if (this.meta[name].num_elems == 1)
                    this.arrs[name].push(v)  // plain value, not an array
                else
                    this.arrs[name].push(...v)
            }
        }
    }

    // from NodePen
    add_vertex(p, props)
    {
        dassert(this.effective_vtx_pos === this.arrs.vtx_pos, "Working with effective_vtx_pos not supported")
        dassert(this.type === MESH_POINTS, "Only points mesh supported") 

        this.add_vertex_props(p, props)
        //this.arrs.idx.push( (this.arrs.vtx_pos.length - 2) / 2 )
    }

    get_last_vertex() {
        const vtx = this.arrs.vtx_pos
        if (vtx === null || vtx.length < 2)
            return null
        return [vtx[vtx.length-2], vtx[vtx.length-1]]
    }

    describe(parent, dlg) 
    {
        if (dlg.recreate_if_needed(this)) {
            dlg.eobj.vtxnum = dlg.add_line("Vertex Count: ").value_elem
            dlg.eobj.type = dlg.add_line("Type: ").value_elem
            dlg.eobj.facenum = dlg.add_line("Face Count: ").value_elem
            dlg.eobj.props = dlg.add_line("Properties:", true).value_elem
            dlg.eobj.props.classList.add("obj_inf_prop_list")
            dlg.adjust_labels()

        }
        dlg.eobj.vtxnum.innerText = this.arrs.vtx_pos.length / 2
        dlg.eobj.type.innerText = meshTypeName(this.type)
        dlg.eobj.facenum.innerText = this.face_count()
        const prop_lines = []
        for(let name in this.arrs)
            prop_lines.push(name + ": " + this.arrs[name].constructor.name + "(" + this.arrs[name].length + ")")
        dlg.eobj.props.innerText = prop_lines.join("\n")
        
    }
}

function is_per_vertex_prop_name(name) {
    return name.startsWith("vtx_") || name.startsWith("line_")
}

const CLIPPER_SCALE = 1

// construct a clipper.js style object from context ops
class ClipperPathsBuilder 
{
    constructor() {
        this.d = []
        this.cur_path = null
    }
    moveTo(x, y, vidx) {
        this.cur_path = [{X:x, Y:y, Z:vidx}]
        this.cur_path.closed = false
        this.d.push(this.cur_path)
    }
    lineTo(x, y, vidx) {
        dassert(this.cur_path !== null, "Path needs to start with moveTo")
        this.cur_path.push({X:x, Y:y, Z:vidx})
    }
    closePath() {
        dassert(this.cur_path !== null, "Path needs to start with moveTo")
        this.cur_path.closed = true
    }
    bezierCurveTo() {
        dassert(false, "not implemented")
    }
}


let g_buf_id = 1

function arr_gl_type(arr) {
    let ctor = arr.constructor
    if (ctor === Float32Array)
        return gl.FLOAT
    if (ctor === Uint8Array || ctor === Uint8ClampedArray)
        return gl.UNSIGNED_BYTE
    if (ctor === Uint32Array)
        return gl.UNSIGNED_INT
    if (ctor === Uint16Array)
        return gl.UNSIGNED_SHORT
    throw new Error("unexpected array type")
}

/*  make line segments, not really needed
    draw_poly_stroke() {
        if (this.type != MESH_TRI && this.type != MESH_QUAD)
            return
        let idx = this.arrs.idx
        if (this.lines_cache === null) {
            // upper bound to the number of lines is the the number of edges. it will be lower since the outer hull 
            let vtx_visited = new Uint8Array(this.arrs.vtx_pos.length)
            let lines_idx = new Uint32Array(idx.length)
            let ladd = 0
            function check_add(a,b) {
                if (vtx_visited[b] != 0)
                    return
                vtx_visited[b] = 1
                lines_idx[ladd++] = a
                lines_idx[ladd++] = b
            }
            for(let i = 0; i < idx.length; i += 3) {
                check_add(idx[i], idx[i+1])
                check_add(idx[i+1], idx[i+2])
                check_add(idx[i+2], idx[i])
            }
            this.lines_cache = lines_idx.slice(0,ladd)
            console.log("triangles-idx:" + idx.length + " lines-idx:" + ladd)
        }

        let lidx = this.lines_cache
        let i = 0
        while(i < lidx.length) {
            let idx = lidx[i++]<<1
            ctx_img.moveTo(vtx[idx], vtx[idx+1])
            idx = idxs[i++]<<1
            ctx_img.lineTo(vtx[idx], vtx[idx+1])
        }

    }
*/
"use strict"

function save_program() {
    let sprog = { nodes: {}, lines:[], 
        next_node_id: program.next_obj_id, 
        names_idx_s: program.names_indices,
        display_node_id: (program.display_node === null) ? null : program.display_node.id,
        tdisp_node_ids: [], 
        input_node_ids: [],
        //glob_var_node_ids: [],
        //anim_flow_start_node_id: (program.anim_flow.start_node === null) ? null : program.anim_flow.start_node.id,
        nodes_view: nodes_view.save(),  // part of the program so the user won't need to start looking for the nodes
        decor: []
    }
    for(let n of program.nodes) {
        let sn = { params: {}, 
                   name:n.name, 
                   cls_name: n.cls.constructor.name(), 
                   x:n.x, y:n.y, 
                   disp_param:n.display_values,
                   enable_active: n.enable_active }
        for(let p of n.parameters) {
            const ov = p.save()
            if (ov !== null)
                sn.params[p.label] = ov
        }
        if (n.following_node !== null)
            sn.following = n.following_node.id 
        for(let i = 0; i < n.outputs.length; ++i)
            if (!n.outputs[i].caching) { // default is true
                if (sn.non_caching_out == undefined)
                    sn.non_caching_out = []
                sn.non_caching_out.push(i)
            }
        sprog.nodes[n.id] = sn
    }
    for(let line of program.lines) {
        let from_term = line.from_term.get_attachee()
        let to_term = line.to_term.get_attachee()
        sprog.lines.push({ from_name: from_term.name, from_id: from_term.owner.id,
                           to_name:   to_term.name,   to_id: to_term.owner.id,
                           uid: line.uid })
    }
    for(let tn of program.tdisp_nodes) {
        sprog.tdisp_node_ids.push(tn.id)
    }
    for(let inn of program.input_nodes) {
        sprog.input_node_ids.push(inn.id)
    }
    /*for(let gnn of program.glob_var_nodes) {
        sprog.glob_var_node_ids.push(gnn.id)
    }*/
    for(let dec of program.nodes_decor) {
        const r = dec.save()
        r.type = dec.constructor.name()
        r.uid = dec.uid
        sprog.decor.push(r)
    }
    return sprog
}

function json_stringify(obj) {
    let json = JSON.stringify(obj, function(k, v) {
        if (ArrayBuffer.isView(v)) 
            return Array.from(v);        
        return v;
    })
    return json
}

function save_program_json() {
    let sprog = save_program()
    return json_stringify(sprog)
}

function load_prog_obj(prog) {
    load_program(prog)
    draw_nodes()
    trigger_frame_draw(true)
}

function load_prog_json(prog_s) {
    let prog = JSON.parse(prog_s)
    load_prog_obj(prog)
}

var user_saved_programs = {}

function make_state(with_saves) {
    let state = { program: save_program(),                  
                  main_view_s: main_view_state.save(),                  
                }
    let color_pre = ColorPicker.get_presets()
    if (Object.keys(color_pre).length > 0)
        state.color_presets = color_pre
    if (with_saves)
        state.user_saved_progs = user_saved_programs

    const  json = json_stringify(state)
    return json
}

function save_state() {
    if (g_loading_page || g_loading_prog)
        return
    const json = make_state(false)
    localStorage.setItem("state", json)
}

function save_saved_progs() {
    const j_saved = json_stringify(user_saved_programs)
    localStorage.setItem("user_saved_progs", j_saved)
}

// -----------
function find_param_by_name(name, parameters) {
    for(let p of parameters)
        if (p.label === name)
            return p
    return null
}

function load_program(sprog) {
    try {
        g_loading_prog = true
        _load_program(sprog)
    }
    finally {
        g_loading_prog = false
    }
}

function _load_program(sprog) 
{
    nodes_unselect_all(false)
    clear_program()
    
    const newprog = new Program()

    // creating nodes below doesn't add to this, adds only ephmeral ids
    newprog.next_obj_id = parseInt(sprog.next_node_id) 
    for(let n in sprog.names_idx_s)
        newprog.names_indices[n] = parseInt(sprog.names_idx_s[n])

    for(let nid_s in sprog.nodes) {
        let nid = parseInt(nid_s)
        let sn = sprog.nodes[nid]
        let cls = nodes_classes_by_name[sn.cls_name]
        console.assert(cls !== undefined && cls !== null, "Unknown node class " + sn.cls_name)
        let n = newprog.add_node(sn.x, sn.y, sn.name, cls, nid)
        for(let spname in sn.params) {
            let sp = sn.params[spname]            
            let p = find_param_by_name(spname, n.parameters)
            if (p === null)
                p = n.param_aliases[spname]
            if (p === undefined) {
                console.error("Missing parameter " + spname + " of node " + sn.name)
                continue
            }
            try {
                p.load(sp)
                p.call_change()
                p.pset_dirty()
            }
            catch (e) {
                console.warn("Failed load of parameter", p.label, "in node", sn.name, ':', e)
            }
        }
        if (sn.non_caching_out !== undefined)
            for(let oidx of sn.non_caching_out)
                n.outputs[oidx].set_caching(false)
        //if (n.cls.post_load_hook)  moved below
        //    n.cls.post_load_hook()
        if (sn.enable_active)
            n.cls.toggle_enable_flag(false, true)
        if (sn.disp_param)
            n.display_values = sn.disp_param
    }
    let find_by_name = function (cont, name) {
        for(let o of cont)
            if (o.name == name)
                return o
        return null
    }
    for(let sl of sprog.lines) {
        let from_node = newprog.obj_map[sl.from_id]
        console.assert(from_node.constructor === Node)
        let from_term = find_by_name(from_node.terminals, sl.from_name)
        let to_node = newprog.obj_map[sl.to_id]
        console.assert(to_node.constructor === Node)
        let to_term = find_by_name(to_node.terminals, sl.to_name)
        if (to_term === null)
            to_term = to_node.terminal_aliases[sl.to_name]
        if (to_term === undefined) {
            console.log("Can't find terminal ", sl.to_name, " for node ", to_node.name)
            continue // happens when terminal names change
        }
        if (from_term === null || to_term === null) { // term changed name?
            console.warn("did not find terminal of node ", from_node.name)
            continue
        }
        newprog.add_line(new Line(from_term.get_attachment(), to_term.get_attachment()), sl.uid, false)
    }
    // need to do this after all nodes were created
    for(let nid in sprog.nodes) {
        let sn = sprog.nodes[nid]
        if (sn.following !== undefined)
            newprog.obj_map[nid].follow(newprog.obj_map[sn.following])
    }
    for(let n of newprog.nodes) {
        if (n.cls.post_load_hook)
            n.cls.post_load_hook()
        for(let p of n.parameters)
            if (p.post_load_hook)
                p.post_load_hook()
    }

    if (sprog.display_node_id === null || newprog.obj_map[sprog.display_node_id] === undefined)
        newprog.set_display_node(null)
    else
        newprog.set_display_node(newprog.obj_map[sprog.display_node_id])

    /*if (sprog.anim_flow_start_node_id === null || sprog.anim_flow_start_node_id === undefined || newprog.obj_map[sprog.anim_flow_start_node_id] === undefined)
        newprog.anim_flow.set_anim_node(null)
    else
        newprog.anim_flow.set_anim_node(newprog.obj_map[sprog.anim_flow_start_node_id])
*/
    newprog.tdisp_nodes = []
    if (sprog.tdisp_node_ids !== undefined) {
        for(let tnid of sprog.tdisp_node_ids) {
            let tn = newprog.obj_map[tnid]
            if (tn === undefined)
                continue
            //console.assert(tn !== undefined, "template node not found")
            newprog.set_template_node(tn, false)
        }
    }
    if (sprog.input_node_ids !== undefined) {
        for(let inid of sprog.input_node_ids) {
            const inn = newprog.obj_map[inid]
            console.assert(inn !== undefined, "input node not found")
            newprog.set_input_node(inn, false)
        }
    }

    if (sprog.nodes_view !== undefined) // old progs don't have it
        nodes_view.load(sprog.nodes_view)

    if (sprog.decor !== undefined) {        
        for(let sdec of sprog.decor) {
            const type = nodes_decor_by_name[sdec.type]
            if (type === undefined) {
                console.warn("unknown decor class " + sdec.type)
                continue
            }
            const obj = new type()
            obj.load(sdec)
            newprog.nodes_add_decor(obj, sdec.uid)
        }
    }

    console.assert(newprog.next_obj_id === parseInt(sprog.next_node_id), "Unexpected ids created")

    program = newprog // commit to it
}

var g_loading_prog = false
var g_loading_page = false // used for avoiding spurious saves during load
function set_loading(v) {
    g_loading_page = v
}

function load_state() {
    let state_s = localStorage.getItem("state")
    if (state_s === null)
        return
    //console.log("LOADING: " + state)
    let state = JSON.parse(state_s)
    main_view_state.load(state.main_view_s)
    if (state.color_presets)
        ColorPicker.set_presets(state.color_presets)

    let saved_s = localStorage.getItem('user_saved_progs')
    if (saved_s !== null)
        user_saved_programs = JSON.parse(saved_s)
    else if (state.user_saved_progs)
        user_saved_programs = state.user_saved_progs

    try {
        load_program(state.program) 
    }
    catch(e) {
        console.error("Failed loading current program" + e)
    }
}

"use strict"

// https://github.com/NishadSaraf/First-Order-Differentiation-In-C/blob/d6965c15bef4fe84837105eb0e5ed8f21ae9f80b/calculator.hpp


const FUNC_TYPE_BY_COMPONENT = 0; // not a real type, run the function component by component
const FUNC_TYPE_LOOKUP = -1;  // type for function, given func name is actually a dictionary between type and actual func
const TYPE_NUM = 1;
const TYPE_BOOL = 2;
const TYPE_VEC3 = 10; 
const TYPE_VEC4 = 11;
const TYPE_VEC2 = 12;
const TYPE_MAT3 = 13;
const TYPE_FUNCTION = 21;  // function 
const TYPE_VOID = 22; // for function returns
// returned from global check_type to mean there's not enough info to know what the type is since it depends on evaulators
// that will be set by the cls, check_type will try again in dyn_eval
const TYPE_UNDECIDED = 100; 
// similar to UNDECIDED but only on variables
const TYPE_DEPEND_ON_VAR = 101;

const PARSE_EXPR = 1;
const PARSE_CODE = 2;
var g_lineNum = 0

class ExprErr extends Error {
    constructor(msg, line_num=null) { 
        super(msg)
        if (line_num !== null && line_num !== undefined)
            this.line = line_num
        else
            this.line = g_lineNum
    }
}
class TypeErr extends ExprErr {
    constructor(msg, line_num=null) { super(msg, line_num) }
}

// thrown when the type of the object is really undecided, can depend on input terminal for instance
class UndecidedTypeErr extends Error {
    constructor() { super("undecided-type") }
}
class DependOnVarErr extends Error {
    constructor(msg) { super(msg) }
}

// throw in expressions
function eassert(cond, msg, line_num=null) {
    if (!cond)
        throw new ExprErr(msg, line_num)
}

class NodeBase {
    constructor() {
        this.type = null
        this.line = g_lineNum
    }
    
    clear_types_cache() { // should implemet recursion
        this.type = null
    }
    consumes_subscript() { // for evaluator nodes to tell the parser if they consumed all the subscripts of the identifier that get_evaluator was sent
        return false 
    }
    // needs to be implemented if check_type returns TYPE_FUNC
    //  this predicts what's going to be the type returned by the call to the function object
    func_ret_type(arg_type_tuple) { 
        eassert(false, "func_ret_type not implemented")
    }
    get_const_value() { // if it's a node that has a constant value (number, vec) return it for higher percision than saving a string
        return null
    }
    eval() {
        eassert(false, "eval not implemented")
    }
    check_type() {
        eassert(false, "check_type not implemented")
    }
    to_glsl() { 
        eassert(false, "to_glsl not implemented") 
    }
}

// base class for all evaluators
class EvaluatorBase extends NodeBase {
    constructor() {
        super()
        this.line_num = null // set it StateAccess.get_evaluator
    }
}

function typename(t) {
    switch(t) {
    case TYPE_NUM: return "number"
    case TYPE_BOOL: return "bool"
    case TYPE_VEC2: return "vec2"
    case TYPE_VEC3: return "vec3"
    case TYPE_VEC4: return "vec4"
    case TYPE_MAT3: return "mat3"
    case TYPE_VOID: return "void"
    case TYPE_FUNCTION: return "function"
    default: return "<" + t + ">"
    }
}
function numbersInType(t) {
    switch(t) {
    case TYPE_NUM: return 1
    case TYPE_BOOL: return 1
    case TYPE_VEC2: return 2
    case TYPE_VEC3: return 3
    case TYPE_VEC4: return 4
    default: throw ExprErr("numbersInType for unexpected type " + t)
    }
}

// pack multiple types in the same value, used for function lookup by argument types
function type_tuple_l(lst) {
    if (lst.length > 4)
        throw new TypeErr("too many arguments to function")
    let at = 0, idx = 0
    for(let t of lst)
        at = at | (t << (8*idx++))
    return at
}
function type_tuple() {
    return type_tuple_l(arguments)
}
function type_tuple_str(tt) {
    let s = []
    while(tt !== 0) {
        s.push(typename(tt & 0xff))
        tt = tt >> 8
    }
    return s.join(",")
}


function clamp(a, v, b) {
    if (v < a) return a;
    if (v > b) return b;
    return v;
}

const SUBSCRIPT_TO_IDX = { x:0, y:1, z: 2, w:3, r:0, g:1, b:2, a: 3, alpha:3 }
const SUBIDX_TO_GLSL = ['r','g','b','w']

class FuncsSet {
    constructor() {
        this.set = {}
    }
    add(name, text) {
        if (this.set[name] !== undefined)
            return
        this.set[name] = text
    }
    extend(v) {
        if (v === null)
            return
        this.set = {...this.set, ...v.set}
    }
    to_text() {
        const func_lst = []
        for(let ft_name in this.set)
            func_lst.push(this.set[ft_name])
        return func_lst.join("\n")
    }
    get_kv() {
        return this.set
    }
    get(name) {
        return this.set[name]
    }
    append_text(name, text) {
        if (this.set[name] === undefined)
            this.set[name] = text
        else
            this.set[name] += text
    }
}

var ExprParser = (function() {

// immutable object
class NumNode  extends NodeBase {  
    constructor(_v, str_was_decimal) {
        super()
        eassert(_v !== null && _v !== undefined, "unexpected non-number value")
        this.v = _v;
        this.decimal = str_was_decimal
    }
    eval() {
        return this.v;
    }
    check_type() {
        this.type = TYPE_NUM
        return TYPE_NUM
    }
    to_glsl(emit_ctx) {
        if (Number.isInteger(this.v))
            return this.v + ".0"
        return this.v;
    }
    get_const_value() { 
        if (!this.decimal)
            return null  // original text was hex or oct, don't want to spoil that
        return this.v
    }
}

function make_num_node(v) {
    return new NumNode(v, true)
}


class BoolNode extends NodeBase {
    constructor(_v, str_was_decimal) {
        super()
        eassert(_v !== null && _v !== undefined, "unexpected non-number value")
        this.v = _v;
    }
    eval() {
        return this.v;
    }
    check_type() {
        this.type = TYPE_BOOL
        return TYPE_BOOL
    }
    to_glsl(emit_ctx) {
        return this.v ? "true":"false";
    }
    get_const_value() { 
        return this.v
    }
}


class VecNode extends NodeBase {
    constructor(_v, type) {
        super()
        this.v = _v;
        this.type = type
    }
    eval() {
        return this.v
    }
    check_type() {
        return this.type
    }
}

function checkZero(v) {
    if (v == 0) {
        throw new ExprErr("Division by zero");
    }
    return v;
}

function call_operator(v1, v2, op) {
    let ret;
    switch (op) {
        case OPERATOR_BITWISE_OR:     ret = v1 | v2; break;
        case OPERATOR_BITWISE_XOR:    ret = v1 ^ v2; break;
        case OPERATOR_BITWISE_AND:    ret = v1 & v2; break;
        case OPERATOR_BITWISE_SHL:    ret = v1 << v2; break;
        case OPERATOR_BITWISE_SHR:    ret = v1 >> v2; break;
        case OPERATOR_ADDITION:       ret = v1 + v2; break;
        case OPERATOR_SUBTRACTION:    ret = v1 - v2; break;
        case OPERATOR_MULTIPLICATION: ret = v1 * v2; break;
        case OPERATOR_DIVISION:       ret = v1 / checkZero(v2); break;
        case OPERATOR_MODULO:         ret = v1 % checkZero(v2); break;
        case OPERATOR_POWER:          ret = Math.pow(v1, v2); break;
    //    case OPERATOR_EXPONENT:       ret = v1 * Math.pow(10, v2); break;
        case OPERATOR_SUBSCRIPT:      throw new ExprErr("subscript in binary (bug)");

        case OPERATOR_LESS:           ret = (v1 < v2); break // + to make it a number
        case OPERATOR_LESS_EQ:        ret = (v1 <= v2); break
        case OPERATOR_GREATER:        ret = (v1 > v2); break
        case OPERATOR_GREATER_EQ:     ret = (v1 >= v2); break
        case OPERATOR_EQ:             ret = (v1 == v2); break
        case OPERATOR_NEQ:            ret = (v1 != v2); break
        case OPERATOR_LOGIC_AND:      ret = (v1 && v2); break // not short-circuting evaluation since that would complicate vector ops
        case OPERATOR_LOGIC_OR:       ret = (v1 || v2); break
        default:  throw new ExprErr("unexpected operator");
    }
    return ret;
}

function op_str(op) {
    switch (op) {
        case OPERATOR_BITWISE_OR:     return '|'
        case OPERATOR_BITWISE_XOR:    return '^'
        case OPERATOR_BITWISE_AND:    return '&'
        case OPERATOR_BITWISE_SHL:    return '<<'
        case OPERATOR_BITWISE_SHR:    return '>>'
        case OPERATOR_ADDITION:       return '+'
        case OPERATOR_SUBTRACTION:    return '-'
        case OPERATOR_MULTIPLICATION: return '*'
        case OPERATOR_DIVISION:       return '/'
        case OPERATOR_MODULO:         return '%'
        case OPERATOR_POWER:          return '**'
    //    case OPERATOR_EXPONENT:       return 'e'
        case OPERATOR_SUBSCRIPT:      throw new ExprErr("subscript in binary (bug)");

        case OPERATOR_LESS:           return '<'
        case OPERATOR_LESS_EQ:        return '<='
        case OPERATOR_GREATER:        return '>'
        case OPERATOR_GREATER_EQ:     return '>='
        case OPERATOR_EQ:             return '=='
        case OPERATOR_NEQ:            return '!='
        case OPERATOR_LOGIC_AND:      return '&&'
        case OPERATOR_LOGIC_OR:       return '||'
        default:  throw new ExprErr("unexpected operator");
    }
}

function is_order_op(op) {
    return op == OPERATOR_LESS || op == OPERATOR_LESS_EQ ||  
           op == OPERATOR_GREATER || op == OPERATOR_GREATER_EQ 
}
function is_logic_op(op) {
    return op == OPERATOR_LOGIC_AND || op == OPERATOR_LOGIC_OR
}


class BinaryOpNode extends NodeBase {
    constructor(l, r, _op) {
        super()
        this.left = l;
        this.right = r;
        this.op = _op;
        this.type = null
        this.t1 = null; this.t2 = null
    }
    clear_types_cache() {
        this.type = null
        this.left.clear_types_cache()
        this.right.clear_types_cache()
    }
    check_type() {
        if (this.type === null) {
            let t1 = this.left.check_type(), t2 = this.right.check_type()
            this.t1 = t1; this.t2 = t2
            if (is_order_op(this.op)) { // only between numbers, not supporting vectors of booleans
                if (t1 !== TYPE_NUM || t2 !== TYPE_NUM)
                    throw new TypeErr("boolean operator " + op_str(this.op) + " expects numbers", this.line)
                this.type = TYPE_BOOL
            }
            else if (this.op == OPERATOR_EQ || this.op == OPERATOR_NEQ) {
                if (t1 !== t2)
                    throw new TypeErr("Equality op of different types " + typename(t1) + ", " + typename(t2), this.line)
                this.type = TYPE_BOOL
            }
            else if (is_logic_op(this.op)) {
                if (t1 !== TYPE_BOOL || t2 !== TYPE_BOOL)
                    throw new TypeErr("logic operator " + op_str(this.op) + " expected booleans", this.line)
                this.type = TYPE_BOOL
            }
            else {
                if (t1 > t2) {  let tmp = t1; t1 = t2; t2 = tmp } // t1 is lower
                if (t1 === TYPE_NUM)
                    this.type = t2 // the vec (or float) type
                else if (t1 != t2)
                    throw new TypeErr("can't handle different vec types")
                else 
                    this.type = t1 // both same vec type
            }
        }
        return this.type
    }

    eval() {
        console.assert(this.type !== null)
        const v1 = this.left.eval();
        const v2 = this.right.eval();
        if (this.type === TYPE_NUM || this.type === TYPE_BOOL)
            return call_operator(v1, v2, this.op)
        if (this.t1 == this.t2) // save vec type
            return apply_by_component([v1, v2], (v1, v2)=>{ return call_operator(v1, v2, this.op)})
        // vec and num
        let v,n
        if (this.t1 == TYPE_NUM || this.t1 == TYPE_BOOL)
            v = v2, n = v1
        else
            v = v1, n = v2
        const num_comp = v.length
        const ret = new v.constructor(num_comp)
        for(let i = 0; i < num_comp; ++i) 
            ret[i] = call_operator(v[i], n, this.op)
        return ret
    }

    to_glsl(emit_ctx) {
        return '(' + this.left.to_glsl(emit_ctx) + ops[this.op].str + this.right.to_glsl(emit_ctx) + ')'
    }
}


function call_unary_op(v, op) {
    switch (op) {
    case OPERATORU_NEG: return -v;
    case OPERATORU_BITWISE_NOT: return ~v;
    case OPERATORU_LOGIC_NOT: return !v;
    default:  throw new ExprErr("unexpected unary operator");
    }
}

class UnaryOpNode extends NodeBase {
    constructor(c, op) {
        super()
        this.child = c;
        this.type = null
        this.op = op
    }
    eval() {
        const v = this.child.eval();
        if (this.type == TYPE_NUM || this.type == TYPE_BOOL)
            return call_unary_op(v, this.op)
        const num_comp = v.length
        const ret = new v.constructor(num_comp)
        for(let i = 0; i < num_comp; ++i) 
            ret[i] = call_unary_op(v[i], this.op)
        return ret
    }
    clear_types_cache() {
        this.type = null
        this.child.clear_types_cache()
    }
    check_type() {
        if (this.type === null)            
            this.type = this.child.check_type()
        return this.type
    }
    to_glsl(emit_ctx) {
        const v = this.child.to_glsl(emit_ctx) + ')'
        switch (this.op) {
        case OPERATORU_NEG: return '(-' + v;
        case OPERATORU_BITWISE_NOT: return '(~' + v;
        case OPERATORU_LOGIC_NOT: return '(!' + v;
        default:  throw new ExprErr("unexpected unary operator");
        }
    }
}



const OPERATOR_NULL = 0
const OPERATOR_BITWISE_OR = 1     /// |
const OPERATOR_BITWISE_XOR = 2    /// ^
const OPERATOR_BITWISE_AND = 3    /// &
const OPERATOR_BITWISE_SHL = 4    /// <<
const OPERATOR_BITWISE_SHR = 5    /// >>
const OPERATOR_ADDITION = 6       /// +
const OPERATOR_SUBTRACTION = 7    /// -
const OPERATOR_MULTIPLICATION = 8 /// *
const OPERATOR_DIVISION = 9       /// /
const OPERATOR_MODULO = 10         /// %
const OPERATOR_POWER = 11          /// **
const OPERATOR_EXPONENT = 12        /// e, E
const OPERATOR_LESS = 13 // <
const OPERATOR_LESS_EQ = 14 // <=
const OPERATOR_GREATER = 15 // >
const OPERATOR_GREATER_EQ = 16 // >=
const OPERATOR_EQ = 17 // ==
const OPERATOR_NEQ = 18 // ==
const OPERATOR_LOGIC_AND = 19 // &&
const OPERATOR_LOGIC_OR = 20 // ||
const OPERATOR_SUBSCRIPT = 21 // a.x
const OPERATOR_TRINARY = 22 // ?:

const OPERATORU_LOGIC_NOT = 100 // !
const OPERATORU_BITWISE_NOT = 101 // ~
const OPERATORU_NEG = 102 // -


class Operator
{
    constructor(opr, prec, assoc, str)
    { 
        this.op = opr; /// Operator, one of the OPERATOR_* enum definitions
        this.precedence = prec;
        /// 'L' = left or 'R' = right
        this.associativity = assoc;  // means in what order operators are ground with the same precedence (1+2+3 is (1+2)+3 or 1+(2+3)
        this.str = str
    }
}

// NOTICE: needs to be ordered by the numbers of the operators, only binary operators
// higher number = higher precedence
const ops = [
    new Operator(OPERATOR_NULL, 0, 'L', '<null>'),

    new Operator(OPERATOR_BITWISE_OR, 40, 'L', '|'),
    new Operator(OPERATOR_BITWISE_XOR, 50, 'L', '^'),
    new Operator(OPERATOR_BITWISE_AND, 60, 'L', '&'),
    new Operator(OPERATOR_BITWISE_SHL, 70, 'L', '<<'),
    new Operator(OPERATOR_BITWISE_SHR, 70, 'L', '>>'),

    new Operator(OPERATOR_ADDITION, 100, 'L', '+'),
    new Operator(OPERATOR_SUBTRACTION, 100, 'L', '-'),
    new Operator(OPERATOR_MULTIPLICATION, 200, 'L', '*'),
    new Operator(OPERATOR_DIVISION, 200, 'L', '/'),
    new Operator(OPERATOR_MODULO, 200, 'L', '%'),
    new Operator(OPERATOR_POWER, 300, 'R', 'TBD'),
    null, //new Operator(OPERATOR_EXPONENT, 400, 'R', 'e'),

    new Operator(OPERATOR_LESS, 30, 'L', '<'),
    new Operator(OPERATOR_LESS_EQ, 30, 'L', '<='),
    new Operator(OPERATOR_GREATER, 30, 'L', '>'),
    new Operator(OPERATOR_GREATER_EQ, 30, 'L', '>='),
    new Operator(OPERATOR_EQ, 30, 'L', '=='),
    new Operator(OPERATOR_NEQ, 30, 'L', '=='),

    new Operator(OPERATOR_LOGIC_AND, 20, 'L', '&&'),
    new Operator(OPERATOR_LOGIC_OR, 10, 'L', '||'),
    new Operator(OPERATOR_SUBSCRIPT, 500, 'L', '.'),

    new Operator(OPERATOR_TRINARY, 10, null, '?:')
]



function isEnd() {
    return index_ >= expr_.length;
}

/// Returns the character at the current expression index or
/// 0 if the end of the expression is reached.
function getCharacter() {
    if (!isEnd())
        return expr_[index_];
    return null;
}
function getCharacterAhead(offset) {
    if (index_ + offset < expr_.length)
        return expr_[index_ + offset];
    return null;
}

/// Parse str at the current expression index.
/// @throw error if parsing fails.
///
function expect(str) {
    if (expr_.substr(index_, str.length) !== str)
        throw new ExprErr("Syntax error: unexpected token, expected " + str)
    index_ += str.length;
}


/// Eat all white space characters at the
/// current expression index.
function eatSpaces() {
    while (true) {
        const c = getCharacter()
        if (c === '\n')
            g_lineNum++
        if (c !== ' ' && c !== '\n' && c !== '\r' && c !== '\t')
            break
        index_++
    }
}
function isSpace(c) {
    return (c === ' ' || c === '\n' || c === '\r' || c === '\t')
}

/// Parse a binary operator at the current expression index.
/// @return Operator with precedence and associativity.
///
function parseOp()
{
    eatSpaces();
    let ne
    switch (getCharacter()) {
        case '|':
            index_++;
            ne = getCharacter()
            if (ne == '|') {
                index_++;
                return ops[OPERATOR_LOGIC_OR];
            }            
            return ops[OPERATOR_BITWISE_OR];
        case '^':
            index_++;
            return ops[OPERATOR_BITWISE_XOR];
        case '&':
            index_++;
            ne = getCharacter()
            if (ne == '&') {
                index_++;
                return ops[OPERATOR_LOGIC_AND];
            }
            return ops[OPERATOR_BITWISE_AND];
        case '<':
            index_++;
            ne = getCharacter()
            if (ne == '<') {
                index_++;
                return ops[OPERATOR_BITWISE_SHL];
            }
            if (ne == '=') {
                index_++;
                return ops[OPERATOR_LESS_EQ];
            }
            return ops[OPERATOR_LESS];
        case '>':
            index_++;
            ne = getCharacter()
            if (ne == '>') {
                index_++;
                return ops[OPERATOR_BITWISE_SHR];
            }
            if (ne == '=') {
                index_++;
                return ops[OPERATOR_GREATER_EQ];
            }
            return ops[OPERATOR_GREATER];
        case '=':
            if (getCharacterAhead(1) != '=')
                return ops[OPERATOR_NULL];  // assignment handled at the top level
            index_ += 2;
            return ops[OPERATOR_EQ];
        case '!':
            expect('!=')
            return ops[OPERATOR_NEQ];            
        case '+':
            index_++;
            return ops[OPERATOR_ADDITION];
        case '-':
            index_++;
            return ops[OPERATOR_SUBTRACTION]
        case '/':
            index_++;
            return ops[OPERATOR_DIVISION];
        case '%':
            index_++;
            return ops[OPERATOR_MODULO];
        case '*':
            index_++;
            if (getCharacter() != '*')
                return ops[OPERATOR_MULTIPLICATION];
            index_++;
            return ops[OPERATOR_POWER];
     /*   case 'e':
            index_++;
            return ops[OPERATOR_EXPONENT];
        case 'E':
            index_++;
            return ops[OPERATOR_EXPONENT];*/
        case '.':
            index_++;
            return ops[OPERATOR_SUBSCRIPT]
        case '?':
            index_++;
            return ops[OPERATOR_TRINARY]
        default:
            return ops[OPERATOR_NULL];
    }
}

class FuncDef {
    constructor(jsfunc, num_args, type=FUNC_TYPE_BY_COMPONENT, ret_type=null) {
        this.f = jsfunc
        this.num_args = num_args // negative means atleast that many, list of two numbers means range
        this.dtype = type
        this.ret_type = ret_type // for FUNC_TYPE_LOOKUP - either a type or null to indicate it's the same as the input-arg type
    }
}


function md5(d){return ((binl_md5(rstr2binl(d),8*d.length)))}function rstr2hex(d){for(var _,m="0123456789ABCDEF",f="",r=0;r<d.length;r++)_=d.charCodeAt(r),f+=m.charAt(_>>>4&15)+m.charAt(15&_);return f}function rstr2binl(d){for(var _=Array(d.length>>2),m=0;m<_.length;m++)_[m]=0;for(m=0;m<8*d.length;m+=8)_[m>>5]|=(255&d.charCodeAt(m/8))<<m%32;return _}function binl2rstr(d){for(var _="",m=0;m<32*d.length;m+=8)_+=String.fromCharCode(d[m>>5]>>>m%32&255);return _}function binl_md5(d,_){d[_>>5]|=128<<_%32,d[14+(_+64>>>9<<4)]=_;for(var m=1732584193,f=-271733879,r=-1732584194,i=271733878,n=0;n<d.length;n+=16){var h=m,t=f,g=r,e=i;f=md5_ii(f=md5_ii(f=md5_ii(f=md5_ii(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_ff(f=md5_ff(f=md5_ff(f=md5_ff(f,r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+0],7,-680876936),f,r,d[n+1],12,-389564586),m,f,d[n+2],17,606105819),i,m,d[n+3],22,-1044525330),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+4],7,-176418897),f,r,d[n+5],12,1200080426),m,f,d[n+6],17,-1473231341),i,m,d[n+7],22,-45705983),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+8],7,1770035416),f,r,d[n+9],12,-1958414417),m,f,d[n+10],17,-42063),i,m,d[n+11],22,-1990404162),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+12],7,1804603682),f,r,d[n+13],12,-40341101),m,f,d[n+14],17,-1502002290),i,m,d[n+15],22,1236535329),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+1],5,-165796510),f,r,d[n+6],9,-1069501632),m,f,d[n+11],14,643717713),i,m,d[n+0],20,-373897302),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+5],5,-701558691),f,r,d[n+10],9,38016083),m,f,d[n+15],14,-660478335),i,m,d[n+4],20,-405537848),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+9],5,568446438),f,r,d[n+14],9,-1019803690),m,f,d[n+3],14,-187363961),i,m,d[n+8],20,1163531501),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+13],5,-1444681467),f,r,d[n+2],9,-51403784),m,f,d[n+7],14,1735328473),i,m,d[n+12],20,-1926607734),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+5],4,-378558),f,r,d[n+8],11,-2022574463),m,f,d[n+11],16,1839030562),i,m,d[n+14],23,-35309556),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+1],4,-1530992060),f,r,d[n+4],11,1272893353),m,f,d[n+7],16,-155497632),i,m,d[n+10],23,-1094730640),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+13],4,681279174),f,r,d[n+0],11,-358537222),m,f,d[n+3],16,-722521979),i,m,d[n+6],23,76029189),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+9],4,-640364487),f,r,d[n+12],11,-421815835),m,f,d[n+15],16,530742520),i,m,d[n+2],23,-995338651),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+0],6,-198630844),f,r,d[n+7],10,1126891415),m,f,d[n+14],15,-1416354905),i,m,d[n+5],21,-57434055),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+12],6,1700485571),f,r,d[n+3],10,-1894986606),m,f,d[n+10],15,-1051523),i,m,d[n+1],21,-2054922799),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+8],6,1873313359),f,r,d[n+15],10,-30611744),m,f,d[n+6],15,-1560198380),i,m,d[n+13],21,1309151649),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+4],6,-145523070),f,r,d[n+11],10,-1120210379),m,f,d[n+2],15,718787259),i,m,d[n+9],21,-343485551),m=safe_add(m,h),f=safe_add(f,t),r=safe_add(r,g),i=safe_add(i,e)}return Array(m,f,r,i)}function md5_cmn(d,_,m,f,r,i){return safe_add(bit_rol(safe_add(safe_add(_,d),safe_add(f,i)),r),m)}function md5_ff(d,_,m,f,r,i,n){return md5_cmn(_&m|~_&f,d,_,r,i,n)}function md5_gg(d,_,m,f,r,i,n){return md5_cmn(_&f|m&~f,d,_,r,i,n)}function md5_hh(d,_,m,f,r,i,n){return md5_cmn(_^m^f,d,_,r,i,n)}function md5_ii(d,_,m,f,r,i,n){return md5_cmn(m^(_|~f),d,_,r,i,n)}function safe_add(d,_){var m=(65535&d)+(65535&_);return(d>>16)+(_>>16)+(m>>16)<<16|65535&m}function bit_rol(d,_){return d<<_|d>>>32-_}

function myrand(seed) {
    let r = md5('x' + seed)[seed%4]
    r &= 2147483647
    r /= 2147483647
    return r;
}
function randvec2(seed) {
    var r = myrand(seed) * 2.0 * Math.PI;
    return vec2.fromValues(Math.cos(r), Math.sin(r))
}

function fit(v, oldmin, oldmax, newmin, newmax) {
    eassert((oldmin < oldmax) == (newmin < newmax), "mismatch order of arguments in fit()")
    if (v > oldmax)
        v = oldmax
    if (v < oldmin)
        v = oldmin
    let nv = (v - oldmin)/(oldmax-oldmin)*(newmax-newmin) + newmin
    return nv;
}
function glsl_clamp(v, minv, maxv) {  // normal clamp has different argument order
    if (v < minv) return minv;
    if (v > maxv) return maxv;
    return v;
}
function smoothstep(edge0, edge1, x) {
    // Scale, bias and saturate x to 0..1 range
    const r = glsl_clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); 
    // Evaluate polynomial
    return r * r * (3 - 2 * r);
}

function sqr(v) { return v*v }
function degrees(v) { return v*180/Math.PI }
function radians(v) { return v*Math.PI/180 }
function fit01(v, nmin, nmax) { return fit(v, 0, 1, nmin, nmax) }
function fit11(v, nmin, nmax) { return fit(v, -1, 1, nmin, nmax) }
//function ifelse(v, vt, vf) { return v?vt:vf }

function make_float(v) { return +v }
function make_vec2(x, y) { return vec2.fromValues(x, y) }
function make_mat3() {
    const a = arguments
    if (a.length == 0)
        return mat3.create() // identity
    eassert(a.length === 9, "Missing arguments, expected 9 values")
    return mat3.fromValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
}

const make_vec3 = {
[type_tuple(TYPE_NUM, TYPE_NUM, TYPE_NUM)]: function(x, y, z) { return vec3.fromValues(x, y, z) },
[type_tuple(TYPE_VEC2, TYPE_NUM)]: function(v2,z) { return vec3.fromValues(v2[0], v2[1], z) },
[TYPE_VEC3]: function(v) { return v },
[TYPE_VEC4]: function(v) { return vec3.fromValues(v[0], v[1], v[2]) }
}
const make_vec4 = {
[type_tuple(TYPE_NUM, TYPE_NUM, TYPE_NUM, TYPE_NUM)]: function(x, y, z, w) { return vec4.fromValues(x, y, z, w) },
[type_tuple(TYPE_VEC2, TYPE_NUM, TYPE_NUM)]: function(v2,z,w) { return vec4.fromValues(v2[0], v2[1], z, w) },
[type_tuple(TYPE_VEC3, TYPE_NUM)]: function(v3,z) { return vec4.fromValues(v3[0], v3[1], v3[2], w) },
[TYPE_VEC4]: function(v) { return v }
}

const distance_lookup = {
[type_tuple(TYPE_NUM, TYPE_NUM)]:  function(a,b) { return Math.abs(a-b) },
[type_tuple(TYPE_VEC2, TYPE_VEC2)]: function(a,b) { return vec2.distance(a,b) },
[type_tuple(TYPE_VEC3, TYPE_VEC3)]: function(a,b) { return vec3.distance(a,b) },
[type_tuple(TYPE_VEC4, TYPE_VEC4)]: function(a,b) { return vec4.distance(a,b) },
}
const length_lookup = {
[TYPE_NUM]:  function(a) { return Math.abs(a) },
[TYPE_VEC2]: function(a) { return vec2.length(a) },
[TYPE_VEC3]: function(a) { return vec3.length(a) },
[TYPE_VEC4]: function(a) { return vec4.length(a) },
}
const normalize_lookup = {
[TYPE_NUM]:  function(v) { return 1 },
[TYPE_VEC2]: function(v) { let x = vec2.create(); vec2.normalize(x,v); return x },
[TYPE_VEC3]: function(v) { let x = vec3.create(); vec3.normalize(x,v); return x },
[TYPE_VEC4]: function(v) { let x = vec3.create(); vec3.normalize(x,v); return x },
}

// range 360,100,100
function hsl(h, s, v) {
    const obj = {}
    ColorPicker.HSLtoRGB(h, s, v, obj)
    return [obj.r, obj.g, obj.b]
}
// range 360,100,100, 1.0
function hsla(h, s, v, a) {
    const obj = {}
    ColorPicker.HSLtoRGB(h, s, v, obj)
    return [obj.r, obj.g, obj.b, a]
}

function plasma(coord, time=null, move=null) {
    x = coord[0]*10  
    y = coord[1]*10 
    if (time === null)
        t = 20000
    if (move === null)
        move = vec2.create(0,0)

    da = vec2.distance(vec2.fromValues(x+Math.cos(time/1110.0)*4.0,y), vec2.fromValues(1.0,2.1))
    db = vec2.distance(vec2.fromValues(x,y), vec2.fromValues(8.0 + 16.0*move[0], 6.1 + 8.0*(1.0 - move[1]) ))
    dc = vec2.distance(vec2.fromValues(x,y + Math.cos(time / 998.0)*2.0), vec2.fromValues(10.0, 3.1))
    c1 = Math.sin(da) + Math.sin(x) * Math.sin(time/1000.0)
    c2 = Math.sin(db - time / 500.0)*1.0
    c3 = Math.cos(dc / 2.0) + Math.sin(time/1000.0)
    c = (c1 + c2 + c3) / 3.0
    
    return c*0.5+0.5  // return range [0,1]
}

function smoothmin(k, d1, d2) {
    eassert(false, "not-implemented")
}

// input and outputs are in range [0,1]
// https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately/54024653#54024653
function rgb2hsv(va) {
    let r=va[0], g=va[1], b=va[2]
    let v=Math.max(r,g,b), c=v-Math.min(r,g,b);
    let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); 
    return [60*(h<0?h+6:h)/360, v&&c/v, v];
}
function hsv2rgb(va) {
    let h = va[0]*360, s = va[1], v = va[2]
    let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);     
    return [f(5),f(3),f(1)];   
}

function mat3_translate(that, x, y) { mat3.translate(that, that, vec2.fromValues(x, y)) }
function mat3_rotate(that, v) { mat3.rotate(that, that, glm.toRadian(v)) }
function mat3_scale(that, x, y) { mat3.scale(that, that, vec2.fromValues(x, y)) }
function mat3_get_pos(that) { return vec2.fromValues(that[6], that[7]) }



const func_defs = {
    'cos': new FuncDef(Math.cos, 1), 'sin': new FuncDef(Math.sin, 1), 'tan': new FuncDef(Math.tan, 1),
    'acos': new FuncDef(Math.acos, 1), 'asin': new FuncDef(Math.acos, 1), 'atan': new FuncDef(Math.atan, 1), 'atan2': new FuncDef(Math.atan2, 2),
    'sqrt': new FuncDef(Math.sqrt, 1), 'sqr': new FuncDef(sqr, 1), 'pow': new FuncDef(Math.pow, 2),
    'distance': new FuncDef(distance_lookup, 2, FUNC_TYPE_LOOKUP, TYPE_NUM), 'length': new FuncDef(length_lookup, 1, FUNC_TYPE_LOOKUP, TYPE_NUM),
    'log': new FuncDef(Math.log, 1), 'log10': new FuncDef(Math.log10, 1), 'log2': new FuncDef(Math.log2, 1),
    'round': new FuncDef(Math.round, 1), 'ceil': new FuncDef(Math.ceil, 1), 'floor': new FuncDef(Math.floor, 1), 'trunc': new FuncDef(Math.trunc, 1),
    'abs': new FuncDef(Math.abs, 1), 'sign': new FuncDef(Math.sign, 1),
    'min': new FuncDef(Math.min, -2), 'max': new FuncDef(Math.max, -2), 'clamp': new FuncDef(glsl_clamp, 3), // negative means atleast
    'smoothstep' : new FuncDef(smoothstep, 3),
    'rand': new FuncDef(myrand, 1),
    'randvec2': new FuncDef(randvec2, 1, [TYPE_NUM], TYPE_VEC2),
    'fit': new FuncDef(fit, 5), 'fit01': new FuncDef(fit01, 3), 'fit11': new FuncDef(fit11, 3),
    'degrees': new FuncDef(degrees, 1), 'radians': new FuncDef(radians, 1),
 //   'ifelse': new FuncDef(ifelse, 3),
    'float':new FuncDef(make_float, 1, [TYPE_BOOL], TYPE_NUM),
    'vec2': new FuncDef(make_vec2, 2, [TYPE_NUM, TYPE_NUM], TYPE_VEC2), 'vec3': new FuncDef(make_vec3, [1,3], FUNC_TYPE_LOOKUP, TYPE_VEC3), 'vec4': new FuncDef(make_vec4, [1,4], FUNC_TYPE_LOOKUP, TYPE_VEC4),
    'mat3': new FuncDef(make_mat3, [0,9], Array(9).fill(TYPE_NUM), TYPE_MAT3),
    'normalize': new FuncDef(normalize_lookup, 1, FUNC_TYPE_LOOKUP, null),
    'hsl' : new FuncDef(hsl, 3, [TYPE_NUM, TYPE_NUM, TYPE_NUM], TYPE_VEC3), 
    'hsla' : new FuncDef(hsla, 4, [TYPE_NUM, TYPE_NUM, TYPE_NUM, TYPE_NUM],TYPE_VEC4),
    'rgb2hsv' : new FuncDef(rgb2hsv, 1, [TYPE_VEC3], TYPE_VEC3), 'hsv2rgb' : new FuncDef(hsv2rgb, 1, [TYPE_VEC3], TYPE_VEC3),
    'plasma' : new FuncDef(plasma, [1,3], [TYPE_VEC2, TYPE_NUM, TYPE_VEC2] , TYPE_NUM),
    'smoothmin' : new FuncDef(smoothmin, -3, [TYPE_NUM, TYPE_NUM, TYPE_NUM], TYPE_NUM),

    'translate' : new FuncDef(mat3_translate, 3, [TYPE_MAT3, TYPE_NUM, TYPE_NUM], TYPE_VOID), 
    "rotate": new FuncDef(mat3_rotate, 2, [TYPE_MAT3, TYPE_NUM], TYPE_VOID),
    "scale": new FuncDef(mat3_scale, 3, [TYPE_MAT3, TYPE_NUM, TYPE_NUM], TYPE_VOID),
    "get_pos": new FuncDef(mat3_get_pos, 1, [TYPE_MAT3], TYPE_VEC2)
}
// aliases
func_defs['rgb'] = func_defs['vec3']
func_defs['rgba'] = func_defs['vec4']





// a place holder for an internal func that is returned from lookup and replaced by a FuncCallNode
class FuncDefNode extends NodeBase {
    constructor(def, that=null) {
        super()
        this.def = def
        this.that = that
    }
    eval() { eassert(false, "function can't be used as a value", this.line ) }
    num_args() { return this.def.num_args }
    check_type() {
        return TYPE_FUNCTION
    }
}

class AddGlslFunc {
    constructor(s) { this.func_str = s }
}

const glsl_translate = {
    'rgb': "vec3", "rgba": "vec4",
    'atan2': 'atan',
    'sqr': new AddGlslFunc("$T sqr($T v) { return v*v; }"),
    'log10': new AddGlslFunc("$T log10($T v) { return log(v)/log(10) }"),
    'rand': null, 'fit': null, 'fit01': null, 'fit11': null, 
//    'ifelse': new AddGlslFunc("$T ifelse(bool c, $T a, $T b) { return c?a:b; }"),
    'plasma': new AddGlslFunc(`
float plasma(vec2 coord, float time, vec2 move) {    
    float x = coord.x * 10.0;
    float y = coord.y * 10.0;
    float da = distance(vec2(x+cos(time / 1110.0) * 4.0, y), vec2(1.0,2.1));
    float db = distance(vec2(x,y), vec2(8.0 + 16.0 * move.x, 6.1 + 8.0*(1.0 - move.y) ));
    float dc = distance(vec2(x,y + cos(time / 998.0)*2.0), vec2(10.0, 3.1));
    float c1 = sin(da) + sin(x) * sin(time / 1000.0);
    float c2 = sin(db - time / 500.0)*1.0;
    float c3 = cos(dc / 2.0) + sin(time / 1000.0);
    float c = (c1 + c2 + c3) / 3.0;
    return c * 0.5 + 0.5;
}
float plasma(vec2 coord, float time) { return plasma(coord, time, vec2(0.0, 0.0)); }
float plasma(vec2 coord) { return plasma(coord, 20000.0, vec2(0.0, 0.0)); }
    `),
    'smoothmin': new AddGlslFunc(`
float smoothmin(float k, float d1, float d2) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}
    `),
    'rgb2hsv': new AddGlslFunc(`
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
    `),
    'hsv2rgb': new AddGlslFunc(`
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}  
    `)
    
}

// given a function f that takes num and a list of vecs, apply f individually on the components of f
function apply_by_component(argvals, f) {
    let num_comp = argvals[0].length // 3 or 4
    let ret = new argvals[0].constructor(num_comp)
    let c_argvals = new Array(num_comp)
    for(let ci = 0; ci < num_comp; ++ci) {
        for(let ai = 0; ai < argvals.length; ++ai)
            c_argvals[ai] = argvals[ai][ci]
        const r = f.apply(null, c_argvals)
        ret[ci] = r
    } 
    return ret
}

function args_check_type_tuple(args) {
    const atypes = []
    for(let arg of args)
        atypes.push(arg.check_type())
    return type_tuple_l(atypes)    
}

function args_check_type_lst(args) {
    const atypes = []
    for(let arg of args)
        atypes.push(arg.check_type())
    return atypes    
}

class InternalFuncCallNode extends NodeBase {
    constructor(def, funcname, args) {
        super()
        this.def = def
        this.f = def.f
        this.args = args // input nodes
        this.type = null
        this.funcname = funcname
        this.lookedup_f = null
    }
    eval() {
        let argvals = []
        for(let arg of this.args)
            argvals.push(arg.eval())
        if (this.def.dtype == FUNC_TYPE_LOOKUP)
            return this.lookedup_f.apply(null, argvals)       
        if (this.def.dtype != FUNC_TYPE_BY_COMPONENT || this.type == TYPE_NUM || this.type == TYPE_BOOL)
            return this.f.apply(null, argvals) 
        return apply_by_component(argvals, this.f)
    }
    clear_types_cache() {
        this.type = null
        for(let arg of this.args)
            arg.clear_types_cache()
    }
    check_type() {
        if (this.type !== null) {
            return this.type
        }
        let def_t = this.def.dtype
        let ret_t = null
        if (def_t == FUNC_TYPE_BY_COMPONENT) { // all arguments need to be the same type
            const args_type = this.args[0].check_type()
            for(let arg of this.args) {
                const t = arg.check_type()
                if (t !== args_type)
                    throw new TypeErr("function needs all arguments of the same type, got " + typename(t))
            }
            ret_t = args_type
        }
        else if (def_t == FUNC_TYPE_LOOKUP) {          
            const args_type = args_check_type_tuple(this.args)
            this.lookedup_f = this.f[args_type]
            eassert(this.lookedup_f !== undefined, "Can't find function overload for argument types") // TBD better error
            // return type
            if (this.def.ret_type === null) {
                if (atypes.length === 1)
                    ret_t = atypes[0]
                else
                    throw new TypeErr("Can't deduce return type of func " + this.funcname)
            }
            else
                ret_t = this.def.ret_type
        }
        else { // args value has a specific given type
            eassert(Array.isArray(def_t))
            const args_type = args_check_type_lst(this.args)

            if (Number.isInteger(this.def.num_args)) // otherwise it's a range
            {
                if (this.def.num_args > 0) // sanity, might have been checked before
                    eassert(args_type.length === def_t.length, "Unexpected number of arguments " + args_type.length + " != " + def_t.length)
                else {
                    eassert(args_type.length >= def_t.length, "Unexpected number of arguments " + args_type.length + " != " + def_t.length)
                    // check the last ones, if the exist, type needs to be as the last type of the in the definition
                    for(let i = def_t.length; i < args_type.length; ++i)
                        if (args_type[i] !== def_t[def_t.length - 1])
                            throw new TypeErr("Unexpected argument types expected arg: " + (i+1) + ": " + type_tuple_str(def_t[def_t.length - 1]) + " got " + type_tuple_str(args_type[i]))    
                }
            }
            for(let i = 0; i < args_type.length; ++i) // check only upto how many are given
                if (args_type[i] !== def_t[i])  
                    throw new TypeErr("Unexpected argument types expected arg: " + (i+1) + ": " + type_tuple_str(def_t[i]) + " got " + type_tuple_str(args_type[i]))

            ret_t = this.def.ret_type
        }
        this.type = ret_t
        return this.type        
    }
    to_glsl(emit_ctx) {
        let slst = []
        const tr = glsl_translate[this.funcname] 
        let name = this.funcname
        if (tr !== undefined) {
            if (tr === null) // marks is as unsupported
                throw new ExprErr("Function not supported in GLSL: " + this.funcname)
            if (typeof tr === 'string')
                name = tr
            else if (tr.constructor === AddGlslFunc) {
                const gtype = TYPE_TO_STR[this.type]
                let text = tr.func_str.replace(/\$T/g, gtype) // assume there's only on type, that's the same as the func return type
                const key = name + "|" + gtype
                g_glsl_added_funcs.add(key, {name:name, text:text})
            }
        }
        for(let arg of this.args)
            slst.push(arg.to_glsl(emit_ctx))
        
        if (this.def.num_args <= -2 && slst.length > 2) {
            // case of "at least two arguments but maybe more" - Math.min like functions - call pairwise
            // if there are more than 2 args, assume the first are constant to all calls (like smoothmin)
            let constant_args = ""
            const c_offset = -(2 + this.def.num_args)
            for(let i = 0; i < c_offset; ++i)
                constant_args += slst[i] + ", "

            let ret = "", len = slst.length
            for(let i = c_offset; i < len - 2; ++i) 
                ret += name + "(" + constant_args + slst[i] + ", "
            ret += name + "(" + constant_args + slst[len-2] + ", " + slst[len-1]
            ret += ')'.repeat(len-1-c_offset)
            return ret
        }

        // number of arguments was check during parse
        return name + '(' + slst.join(',') + ')'
        
    }
}


class FuncObjCallNode extends NodeBase 
{
    constructor(func_node, func_name, args) {
        super()
        this.func_node = func_node
        this.arg_nodes = args
        this.func_name = func_name
    }
    eval() { 
        let argvals = []
        for(let arg of this.arg_nodes)
            argvals.push(arg.eval())
            
        eassert(this.func_node.eval_func !== undefined, "func node without eval_func")
        return this.func_node.eval_func(argvals)
    }
    check_type() { 
        if (this.type !== null) 
            return this.type
        if (this.func_node.check_type() !== TYPE_FUNCTION)
            throw new TypeErr("Identifier " + this.func_name + " is not a function")
        let arg_types = []    
        for(let arg of this.arg_nodes)
            arg_types.push(arg.check_type())
        this.type = this.func_node.func_ret_type(type_tuple_l(arg_types))
        return this.type
    }
    clear_types_cache() { 
        for(let arg of this.arg_nodes)
            arg.clear_types_cache()
        this.func_node.clear_types_cache()
    }  
    to_glsl(emit_ctx) { 
        let args = []
        for(let arg of this.arg_nodes)
            args.push(arg.to_glsl(emit_ctx))

        let name
        if (this.func_node.to_glsl_mutate_args !== undefined) // hack for allowing the function node to modify the arguments (image distance field needs it)
            name = this.func_node.to_glsl_mutate_args(emit_ctx, args)
        else
            name = this.func_node.to_glsl(emit_ctx)

        return name + "(" + args.join(",") + ")"
    }
}

// func_node is either FuncDefNode or GlslTextEvaluator
function parseFuncCall(func_node, func_name) {
    //if (!func_node.is_function())
    //    throw new ExprErr("Identifier " + func_name + " is not a function" )  
    const args = []
    if (func_node.that !== null && func_node.that !== undefined)
        args.push(func_node.that)
    index_++; // skip open paren
    eatSpaces();
    let first = true
    if (getCharacter() !== ')') { // there are any args
        // negative num_args means at least that many
        do {
            if (!first)
                index_++; // skips the comma
            let arg = parseExpr()
            args.push(arg)
            eatSpaces()
            first = false
        } while (getCharacter() == ',')
    }
    if (getCharacter() != ')')
        throw new ExprErr("Expected closing paren for argument list at " + index_)
    ++index_; // skip paren

    if (func_node.constructor === FuncDefNode) { // dummy is discarded
        // internal func can have the argument number check during parsing
        const expect_num_arg = func_node.num_args()
        if (Array.isArray(expect_num_arg)) { // range was given
            if (args.length < expect_num_arg[0] || args.length > expect_num_arg[1])
                throw new ExprErr("Wrong number of arguments to function " + func_name + " expected in range [" + expect_num_arg[0] + ", " + expect_num_arg[1] + "] got " + args.length)
        }
        if (expect_num_arg === 0)
            throw new ExprErr("internal func can't have 0 arguments")
        if (expect_num_arg > 0) {
            if (args.length != expect_num_arg)
                throw new ExprErr("Wrong number of argument to function " + func_name + " expected " + expect_num_arg + " got " + args.length)
        }
        else {
            if (args.length < -expect_num_arg)
                throw new ExprErr("Not enough arguments to function " + func_name + " expected at least " + expect_num_arg + " got " + args.length)
        }
        return new InternalFuncCallNode(func_node.def, func_name, args)
    }
    else {
        return new FuncObjCallNode(func_node, func_name, args)
    }
}

// dummy since this is just a place-holder, doesn't appear in the final AST
class DummyReservedWord extends NodeBase {
    constructor(_v) {
        super()
        this.v = _v;
    }
}



const constants = {"PI": new NumNode(Math.PI, true), 
                   "true": new BoolNode(true), "false":new BoolNode(false),
                   "if": new DummyReservedWord("if"), "return": new DummyReservedWord("return")
                }

function parseIdentifier() {
    let sb = ''
    while(true) {
        let c = getCharacter();
        if (c === null)
            break;
        // identifier can have digits but not start with a digit (checked by the caller)
        if ( (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == '.' || (c >= '0' && c <= '9') )
            sb = sb + c;
        else
            break;
        index_++;
    }
    if (sb[0] == '.' || sb[sb.length-1] == '.')
        throw new ExprErr("Unexpected dot in an identifier at " + index_)

    return [sb, lookupIdentifier(sb)]
}

function split_possibilites(sps, obj)
{
    if (sps.length === 1) 
        return obj
    if (sps.length === 2) { // t.translate(x, y)
        const def = func_defs[sps[1]]
        if (def !== undefined)
            return new FuncDefNode(def, obj)
    }
    return new SubscriptNode(obj, sps.slice(1))  // v.x
}

function lookupIdentifier(sb)
{
    if (constants[sb] !== undefined)
        return constants[sb]
    if (func_defs[sb] !== undefined)
        return new FuncDefNode(func_defs[sb])

    const sps = sb.split('.')
    const varname = sps[0]

    // is it a symbol?
    if (g_symbol_table !== null) {
        const sn = g_symbol_table[varname] // symbol node
        if (sn !== undefined) {
            return split_possibilites(sps, sn)
        }    
    }

    // try evaluators?
    let e = g_state_access.get_evaluator(sb, g_lineNum)
    if (e !== null) {
        if (!e.consumes_subscript()) {
            return split_possibilites(sps, e)
        }
        return e;
    }

    // default is to assume it's a variable
    g_state_access.score |= EXPR_NEED_VAR
    // create only 1 evaluator for any variable in an expression
    let ve = g_state_access.need_variables[varname]
    if (ve === undefined) {
        ve = new VariableEvaluator(varname, g_lineNum) // a VarBox will be set to it in resolve_variables
        g_state_access.need_variables[varname] = ve
    }

    return split_possibilites(sps, ve)

}

function toInteger(c) {
    if (c === null)
        return 0xf + 1
    if (c >= '0' && c <= '9') return c.charCodeAt(0) - 48; // '0'
    if (c >= 'a' && c <= 'f') return c.charCodeAt(0) - 97 + 0xa;  // 'a'
    if (c >= 'A' && c <= 'F') return c.charCodeAt(0) - 65 + 0xa;  // 'A'
    return  0xf + 1;
}

function getInteger() {
    return toInteger(getCharacter());
}

function parseDecimal() {
    let value = 0;
    for (let d; (d = getInteger()) <= 9; index_++)
        value = value * 10 + d;
    if (getCharacter() == '.') {
        index_++;
        let f = 0.1
        for (let d; (d = getInteger()) <= 9; index_++) {
            value = value + d * f;
            f *= 0.1
        }
    }
    let c = getCharacter()
    if (c == 'e' || c == 'E') {
        const lookahead = (expr_[index_+1] == '-')?1:0
        c = expr_[index_+lookahead+1]
        if (c >= '0' && c <= '9') {
            index_ += 1+lookahead
            let exp = 0
            for (let d; (d = getInteger()) <= 9; index_++)
                exp = exp * 10 + d;
            if (lookahead)
                exp = -exp
            value = value * Math.pow(10, exp)
            console.log(value)
        }
    }
    return new NumNode(value, true);
}

function parseHex() {
    index_ = index_ + 2;
    let value = 0;
    for (let h; (h = getInteger()) <= 0xf; index_++)
        value = value * 0x10 + h;
    return new NumNode(value, false);
}
function parseBin() {
    index_ = index_ + 2;
    let value = 0;
    for (let h; (h = getInteger()) <= 1; index_++)
        value = value * 2 + h;
    return new NumNode(value, false);
}
function parseOct() {
    index_ = index_ + 2;
    let value = 0;
    for (let h; (h = getInteger()) <= 7; index_++)
        value = value * 8 + h;
    return new NumNode(value, false);
}

function getBase()
{
    if (index_ + 2 < expr_.length) {
        let x = expr_[index_ + 1].toLowerCase();
        let h = expr_[index_ + 2];
        if (x == 'x' && toInteger(h) <= 0xf)
            return 16;
        if (x == 'b' && toInteger(h) <= 1)
            return 2;
        if (x == 'o' && toInteger(h) <= 8)
            return 8;
    }
    return 10;
}

/// Parse an integer value at the current expression index.
/// The unary `+', `-' and `~' operators and opening
/// parentheses `(' cause recursion.
///
function parseValue() {
    let val = null;
    eatSpaces();
    let c = getCharacter();
    switch (c) {
        case '0': {
            let base = getBase();
            if (base == 16)
                val = parseHex();
            else if (base == 2)
                val = parseBin();
            else if (base == 8)
                val = parseOct();
            else
                val = parseDecimal();
            break;
        }
        case '1':  case '2':   case '3':
        case '4':  case '5':   case '6':
        case '7':  case '8':   case '9':   case '.':
            val = parseDecimal();
            break;
        case '(':
            index_++;
            val = parseExpr();
            eatSpaces();
            if (getCharacter() != ')') {
                throw new ExprErr("Syntax error: `)' expected at end of expression");
            }
            index_++;
            break;

        case '+':
            index_++;
            val = parseValue();
            break;
        case '-':
            index_++;
            val = new UnaryOpNode(parseValue(), OPERATORU_NEG);
            break;
        case '~':
            index_++;
            val = new UnaryOpNode(parseValue(), OPERATORU_BITWISE_NOT);
            break;
        case '!':
            index_++;
            val = new UnaryOpNode(parseValue(), OPERATORU_LOGIC_NOT);
            break;
                    
        default:
            if ( (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_') {
                const [name, val_] = parseIdentifier();
                val = val_

                eatSpaces()
                if (val.constructor !== DummyReservedWord) {   // reserved words are never functions
                    if (getCharacter() == '(')  {// function call - TBD shouldn't really be here. should be outside
                        val = parseFuncCall(val, name) 
                    }
                }

                break;
            }
            throw new ExprErr("Syntax error: value expected at end of expression");
    }
    return val;
}

// just holds a parsed token in the middle of parsing.
// used for holding the subscript when parsing OPERATOR_SUBSCRIPT
class TokenDummyNode extends NodeBase {
    constructor(token) {
        super()
        this.token = token
    }
}

/// The current operator and its left value
/// are pushed onto the stack if the operator on
/// top of the stack has lower precedence.
var stack_ = [];

/// Parse all operations of the current parenthesis
/// level and the levels above, when done
/// return the result (value).
///
function parseExpr() {
    stack_.push({ op:ops[OPERATOR_NULL] });
    // first parse value on the left
    let value = parseValue();
    let tri_mid_expr = null

    while (stack_.length != 0) {
        // parse an operator (+, -, *, ...)
        let op = parseOp();
        while (op.precedence < stack_[stack_.length-1].op.precedence || 
               (op.precedence == stack_[stack_.length-1].op.precedence && op.associativity == 'L'))
        {
            let peek = stack_[stack_.length-1]
            // end reached
            if (peek.op.op == OPERATOR_NULL) {
                stack_.pop();
                return value;
            }
            // do the calculation ("reduce"), producing a new value
            if (peek.op.op === OPERATOR_SUBSCRIPT)
                value = new SubscriptNode(peek.value, null, value) // handle things like rgb(1,2,3).r
            else if (peek.op.op == OPERATOR_TRINARY) {
                eassert(tri_mid_expr !== null, "Missing mid value in trinary operator")
                value = new TrinaryOpNode(peek.value, tri_mid_expr, value)
                tri_mid_expr = null
            }
            else
                value = new BinaryOpNode(peek.value, value, peek.op.op);
            stack_.pop();
        }

        // store on stack_ and continue parsing ("shift")
        stack_.push( {op:op, value:value });
        // parse value on the right
        if (op.op === OPERATOR_SUBSCRIPT)
            value = new TokenDummyNode(parseNewIdentifier())  // assume only one subscript in the chain
        else if (op.op == OPERATOR_TRINARY) {
            tri_mid_expr = parseExpr() // middle value between the ? and :
            let c = getCharacter()
            eassert(c === ':', "Trinary operator expects ':'")
            index_++
            value = parseValue(); // not parseExpr since we only want to collect something if its in parens, and not a binary operator that might be there like in (1 == 1)?0.1:0.2+0.1
        }
        else {
            value = parseValue();  // next part in the chain
        }
    }
    return null;
}


function parseNewIdentifier() {
    let sb = ''
    let c = getCharacter();
    if (c == '#')
        return null // comment
    if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
        throw new ExprErr("unexpected char at start of statement " + c)
    while(true) {
        let c = getCharacter();
        if (c === null)
            break;
        // identifier can have digits but not start with a digit
        if ( (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == '.' || (c >= '0' && c <= '9') )
            sb = sb + c;
        else
            break;
        index_++;
    }
    return sb
}

// added to the symbol table when parsing
// assignment sets a value into it, expression reference it from parseIdentifier
class SymbolNode extends NodeBase {
    constructor(name) {
        super()
        this.name = name
        this.valueNode = null  // NumNode or VecNode
        this.type = null  // set by assignment
    }
    eval() {
        if (this.valueNode === null)
            throw new ExprErr("Symbol " + this.name + " not assigned to yet")
        return this.valueNode.eval()
    }
    check_type() {
        if (this.type === null)
            throw new ExprErr("Symbol " + this.name + " not assigned to yet (type)")
        return this.type
    }
    to_glsl(emit_ctx) {
        return this.name
    }
}


class SubscriptNode extends NodeBase 
{
    constructor(wrapNode, subscripts, token_dummy=null) {
        super()
        this.wrapNode = wrapNode
        if (subscripts !== null) {
            if (subscripts.length !== 1)
                throw new ExprErr("Only one subscript is supported")
            this.subname = subscripts[0]
        }
        else if (token_dummy !== null && token_dummy.constructor === TokenDummyNode) {
            this.subname = token_dummy.token
        }
        else 
            eassert(false, "unexpected SubscriptNode without source")
        this.subidx = SUBSCRIPT_TO_IDX[this.subname]
        if (this.subidx === undefined)
            throw new ExprErr("unknown subscript: " + this.subname)
    }
    eval() {
        let v = this.wrapNode.eval()
        let sv = v[this.subidx]
        if (sv === undefined)
            throw new ExprErr("object doesn't have this subscript " + this.subname)
        return sv
    }
    check_type() {
        const wrapped = this.wrapNode.check_type()
        if (wrapped !== TYPE_VEC2 && wrapped !== TYPE_VEC3 && wrapped !== TYPE_VEC4)
            throw new TypeErr("Can't take subscript of something that's not a vector: " + typename(wrapped))
        this.type = TYPE_NUM
        return TYPE_NUM
    }
    to_glsl(emit_ctx) {
        return this.wrapNode.to_glsl(emit_ctx) + "." + SUBIDX_TO_GLSL[this.subidx]
    }
}

function parseAssignStmt(name) {
    eassert(name.length > 0, "empty var in assignment")
    let assign_type = OPERATOR_NULL
    let c = getCharacter();
    switch(c) {
    case '+': assign_type = OPERATOR_ADDITION; break;
    case '-': assign_type = OPERATOR_SUBTRACTION; break;
    case '*': assign_type = OPERATOR_MULTIPLICATION; break;
    case '/': assign_type = OPERATOR_DIVISION; break;
    }
    if (assign_type !== OPERATOR_NULL) {
        index_++;
        c = getCharacter();
    }
    if (c !== '=')
        throw new ExprErr("expected assignment")
    index_++;
    eatSpaces()
    const expr = parseExpr()
    if (assign_type === OPERATOR_NULL) {
        return new AssignNameStmt(name, expr)
    }
    return new AssignNameStmt(name, new BinaryOpNode(lookupIdentifier(name), expr, assign_type))
}



function parseIfStmt() {
    eatSpaces()
    let c = getCharacter();
    if (c !== '(')
        throw new ExprErr("if expects open trace '('")
    index_++;
    const cond = parseExpr()
    eatSpaces()
    c = getCharacter();
    if (c !== ')')
        throw new ExprErr("if condition expects close trace ')'")
    index_++;
    eatSpaces()
    let true_code = parseCodeBlock()
    if (true_code.count() == 0)
        true_code = null
    eatSpaces()
    let else_code = null
    if (expr_.substr(index_, 4) == 'else') {
        index_ += 4
        else_code = parseCodeBlock()
        if (else_code.count() == 0)
            else_code = null
    }
    return new IfStatement(cond, true_code, else_code)
}


class Statement {
    constructor() {
        this.type = null
        this.line = g_lineNum
    }
    sclear_types_cache() {
        this.type = null
    }
    invoke() {  // returns non-null when the code did "return"
        return null
    }
}

class IfStatement extends Statement
{
    constructor(cond, true_code, else_code) {
        super()
        this.cond_expr = cond
        this.true_code = true_code // either can be null
        this.else_code = else_code 
    }
    invoke() {
        const cv = this.cond_expr.eval()
        let v = null
        if (cv === true) {
            if (this.true_code !== null)
                v = this.true_code.eval()
        }
        else if(cv === false) {
            if (this.else_code !== null)
                v = this.else_code.eval()
        }
        else 
            throw new ExprErr("Unexpected value from if condition " + v)
        return v
    }
    sclear_types_cache() {
        super.sclear_types_cache()
        this.cond_expr.clear_types_cache()
        if (this.true_code !== null)
            this.true_code.clear_types_cache()
        if (this.else_code !== null)
            this.else_code.clear_types_cache()            
    }
    scheck_type() {
        const cond_type = this.cond_expr.check_type()
        eassert(cond_type === TYPE_BOOL, "If statement with non-bool condition")
        let t1 = null, t2 = null
        if (this.true_code !== null)
            t1 = this.true_code.check_type()
        if (this.else_code !== null)
            t2 = this.else_code.check_type()
        if (t1 !== null && t2 != null) {
            eassert(t1 === t2, "return different types: " + typename(t1) + " != " + typename(t2))
            this.type = t1
            return t1
        }
        this.type = null // also means we didn't check, that's why there's no caching of the type here
        return null      
    }
    sto_glsl(emit_ctx) {
        let s = "if (" + this.cond_expr.to_glsl(emit_ctx) + ") {\n"
        if (this.true_code !== null)
            s += this.true_code.to_glsl(emit_ctx)
        if (this.else_code !== null) {
            s += "} else {\n"
            s += this.else_code.to_glsl(emit_ctx)
        }
        s += "}\n"
        return s
    }

}

class TrinaryOpNode extends NodeBase {
    constructor(cond, true_node, false_node) {
        super()
        this.cond = cond
        this.true_node = true_node
        this.false_node = false_node
    }
    clear_types_cache() {
        this.type = null
        this.cond.clear_types_cache()
        this.true_node.clear_types_cache()
        this.false_node.clear_types_cache()
    }
    check_type() {
        if (this.type === null) {
            const cond_type = this.cond.check_type()
            eassert(cond_type === TYPE_BOOL, "Trinary expression with non-bool condition")            
            let t1 = this.true_node.check_type(), t2 = this.false_node.check_type()
            eassert(t1 === t2, "Trinary expression mismatch types " + typename(t1) + ", " + typename(t2))
            this.type = t1
        }
        return this.type
    }

    eval() {
        console.assert(this.type !== null)
        const cv = this.cond.eval()
        if (cv === true)
            return this.true_node.eval()
        else if (cv === false)
            return this.false_node.eval()
        else
            throw new ExprErr("Unexpected value from trinary condition " + cv)
    }

    to_glsl(emit_ctx) {
        return '((' + this.cond.to_glsl(emit_ctx) + ')?(' + this.true_node.to_glsl(emit_ctx) + '):(' + this.false_node.to_glsl(emit_ctx) + '))';
    }

}

class ExpressionStatement extends Statement
{
    constructor(e) {
        super()
        this.e = e
    }
    invoke() {
        this.e.eval()
        return null // not doing return
    }
    sclear_types_cache() {
        super.sclear_types_cache()
        this.e.clear_types_cache()         
    }
    scheck_type() {
        this.e.check_type()
        return null  // not doing return
    }
    sto_glsl(emit_ctx) {
        return this.e.to_glsl(emit_ctx)
    }

}


const STMT_COMMENT = 1
const STMT_END_BLOCK = 2

function parseStmt() {
    eatSpaces()
    if (index_ > 0 && !isSpace(expr_[index_-1]))
        throw new ExprErr("Statments must be separated by whitespace")
    // statement starts with a variable name to assign to or 'return'
    let c = getCharacter();
    if (c === '}')
        return STMT_END_BLOCK
    if (c == '#')
        return STMT_COMMENT 

    //const name = parseNewIdentifier()
    const firstExpr = parseExpr()
    //if (name === null) // comment statement
    //    return STMT_COMMENT 
    eatSpaces()
    if (firstExpr.constructor == DummyReservedWord) {
        if (firstExpr.v === 'if') {
            return parseIfStmt()
        }
        if (firstExpr.v === 'return') {
            const expr = parseExpr()
            return new ReturnStmt(expr)
        }
        throw new ExprErr("unknown identifier " + firstExpr.v)
    }

    let assign_name = null
    if (firstExpr.constructor === VariableEvaluator) {
        assign_name = firstExpr.varname
        // marke the variable from need_variables as an error so that if anything is using it, it would get an error
        g_state_access.need_variables[assign_name].name_reused_error = true
    }
    else if (firstExpr.constructor === SymbolNode) {
        assign_name = firstExpr.name
    }
    else if (firstExpr.constructor === SubscriptNode) {
        eassert(firstExpr.wrapNode.constructor === SymbolNode, "Can't assign to subscript of something that's not a symbol")
        assign_name = firstExpr.wrapNode.name + "." + firstExpr.subname
    }
    
    if (assign_name !== null) {
        return parseAssignStmt(assign_name)
    }
    return new ExpressionStatement(firstExpr)
    
}

class ReturnStmt extends Statement {
    constructor(expr) {
        super()
        this.expr = expr
        this.type = null
    }
    invoke() {
        const v = this.expr.eval()
        return v
    }
    sclear_types_cache() {
        super.sclear_types_cache()
        this.expr.clear_types_cache()
    }
    scheck_type() {
        if (this.type !== null)
            return this.type
        this.type = this.expr.check_type()
        return this.type
    }
    sto_glsl(emit_ctx) {
        return "return " + this.expr.to_glsl(emit_ctx) + ";"
    }
}


const TYPE_TO_STR = { [TYPE_NUM]:'float', [TYPE_VEC2]:'vec2', [TYPE_VEC3]:'vec3', [TYPE_VEC4]:'vec4' }

class AssignNameStmt  extends Statement {  // not a proper node (no eval, has side-effects)
    constructor(in_name, expr) {
        super()
        this.in_name = in_name // for err msg
        const sp = in_name.split('.')
        eassert(sp.length == 1 || sp.length == 2, "Assigning to multi-level subscript not supported") // no such use case yet
        this.name = sp[0]
        this.subscriptName = (sp.length > 1) ? sp[1] : null
        this.subscriptIdx = (sp.length > 1) ? SUBSCRIPT_TO_IDX[sp[1]] : null
        eassert(this.subscriptIdx !== undefined, "Unknown subscript in: " + in_name)
        this.expr = expr
        this.expr_type = null
        this.symbol = g_symbol_table[this.name]
        this.vNode = null  // a new node that has the actual value assigned to the symbol
        this.first_definition = false
        if (this.symbol === undefined) { // wasn't already there
            eassert(this.subscriptIdx === null, "Can't set subscript of non existing symbol")
            this.symbol = new SymbolNode(this.name)
            g_symbol_table[this.name] = this.symbol
            this.first_definition = true
        }
    }
    invoke() {
        const v = this.expr.eval()
        if (this.subscriptIdx !== null) { 
            eassert(this.symbol.valueNode !== null, "Assign to undefiend symbol") // sanity, was already checked in scheck_type
            this.symbol.valueNode.v[this.subscriptIdx] = v
        }
        else {
            let vNode
            switch  (this.expr_type) {
            case TYPE_NUM: vNode = new NumNode(v, false); break;
            case TYPE_BOOL: vNode = new BoolNode(v); break;
            default: vNode = new VecNode(v, this.expr_type); break;
            }
            // valueNode in symbol is null as long as the symbol doesn't have a value
            this.symbol.valueNode = vNode
        }
        return null // never returning from the code in this statement
    }
    sclear_types_cache() {
        super.sclear_types_cache()
        this.expr.clear_types_cache()
    }
    scheck_type() {
        this.expr_type = this.expr.check_type()
        eassert(this.expr_type !== TYPE_VOID, "Can't assing void return value", this.line)
        if (this.subscriptIdx !== null) {
            eassert(this.expr_type === TYPE_NUM || this.expr_type === TYPE_BOOL, "Subscript assign to `" + this.in_name + "` expects a number", this.line) // assume we don't assign things bigger than a number (no swizzle yet)
            eassert(this.symbol.type !== null, "Trying to assign subscipt of an undefined symbol: " + this.name, this.line)
            eassert(this.symbol.type !== TYPE_NUM && this.symbol.type !== TYPE_BOOL, "Number type symbol `" + this.name + "` can't have subscript", this.line)
            eassert(this.subscriptIdx < numbersInType(this.symbol.type), "Assigning to non-existing subscript " + this.subscriptName + " of symbol " + this.name, this.line)
        }
        else {
            if (this.symbol.type !== null)
                eassert(this.symbol.type === this.expr_type, "Symbol `" + this.in_name + "` can't change type (from " + typename(this.symbol.type) + " to " + typename(this.expr_type) + ")", this.line)
            // changing type of a variable won't work in glsl so we don't allow it                
            this.symbol.type = this.expr_type  // needs to be here since it's needed in the check_type of referencing this symbol
        }
        this.type = null
        return null // doesn't return from a code-block so it needs to be null
    }
    sto_glsl(emit_ctx) {
        let s = this.name
        if (this.subscriptIdx !== null) {
            s += "." + SUBIDX_TO_GLSL[this.subscriptIdx]
        }
        s += "=" + this.expr.to_glsl(emit_ctx) + ";"
        if (this.first_definition)
            emit_ctx.locals_defs[this.name] = this.expr_type
        return s
    }
}

// maps name to SymbolNode with the value that resulted from the expression
var g_symbol_table = null
var g_glsl_added_funcs = null // map [name of func]_[arg type] to the func text

class CodeNode extends NodeBase {
    constructor(stmts, symbol_table) {
        super()
        this.stmts = stmts
        this.symbol_table = symbol_table
    }
    count() {
        return this.stmts.length
    }
    eval() {  // returns non-null if the code does "return"
        let ret = null
        for(let stmt of this.stmts) {
            ret = stmt.invoke()
            if (ret !== null) {
                break
            }
        }
        return ret
    }
    clear_types_cache() {
        this.type = null
        for(let stmt of this.stmts)
            stmt.sclear_types_cache()
    }
    check_type() {
        if (this.type !== null)
            return this.type
        for(let stmt of this.stmts) {
            const sret = stmt.scheck_type()
            if (sret !== null) { // means all control paths of this statement return a value
                this.type = sret
                break // anything after that is not going to be executed so it doesn't need to be checked
            }
        }
        return this.type
    }
    to_glsl(emit_ctx) {
        let s = ""
        for(let stmt of this.stmts) {
            let ret = stmt.sto_glsl(emit_ctx) 
            s += ret + "\n"
        }
        return s
    }

}

function skip_to_next_line() {
    while(true) {
        let c = getCharacter()
        if (c === null)
            break;
        ++index_
        if (c == '\n') {
            g_lineNum++
            break
        }
    }
}

// with the curly braces, if they exist - sub code of an if statement
function parseCodeBlock() {
    let c = getCharacter();
    let code
    if (c == '{') {
        index_++;
        code = parseCode()
        eatSpaces()
        c = getCharacter();
        if (c !== '}')
            throw new ExprErr("code block expects closing curly braces")
        index_++;
    }
    else { // single command
        code = parseCode(true)
        eatSpaces()
    }
    return code
}

// parse block of statements (without curly braces) or just one statement (instead of a block where there are no curly brances in an if)
function parseCode(only_one_line) {
    let lst = []
    while(!isEnd()) {
        const e = parseStmt()
        if (e === STMT_COMMENT) {
            skip_to_next_line() // comment
            continue
        }
        else if (e === STMT_END_BLOCK)
            break
        lst.push(e)
        if (only_one_line)
            break
    }
    return new CodeNode(lst, g_symbol_table)
}

// parse a complete program from the use
function parseCompleteCode()
{
    let symbol_table = {}
    g_symbol_table = symbol_table
    const c = parseCode()
    g_symbol_table = null
    return c
}

/// Expression string
var expr_ = null
/// Current expression index, incremented whilst parsing
var index_ = 0

var g_state_access = null

function eparse(expr, state_access, opt) {
    if (typeof expr != "string")
        return new NumNode(expr, true)
    if (expr == "")
        throw new ExprErr("empty expression")
    index_ = 0;
    expr_ = expr;
    g_lineNum = 1
    if (state_access) {
        g_state_access = state_access
    }
    let result = null;
    try {
        if (opt === PARSE_EXPR)
            result = parseExpr();   
        else if (opt == PARSE_CODE) 
            result = parseCompleteCode();
        else 
            throw new ExprErr("unknown opt " + opt)
        if (!isEnd())
            throw new ExprErr("Syntax error: unexpected token, expected expression end")
    }
    catch(e)
    {
        while (stack_.length != 0)
            stack_.pop();
        throw e;
    }
    finally {
        g_state_access = null
        g_lineNum = 1 // for any other errors, for instance type checks
    }
    return result;
}

// expect_var_resolved means if there are still unresolved vars, throw, rather than set the exception
function check_type(node, expect_var_resolved=false) {
    try {
        const ret = node.check_type()
        if (ret === null)
            throw new ExprErr("Not all control paths return a value")
        return ret
    } catch(e) {
        if (e.constructor === UndecidedTypeErr)
            return TYPE_UNDECIDED
        if (e.constructor === DependOnVarErr && !expect_var_resolved)
            return TYPE_DEPEND_ON_VAR
        throw e
    }
}

function clear_types_cache(node) {
    node.clear_types_cache()
}

function do_eval(node) {
    if (node.symbol_table !== undefined) {
        g_symbol_table = node.symbol_table
        // clear values from symbol table 
        for(let [name,sym] of Object.entries(node.symbol_table)) {
            sym.valueNode = null
        }
    }
    const ret = node.eval()
    g_symbol_table = null
    return ret
}

function do_to_glsl(node, emit_ctx, opt=null) {
    g_glsl_added_funcs = new FuncsSet()
    let ret = node.to_glsl(emit_ctx)
    if (ret === null)
        throw new ExprErr("No return statement")
    if (opt === PARSE_EXPR)  //  single expression, no multiple lines, should be wrapped in return to be a function body
        ret = "return " + ret + ";"

    // g_glsl_added_funcs is keyed by name|type, need to aggregate just by name
    const funcs_agg = new FuncsSet()
    for(let k in g_glsl_added_funcs.get_kv()) {
        const entry = g_glsl_added_funcs.get(k)
        funcs_agg.append_text(entry.name, entry.text)
    }
    emit_ctx.add_funcs = funcs_agg

    return ret
}

return {parse:eparse, 
       make_num_node:make_num_node, 
       check_type:check_type, 
       clear_types_cache:clear_types_cache, 
       do_eval:do_eval, 
       do_to_glsl:do_to_glsl
    }
})()




// from https://www.shadertoy.com/view/4sKyzW#
// sdCubicBezier
const DFFUNC_BEZIER = `/*
Exact distance to cubic bezier curve by computing roots of the derivative(s)
to isolate roots of a fifth degree polynomial and Halley's Method to compute them.
Inspired by https://www.shadertoy.com/view/4sXyDr and https://www.shadertoy.com/view/ldXXWH
See also my approximate version:
https://www.shadertoy.com/view/lsByRG
*/
const float eps = .000005;
const float zoom = 1.;
const float dot_size=.005;
const vec3 point_col=vec3(1,1,0);
const int halley_iterations = 8;

//lagrange positive real root upper bound
//see for example: https://doi.org/10.1016/j.jsc.2014.09.038
float upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){

	vec4 coeffs1 = vec4(a0,a1,a2,a3);

	vec4 neg1 = max(-coeffs1,vec4(0));
	float neg2 = max(-a4,0.);

	const vec4 indizes1 = vec4(0,1,2,3);
	const float indizes2 = 4.;

	vec4 bounds1 = pow(neg1,1./(5.-indizes1));
	float bounds2 = pow(neg2,1./(5.-indizes2));

	vec2 min1_2 = min(bounds1.xz,bounds1.yw);
	vec2 max1_2 = max(bounds1.xz,bounds1.yw);

	float maxmin = max(min1_2.x,min1_2.y);
	float minmax = min(max1_2.x,max1_2.y);

	float max3 = max(max1_2.x,max1_2.y);

	float max_max = max(max3,bounds2);
	float max_max2 = max(min(max3,bounds2),max(minmax,maxmin));

	return max_max + max_max2;
}

//lagrange upper bound applied to f(-x) to get lower bound
float lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){

	vec4 coeffs1 = vec4(-a0,a1,-a2,a3);

	vec4 neg1 = max(-coeffs1,vec4(0));
	float neg2 = max(-a4,0.);

	const vec4 indizes1 = vec4(0,1,2,3);
	const float indizes2 = 4.;

	vec4 bounds1 = pow(neg1,1./(5.-indizes1));
	float bounds2 = pow(neg2,1./(5.-indizes2));

	vec2 min1_2 = min(bounds1.xz,bounds1.yw);
	vec2 max1_2 = max(bounds1.xz,bounds1.yw);

	float maxmin = max(min1_2.x,min1_2.y);
	float minmax = min(max1_2.x,max1_2.y);

	float max3 = max(max1_2.x,max1_2.y);

	float max_max = max(max3,bounds2);
	float max_max2 = max(min(max3,bounds2),max(minmax,maxmin));

	return -max_max - max_max2;
}

vec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){
	vec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);
	vec2 a1 = (3. * p0  -6. * p1 + 3. * p2);
	vec2 a2 = (-3. * p0 + 3. * p1);
	vec2 a3 = p0;

	return (((a0 * t) + a1) * t + a2) * t + a3;
}

void sort_roots3(inout vec3 roots){
	vec3 tmp;

	tmp[0] = min(roots[0],min(roots[1],roots[2]));
	tmp[1] = max(roots[0],min(roots[1],roots[2]));
	tmp[2] = max(roots[0],max(roots[1],roots[2]));

	roots=tmp;
}

void sort_roots4(inout vec4 roots){
	vec4 tmp;

	vec2 min1_2 = min(roots.xz,roots.yw);
	vec2 max1_2 = max(roots.xz,roots.yw);

	float maxmin = max(min1_2.x,min1_2.y);
	float minmax = min(max1_2.x,max1_2.y);

	tmp[0] = min(min1_2.x,min1_2.y);
	tmp[1] = min(maxmin,minmax);
	tmp[2] = max(minmax,maxmin);
	tmp[3] = max(max1_2.x,max1_2.y);

	roots = tmp;
}

float eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){

	float f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;

	return f;
}

//halley's method
//basically a variant of newton raphson which converges quicker and has bigger basins of convergence
//see http://mathworld.wolfram.com/HalleysMethod.html
//or https://en.wikipedia.org/wiki/Halley%27s_method
float halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){

	float f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;
	float f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;
	float f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;

	return x - (2. * f * f1) / (2. * f1 * f1 - f * f2);
}

float halley_iteration4(vec4 coeffs, float x){

	float f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];
	float f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];
	float f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];

	return x - (2. * f * f1) / (2. * f1 * f1 - f * f2);
}

// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
// Credits to Doublefresh for hinting there
int solve_quadric(vec2 coeffs, inout vec2 roots){

    // normal form: x^2 + px + q = 0
    float p = coeffs[1] / 2.;
    float q = coeffs[0];

    float D = p * p - q;

    if (D < 0.){
		return 0;
    }
    else if (D > 0.){
		roots[0] = -sqrt(D) - p;
		roots[1] = sqrt(D) - p;

		return 2;
    }
}

//From Trisomie21
//But instead of his cancellation fix i'm using a newton iteration
int solve_cubic(vec3 coeffs, inout vec3 r){

	float a = coeffs[2];
	float b = coeffs[1];
	float c = coeffs[0];

	float p = b - a*a / 3.0;
	float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;
	float p3 = p*p*p;
	float d = q*q + 4.0*p3 / 27.0;
	float offset = -a / 3.0;
	if(d >= 0.0) { // Single solution
		float z = sqrt(d);
		float u = (-q + z) / 2.0;
		float v = (-q - z) / 2.0;
		u = sign(u)*pow(abs(u),1.0/3.0);
		v = sign(v)*pow(abs(v),1.0/3.0);
		r[0] = offset + u + v;	

		//Single newton iteration to account for cancellation
		float f = ((r[0] + a) * r[0] + b) * r[0] + c;
		float f1 = (3. * r[0] + 2. * a) * r[0] + b;

		r[0] -= f / f1;

		return 1;
	}
	float u = sqrt(-p / 3.0);
	float v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;
	float m = cos(v), n = sin(v)*1.732050808;

	//Single newton iteration to account for cancellation
	//(once for every root)
	r[0] = offset + u * (m + m);
    r[1] = offset - u * (n + m);
    r[2] = offset + u * (n - m);

	vec3 f = ((r + a) * r + b) * r + c;
	vec3 f1 = (3. * r + 2. * a) * r + b;

	r -= f / f1;

	return 3;
}

// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
// Credits to Doublefresh for hinting there
int solve_quartic(vec4 coeffs, inout vec4 s){

	float a = coeffs[3];
	float b = coeffs[2];
	float c = coeffs[1];
	float d = coeffs[0];

    /*  substitute x = y - A/4 to eliminate cubic term:
	x^4 + px^2 + qx + r = 0 */

    float sq_a = a * a;
    float p = - 3./8. * sq_a + b;
    float q = 1./8. * sq_a * a - 1./2. * a * b + c;
    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;

	int num;

	/* doesn't seem to happen for me */
    //if(abs(r)<eps){
	//	/* no absolute term: y(y^3 + py + q) = 0 */

	//	vec3 cubic_coeffs;

	//	cubic_coeffs[0] = q;
	//	cubic_coeffs[1] = p;
	//	cubic_coeffs[2] = 0.;

	//	num = solve_cubic(cubic_coeffs, s.xyz);

	//	s[num] = 0.;
	//	num++;
    //}
    {
		/* solve the resolvent cubic ... */

		vec3 cubic_coeffs;

		cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;
		cubic_coeffs[1] = - r;
		cubic_coeffs[2] = - 1.0/2. * p;

		solve_cubic(cubic_coeffs, s.xyz);

		/* ... and take the one real solution ... */

		float z = s[0];

		/* ... to build two quadric equations */

		float u = z * z - r;
		float v = 2. * z - p;

		if(u > -eps){
			u = sqrt(abs(u));
		}
		else{
			return 0;
		}

		if(v > -eps){
			v = sqrt(abs(v));
		}
		else{
			return 0;
		}

		vec2 quad_coeffs;

		quad_coeffs[0] = z - u;
		quad_coeffs[1] = q < 0. ? -v : v;

		num = solve_quadric(quad_coeffs, s.xy);

		quad_coeffs[0]= z + u;
		quad_coeffs[1] = q < 0. ? v : -v;

		vec2 tmp=vec2(1e38);
		int old_num=num;

		num += solve_quadric(quad_coeffs, tmp);
        if(old_num!=num){
            if(old_num == 0){
                s[0] = tmp[0];
                s[1] = tmp[1];
            }
            else{//old_num == 2
                s[2] = tmp[0];
                s[3] = tmp[1];
            }
        }
    }

    /* resubstitute */

    float sub = 1./4. * a;

	/* single halley iteration to fix cancellation */
	for(int i=0;i<4;i+=2){
		if(i < num){
			s[i] -= sub;
			s[i] = halley_iteration4(coeffs,s[i]);

			s[i+1] -= sub;
			s[i+1] = halley_iteration4(coeffs,s[i+1]);
		}
	}

    return num;
}

//Sign computation is pretty straightforward:
//I'm solving a cubic equation to get the intersection count
//of a ray from the current point to infinity and parallel to the x axis
//Also i'm computing the intersection count with the tangent in the end points of the curve
int cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){

	float cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);
	float qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);
	float li = (-3. * p0.y + 3. * p1.y);
	float co = p0.y - uv.y;

	vec3 roots = vec3(1e38);
	int n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);

	int n_ints = 0;

	for(int i=0;i<3;i++){
		if(i < n_roots){
			if(roots[i] >= 0. && roots[i] <= 1.){
				float x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;
				x_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;
				x_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;
				x_pos = x_pos * roots[i] + p0.x;

				if(x_pos < uv.x){
					n_ints++;
				}
			}
		}
	}
	return n_ints;

	/*if(n_ints==0 || n_ints==2 || n_ints==4){
		return 1.;
	}
	else{
		return -1.;
	}*/
}

float cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){

	//switch points when near to end point to minimize numerical error
	//only needed when control point(s) very far away
	#if 0
	vec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);
	vec2 mid_points = (p0 + p3)/2.;

	vec2 tang = mid_curve-mid_points;
	vec2 nor = vec2(tang.y,-tang.x);

	if(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){
		vec2 tmp = p0;
		p0 = p3;
		p3 = tmp;

		tmp = p2;
		p2 = p1;
		p1 = tmp;
	}
	#endif

	vec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);
	vec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);
	vec2 a1 = (-3. * p0 + 3. * p1);
	vec2 a0 = p0 - uv;
    
    //compute polynomial describing distance to current pixel dependent on a parameter t
	float bc6 = dot(a3,a3);
	float bc5 = 2.*dot(a3,a2);
	float bc4 = dot(a2,a2) + 2.*dot(a1,a3);
	float bc3 = 2.*(dot(a1,a2) + dot(a0,a3));
	float bc2 = dot(a1,a1) + 2.*dot(a0,a2);
	float bc1 = 2.*dot(a0,a1);
	float bc0 = dot(a0,a0);

	bc5 /= bc6;
	bc4 /= bc6;
	bc3 /= bc6;
	bc2 /= bc6;
	bc1 /= bc6;
	bc0 /= bc6;
    
    //compute derivatives of this polynomial

	float b0 = bc1 / 6.;
	float b1 = 2. * bc2 / 6.;
	float b2 = 3. * bc3 / 6.;
	float b3 = 4. * bc4 / 6.;
	float b4 = 5. * bc5 / 6.;

	vec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;
	vec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;
	vec2 c3 = vec2(c2[1],2.*c2[2])/3.;
	float c4 = c3[1]/2.;

	vec4 roots_drv = vec4(1e38);

	int num_roots_drv = solve_quartic(c1,roots_drv);
	sort_roots4(roots_drv);

	float ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);
	float lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);

	vec3 a = vec3(1e38);
	vec3 b = vec3(1e38);

	vec3 roots = vec3(1e38);

	int num_roots = 0;
    
	//compute root isolating intervals by roots of derivative and outer root bounds
    //only roots going form - to + considered, because only those result in a minimum
	if(num_roots_drv==4){
		if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){
			a[0]=lb;
			b[0]=roots_drv[0];
			num_roots=1;
		}

		if(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){
            if(num_roots == 0){
				a[0]=roots_drv[1];
				b[0]=roots_drv[2];
                num_roots=1;
            }
            else{
            	a[1]=roots_drv[1];
				b[1]=roots_drv[2];
                num_roots=2;
            }
		}

		if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){
            if(num_roots == 0){
                a[0]=roots_drv[3];
                b[0]=ub;
                num_roots=1;
            }
            else if(num_roots == 1){
                a[1]=roots_drv[3];
                b[1]=ub;
                num_roots=2;
            }
            else{
                a[2]=roots_drv[3];
                b[2]=ub;
                num_roots=3;
            }
		}
	}
	else{
		if(num_roots_drv==2){
			if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){
				num_roots=1;
				a[0]=roots_drv[1];
				b[0]=ub;
			}
			else if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){
				num_roots=1;
				a[0]=lb;
				b[0]=roots_drv[0];
			}
			else{
				num_roots=2;

				a[0]=lb;
				b[0]=roots_drv[0];

				a[1]=roots_drv[1];
				b[1]=ub;
			}

		}
		else{//num_roots_drv==0
			vec3 roots_snd_drv=vec3(1e38);
			int num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);

			vec2 roots_trd_drv=vec2(1e38);
			int num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);
			num_roots=1;

			a[0]=lb;
			b[0]=ub;
		}
        
        //further subdivide intervals to guarantee convergence of halley's method
		//by using roots of further derivatives
		vec3 roots_snd_drv=vec3(1e38);
		int num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);
		sort_roots3(roots_snd_drv);

		int num_roots_trd_drv=0;
		vec2 roots_trd_drv=vec2(1e38);

		if(num_roots_snd_drv!=3){
			num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);
		}

		for(int i=0;i<3;i++){
			if(i < num_roots){
				for(int j=0;j<3;j+=2){
					if(j < num_roots_snd_drv){
						if(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){
							if(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){
								b[i]=roots_snd_drv[j];
							}
							else{
								a[i]=roots_snd_drv[j];
							}
						}
					}
				}
				for(int j=0;j<2;j++){
					if(j < num_roots_trd_drv){
						if(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){
							if(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){
								b[i]=roots_trd_drv[j];
							}
							else{
								a[i]=roots_trd_drv[j];
							}
						}
					}
				}
			}
		}
	}

	float d0 = 1e38;

    //compute roots with halley's method
    
	for(int i=0;i<3;i++){
		if(i < num_roots){
			roots[i] = .5 * (a[i] + b[i]);

            for(int j=0;j<halley_iterations;j++){
				roots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);
            }
			

            //compute squared distance to nearest point on curve
			roots[i] = clamp(roots[i],0.,1.);
			vec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);
			d0 = min(d0,dot(to_curve,to_curve));
		}
	}

	return d0; //sqrt(d0);
}

// p0, p3 real points, p1 point of p0, p2 point of p3
/*float sdCubicBezier(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3)
{
	float d0 = 1e38;
	d0 = min(d0,cubic_bezier_dis(uv,p0,p1,p2,p3));
    float sgn = cubic_bezier_sign(uv,p0,p1,p2,p3);   
    return d0 * sgn; 
}*/
`
"use strict"

const LINE_COLOR_VARS = "#a9ef50"
const TERM_COLOR_VARS = "#b9ff50"

// only variable node has this
class VarOutTerminal extends OutTerminal
{
    constructor(in_node, name) {
        super(in_node, name)
        this.kind = KIND_VARS
        this.yoffset = in_node.height/2;
        this.xoffset = in_node.width+2
        this.color = TERM_COLOR_VARS
    }
    draw_path(ctx) {
        const px = this.px(), py = this.py()
        const dr = -6, r = 8, s = 4, re = 9
        const pnts = [px+dr,py-r, px+s,py-r, px+re,py, px+s,py+r, px+dr,py+r, px+dr,py-r ]
        draw_curve(ctx, pnts)
    }
}

// every node has this, hidden in the view if not connected
class VarsInTerminal extends InTerminal
{
    constructor(in_node, name) {
        super(in_node, name)
        this.kind = KIND_VARS
        this.yoffset = in_node.height/2;
        this.xoffset = -4
        this.color = TERM_COLOR_VARS

        this.my_vsb = new VariablesObj()
        this.h = null // never used
    }
    draw_path(ctx, force) {
        if (this.lines.length == 0 && !force)
            return
        const px = this.px(), py = this.py()
        const hw = 4, hh = 9
        const pnts = [px-hw,py-hh, px+hw,py-hh, px+hw,py+hh, px-hw,py+hh, px-hw,py-hh]
        draw_curve(ctx, pnts)
    }

    collect_terminal() {
        for(let name in this.my_vsb.vb)
            this.my_vsb.vb[name].valive = false

        // first set all weak vars
        for(let line of this.lines) {
            const cb = line.from_term.get_ctrl_block()
            assert(cb !== null, line.from_term.owner.cls, "No output from node " + line.from_term.owner.name)
            if (!cb.po.weak_var)
                continue
            this.intr_set(cb, 0, true)
        }
        // then all non-weak
        for(let line of this.lines) {
            const cb = line.from_term.get_ctrl_block()
            if (cb.po.weak_var)
                continue
            this.intr_set(cb, 0, false)
        }

        // this is needed for managing lifetime of global variables
        for(let name in this.my_vsb.vb)
            if (!this.my_vsb.vb[name].valive)
                delete this.my_vsb.vb[name]
    }

    // this function takes CtrlBlock in all overrides
    intr_set(cblock, uver, skip_if_exists) 
    {
        const obj = cblock.po
        assert(obj.constructor === VariablesObj, this.owner.cls, "Unexpected object type")
        let any_dirty = false
        for(let name in obj.vb) 
        {
            const evb = this.my_vsb.vb[name]
            const exists = evb !== undefined
            if (exists)
                evb.valive = true
            if (skip_if_exists && exists)
                continue // already exists

            if (exists && vb_equals(obj.vb[name], evb))
                continue  // already same value

            // every node input term has its own clone of the VarBox so that it could keep track of if its dirty or not
            // and so that the original (incoming) VarBox dirty flag could be cleared after the node is done running

            const vb = clone(obj.vb[name])
            // the fact the for me (this terminal) the value was different means that my node should see this as dirty now in my copy of the VerBox
            // when it's going to check the dirtyness of the VerBox in resolve_variables
            vb.mark_dirty_now() 
            this.my_vsb.vb[name] = vb
            vb.valive = true
            any_dirty = true
        }
        // if this function is called, the var node attach was ran so we assume that's because something changed in it
        // VarNode doesn'd do object caching so it's a safe assumption
        this.tset_dirty(any_dirty)
    }

    is_dirty() {
        return this.dirty
    }



}

// compare VarBoxs
function vb_equals(a, b) {
    if (a.type !== b.type)
        return false
    switch(a.type) {
    case TYPE_BOOL:
    case TYPE_NUM: return a.v === b.v
    case TYPE_VEC2: return vec2.equals(a.v, b.v)
    case TYPE_VEC3: return vec3.equals(a.v, b.v)
    case TYPE_VEC4: return vec4.equals(a.v, b.v)
    case TYPE_MAT3: return mat3.equals(a.v, b.v)
    }
    throw new Error("VarBox unknown type in vb_equals")
}

// like a shared_ptr for VarBox, holds a single ref count 
// use for global variables so that there won't be garbage left there
// not needed in non-global VariableObj since it is reacreated every frame
class VBRef {
    constructor(vso, name) {
        this.name = name    // VarBox
        this.vso = vso  // VariablesObj
        ++this.vso.vb[name].vref_count
    }
    destroy() {
        if (this.vso === null)
            return
        const vb = this.vso.vb[this.name]
        if (--vb.vref_count === 0) {
            vb.vbset_invalid()
            this.vso.remove(this.name)
        }
        this.vso = null
    }
}


class VarBox {
    constructor() {
        this.v = null
        this.type = null
        this.vdirtied_at_ver = null // this is used for determining dirtyness in a way that doesn't require clear()

        this.pulse_need_reset = false
        this.vref_count = 0 // used for global vars
        this.valive = false // used for checking which were removed during collect of inputs (important for globals)
    }
    vbset(v, type) {
        this.v = v
        this.type = type
        this.vdirtied_at_ver = frame_ver
    }
    vbget() {
        return this.v
    }
    vbset_invalid() {  // signals dirtiness to all expressions that still hold this var
        this.v = null
        this.type = null
        this.vdirtied_at_ver = frame_ver 
    }
    mark_dirty_now() {
        this.vdirtied_at_ver = frame_ver 
    }

    // implement pulse functionality, this is not a separate class since I don't to need to recreate the VarBox on type change
    trigger() {
        this.pulse_need_reset = true
        this.vbset(true, TYPE_BOOL)        
    }


    vis_dirty() {
        let ret = this.vdirtied_at_ver == frame_ver
        if (!ret && this.pulse_need_reset) {
            this.vbset(false, TYPE_BOOL)
            this.pulse_need_reset = false
            ret = this.vdirtied_at_ver == frame_ver // doesn't do anything?
        }
        return ret
    }
}




class VariablesObj extends PObject
{
    static name() { return "Variables" }
    constructor(set_only_if_missing) {
        super()
        this.vb = {} // map variable name to VarBox where type is of TYPE_xxx
        this.weak_var = set_only_if_missing // weak variable set by non flowing node (so that it won't disappear)
    }
    lookup(name) {
        let r = this.vb[name]
        if (r !== undefined)
            return r
        return null
    }
    exists(name) {
        return this.vb[name] !== undefined
    }

    set_value(name, value, type) {
        if (this.vb[name] === undefined) {
            const nv = new VarBox()
            this.vb[name] = nv
            nv.vbset(value, type)
        }
        else {
            this.vb[name].vbset(value, type)
        }
    }
    // for globals
    make_ref(name) {
        return new VBRef(this, name)
    }

    add(name, vb) {
        this.vb[name] = vb  // VarBox
    }
    remove(name) {
        delete this.vb[name]
    }
    clear() {
        this.vb = {}
    }
    draw() {}
    draw_selection() {}
    draw_template() {}

    describe(parent, dlg) {
        dlg.clear_desc()
        const grid = add_div(parent, "obj_inf_grid")

        for(let name in this.vb) {
            const vb = this.vb[name]
            const v = vb.v

            const label_e = add_div(grid, "obj_inf_var_label")
            label_e.innerText = name
            const value_e = add_div(grid, "obj_inf_var_value")
            let text, s = []

            switch(vb.type) {
            case TYPE_NUM: text = toFixedMag(v); break;
            case TYPE_VEC2: case TYPE_VEC3:
            case TYPE_VEC4: 
                for(let i = 0; i < v.length; ++i)
                    s.push(toFixedMag(v[i]))
                text = s.join(", ")
                break
            case TYPE_BOOL: text = v ? "true" : "false"; break;
            case TYPE_MAT3: 
                text = format_matrix(v)
                value_e.classList.add("obj_inf_var_matrix")
                break;
            default: text = vb.v
            }

            value_e.innerText = text
            const type_elem = add_div(grid, "obj_inf_var_type")
            type_elem.innerText = typename(vb.type)
        }
    }
    
}

function format_matrix(v) {
    const s = []
    for(let i = 0; i < 9; ++i)
        s[i] = toFixedMag(v[i])
    const colw = [Math.max(s[0].length, s[1].length, s[2].length), 
                  Math.max(s[3].length, s[4].length, s[5].length),
                  Math.max(s[6].length, s[7].length, s[8].length)]

    let text = ""
    for(let i = 0; i < 3; ++i) {
        for(let j = 0; j < 3; ++j) {
            const idx = i+3*j
            text += s[idx] + " ".repeat(colw[j] - s[idx].length + 2)
        }
        text += "\n"
    }
    return text
}

// added into expression
class VariableEvaluator extends EvaluatorBase
{
    constructor(varname, line_num) {
        super()
        this.varname = varname
        this.var_box = null
        this.line_num = line_num // line of the first apperance of this variable name
        this.name_reused_error = false // set to true if this name is also assigned to in any expression in the node
    }
    is_valid() {
        // if this is set then this evaluator remains as a placeholder and should not be considered when resolving variables
        return !this.name_reused_error
    }
    consumes_subscript() { return false }
    eval() {
        if (this.var_box === null)
            throw new ExprErr("Unknown identifier " + this.varname) // happens when just parsing, not as part of resolve_variables
        return this.var_box.vbget()
    }
    check_type() {
        eassert(!this.name_reused_error, "Identifier " + this.varname + " should not be used as both variable and local symbol", this.line_num)
        if (this.var_box === null)
            throw new DependOnVarErr("Unknown identifier " + this.varname) 
        return this.var_box.type
    }
    to_glsl(emit_ctx) {
        if (this.var_box === null)
            throw new DependOnVarErr("Unknown identifier " + this.varname) 
        emit_ctx.add_uniform(this.var_box.type, this.varname, this)
        return this.varname
    }

}


class NodeVarCls extends NodeCls
{
    constructor(node) {
        super(node)
        node.can_display = false
        node.can_input = false
        node.can_enable = false
        node.name_xmargin = 8 // due to side terminal
        node.width = 80
        node.nkind = KIND_VARS

        this.var_out = new VarOutTerminal(node, "variable_out")

    }

    out_single_var(name, type, value) {
        const vsb = new VariablesObj()
        const vb = new VarBox()
        vsb.add(name, vb)
        vb.vbset(value, type)
        this.var_out.set(vsb)
    }
}


class NodeVariable extends NodeVarCls
{
    static name() { return "Variable" }
    constructor(node) {
        super(node)

        this.namer = new ParamObjStore(node, "<obj-store>", {gen_id:2, prms_lst:[1]}, ()=>{
            for(let p of this.vars_prm)
                for(let param of p.params)
                    node.remove_param(param)
            this.vars_prm.length = 0
            const lst_copy = [...this.namer.v.prms_lst]
            this.namer.v.prms_lst.length = 0 // going to repopulate it
            for(let id of lst_copy)
                this.add_variable(node, id)
            this.v_group.update_elems()
        })
        this.global_checkbox_override = null
        this.global = new ParamBool(node, "Global Namespace", false, (v)=>{
            if (this.global_checkbox_override !== null) {
                this.global_checkbox_override(v)
                return
            }
            node.can_enable = v
            draw_nodes()
        }, {allow_expr:false})
        this.brief = new ParamBool(node, "Brief View", false, (v)=>{
            this.set_brief(v)
        }, {allow_expr:false})
        this.brief.share_line_elem_from(this.global)

        this.v_group = new ParamGroup(node, "vars_params")

        this.vars_prm = []
        //const p = this.add_variable(node)
        //this.vars_prm = [p]
        this.add_prm_btn = new ParamButton(node, "[+]", ()=>{
            this.add_variable(node)
            this.v_group.update_elems()
        }, ["param_btn", "param_var_add_btn"])


        node.register_rename_observer((newname)=>{
            if (this.vars_prm.length == 1)
                this.vars_prm[0].name.modify(newname)
        })

        // if we're setting global variables, these are the VBRefs last created
        this.cur_glob_refs = []
        this.set_only_if_missing = false // for FlowVariable
    }

    toggle_enable_flag(do_draw, to_value=null) {
        this.node.of_program.set_glob_var_node(this.node, do_draw, (to_value !== null) ? to_value : (!this.node.enable_active))
        if (!this.node.enable_active) {
            // just deactivated, need to remove all current global references, not rely on run() to do it since we might not get run and if we do it's due to selection and too late
            this.del_cur_refs()
        }
    }


    set_brief(v) 
    {
        this.add_prm_btn.set_visible(!v)
        for(let p of this.vars_prm) {
            p.type.set_visible(!v)
            p.remove_btn.set_visible(!v)
            p.name.set_visible(!v)
            p.mouseState.set_visible(!v && p.type.sel_idx == 3)
            p.sep.set_visible(!v)
            p.up_btn.set_visible(!v)
            p.down_btn.set_visible(!v)
            for(let name of ["expr_float", "expr_int", "expr_vec2", "expr_vec2_mouse", "expr_color", "expr_bool"]) {
                if (v) {
                    // need to save a backup of the original name that looked like "Float"
                    if (p[name].label_display_bak === undefined) // do it only on the first time since only the first time the label_display is what it was inited with
                        p[name].label_display_bak = p[name].label_display
                    p[name].label_display = p.name.get_value()
                }
                else {
                    if (p[name].label_display_bak !== undefined) // will be undefined on the first call from load
                        p[name].label_display = p[name].label_display_bak
                }
            }
        }

        if (this.node.is_selected_inf !== null)
            reshow_params_of(this.node) // refresh display labels
    }
    post_load_hook() {
        if (this.brief.v)
            this.set_brief(true) // need to set their display names which were wrong in the initial call_change of the param from load since that was before the params were loaded
    }

    any_prm_need_input() {
        for(let p of this.vars_prm)
            if (p.type.sel_idx === 3 || p.type.sel_idx == 4)
                return true
        return false
    }

    add_variable(node, id = null)
    {
        if (id === null)
            id = this.namer.v.gen_id++
        const prefix = "p" + id + "_";
        const p = {}
        p.id = id
        this.namer.v.prms_lst.push(id)
        this.vars_prm.push(p)

        p.p_group = new ParamGroup(node, prefix + "group")
        p.p_group.set_group(this.v_group)

        p.type = new ParamSelect(node, ["Type", prefix], 0, ['Float', 'Integer', 'Float2', 'Float2-Mouse', 'Float2-Mouse-Delta', 'Color', 'Bool', 'Bool-Pulse', 'Transform'], (sel_idx)=>{ // TBD Function
            p.expr_float.set_visible(sel_idx === 0)
            p.expr_int.set_visible(sel_idx === 1)
            p.expr_vec2.set_visible(sel_idx === 2)
            p.expr_vec2_mouse.set_visible(sel_idx === 3 || sel_idx === 4)
            p.mouseState.set_visible(sel_idx === 3 || sel_idx === 4)
            p.expr_color.set_visible(sel_idx === 5)
            p.expr_bool.set_visible(sel_idx === 6)
            p.btn_bool_pulse.set_visible(sel_idx === 7)
            p.expr_trans.set_visible(sel_idx === 8)

            const prev = node.can_input
            // check if any param has input
            node.can_input = this.any_prm_need_input()
            if (prev != node.can_input) { // was changed?
                draw_nodes()
                if (!node.can_input && node.receives_input) { // just changed out of it, make sure it no longer receives input
                    this.node.of_program.set_input_node(node)
                }
            }
        })
        p.remove_btn = new ParamButton(node, ["[-]", prefix], ()=>{
            arr_remove_is(this.vars_prm, p)
            arr_remove_eq(this.namer.v.prms_lst, p.id)
            for(let pp of p.params)
                node.remove_param(pp)
            this.v_group.update_elems()
            this.v_group.pset_dirty() // otherwise it wouldn't be saved
        }, ["param_btn", "param_var_rm_btn"]) 
        p.remove_btn.share_line_elem_from(p.type)

        p.up_btn = new ParamButton(node, ["[/\\]", prefix], ()=>{
            this.move_variable(id, -1)
        }, ["param_btn", "param_var_arrow", "param_var_up_btn"])
        p.up_btn.share_line_elem_from(p.type)

        p.down_btn = new ParamButton(node, ["[\\/]", prefix], ()=>{
            this.move_variable(id, 1)
        }, ["param_btn", "param_var_arrow", "param_var_down_btn"])
        p.down_btn.share_line_elem_from(p.type)

        p.name = new ParamStr(node, ["Name", prefix], "var", (v)=>{
            if (this.vars_prm.length == 1) { // with one var the name of the var is the name of the node
                node.set_name(v)
                draw_nodes()
            }
        })
        p.expr_float = new ParamFloat(node, ["Float", prefix], 1.0, {min:0, max:2})
        p.expr_int = new ParamInt(node, ["Integer", prefix], 1, {min:0, max:10})
        p.expr_vec2 = new ParamVec2(node, ["Float2" ,prefix], 0, 0)
        p.expr_color = new ParamColor(node, ["Color", prefix], "#cccccc")
        p.expr_vec2_mouse = new ParamVec2(node, ["Mouse Coord", prefix], 0, 0) // want a different one since we don't want to mess with expr_vec2 being in code or not
        p.expr_vec2_mouse.set_enable(false)  // user never edits it directly
        p.expr_bool = new ParamBool(node, ["Bool", prefix], false)
        p.btn_bool_pulse = new ParamButton(node, ["Trigger", prefix], ()=>{ p.vb.trigger(); p.btn_bool_pulse.pset_dirty() }) // TBD
        p.expr_trans = new ParamTransform(node, ["Transform", prefix])

        p.mouseState = new ParamSelect(node, ["Sample At", prefix], 0, ["Mouse left down", "Mouse move"])
        p.sep = new ParamSeparator(node, prefix + "sep", "param_sep_line")

        // for easy removal
        p.params = [p.p_group, p.type, p.remove_btn, p.up_btn, p.down_btn, p.name, p.expr_float, p.expr_int, p.expr_vec2, p.expr_color, p.expr_vec2_mouse, p.expr_bool, p.btn_bool_pulse, p.expr_trans, p.mouseState, p.sep]
        for(let pp of p.params) {
            if (pp === p.p_group)
                continue // don't want to set the group to the group of this var
            pp.set_group(p.p_group)
            pp.call_change()            
        }

        //p.vb = new VarBox()

        return p
    }
    get_sorted_labels(for_group) {
        if (for_group !== this.v_group)
            return null
        const lst = []
        for(let id of this.namer.st_get("prms_lst"))
            lst.push("p" + id + "_group")
        return lst
    }

    move_variable(id, dir) {
        let lst = this.namer.st_get("prms_lst")
        // modifying directly the list that is referenced in namer
        const idx = lst.indexOf(id)
        if (idx === -1)
            console.error("didn't find index of ", id)
        if (idx + dir < 0 || idx + dir >= lst.length)
            return
        lst.splice(idx, 1)
        lst.splice(idx + dir, 0, id)

        this.v_group.update_elems()
      
    }

    run() {
        // input validation
        const name_set = new Set()
        for(let p of this.vars_prm)
        {
            const name = p.name.v
            assert(name.length > 0, this, "Name can't be empty")
            assert(!name_set.has(name), this, "Name defined multiple times: " + name)
            name_set.add(name)
        }

        const is_global = this.global.get_value()
        if (is_global) {
            if (!this.node.enable_active) { // if it's not enabled, it shouldn't run, just return the global variables unchanged
                this.del_cur_refs()
                this.var_out.set(out_obj)
                return
            }
            this.set_all_values(g_anim.globals_vars_box)
        }

        const out_obj = new VariablesObj(this.set_only_if_missing)
        this.set_all_values(out_obj)

        // manage references to global vars
        this.manage_global_refs(is_global)

        this.var_out.set(out_obj)
    }

    set_all_values(set_obj)
    {
        for(let p of this.vars_prm)
        {
            const name = p.name.v
            if (this.set_only_if_missing) {  // for global variables, if the variable is already there, and we're not flowing, don't set it
                if (set_obj.exists(name))
                    continue
            }

            switch(p.type.sel_idx) {
            case 0: set_obj.set_value(name, p.expr_float.get_value(), TYPE_NUM); break;
            case 1: set_obj.set_value(name, p.expr_int.get_value(), TYPE_NUM); break;
            case 2: set_obj.set_value(name, p.expr_vec2.get_value(), TYPE_VEC2); break;
            case 3: 
            case 4: set_obj.set_value(name, p.expr_vec2_mouse.get_value(), TYPE_VEC2); break;
            case 5: set_obj.set_value(name, color_to_uint8arr(p.expr_color.v), TYPE_VEC4); break;
            case 6: set_obj.set_value(name, p.expr_bool.get_value(), TYPE_BOOL); break;
            case 8: set_obj.set_value(name, p.expr_trans.get_value(), TYPE_MAT3); break;
            }
        }
    }

    manage_global_refs(is_global) {
        const new_refs = []
        if (is_global)
        {
            // add refs to all current ones
            for(let p of this.vars_prm)
                new_refs.push(g_anim.globals_vars_box.make_ref(p.name.v))
        }
        // remove ref from all the previous ones, if they existed
        this.del_cur_refs()
        this.cur_glob_refs = new_refs
    }

    del_cur_refs() {
        if (this.cur_glob_refs.length === 0)
            return
        for (let r of this.cur_glob_refs)
            r.destroy()
        this.cur_glob_refs = []            
    }

    // API
    destructor() {
        this.del_cur_refs()
    }


    inputevent(name, e) {
        let want_capture = false
        if (name == "mouseup") {
            // reset on up
            for(let p of this.vars_prm) {
                if (p.type.sel_idx === 4)
                    p.expr_vec2_mouse.modify_e(0, 0, true, true) // don't keep it with constant delta since if there's animation, it will continue moving
            }
            return
        }           
        if (name == "mousedown" && e.e.button == 0) {
            for(let p of this.vars_prm)
                if (p.mouseState.sel_idx == 0)
                    want_capture = true // want to capture
        }

        // mousedown and mousemove

        //let did_anything = false
        const move_action = (e, p)=>{
            if (p.type.sel_idx === 3) {
                const cp = image_view.epnt_to_model(e.ex, e.ey)
                p.expr_vec2_mouse.modify(cp)
            }
            else if (p.type.sel_idx === 4) {
                p.expr_vec2_mouse.modify_e(e.dx, e.dy, true, true) // force change since dx and dy can be the same if mouse is moving slowly in one axis
            }
            else
                assert(false, this, "unexpected type")
            //did_anything = true
        }

        // push and drag can be used only if the press was captured in the image canvase. 
        //  Otherwise, capture from node canvas and drag to image canvas would also move it
        for(let p of this.vars_prm) {
            if (p.type.sel_idx !== 3 && p.type.sel_idx !== 4)
                continue
            if (p.mouseState.sel_idx == 0 && ((e.buttons & 1) != 0) && (want_capture || e.img_canvas_capture === true))
                move_action(e, p)
            else if (p.mouseState.sel_idx == 1) // any mouse move
                move_action(e, p)
        }
        return want_capture

    }
}


// create a variable and update its value
class NodeVarStep extends NodeVarCls
{
    static name() { return "Variable Step" }
    constructor(node) {
        super(node)
        node.set_state_evaluators({"prev_value":  (m,s)=>{ return new ObjSubscriptEvaluator(m,s) }})

        this.type = new ParamSelect(node, "Type", 0, [["Float", TYPE_NUM], ["Float2", TYPE_VEC2]], (sel_idx)=>{
            this.start_float.set_visible(sel_idx === 0)
            this.update_float.set_visible(sel_idx === 0)
            this.start_vec2.set_visible(sel_idx === 1)
            this.update_vec2.set_visible(sel_idx === 1)
        })
        this.name = new ParamStr(node, "Name", "var")
        this.reset_cond = new ParamBool(node, "Reset Condition", false, null, { expr_visible:true })
        this.start_float = new ParamFloat(node, "Start Float", 0)
        this.start_vec2 = new ParamVec2(node, "Start Float2", 0, 0)
        this.update_float = new ParamFloat(node, "Update Float", 0)
        this.update_vec2 = new ParamVec2(node, "Update Float2", 0, 0)

        this.v = [{value:null, prm_start:this.start_float, prm_update:this.update_float, make_ret:(v)=>{ return v[0] } },
                  {value:null, prm_start:this.start_vec2,  prm_update:this.update_vec2,  make_ret:(v)=>{ return vec2.fromValues(v[0], v[1])} }]
    }

    run() {
        const sel_type = this.type.sel_idx
        let v = this.v[sel_type]
        if (v.value === null || this.reset_cond.get_value()) {
            v.value = v.prm_start.get_value()
            if (sel_type === 0)
                v.value = [v.value] // number needs to be wrapped
        }
        else {
            const need_prev = v.prm_update.need_input_evaler("prev_value")
            if (need_prev !== null)
                need_prev.dyn_set_obj(v.value)
            v.value = v.prm_update.dyn_eval()
        }
        const v_ret = v.make_ret(v.value)
        this.out_single_var(this.name.get_value(), this.type.get_sel_val(), v_ret)
    }
}
"use strict"


class NodeTestDummy extends NodeCls {
    static name() { return "Test_Dummy" }
    constructor(node) {
        super(node)
        this.in_1 = new InTerminal(node, "in_1")
        this.in_2 = new InTerminal(node, "in_2")
        this.out = new OutTerminal(node, "out")
    }
}


function make_mesh_quadtri(hx, hy) {
    const obj = new Mesh()
    // center at 0,0
    obj.set('vtx_pos', new TVtxArr([-hx, -hy, -hx, hy, hx, hy, hx, -hy]), 2)
    obj.set('idx', new TIdxArr([0, 1, 2, 0, 2, 3]))
    obj.set_type(MESH_TRI)
    return obj
}
function vec2_len(x, y) {
    return Math.sqrt(x*x+y*y)
}
function vecs_angle(a, b) {
    return Math.asin( vec2.dot(a, b) / (vec2.len(a)*vec2.len(b)) )
}

class NodeGeomPrimitive extends NodeCls
{
    static name() { return "Geom Primitive" }
    constructor(node) {
        super(node)
        this.out = new OutTerminal(node, "out_mesh")
        this.shape = new ParamSelect(node, "Shape", 0, ["Rectangle", "Rectangle from triangles", "Ellipse", "Regular Poly", "Star"], (sel_idx)=>{
            this.num_points.set_visible(sel_idx == 3 || sel_idx == 4)
            this.inner_point.set_visible(sel_idx == 4)
            this.center_inner_btn.set_visible(sel_idx == 4)
        })
        this.size = new ParamVec2(node, "Size", 0.5, 0.5)
        this.num_points = new ParamInt(node, "Num Points", 5, [3,12]) 
        this.inner_point = new ParamVec2(node, "Inner Point", 0.226, -0.311) // for a nice 5 point star
        this.center_inner_btn = new ParamButton(node, "Center", ()=>{
            const angle = 0.5/this.num_points.v*Math.PI*2
            const r = vec2_len(this.inner_point.x, this.inner_point.y)
            this.inner_point.modify(vec2.fromValues(r*Math.sin(angle), -r*Math.cos(angle)))
        })
        this.center_inner_btn.share_line_elem_from(this.inner_point)

        this.transform = new ParamTransform(node, "Transform")

        this.inner_dial = new PointDial((dx,dy)=>{
            this.inner_point.increment(vec2.fromValues(dx/this.size.x*2, dy/this.size.y*2))
        })
    }
    run() {
        assert(this.transform.is_valid(), this, "invalid transform")
        let obj
        let hx = this.size.x * 0.5, hy = this.size.y * 0.5
        if (this.shape.sel_idx == 0) { //quad
            obj = new Mesh()
            // center at 0,0
            obj.set('vtx_pos', new TVtxArr([-hx, -hy, -hx, hy, hx, hy, hx, -hy]), 2)
            obj.set('idx', new TIdxArr([0, 1, 2, 3]))
            obj.set_type(MESH_QUAD)
        }
        else if (this.shape.sel_idx == 1) { // square
            obj = make_mesh_quadtri(hx, hy)
        }
        else if (this.shape.sel_idx == 2) { // circle
            obj = new MultiPath()
            obj.set('vtx_pos', new TVtxArr([hx,0, 0,-hy, -hx,0, 0,hy]), 2)
            let dc = 0.5 * 4*(Math.sqrt(2)-1)/3 // see https://stackoverflow.com/questions/1734745/how-to-create-circle-with-b%C3%A9zier-curves
            let dc_x = this.size.x * dc, dc_y = this.size.y * dc
            obj.set('ctrl_to_prev',   new TVtxArr([0,dc_y, dc_x,0,  0,-dc_y,  -dc_x,0] ), 2)
            obj.set('ctrl_from_prev', new TVtxArr([dc_x,0,  0,-dc_y, -dc_x,0, 0,dc_y] ), 2)
            obj.paths_ranges = [0,4,PATH_CLOSED]
        }
        else if (this.shape.sel_idx == 3 || this.shape.sel_idx == 4) { // regular poly or star
            const vtx = [], np = this.num_points.v
            const rx = this.size.x*0.5, ry = this.size.y*0.5

            const isStar = this.shape.sel_idx == 4
            const inner = vec2.fromValues(this.inner_point.x, this.inner_point.y)
            const start_inner_angle = Math.atan2(this.inner_point.y, this.inner_point.x)+Math.PI/2
            const r_inner = vec2.len(inner)
            for(let i = 0; i < np; ++i) {
                const angle = i/np*Math.PI*2
                vtx.push(rx*Math.sin(angle), -ry*Math.cos(angle))
                if (isStar) {
                    const inner_angle = start_inner_angle + i/np*Math.PI*2
                    vtx.push(rx*r_inner*Math.sin(inner_angle), -ry*r_inner*Math.cos(inner_angle))
                }
            }

            if (!isStar && (np == 3 || np == 4)) {
                obj = new Mesh()
                if (np == 3) {
                    obj.type = MESH_TRI
                    obj.arrs.idx = [0,1,2]
                }
                else {
                    obj.type = MESH_QUAD
                    obj.arrs.idx = [0,1,2,3]
                }
            }
            else {
                obj = new MultiPath()
                obj.paths_ranges = [0,np*(isStar?2:1),PATH_CLOSED]
            }
            obj.set('vtx_pos', new TVtxArr(vtx), 2)
        }
        else 
            assert("unknown shape")
        obj.transform(this.transform.v)
        this.out.set(obj)
    }
    draw_selection(m) {
        let outmesh = this.out.get_const()
        if (outmesh === null)
            return
        this.transform.draw_dial_at_obj(outmesh, m)

        //  dials
        this.size.size_dial_draw(this.transform.v, m)
        // the inner point needs to move along with the entire size
        if (this.shape.sel_idx == 4)
            this.inner_dial.draw(this.inner_point.x*this.size.x/2, this.inner_point.y*this.size.y/2, this.transform.v, m)
    }    
    image_find_obj(e) {
        let hit = this.transform.dial.find_obj(e) || this.size.size_dial_find_obj(e)
        if (hit)
            return hit
        if (this.shape.sel_idx == 4)
            return this.inner_dial.find_obj(e)
        return null
    }
}

class PointSelectHandle
{
    constructor(list_param, index, ofnode) {
        this.list_param = list_param
        this.index = index
        this.ofnode = ofnode
        // TBD add offset
    }
    mousedown() {
        if (this.ofnode.point_mousedown)
            this.ofnode.point_mousedown(this.index)
        else            
            this.ofnode.set_selection(this.index) 
        trigger_frame_draw(false)
    }
    mouseup() {}
    mousemove(ev) {
        // moving all of them together
        for(let sn of selected_nodes)
            sn.cls.move_selection(ev)
    }
}


function add_point_select_mixin(node_cls, selected_indices, points_param) {

    // API
    node_cls.image_find_obj = function(e) {
        let [x,y] = image_view.epnt_to_model(e.ex, e.ey)
        let r = Math.max(7, MESH_DISP.vtx_radius) / image_view.viewport_zoom // if the disp radius gets lower, we still want it at reasonable value
        let len = points_param.count()
        for(let i = 0; i < len; ++i) {
            let [px,py] = points_param.get_value(i*2)
            if (px === null)
                continue
            if (m_dist(px, py, x, y) < r) {
                return new PointSelectHandle(this.points, i, this)
            }
        }
        if (node_cls.image_find_additional)
            return node_cls.image_find_additional(e)
        return null
    }
    node_cls.move_selection = function(ev) {
        for(let idx of selected_indices)
            points_param.increment(idx, [ev.dx, ev.dy])
        trigger_frame_draw(true)
    }

    node_cls.clear_selection = function() {
        selected_indices.length = 0 // don't recreate the array since there's reference from the CoordListParam
        trigger_frame_draw(false)
        points_param.reprint_all_lines()
    }
    node_cls.set_selection = function(idx) {
        // change the selection only if we just clicked an unselected point
        // otherwise we might be trying to move a selected group of points
        if (!selected_indices.includes(idx)) {
            selected_indices.length = 0
            selected_indices.push(idx)    
        }
        points_param.reprint_all_lines() // mark with yellow the selected
    }

    let rect_elem = null // rect selection DOM elem if one is active
    node_cls.rect_select = function(min_ex, min_ey, max_ex, max_ey) {
        if (min_ex === undefined && rect_elem !== null) { // indicates it needs to be cleared
            main_view.removeChild(rect_elem)   // rect can be null if there was no move with ctrl
            rect_elem = null
            return;
        }
        let [min_x,min_y] = image_view.epnt_to_model(min_ex, min_ey)
        let [max_x,max_y] = image_view.epnt_to_model(max_ex, max_ey)
        let len = points_param.count()
        selected_indices.length = 0
        for(let i = 0; i < len; ++i) {
            let [x,y] = points_param.get_value(i*2)
            if (x > min_x && x < max_x && y > min_y && y < max_y) {
                selected_indices.push(i)
            }
        }
        if (rect_elem === null) {
            rect_elem = add_div(main_view, "selection_rect")
        }
        rect_elem.style.left = min_ex + "px"
        rect_elem.style.top = min_ey + "px"
        rect_elem.style.width = (max_ex - min_ex) + "px"
        rect_elem.style.height = (max_ey - min_ey) + "px"
        trigger_frame_draw(false)
        points_param.reprint_all_lines() // re-mark yellows
    } 
    
    node_cls.draw_selection = function(m) {
        let obj = this.out.get_const()
        if (obj === null) 
            return
        let s = selected_indices
        // this is needed since in Gradient the order of the points in the object is different (sorted) than in the Node
        if (points_param.translate_idx_to_obj !== undefined)
            s = points_param.translate_idx_to_obj(s)
        obj.draw_selection(m, s)
    }    
}



// stand-in for a node for the point_select mixing to handle the path control points that are offset of the geom points
class DummyNodeCtrlPoints {
    constructor(points_lst, ctrl_lst, prev_point, path_ranges) {
        this.points_lst = points_lst
        this.ctrl_lst = ctrl_lst
        this.prev_point = prev_point
        this.path_ranges = path_ranges // needed for finding the prev point in a closed path
        this.selected_indices = [] // don't want to interfere with the points selection
        add_point_select_mixin(this, this.selected_indices, this)
    }

    // this class also serves as an adapter, adapt the list of control points which are diffs from the main point to what the point_select mixin expects
    count() {
        return this.ctrl_lst.count()
    }
    get_value(vidx) {
        const d = this.ctrl_lst.get_value(vidx)
        if (d[0] == 0 && d[1] == 0)
            return [null, null]
        if (this.prev_point)
            vidx = this.path_ranges.get_prev_point_in_path(vidx/2)*2 // 2 factor sice ranges want to deal with idx not vidx
        const p = this.points_lst.get_value(vidx)
        return [p[0]+d[0], p[1]+d[1]]
    }
    increment(idx, dp) {
        this.ctrl_lst.increment(idx, dp)
    }
    reprint_all_lines() {
    }
}

class ParamColumnInfoStore extends Parameter {
    constructor(node, label, change_func=null) {
        super(node, label)
        this.v = []
        this.loaded_v = null
        this.change_func = change_func // to get load event
    }
    save() { 
        const sv = []
        for(let obj of this.v) {
            sv.push({label: obj.label, ctor: obj.constructor.name})
        }
        return {v:sv}
    }
    load(v) { 
        this.loaded_v = v.v
    }
    add_elems(parent) {}
    sl_add(v) {
        this.v.push(v)
        this.pset_dirty() 
    }
    sl_remove(v) {
        arr_remove_is(this.v, v)
        this.pset_dirty() 
    }
}


class NodeManualGeom extends NodeCls
{
    static name() { return "Manual Geometry" }
    constructor(node) {
        super(node)
        this.selected_indices = [] // point indices. DO NOT RECREATE THIS. a reference of it goes to this.points
        this.pnt_attrs = []  // Param objets of additional attributes of each point other than it's coordinate

        this.out = new OutTerminal(node, "out_mesh")

        // needs to be first so that load would load the added params
        this.columns_store = new ParamColumnInfoStore(node, "col_store", ()=>{
            if (this.columns_store.loaded_v === null) // only initial load is interesting
                return
            // if we're loading, remove the default added color param, it will be be added by the loaded data if it's needed
            node.remove_param(this.color)
            this.table.del_column(this.color.column_key, false)
            this.color = null   
            // clear everything since we're loading all from loaded_v
            this.columns_store.v.length = 0
            this.pnt_attrs.length = 0

            const lst = this.columns_store.loaded_v
            for(let loaded_v of lst) {             
                this.add_additional_column(node, loaded_v.label, window[loaded_v.ctor], false)
            }
            this.columns_store.loaded_v = null
        })
        this.geom_type = new ParamSelect(node, "Type", 0, ["Mesh", "Paths"])
        this.add_pnts_btn = new ParamBool(node, "Add points", true, null, {allow_expr:false, as_btn:true})
        this.add_col_btn = new ParamTextMenuBtn(node, "Add Column", ["Curve Controls", "Float", "Vec2", "Color"], (opt, sel_idx)=>{
            if (sel_idx === 0 && this.cfp === null) {
                this.add_additional_column(node, "ctrl_from_prev", ParamCoordList, true)
                this.add_additional_column(node, "ctrl_to_prev", ParamCoordList, true)
            }
            else if (sel_idx === 1) {
                this.add_additional_column(node, "vtx_radius", ParamFloatList, true)
            }
            else if (sel_idx === 2) {
                this.add_additional_column(node, "vtx_normal", ParamCoordList, true)
            }
            else if (sel_idx === 3) {
                this.add_additional_column(node, "line_color", ParamColorList, true)
            }
        })
        this.add_col_btn.share_line_elem_from(this.add_pnts_btn)
        this.table = new ParamTable(node, "Point List")
        this.table.with_column_title = true
        this.table.on_remove_column = (lstprm)=>{ this.remove_column(lstprm) }
        this.points = new ParamCoordList(node, "vtx_pos", this.table, this.selected_indices)
      //  this.dummy = new ParamFloatList(node, "Dummy", this.table, this.selected_indices)
      //  this.color = new ParamColorList(node, "vtx_color", this.table)
        this.color = this.add_additional_column(node, "vtx_color", ParamColorList, false)

      //  this.columns_store.loaded_v = [{label:"vtx_color", ctor:"ParamColorList"}]

        this.cfp = this.ctp = null
        this.paths_ranges = new PathRangesList(node) // not shown

        // backwards compat
        node.param_alias("Coord", this.points)
        node.param_alias("Point Color", this.color)

        // TBD user able to add columns

        add_point_select_mixin(this, this.selected_indices, this.points)
        this.cfp_select = this.ctp_select = null
    }

    // from table context menu
    remove_column(lstprm) {
        this.node.remove_param(lstprm)
        this.table.del_column(lstprm.column_key, true)
        this.columns_store.sl_remove(lstprm)
        arr_remove_is(this.pnt_attrs, lstprm)
    }

    image_find_additional(e) {
        if (this.cfp_select !== null) {
            return this.cfp_select.image_find_obj(e) || this.ctp_select.image_find_obj(e)
        }
        return null
    }

    col_name_exists(label) {
        for(let prm of this.node.parameters)
            if (prm.label === label)
                return true
        return false
    }

    add_additional_column(node, label, ctor, from_ui) {
        // check that the name doesn't already exist
        if (this.col_name_exists(label)) {
            let i = 2
            while (this.col_name_exists(label + i))
                ++i;
            label = label + i
        }

        const prm = new ctor(node, label, this.table)
        prm.allow_title_edit = true

        if (from_ui) { // don't need to do all these if we're just loading the params
            this.table.remake_table()
            const def_val = prm.get_def_val()
            for(let i = 0; i < this.points.count(); ++i)
                prm.add(def_val)
        }
        //this[var_name] = prm
        this.pnt_attrs.push(prm)
        this.columns_store.sl_add(prm)

        if (label === "ctrl_from_prev")
            this.cfp_select = new DummyNodeCtrlPoints(this.points, prm, true, this.paths_ranges)
        else if(label === "ctrl_to_prev")
            this.ctp_select = new DummyNodeCtrlPoints(this.points, prm, false, null)
        return prm
    }

    image_click(ex, ey) {
        if (!this.add_pnts_btn.v)
            return
        let ti = image_view.epnt_to_model(ex, ey)
        this.points.add(ti)
        for(let attr_param of this.pnt_attrs) {
            attr_param.add(attr_param.get_def_val())
        }

        this.paths_ranges.add_default() // do this anyway just to keep it simple, not much of an overhead

        trigger_frame_draw(true)
    }

    point_mousedown(idx) {
        if (this.add_pnts_btn.v && this.geom_type.sel_idx == 1) {
            // when adding points to path, instead of select, close the path
            if (this.paths_ranges.close_current(idx)) {
                trigger_frame_draw(true)
                return
            } // if didn't close, select
        }
        this.set_selection(idx)     
    }

    selected_obj_name() { return (this.selected_indices.length > 0) ? "points" : null }
    delete_selection() {
        this.points.remove(this.selected_indices)
        for(let attr_param of this.pnt_attrs) {
            attr_param.remove(this.selected_indices)
        }
        this.paths_ranges.remove(this.selected_indices)
        this.clear_selection()
        trigger_frame_draw(true)
    }

    // API
    run() {
        let obj
        if (this.geom_type.sel_idx == 0) // mesh
        {
            obj = new Mesh()
            obj.type = MESH_POINTS
        }
        else if (this.geom_type.sel_idx == 1) // paths
        {
            obj = new MultiPath()
            obj.paths_ranges = this.paths_ranges.lst.slice();
        }
        else {
            assert(false, this, "unexpected type")
        }

        obj.set('vtx_pos', this.points.lst, 2)
        for (let attr of this.pnt_attrs) {
            obj.set(attr.label, attr.lst, attr.values_per_entry, attr.pneed_normalize)
        }


        this.out.set(obj)
    }


}


class ObjRef { // top level variable that references an object
    constructor(name) {
        this.name = name
        this.obj = null
        this.idx = null
        this.dirty_obj_ver = 1 // incremented evaluator needs to invalidation anything it cached about the object
    }
    dyn_set_obj(obj) { // existing epression set with a new object
        this.obj = obj
        ++this.dirty_obj_ver;
    }
    dyn_set_prop_index(idx) { // for mesh objects
        this.idx = idx  // usually index of the current vertex or face being evaluated
    }       
}

class ObjSingleEvaluator extends EvaluatorBase {
    constructor(objref, subscripts) {
        super()
        if (subscripts.length != 0)
            throw new Error("Unexpected subscript given to variable")
        this.objref = objref
    }
    consumes_subscript() { return true }

    eval() {
        // single obj needs to be a reference object we make it a 1 item array
        return this.objref.obj[0]
    }
    check_type() {
        if (this.objref.obj === null)
            throw new UndecidedTypeErr()
        return TYPE_NUM
    }
}

// evaluates either a vec object or a subscript of a vec object
class ObjSubscriptEvaluator extends EvaluatorBase {
    constructor(objref, subscripts) {
        super()
        //if (subscripts.length != 1)
        //    throw new Error("Wrong subscript given to variable " + name)
        this.objref = objref
        this.subscript = (subscripts.length > 0) ? subscripts[0] : null
        this.type = null
    }
    consumes_subscript() { return true }

    eval() {
        if (this.subscript === null) {
            eassert(this.objref.obj.length !== undefined, "object is not an array")
            return [...this.objref.obj] // copy it to be on the safe side, probably not needed
        }
        eassert(this.objref.obj !== null, "object not set")
        let v = this.objref.obj[this.subscript]
        eassert(v !== undefined, "subscript not found " + this.subscript)        
        return v
    }
    eval_func(argvals) {
        eassert(this.type = TYPE_FUNCTION, "eval_func to not a function")
        eassert(this.objref.obj._call_at !== undefined, "Missing _call_at")
        return this.objref.obj._call_at(...argvals)
    }
    obj_vec_type() { 
        if (this.objref.obj === null)
            throw new UndecidedTypeErr()
        else {
            eassert(this.objref.obj.length !== undefined, "Missing length")
            const num_elems = this.objref.obj.length
            return type_from_numelems(num_elems)
        }
    }
    check_type() {
        if (this.subscript === null) { // need to wait for obj
            this.type = this.obj_vec_type()
        }
        else if (this.subscript === "at")
            this.type = TYPE_FUNCTION
        else
            this.type = TYPE_NUM
        return this.type
    }

    func_ret_type() {
        return this.obj_vec_type()
    }
}

function type_from_numelems(num_elems) {
    switch(num_elems) { // this could be just return num_elems but better to do it explicit
        case 1: return TYPE_NUM; 
        case 2: return TYPE_VEC2;
        case 3: return TYPE_VEC3;
        case 4: return TYPE_VEC4;
    }
}


class MeshPropEvaluator extends EvaluatorBase
{
    constructor(meshref, subscripts, param_bind_to) 
    {
        super()
        console.assert(meshref !== undefined  && meshref !== null)
        eassert(subscripts.length == 2 || subscripts.length == 1, "Not enough subscript given to variable " + name)
        this.meshref = meshref
        this.param_bind_to = param_bind_to
        this.attrname = subscripts[0]
        if (this.attrname == "index") {
            eassert(subscripts.length == 1, "unexpected additional subscript to value")
            this.valindex = -1;
        }
        else {
            // valname is line x,y,alpha
            this.valname = (subscripts.length == 2) ? subscripts[1] : null
            this.valindex = (this.valname !== null) ? SUBSCRIPT_TO_IDX[this.valname] : 0  // 0 for the case it's a float property
            eassert(this.valindex !== undefined, "Unknown subscript `" + this.valname + "`")
        }
        // idx is in meshref not multiplied for any property
        this.attr = null
        this.num_elems = null
        this.last_obj_ver = 0
        this.type = null
    }
    consumes_subscript() { return true }

    resolve_attr() {
        if (this.valindex === -1) 
            return
        if (this.type !== null && this.attr !== null && this.last_obj_ver === this.meshref.dirty_obj_ver) 
            return // don't need an update since the object was not changed (unless type was cleared)
        eassert(this.meshref.obj !== null, "unexpected null object")
        if (this.param_bind_to.sel_idx == 0) // vertices  TBD this is not invalidated if bind_to changes
            eassert(this.attrname.startsWith("vtx_"), "bind to Vertices can only sample vertex attribute: " + this.attrname)
        else if (this.param_bind_to.sel_idx == 1) // faces
            eassert(this.attrname.startsWith("face_"), "bind to Faces can only sample face attribute: " + this.attrname)
        let attr = this.meshref.obj.arrs[this.attrname]
        if (attr === undefined && this.meshref.obj.computed_prop !== undefined)
            attr = this.meshref.obj.computed_prop(this.attrname)
        eassert(attr !== undefined && attr !== null, "unknown attribute " + this.attrname + " of object")

        if (attr.computed_value === undefined) { // it's not computed
            this.num_elems = this.meshref.obj.meta[this.attrname].num_elems
            if (this.num_elems == 1)
                eassert(this.valname === null, "unexpected additional subscript to value")
            // else no further subscripts, return vec
            if (this.valname === null) // only if it doesn't have a extra subscript
                this.type = type_from_numelems(this.num_elems)
        }
        else {
            if (this.valname === null)
                this.type = attr.computed_type()
        }
        this.attr = attr
        this.last_obj_ver = this.meshref.dirty_obj_ver // incrememnted when the object changes so we need to retake its array
    }

    eval() {
        eassert(this.meshref.idx !== null, "unexpected null object")
        eassert(this.type !== null, "unexpected null type")
          
        this.resolve_attr()

        if (this.valindex === -1)
            return this.meshref.idx        

        if (this.attr.computed_value !== undefined) {
            const v = this.attr.computed_value(this.meshref.idx)
            if (this.valname === null)
                return v  // no subscript, just return whatever we computed
            return v[this.valindex]
        }
        else {
            const offs = this.meshref.idx * this.num_elems
            switch(this.type) {
            case TYPE_NUM: return this.attr[offs + this.valindex]  // either the prop is float or we gave a subscript
            case TYPE_VEC2: return vec2.fromValues(this.attr[offs], this.attr[offs + 1])
            case TYPE_VEC3: return vec3.fromValues(this.attr[offs], this.attr[offs + 1], this.attr[offs + 2])
            case TYPE_VEC4: return vec3.fromValues(this.attr[offs], this.attr[offs + 1], this.attr[offs + 2], this.attr[offs + 3])    
            }
            eassert(false, "unexpected num_elems " + this.num_elems)
        }
    }
    check_type() {
        // in case it's not ".index" but the expr didn't give any subscript
        //  the type needs to be whatever is the type of the mesh property, which is not known in parse type
        if (this.valindex >= 0 && this.valname === null) {
            if (this.meshref.obj === null)
                throw new UndecidedTypeErr() // would cause a call to here when there's a mesh set (rather than only after parse)
                // happens for instance for `p = in_obj.face_center`
            this.resolve_attr()
            dassert(this.type !== null, "resolve_attr didn't set type (bug)")
        }
        else {
            if (this.meshref.idx === null)
                throw new UndecidedTypeErr() 
                // in this case the type is known but we still throw that to prevent eval() since we can't eval without the obj idx
            this.type = TYPE_NUM
        }
        return this.type
    }    
}




// examples:
//  abs(in_obj.vtx_pos.x)*20
//  in_src.r
//  center of faces is sampled only when sampling color
//  rand(in_obj.index)  - works for vertices and faces
//  in_obj.face_center - for faces
// with "Image Fill" the attr_name needs to be "fill", bind to face, and in_src is what's being filled
//     
class NodeSetAttr extends NodeCls
{
    static name() { return "Set Attribute" }
    constructor(node) {
        super(node)
        this.in_mesh = new InTerminal(node, "in_obj")
        this.in_source = new InTerminal(node, "in_src") // future - may not be an image? proximity to other mesh?
        this.out_mesh = new OutTerminal(node, "out_mesh")

        // node says what evaluators it wants for its inputs
        node.set_state_evaluators({"in_src":  (m,s)=>{ return new ObjSubscriptEvaluator(m,s) }, 
                                   "in_obj": (m,s)=>{ return new MeshPropEvaluator(m,s, this.bind_to) }})

        // should be above attr_name that sets it                                    
        this.name_per_type = new ParamObjStore(node, "npt", { 0:"color", 1:"radius", 2:"normal", 3:"fill", 4:"transform" })

        //this.use_code = new ParamBool(node, "Use Code", false, (v)=>{})
        this.bind_to = new ParamSelect(node, "Bind To", 0, [["Vertices", "vtx_"], ["Faces", "face_"], ["Lines", "line_"]])
        // needs to be before attr_name since otherwise the loaded name goes to the initial type (color)

        this.attr_type = new ParamSelect(node, "Type", 0, ["Color", "Float", "Float2", "Image Fill", "Transform"], (sel_idx)=>{
            const type_idx = this.attr_type.sel_idx
            this.expr_color.set_visible(type_idx == 0)
            this.expr_float.set_visible(type_idx == 1)
            this.expr_vec2.set_visible(type_idx == 2)
            this.expr_bool.set_visible(type_idx == 3)
            this.expr_transform.set_visible(type_idx == 4)

            const prm = this.param_of_index[type_idx]
            if (prm.show_code !== undefined) // update show code checkbox according to the type
                this.edit_code.modify(prm.show_code)
            else
                this.edit_code.modify(false)

            this.attr_name.modify(this.name_per_type.st_get(sel_idx))
        })
        this.edit_code = new ParamBool(node, "Edit code", false, (v)=>{
            // can be different for each type
            const prm = this.param_of_index[this.attr_type.sel_idx]
            if (prm.set_show_code)
                prm.set_show_code(v)
        }, {allow_expr:false})
        this.edit_code.share_line_elem_from(this.attr_type)

        this.attr_name = new ParamStr(node, "Name", "color", (v)=>{
            this.name_per_type.st_set(this.attr_type.sel_idx, v)
        })
        this.expr_color = new ParamColor(node, "Color", [DEFAULT_VTX_COLOR.hex, DEFAULT_VTX_COLOR.rgb])
        this.expr_float = new ParamFloat(node, "Float", 0)
        this.expr_vec2 = new ParamVec2(node, "Float2", 0, 0, true)
        this.expr_bool = new ParamFloat(node, "Select", "1.0")  
        this.expr_transform = new ParamTransform(node, "Transform")

        this.param_of_index = [this.expr_color, this.expr_float, this.expr_vec2, this.expr_bool, this.expr_transform]

        // connect callback from context menu to the bool param
        const show_code_callback = (v)=>{this.edit_code.modify(v) }
        for(let p of this.param_of_index) {
            if (p.show_code_callback !== undefined) 
                p.show_code_callback = show_code_callback
        }
    }

    prop_from_const(mesh, prop, src, mutate_assign) {
        if (this.attr_type.sel_idx == 0) {
            let col = src.v
            for(let i = 0; i < prop.length; i += prop.elem_sz) {
                prop[i] = col.r
                prop[i+1] = col.g
                prop[i+2] = col.b
                prop[i+3] = col.alphai // normalized back to 0-1 in mesh draw
            }
        }
        else if (this.attr_type.sel_idx == 1) { // float
            prop.fill(src.v)
        }
        else if (this.attr_type.sel_idx == 2) { // vec2 
            for(let i = 0; i < prop.length; i += prop.elem_sz) {
                prop[i] = src.x
                prop[i+1] = src.y
            }
        }
        else if (this.attr_type.sel_idx == 3) { // fill
            let dummy = []
            mutate_assign(dummy, 0, src.v)
            if (src.v !== 0)
                prop.fill(dummy[0])
        }
        else if (this.attr_type.sel_idx == 4) { // transform
            for(let i = 0; i < prop.length; i += prop.elem_sz) {
                mutate_assign(prop, i, src.v)
            }
        }
        else
            assert(false, this, "unknown attr")
    }

    prop_from_mesh_attr(prop, value_need_mesh, src_param, mutate_assign) 
    {
        for(let i = 0, pi = 0; pi < prop.length; ++i, pi += prop.elem_sz) 
        {
            value_need_mesh.dyn_set_prop_index(i)
            let vc = src_param.dyn_eval()
            mutate_assign(prop, pi, vc)
        }
    }

    prop_from_input_framebuffer(prop, mesh, src_sampler, value_need_src, value_need_mesh, src_param, mutate_assign) 
    {

        // see https://www.khronos.org/opengl/wiki/Vertex_Post-Processing#Viewport_transform
        // from Xw = (w/2)*Xp + (w/2) 
        src_sampler.do_get_pixels()
        let w = src_sampler.width(), h = src_sampler.height()

        mesh.ensure_tcache(src_sampler.transform)
        let vtx = mesh.tcache.vtx_pos


        const samp_vtx = (this.bind_to.sel_idx === 0 || this.bind_to.sel_idx == 2)
        //let face_sz = mesh.face_size()
        let vtxi = 0
        let expr_input = [0, 0, 0, 0]
        expr_input._call_at = function() { // implement in_src.at(x, y)
            return src_sampler.sample_at(...arguments)
        }
        value_need_src.dyn_set_obj(expr_input)

        const pixels = src_sampler.pixels
        // implement in_src.r/g/b/a
        for(let i = 0, pi = 0; pi < prop.length; ++i, pi += prop.elem_sz) 
        {
            let x = 0, y = 0
            if (samp_vtx) {
                x = vtx[vtxi++]
                y = vtx[vtxi++]
            }
            else { // sample at faces, at center of the face (average face points)
                let vidxs = mesh.vidxs_of_face(i) // returns the list of indices into vtx of the points that make face i (index of x, +1 of y)
                for(let vidx of vidxs) {
                    x += vtx[vidx]
                    y += vtx[vidx+1]                    
                }
                x /= vidxs.length
                y /= vidxs.length
            }

            const rx = Math.round(x)
            const ry = Math.round(y)

            if (value_need_mesh !== null)
                value_need_mesh.dyn_set_prop_index(i)
            
            if (rx < 0 || ry < 0 || rx >= w || ry >= h) {
                expr_input[0] = expr_input[1] = expr_input[2] = expr_input[3] = 0
            }
            else {
                const pidx = (ry*w + rx)*4
                expr_input[0] = pixels[pidx]
                expr_input[1] = pixels[pidx+1]
                expr_input[2] = pixels[pidx+2]
                expr_input[3] = pixels[pidx+3]
            }

            const vc = src_param.dyn_eval()
            mutate_assign(prop, pi, vc)
        }

    }

    async run() {
        assert(this.bind_to.sel_idx != -1, this, "'Bind To' not set")
        //assert(this.source_sel.sel_idx != -1, this, "'Bind To' not set")
        let mesh = this.in_mesh.get_const()
        assert(mesh, this, "missing in_mesh")
        assert(mesh.constructor === Mesh || mesh.constructor === MultiPath, this, "Expected input geometry")


        /*if (this.source_sel.sel_idx == 0 && this.expr_color.v === null) {
            this.out_mesh.set(mesh)
            return // TBD warning
        }*/

        let elem_num
        let attr_name = this.bind_to.get_sel_val()
        // check that the mesh has face to bind to, otherwise this is a noop
        if (this.bind_to.sel_idx == 1) { 
            elem_num = mesh.face_count()
            if (elem_num == 0) {
                this.out_mesh.set(mesh)
                return  // TBD warning
            }
        }
        else {
            elem_num = mesh.vtx_count()
        }
        attr_name += this.attr_name.v

        let prop = null, src_param = null
        //let mutate_value = (prevv, newv)=>{return newv} // optional transformation on the value that comes from the expression
        let mutate_assign = null, need_normalize = false

        if (this.attr_type.sel_idx == 0) { // color
            prop = new TColorArr(elem_num * 4)
            prop.elem_sz = 4
            src_param = this.expr_color
            mutate_assign = (prop, pi, vc)=>{
                for(let si = 0; si < 4; ++si)
                    prop[pi+si] = vc[si]
            }
            need_normalize = true
        }
        else if (this.attr_type.sel_idx == 1) { // float
            prop = new Float32Array(elem_num * 1)
            prop.elem_sz = 1
            src_param = this.expr_float
            mutate_assign = (prop, pi, vc)=>{
                prop[pi] = vc
            }            
        }
        else if (this.attr_type.sel_idx == 2) { // float2
            prop = new Float32Array(elem_num * 2)
            prop.elem_sz = 2
            src_param = this.expr_vec2
            mutate_assign = (prop, pi, vc)=>{
                prop[pi] = vc[0]
                prop[pi+1] = vc[1]
            }            
        }
        else if (this.attr_type.sel_idx == 3) { // image-fill
            // TBD warning that the attr name to should be "fill"
            const existing = mesh.arrs[attr_name]
            if (existing !== undefined) { // if it already exists, add upon it (expression controls when to write)
                assert(existing.length == elem_num, this, "unexpected existing prop size")
                prop = new Uint16Array(existing)
            }
            else
                prop = new Uint16Array(elem_num)
            prop.elem_sz = 1
            src_param = this.expr_bool
            let id = this.set_image_fill(attr_name, elem_num)
            // don't change what's there if we're setting 0
            mutate_assign = (prop, pi, vc)=>{
                if (vc !== 0) // vc is 1 or 0 - put the new one or not
                    prop[pi] = id
            }
        }
        else if (this.attr_type.sel_idx == 4) { // transform
            src_param = this.expr_transform;
            prop = new Float32Array(elem_num * 6)
            prop.elem_sz = 6
            mutate_assign = (prop, pi, vc)=>{
                prop[pi] = vc[0];   prop[pi+1] = vc[1]; prop[pi+2] = vc[3]
                prop[pi+3] = vc[4]; prop[pi+4] = vc[6]; prop[pi+5] = vc[7]
            }            
        }
        else {
            assert(false, this, "unknown type")
        }

        assert(src_param.get_last_error() === null, this, "Parameter expression error " + src_param.get_last_error())
        let value_need_src = src_param.need_input_evaler("in_src")
        let value_need_mesh = src_param.need_input_evaler("in_obj")
        let need_inputs = value_need_src || value_need_mesh
        
        let src_sampler = null
        if (value_need_src !== null) { // make sure we have a src to get the value from
            src_sampler = new ImgInputSampler(this.in_source, this)
            await src_sampler.prepare(mesh)
        }
        if (value_need_mesh !== null) {
            value_need_mesh.dyn_set_obj(mesh)
        }


        // commiting to work
        const out_mesh = this.in_mesh.get_mutable()

        try {
            if (!need_inputs) { // from const
                this.prop_from_const(out_mesh, prop, src_param, mutate_assign)
            }
            else if (value_need_src !== null) { // from img input

                this.prop_from_input_framebuffer(prop, out_mesh, src_sampler, value_need_src, value_need_mesh, src_param, mutate_assign)
            }
            else if (value_need_mesh !== null) {
                this.prop_from_mesh_attr(prop, value_need_mesh, src_param, mutate_assign)
            }
        }
        catch(e) {
            if (e instanceof ExprErr) 
                assert(false, this, "Parameter expression error")
            else
                throw e
        }
        finally {
            if (value_need_mesh !== null)
                value_need_mesh.dyn_set_obj(null) // don't want these to reference local objects that are no longer relevant (and hide errors)
            if (value_need_src !== null)
                value_need_src.dyn_set_obj(null)
        }

        out_mesh.set(attr_name, prop, prop.elem_sz, need_normalize) // normalize true has effect only on int which is only color here
        this.out_mesh.set(out_mesh)
    }

    set_image_fill() {
        const src = this.in_source.get_const()
        assert(src !== null, this, "missing input source image")

        const mesh = this.in_mesh.get_mutable()
        // there's going to be a single line since it's not a multi terminal
        const disp_values = this.in_source.lines[0].from_term.owner.display_values
        const id = mesh.add_fillobj(new ObjConstProxy(src, clone(disp_values)))
        return id        
    }
}

class ObjConstProxy {
    constructor(in_obj, display_values) {
        this.obj = in_obj
        this.with_display_values = display_values
        if (this.with_display_values !== null && Object.keys(this.with_display_values).length == 0) { 
            // happens if this node was never displayed
            //   used for the side-effect that it sets the defaults
            this.obj.get_disp_params(this.with_display_values)
        }
    }
    draw(m) {
        this.obj.draw(m, this.with_display_values)
    }
    async pre_draw(m) {
        await this.obj.pre_draw(m, this.with_display_values)
    }
    prox_get_const_obj() {
        return this.obj
    }
}

// if the value is a single number, it's not in a list, as per convention everywhere else
const DEFAULT_FOR_VTX_ATTRS = {
    "vtx_radius" : { v:MESH_DISP.vtx_radius,    num_elems:1 },
    "vtx_color"  : { v:DEFAULT_VTX_COLOR.arr,   num_elems:4 },
    "line_width" : { v:1,                       num_elems:1 },
    "line_color" : { v:DEFAULT_VTX_COLOR.arr,   num_elems:4 },
}

function get_default_value(name, numelems) {
    const def = DEFAULT_FOR_VTX_ATTRS[name]
    if (def === undefined || def.num_elems !== numelems)
        return Array(numelems).fill(0);
    return def.v
}

function fill_default_value(narr, at_index, name, num_elems, count) {
    const def = DEFAULT_FOR_VTX_ATTRS[name] // fill with a default value?
    if (def !== undefined && def.num_elems === num_elems) { // if it's not the same num_elems, don't bother
        for(let i = 0; i < count * num_elems; ++i)
            narr[at_index++] = def.v[i % num_elems]
    }  // otherwise keep it 0
    else 
        at_index += count * num_elems
    return at_index
}

class NodeConstAttr extends NodeCls
{
    static name() { return "Const Attribute" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_geom")
        this.out_obj = new OutTerminal(node, "out_geom")

        // should be above attr_name that sets it                                    
        this.name_per_type = new ParamObjStore(node, "npt", { 0:"color", 1:"radius", 2:"normal" }) 

        //this.use_code = new ParamBool(node, "Use Code", false, (v)=>{})
        this.bind_to = new ParamSelect(node, "Bind To", 0, [["Vertices", "vtx_"], ["Faces", "face_"], ["Lines", "line_"]])
       
        this.attr_type = new ParamSelect(node, "Type", 0, ["Color", "Float", "Float2"], (sel_idx)=>{
            const type_idx = this.attr_type.sel_idx
            this.expr_color.set_visible(type_idx == 0)
            this.expr_float.set_visible(type_idx == 1)
            this.expr_vec2.set_visible(type_idx == 2)

            this.attr_name.modify(this.name_per_type.st_get(sel_idx))
        })

        this.attr_name = new ParamStr(node, "Name", "color", (v)=>{
            this.name_per_type.st_set(this.attr_type.sel_idx, v)
        })
        this.expr_color = new ParamColor(node, "Color", [DEFAULT_VTX_COLOR.hex, DEFAULT_VTX_COLOR.rgb])
        this.expr_float = new ParamFloat(node, "Float", 5)
        this.expr_vec2 = new ParamVec2(node, "Float2", 1, 0, true)

    }

    run()
    {
        const obj = this.in_obj.get_mutable()
        assert(obj !== null, this, "Missing input")
        assert(obj.constructor === Mesh || obj.constructor === MultiPath, this, "Input should be either mesh or path")

        let name = this.bind_to.get_sel_val() + this.attr_name.get_value()
        let v = null
        switch(this.attr_type.sel_idx) {
        case 0: v = color_to_uint8arr(this.expr_color.get_value()); break;
        case 1: v = this.expr_float.get_value(); break;
        case 2: v = this.expr_vec2.get_value(); break;
        default: assert(false, this, "Unknown type")
        }
        
        obj.set_const(name, v)
        this.out_obj.set(obj)
    }

}



class NodeGeomMerge extends NodeCls
{
    static name() { return "Geom Merge" }
    constructor(node) {
        super(node)
        this.in_m = new InTerminalMulti(node, "in_multi_mesh")
        this.out = new OutTerminal(node, "out_mesh")

        this.dedup_vtx = new ParamBool(node, "Deduplicate Points (Output mesh)", false, (v)=>{
            this.dedup_epsilon.set_enable(v)
        })
        this.dedup_epsilon = new ParamFloat(node, "Dedup epsilon", 0.00001, {visible:false})
        this.sorted_order = []       
        mixin_multi_reorder_control(node, this, this.sorted_order, this.in_m)
    }

    analyze_inputs(meshes) {
        // figure out the size and type of the unified arrays
        let obj_ctor = null    // mesh or multipath
        let mesh_type = null   // if it's a mesh, the type

        const uni_meta = {}
        assert(this.sorted_order.length == meshes.length, this, "unexpected meshes size")
        for(let si of this.sorted_order) 
        {
            const m = meshes[si]
            assert(m.constructor === Mesh || m.constructor === MultiPath, this, "input is not a mesh or paths")
            if (obj_ctor === null) // first
                obj_ctor = m.constructor 
            else if (obj_ctor !== m.constructor) // mixing mesh and paths 
                obj_ctor = MultiPath

            if (obj_ctor == Mesh) { // all of what we've seen so far were meshes
                if (mesh_type === null) { // first
                    mesh_type = m.type
                    assert(m.type !== MESH_NOT_SET, this, "input mesh type not set")
                    if (m.type !== MESH_POINTS)
                        assert(m.arrs.idx !== null && m.arrs.idx !== undefined, this, "input mesh with faces but no idx array?")
                }
                else if (mesh_type !== m.type) // mixing mesh of different types,
                    obj_ctor = MultiPath
            }
            for(let name in m.arrs) {
                if (m.arrs[name] === null)
                    continue
                if (name.startsWith("vtx_") || name.startsWith("ctrl_"))
                    assert(m.arrs[name].length === m.vtx_count() * m.meta[name].num_elems, this, "unexpected size of array " + name)
                else if (name.startsWith("face_"))
                    assert(m.arrs[name].length === m.face_count() * m.meta[name].num_elems, this, "unexpected size of array " + name)                                        
                else if (name != "idx")
                    assert(false, this, "unexpected array name " + name)

                if (uni_meta[name] === undefined) {
                    uni_meta[name] = { num_elems: m.meta[name].num_elems,
                                       ctor: m.arrs[name].constructor,
                                       need_normalize: m.meta[name].need_normalize
                                    }
                }
                else {
                    assert(m.meta[name].num_elems === uni_meta[name].num_elems, this, "incompatible objects, array " + name + " num_elems different")
                    assert(m.meta[name].need_normalize === uni_meta[name].need_normalize, this, "incompatible objects, array " + name + " normalization different")
                    assert(m.meta[name].constructor === uni_meta[name].constructor, this, "incompatible objects, array " + name + " normalization different")
                }
            }
        }
        // count vertices
        let vtx_count = 0 // for meshes
        let face_count = 0  // for both
        let idx_count = 0
        const start_idxs = [] // for each mesh in the input, when offset its vertices start in, for fixing its idx
        if (obj_ctor === Mesh) {
            for(let m of meshes) {
                start_idxs.push(vtx_count)
                vtx_count += m.vtx_count()
                face_count += m.face_count()
                if (m.arrs.idx != undefined && m.arrs.idx !== null)
                    idx_count += m.arrs.idx.length
            }
        }
        else { // I'm building paths
            for(let m of meshes) {
                // if it's a mesh, I'm going to spread the indices. mesh of just vertices doesn't have idx
                vtx_count += (m.constructor == Mesh && m.arrs.idx !== null) ? m.arrs.idx.length : m.vtx_count()
                face_count += m.face_count()
            }
        }

        return {obj_ctor:obj_ctor, mesh_type:mesh_type, uni_meta:uni_meta, 
                vtx_count:vtx_count, idx_count:idx_count, start_idxs:start_idxs, face_count:face_count}
    }

    merge_to_mesh(d, meshes) 
    {
        const r = new Mesh()
        r.type = d.mesh_type
        for(let name in d.uni_meta) { // go array by array
            const isVtxProp = !name.startsWith("face_")
            const umeta = d.uni_meta[name]
            const narr = new umeta.ctor(((name === "idx") ? d.idx_count : d.vtx_count) * umeta.num_elems)
            let at_index = 0
            for(let si of this.sorted_order) // then go by all the input meshes
            {
                const m = meshes[si]
                if (name === 'idx') {
                    for(let i = 0; i < m.arrs.idx.length; ++i)
                        narr[at_index++] = m.arrs.idx[i] + d.start_idxs[si]
                    continue
                }                    
                if (m.arrs[name] === undefined) { // this mesh doesn't have this name
                    const count = isVtxProp ? m.vtx_count() : m.face_count()
                    at_index = fill_default_value(narr, at_index, name, umeta.num_elems, count)
                    continue 
                }
                // data attribute that exists in this mesh, just copy it
                narr.set(m.arrs[name], at_index)
                at_index += m.arrs[name].length
            }
            r.set(name, narr, umeta.num_elems, umeta.need_normalize)
        }
        return r
    }

    merge_to_paths(d, meshes)
    {
        const r = new MultiPath()
        // make ranges
        const ranges = []
        let at_index = 0; 
        for(let si of this.sorted_order)
        {
            const m = meshes[si]
            if (m.constructor === Mesh) {
                const step = m.face_size()
                const count_paths = (m.arrs.idx !== null) ? (m.arrs.idx.length / step) : m.vtx_count()
                for(let i = 0; i < count_paths; ++i) {
                    ranges.push(at_index, at_index + step, PATH_CLOSED)
                    at_index += step
                }
            }
            else {
                for(let i = 0; i < m.paths_ranges.length; i += 3) {
                    const start_idx = m.paths_ranges[i*3]
                    const end_idx = m.paths_ranges[i*3+1]
                    ranges.push(start_idx + at_index, end_idx + at_index, m.paths_ranges[i*3+2])
                    at_index += end_idx - start_idx // advanced by this many vertices
                }
            }
        }
        // all other attributes
        assert(d.face_count === ranges.length / 3, this, "Unexpected face_count from analyze (BUG)")
        r.paths_ranges = ranges
        for(let name in d.uni_meta)  // go array by array
        {
            if (name === 'idx')
                continue
            const isVtxProp = !name.startsWith("face_")
            const umeta = d.uni_meta[name]
            const narr = new umeta.ctor(d.vtx_count * umeta.num_elems)
            let at_index = 0
            for(let si of this.sorted_order) // then go by all the input meshes
            {
                const m = meshes[si]
                const marr = m.arrs[name]
                if (marr === undefined) { // this mesh doesn't have this name
                    let count;
                    if (isVtxProp)
                        count = (m.constructor === Mesh && m.arrs.idx !== null) ? m.arrs.idx.length : m.vtx_count()
                    else
                        count = m.face_count()
                    at_index = fill_default_value(narr, at_index, name, umeta.num_elems, count)
                    continue 
                }
                
                if (m.constructor === Mesh && m.arrs.idx !== null && !isVtxProp) {
                    for(let idx of m.arrs.idx) {  // expand idx
                        for(let elemi = 0; elemi < umeta.num_elems; ++elemi)
                            narr[at_index++] = marr[idx * umeta.num_elems + elemi]
                    }
                }
                else { // paths, just copy it
                    narr.set(m.arrs[name], at_index)
                    at_index += m.arrs[name].length
                }
            }
            r.set(name, narr, umeta.num_elems, umeta.need_normalize)
        }
        return r
    }

    dedup_vertices(obj) 
    {
        const points_hash = new Map() // map discretisized [x,y] to the first index it appears in
        const old_went_to = [] // went_to[i] is the index int the new vtx_pos where index i went to (for reconstructing idx)
        const new_vtx = []
        const new_to_old_indices = [] // what indices in the original vtx the new_vtx came from (for reconstructing all the other arrays)
        const vtx = obj.effective_vtx_pos // take the baked vertices
        const vtx_len = vtx.length, discrete_factor = 1/this.dedup_epsilon.v
        let count_dups = 0
        // do the deduplication according to coordinates
        for(let vi = 0, i = 0; vi < vtx_len; vi += 2, ++i) {
            const x = vtx[vi], y = vtx[vi+1]
            const key = "" + Math.round(x * discrete_factor) + "_" + Math.round(y * discrete_factor) // no tuple type in ES6 yet so need use string
            let goes_to = points_hash.get(key)
            if (goes_to === undefined) { // something not seen before
                points_hash.set(key, i)
                goes_to = i
                new_vtx.push(x, y)
                new_to_old_indices.push(i)
            }
            else
                ++count_dups
            old_went_to.push(goes_to)
        }
        if (count_dups === 0 && obj.constructor === Mesh) // need to actually do something?
            return obj;  // if it's not a mesh, we want to do it anyway because the output needs to be a mesh
        
        const new_mesh = new Mesh()
        new_mesh.set("vtx_pos", new TVtxArr(new_vtx), 2, false)
        // all other arrays
        for(let name in obj.arrs) {
            if (!name.startsWith("vtx_") || name == "vtx_pos" || name == "vtx_transform") // already baked the transform using effective_vtx so don't need it
                continue
            const arr = obj.arrs[name], meta = obj.meta[name]
            const new_arr = new arr.constructor(new_to_old_indices.length * meta.num_elems)
            let pi = 0
            for(let old_idx of new_to_old_indices) {
                for(let ei = 0; ei < meta.num_elems; ++ei)
                    new_arr[pi++] = arr[old_idx * meta.num_elems + ei]
            }
            new_mesh.set(name, new_arr, meta.num_elems, meta.need_normalize)
        }
        // recreate idx
        if (obj.constructor === Mesh) {
            if (obj.has_idx()) {
                const idx = obj.arrs.idx
                const new_idx = new TIdxArr(idx.length)
                let pi = 0;
                for(let old_idx of idx)
                    new_idx[pi++] = old_went_to[old_idx]
                new_mesh.set("idx", new_idx)
                new_mesh.type = obj.type
            }
            else {
                assert(obj.type === MESH_POINTS, this, "unexpected input mesh type " + obj.type)
                new_mesh.type = MESH_POINTS
            }
        }
        else { // it was paths, discard all the paths information except the points
            new_mesh.type = MESH_POINTS
        }
        return new_mesh
    }

    run() {
        const meshes = this.in_m.get_input_consts()
        if (meshes.length == 0) {
            const r = new Mesh()
            new_mesh.type = MESH_POINTS
            this.out.set(r)
            return
        }
        let r = null
        if (meshes.length == 1) {
            r = meshes[0]
        }
        else {
            const d = this.analyze_inputs(meshes)
            if (d.obj_ctor == Mesh) // all inputs are meshes of the same type
                r = this.merge_to_mesh(d, meshes)
            else 
                r = this.merge_to_paths(d, meshes)
        }

        if (this.dedup_vtx.v)
            r = this.dedup_vertices(r)

        this.out.set(r)
    }
}


// split a single mesh or paths to several paths in a group 
class NodeGeomSplit extends NodeCls
{
    static name() { return "Geom Split" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_obj")
        this.out_group = new OutTerminal(node, "out_group")

        this.bind_to = { sel_idx: 0 } // only vertices for now
        node.set_state_evaluators({ "in_obj": (m,s)=>{ return new MeshPropEvaluator(m,s, this.bind_to) }})

        // TBD - by face
        this.sel_index = new ParamInt(node, "Split By\nIndex", 0, {show_code: true})
    }

    run()
    {
        const obj = this.in_obj.get_const()
        assert(obj, this, "missing input")
        assert(obj.constructor === Mesh || obj.constructor === MultiPath, this, "Expected input geometry")

        const out = new PObjGroup();
        const out_objs = {}

        const add_to_out = (obj, key)=>{
            out_objs[key] = obj
            out.add(obj, key)
            if (this.node.display_values[key] === undefined)
                this.node.display_values[key] = {}  // TBD only keep the disp values that are relevant
        }

        const need_mesh = this.sel_index.need_input_evaler("in_obj")

        const vtx_count = obj.vtx_count()
        if (vtx_count === 0 || need_mesh === null) {
            const key = this.sel_index.v
            add_to_out(obj, key)
            this.out_group.set(out);
            return
        }

        need_mesh.dyn_set_obj(obj)

        const out_objs_defs = {}  // for every output object, its key maps to an object with its arrays
        const vtx_idx_to_obj = [] // for every index, what object it went to 

        for(let i = 0; i < vtx_count; ++i) 
        {
            need_mesh.dyn_set_prop_index(i)
            // this vertex of index i, goes to which object
            const sidx = this.sel_index.dyn_eval()
            vtx_idx_to_obj.push(sidx)
            let to_def = out_objs_defs[sidx]
            if (to_def === undefined) {
                to_def = { darrs: { vtx_pos: [] }, vidx_map: {}, vcount: 0, paths_ranges:[] }
                out_objs_defs[sidx] = to_def
            }
            to_def.vidx_map[i] = to_def.vcount++
            const to_arrs = to_def.darrs
            for(let aname in obj.arrs) {
                if (to_arrs[aname] === undefined)
                    to_arrs[aname] = []
                if (aname.startsWith("face_") || aname == "idx") {
                    continue
                }

                const num_elem = obj.meta[aname].num_elems   
                const vi = i * num_elem
                for(let ei = 0; ei < num_elem; ++ei)
                    to_arrs[aname].push(obj.arrs[aname][vi+ei])
            }

        }

        const face_attr_names = []
         
        for(let aname in obj.arrs) {
            if (aname.startsWith("face_")) {
                face_attr_names.push(aname)
            }
        }
        const copy_face_attr = (obj, to_arrs, fidx)=>{
            for(let faname of face_attr_names) {
                const num_elem = obj.meta[faname].num_elems   
                for(let ei = 0; ei < num_elem; ++ei)
                    to_arrs[faname].push(obj.arrs[faname][fidx*num_elem + ei])
            }
        }

        // reconstruct faces
        if (obj.constructor === Mesh) 
        {
            const fsize = obj.face_size()
            if (fsize > 1) {
                // divide the faces to the objects
                const idx_count = obj.arrs.idx.length
                for(let iidx = 0, fidx = 0; iidx < idx_count; iidx += fsize, ++fidx) {
                    let to_obj_idx = vtx_idx_to_obj[obj.arrs.idx[iidx]]
                    for(let ei = 1; ei < fsize; ++ei) { // check all vertices agree on the same obj
                        if (to_obj_idx !== vtx_idx_to_obj[obj.arrs.idx[iidx + ei]]) {
                            to_obj_idx = null // they don't agree
                            break
                        }
                    }
                    if (to_obj_idx === null) // don't agree, don't add this face anywhere
                        continue
                    const to_def = out_objs_defs[to_obj_idx]             
                    const to_vmap = to_def.vidx_map
                    const to_arrs = to_def.darrs
                    // populate idx array
                    for(let ei = 0; ei < fsize; ++ei)
                        to_arrs.idx.push(to_vmap[obj.arrs.idx[iidx + ei]])

                    copy_face_attr(obj, to_arrs, fidx)
                }
            }
        }
        else // MultiPath
        {
            for(let pri = 0, fidx = 0; pri < obj.paths_ranges.length; pri += 3, ++fidx) 
            {
                const start_idx = obj.paths_ranges[pri]
                const end_idx = obj.paths_ranges[pri+1]
                const flags = obj.paths_ranges[pri+2]

                let to_obj_idx = vtx_idx_to_obj[start_idx]
                for(let iidx = start_idx+1; iidx < end_idx; ++iidx) 
                {
                    if (to_obj_idx !== vtx_idx_to_obj[iidx]) {
                        to_obj_idx = null // they don't agree
                        break
                    }
                }
                if (to_obj_idx === null) // don't agree, don't add this face anywhere
                    continue
                const to_def = out_objs_defs[to_obj_idx]  
                const to_vmap = to_def.vidx_map
                const path_len = end_idx - start_idx
                
                to_def.paths_ranges.push(to_vmap[start_idx], to_vmap[start_idx] + path_len, flags)
                copy_face_attr(obj, to_def.darrs, fidx)
            }
        }

        // create output objects
        for(let key in out_objs_defs) {
            const kobj = new obj.constructor()
            const def = out_objs_defs[key]
            const arrs = def.darrs
            for(let name in arrs) {
                const orig_meta = obj.meta[name]
                const arrCls = obj.arrs[name].constructor
                let arr = arrs[name]
                if (arrCls !== Array)  // it's a typed array (if it's just an Array, don't want to do this, it will create a list of 1 elem)
                    arr = new arrCls(arr)
                kobj.set(name, arr, orig_meta.num_elems, orig_meta.need_normalize)
            }

            if (obj.constructor === Mesh) {
                kobj.type = obj.type
            }
            else {
                kobj.paths_ranges = def.paths_ranges
            }


            add_to_out(kobj, key)
        }


        this.out_group.set(out);
    }

}



const VTX_NUM_ELEM = 2

function repeat_arr(arr, count) {
    const new_arr = new arr.constructor(arr.length * count)
    for(let ti = 0, at_index = 0; ti < count; ++ti, at_index += arr.length)
        new_arr.set(arr, at_index)
    return new_arr
}


// common functionality for NodeGeomCopy and DFCopy
let CopyNodeMixin =  (superclass) => class extends superclass 
{
    add_terminal_and_params(node) {
        this.in_target = new InTerminal(node, "in_target", (c)=>{
            this.create_count.set_enable(!c)
        }) // onto vertices of the target

        // before parameters so initialization would work
        this.bind_to = {sel_idx: 0} // just vertices
        node.set_state_evaluators({"in_target": (m,s)=>{ return new MeshPropEvaluator(m,s, this.bind_to) },
                                   "index": (m,s)=>{ return new ObjSingleEvaluator(m,s)}})

        this.create_count = new ParamInt(node, "Count", 10, {min:2, max:50})
        this.transform = new ParamTransform(node, "Object\nTransform", {tx: "in_target.vtx_pos.x", ty:"in_target.vtx_pos.y"})
    }
    get_meta_target() {
        const target = this.in_target.get_const()

        let tg_vtx_count = null
        const tr_need_target = this.transform.need_input_evaler("in_target")
        if (target !== null) { // if there's a target, it always controls the count
            tg_vtx_count = target.effective_vtx_pos.length / VTX_NUM_ELEM
            if (tr_need_target !== null)
                tr_need_target.dyn_set_obj(target)            
        }
        else {
            assert(tr_need_target === null, this, "in_target object not connected")
            tg_vtx_count = this.create_count.get_value()
        }
        return [tg_vtx_count, tr_need_target]
    }
    get_index_wrap() {
        const tr_need_index = this.transform.need_input_evaler("index")
        const index_wrap = [0]
        if (tr_need_index !== null)
            tr_need_index.dyn_set_obj(index_wrap)
        return index_wrap
    }
}

class NodeGeomCopy extends CopyNodeMixin(NodeCls)
{
    static name() { return "Copy" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_obj") // object to copy
        this.out = new OutTerminal(node, "out_obj")

        this.add_terminal_and_params(node)
    }

    mesh_copy(in_mesh, tg_vtx_count, tr_need_target) 
    {
        const out_mesh = new Mesh()
        out_mesh.type = in_mesh.type

        // copy vertex attribs as is, we're not adding vtx attribs
        for(let name in in_mesh.arrs) {
            const meta = in_mesh.meta[name]
            const arr = in_mesh.arrs[name]
            let new_arr
            if (name.startsWith("vtx_"))
                new_arr = arr  // same vertices shared (will be unshared by Mesh when setting face_transform)
            else if (name.startsWith("face_"))
                new_arr = repeat_arr(arr, tg_vtx_count)
            out_mesh.set(name, new_arr, meta.num_elems, meta.need_normalize)
        }
        let idx = null
        if (in_mesh.has_idx()) {
            idx = in_mesh.arrs.idx
        }
        else {
            assert(in_mesh.type == MESH_POINTS, this, "unexpected mesh type")
            // case of a mesh of points with idx, add idx to it that repeats the points. 
            // every point is its own face
            const vtx_count = in_mesh.vtx_count()
            idx = new TIdxArr(vtx_count)
            for(let i = 0; i < vtx_count; ++i)
                idx[i] = i
        }

        const face_sz = in_mesh.face_size()
        const count_faces = idx.length / face_sz
        // make face transform for every face in the 
        const new_face_tr = this.make_face_transform(count_faces, tg_vtx_count, tr_need_target)
        
        // duplicate the indices
        const new_idx = repeat_arr(idx, tg_vtx_count)

        out_mesh.set("idx", new_idx)
        out_mesh.set("face_transform", new_face_tr, 6, false) // needs to come after idx since its using it
        return out_mesh
    }

    path_copy(in_obj, tg_vtx_count, tr_need_target) 
    {
        const out_paths = new MultiPath()

        // need to duplicate all arrays since there's no vertex sharing in paths
        const vtx_count = in_obj.vtx_count()
        const face_count = in_obj.face_count()
        for(let name in in_obj.arrs) {
            const meta = in_obj.meta[name]
            const arr = in_obj.arrs[name]
            if (name.startsWith("vtx_") || name.startsWith("ctrl_"))
                assert(arr.length === vtx_count * meta.num_elems, this, "unexpected vtx attrib array size")
            else if (name.startsWith("face_"))
                assert(arr.length === face_count * meta.num_elems, this, "unexpected vtx attrib array size")
            else 
                assert(false, this, "unexpected attr name " + name)
            const new_arr = repeat_arr(arr, tg_vtx_count)
            out_paths.set(name, new_arr, meta.num_elems, meta.need_normalize)
        }
        const new_ranges = []
        let at_vtx_index = 0
        for(let ti = 0; ti < tg_vtx_count; ++ti) {
            for(let fi = 0; fi < in_obj.paths_ranges.length; fi += 3) 
                new_ranges.push(in_obj.paths_ranges[fi] + at_vtx_index, in_obj.paths_ranges[fi+1] + at_vtx_index, in_obj.paths_ranges[fi+2])
            at_vtx_index += vtx_count
        }
        out_paths.paths_ranges = new_ranges

        const new_face_tr = this.make_face_transform(face_count, tg_vtx_count, tr_need_target)
        out_paths.set("face_transform", new_face_tr, 6, false)
        return out_paths
    }

    make_face_transform(count_faces, tg_vtx_count, tr_need_target)
    {
        const index_wrap = this.get_index_wrap()

        let pi = 0
        const new_face_tr = new Float32Array(count_faces * tg_vtx_count * 6)

        for(let i = 0; i < tg_vtx_count; ++i) 
        {
            index_wrap[0] = i
            if (tr_need_target !== null)
                tr_need_target.dyn_set_prop_index(i)

            const m = this.transform.dyn_eval()
            // duplicate the same transform for all faces of in_obj
            for(let dupi = 0; dupi < count_faces; ++dupi) {
                new_face_tr[pi++] = m[0]; new_face_tr[pi++] = m[1]; 
                new_face_tr[pi++] = m[3]; new_face_tr[pi++] = m[4]; 
                new_face_tr[pi++] = m[6]; new_face_tr[pi++] = m[7];
            }
        }
        return new_face_tr
    }

    run() {
        const in_obj = this.in_obj.get_const()
        assert(in_obj !== null, this, "No input object to copy")

        const [tg_vtx_count, tr_need_target] = this.get_meta_target()
            
        let out_obj = null
        if (in_obj.constructor === Mesh)
            out_obj = this.mesh_copy(in_obj, tg_vtx_count, tr_need_target)
        else if (in_obj.constructor === MultiPath)
            out_obj = this.path_copy(in_obj, tg_vtx_count, tr_need_target)
        else
            assert(false, this, "Expected geometry object input")
        this.out.set(out_obj)
    }
}

class PGroupDispPrms {
    constructor() {
        this.v = {}
    }
}

// TBD: a slightly better way to do this is to own PHandle and have a custom clone
//      that clones only objects with more than 1 refcount
class PObjGroup extends PObject{
    static name() { return "Group" }
    constructor() {
        super()
        this.v = []
        this.disp_params = []
    }
    add(obj, key) { // key should be integer index
        dassert(key !== undefined, "missing key for group add")
        this.v[key] = obj
    }
    get(key) {
        const v = this.v[key]
        if (v === undefined)
            return null
        return v
    }
    transform(m) {
        for(let obj of this.v) {
            obj.transform(m)
        }
    }
    async pre_draw(m, display_values) {
        //console.assert(Object.keys(display_values).length == this.v.length, "display_values length mismatch")
        for(let i in this.v) {
            dassert(display_values[i] !== undefined, "display_values doesn't include key " + i)
            await this.v[i].pre_draw(m, display_values[i])
        }        
    }
    draw(m, display_values) {
        //console.assert(Object.keys(display_values).length == this.v.length, "display_values length mismatch")
        for(let i in this.v) {
            dassert(display_values[i] !== undefined, "display_values doesn't include key " + i)
            this.v[i].draw(m, display_values[i])
        }
    }
    get_disp_params(values) {
        let r = new PGroupDispPrms()
        for(let i in this.v) {
            dassert(values[i] !== undefined, "missing disp_params in values index " + i)
            r.v[i] = this.v[i].get_disp_params(values[i])
        }
        return r 
    }
    draw_template(m) {
        for(let i in this.v) {
            this.v[i].draw_template(m)
        }        
    }

    describe(parent, dlg) {
        dlg.clear_desc()
        dlg.add_line("Group size: ").value_elem.innerText = Object.keys(this.v).length
        for(let k in this.v) {
            const v = this.v[k]
            const e = add_div(parent, "obj_inf_grp_obj")
            add_div(e, "obj_inf_grp_name").innerText = k + ": " + v.constructor.name()
            if (v.constructor === Mesh || v.constructor === MultiPath) {
                add_div(e, "obj_inf_grp_detail").innerText = "vertices: " + v.vtx_count();
                add_div(e, "obj_inf_grp_detail").innerText = "faces: " + v.face_count();
            }
        }
    }
}

// list of order in of items
// items are maps with { name: id: } only name is displayed
// simple reference: https://www.cssscript.com/demo/drag-drop-dragonflyjs/
class ParamInputOrderList extends ListParam
{
    constructor(node, label, table, sorted_order) {
        super(node, label, 1, table, Array)
        this.sorted_order = sorted_order  // list of indices
        this.sorted_d = [] // list of object that just contain the index. need to be an object since this number is modified on the fly
        this.dragged = null
        this.loaded_order = null
    }
    save() { return { sorted_order: this.sorted_order }}
    load(v) { this.loaded_order = v.sorted_order }
    post_load_hook() {
        // postpone loading sorted_order to after all lines are loaded for a final sort
        let new_d = []
        if (this.loaded_order === null)
            return
        for(let n of this.loaded_order) {
            console.assert(n >= 0 && n < this.sorted_d.length) // when does this happen?
            //if (!(n >= 0 && n < this.sorted_d.length))
            //    return
            new_d.push(this.sorted_d[n])
        }
        this.sorted_d = new_d
        this.loaded_order = null
        this.redo_sort()
    }

    create_elem(parent, start_val, index, change_func, get_cur_val) {
        let wrap = add_div(parent, "param_lst_order_cell")
        let elem = add_div(wrap, "param_lst_order_item")
        elem.innerText = start_val.name
        elem.p_lst_index = index // index of the item in the lst, before sorting
        let doc_mousemove = null, doc_mouseup = null

        elem.addEventListener('mousedown', (ev)=>{
            if (ev.buttons !== 1)
                return
            let trect = ev.target.getBoundingClientRect()
            let offset = [trect.left - ev.pageX, trect.top - ev.pageY - 2] // 2 for border

            let e = ev.target.cloneNode(true)
            e.style.position = 'fixed'
            e.style.top = ev.pageY + offset[1] + "px"
            e.style.left = ev.pageX + offset[0] + "px"
            e.style.width = trect.width - 11 + "px" // no idea
            e.style.pointerEvents = "none"
            edit_params.appendChild(e)

            this.dragged = {lst_index: ev.target.p_lst_index, elem: e, mouse_offset: offset }
            toggle_dragged_style(true)
           
            document.addEventListener('mousemove', doc_mousemove)
            document.addEventListener('mouseup', doc_mouseup)
        })

        let toggle_dragged_style = (v)=>{
            this.elem_lst[this.dragged.lst_index].classList.toggle("param_lst_order_drag_placeholder", v)
        }

        let do_drop = (to)=> {
            if (this.dragged.lst_index === to) 
                return
            const from_i = this.sorted_d.findIndex((d)=>{return d.lst_index == this.dragged.lst_index})
            this.sorted_d.splice(from_i, 1)

            const to_i = this.sorted_d.findIndex((d)=>{return d.lst_index == to})
            let offset = (to_i >= from_i)?1:0
            this.sorted_d.splice(to_i+offset, 0, {lst_index:this.dragged.lst_index})

            this.redo_sort()
            toggle_dragged_style(true)
        }
        myAddEventListener(elem, 'mousemove', (ev)=>{
            if (this.dragged === null)
                return
            this.dragged.elem.style.top = ev.pageY + this.dragged.mouse_offset[1] + "px"
            this.dragged.elem.style.left = ev.pageX + this.dragged.mouse_offset[0] + "px"
            const to = ev.target.p_lst_index
            do_drop(to)
        })

        doc_mousemove = (ev)=>{
            if (this.dragged === null)
                return
            this.dragged.elem.style.top = ev.pageY + this.dragged.mouse_offset[1] + "px"
            this.dragged.elem.style.left = ev.pageX + this.dragged.mouse_offset[0] + "px"
        }

        doc_mouseup = (ev)=>{
            if (this.dragged === null)
                return            
            edit_params.removeChild(this.dragged.elem)
            toggle_dragged_style(false)
            this.dragged = null

            document.removeEventListener('mousemove', doc_mousemove)
            document.removeEventListener('mouseup', doc_mouseup)
        }

        return elem
    }
    external_update(elem, value, index) {
        // nothing to do?
    }    

    idx_from_id(id) {
        return this.lst.findIndex((e)=>{return e.id === id})
    }    

    redo_sort() {  // produce sorted_order frmo sorted_d
        let changed = (this.sorted_d.length !== this.sorted_order.length)
        if (!changed)
            for(let i = 0; i < this.sorted_d.length; ++i)
                if (this.sorted_d[i].lst_index !== this.sorted_order[i]) {
                    changed = true
                    break
                }
        if (!changed)
            return
        this.sorted_order.length = 0
        for(let d of this.sorted_d)
            this.sorted_order.push(d.lst_index)
        this.table.remake_table()
        this.pset_dirty()
    }    
    add(v) {
        v.lst_index = this.lst.length // index in this.lst
        this.sorted_d.push({lst_index:v.lst_index})
        super.add(v) // need to be before redo_sort which recreates the table
        this.redo_sort()
    }
    remove(idx_lst) {
        console.assert(idx_lst.length == 1, "expected only single item to remove")
        let idx = idx_lst[0]
        let d = this.lst[idx]
        super.remove(idx_lst)
        let rm = this.sorted_d.findIndex((v)=>{return v.lst_index == d.lst_index})
        this.sorted_d.splice(rm, 1)
        // fix the indices of all the items that came after this item. (adjust for the culling of lst)
        for(let od of this.sorted_d)
            if (od.lst_index > d.lst_index)
                od.lst_index--;
        this.redo_sort()  
        return d      
    }
    
}

function mixin_multi_reorder_control(node, cls, sorted_order, in_m) 
{
    cls.order_table = new ParamTable(node, "Order", sorted_order)
    cls.order = new ParamInputOrderList(node, "OrderInputs", cls.order_table, sorted_order)
    cls.order_table.with_index_column = true
    cls.order_table.with_column_sep = false
    cls.did_connect = function(to_term, line) {
        if (to_term !== in_m)
            return
        const node = line.from_term.owner
        if (cls.order.idx_from_id(node.id) !== -1)
            return // already there
        const d = { name:node.name, 
                    id:node.id  } 
        d.rename_func = (new_name)=>{d.name = new_name; cls.order_table.remake_table()}
        node.register_rename_observer(d.rename_func)

        cls.order.add(d)
    }
    cls.doing_disconnect = function(to_term, line) {
        if (to_term !== in_m)
            return
        const node = line.from_term.owner
        const idx = cls.order.idx_from_id(node.id)
        console.assert(idx != -1)

        let d = cls.order.remove([idx])
        node.remove_rename_observer(d.rename_func)
    }
}


class NodeGroupObjects extends NodeCls {
    static name() { return "Group Objects" }
    constructor(node) {
        super(node)
        this.sorted_order = []
        
        this.in_m = new InTerminalMulti(node, "in_multi_mesh")
        this.out = new OutTerminal(node, "out_mesh")

        mixin_multi_reorder_control(node, this, this.sorted_order, this.in_m)
    }
    run() {
        this.node.display_values = {}
        let r = new PObjGroup()
        //for(let line of this.in_m.lines) {
        for(let idx of this.sorted_order) {
            const line = this.in_m.lines[idx]
            const obj = line.to_term.get_const()
            r.add(obj, idx)
            // gather the display nodes from the nodes that output the thing
            this.node.display_values[idx] = line.from_term.owner.display_values
        }
        this.out.set(r)
    }
}

class NodeGroupSelect extends NodeCls {
    static name() { return "Group Select" }
    constructor(node) {
        super(node)
        this.in_g = new InTerminal(node, "in_group")
        this.in_default = new InTerminal(node, "in_default")
        this.out = new OutTerminal(node, "out_obj")

        this.key_sel = new ParamInt(node, "Select Index", 0)
    }
    run() {
        const g = this.in_g.get_const();
        assert(g !== null, this, "missing input")
        assert(g.constructor === PObjGroup, this, "Expected group input")

        const key = this.key_sel.get_value()
        let v = g.get(key)
        if (v === null) {
            v = this.in_default.get_const();
        }
        assert(v !== null, this, "Index doesn't exist in group and no default")
        this.out.set(v)
    }

}



// maybe wrap with a proxy?
class NodeTransform extends NodeCls
{
    static name() { return "Transform" }
    constructor(node) {
        super(node)
        this.in = new InTerminal(node, "input")
        this.out = new OutTerminal(node, "output")
        this.transform = new ParamTransform(node, "transform")
        
        this.cached_obj = null
        this.cached_initial_tr = mat3.create() // if there's a cached obj, this is the transform it stated with when it was first cached
    }
    run() {
        assert(this.transform.is_valid(), this, "invalid transform")
        let obj = null
        // if the input didn't change and it supports setting the transform, we don't need to clone it again
        if (!this.in.is_dirty() && this.cached_obj !== null && this.cached_obj.set_transform !== undefined) {
            obj = this.cached_obj
            obj.set_transform(this.cached_initial_tr)
        }
        else {
            obj = this.in.get_mutable()
            assert(obj, this, "missing input")
            if (obj.set_transform !== undefined) {
                console.assert(obj.get_transform !== undefined)
                this.cached_obj = obj
                mat3.copy(this.cached_initial_tr, obj.get_transform())
            } 
        }
        obj.transform(this.transform.v)
        this.out.set(obj)
    }
    draw_selection(m) {
        let out = this.out.get_const()
        if (out === null) // No output object to select
            return
        this.transform.draw_dial_at_obj(out, m)
        out.draw_border(m)
    }    
    image_find_obj(e) {
        return this.transform.dial.find_obj(e)
    }
}

// need this since Math.random can't be seeded
class RandNumGen
{
    constructor(seed) {
        this.state = seed
    }
    next() {
        this.state = (this.state * 1664525 + 1013904223) % 4294967296
        return this.state / 4294967296
    }
}

function dist(ax, ay, bx, by) {
    let dx = ax - bx, dy = ay - by
    return Math.sqrt(dx*dx+dy*dy)
}
function m_dist(ax, ay, bx, by) {
    return Math.max(Math.abs(ax - bx), Math.abs(ay - by))
}

function distance2(a, b) {
    var dx = b[0] - a[0], dy = b[1] - a[1];
    return dx * dx + dy * dy;
  }
  

class Timer {
    constructor() {
        this.start = new Date().valueOf()
    }
    elapsed() {
        return new Date().valueOf() - this.start
    }
}



// https://www.sidefx.com/docs/houdini/nodes/sop/scatter.html
// https://www.jasondavies.com/poisson-disc/
class NodeRandomPoints extends NodeCls
{
    static name() { return "Scatter Uniform" }
    constructor(node) {
        super(node)
        node.set_state_evaluators({"vtx_pos":  (m,s)=>{ return new ObjSubscriptEvaluator(m,s) }} )        

        this.in_obj = new InTerminal(node, "in_obj")
        this.out_mesh = new OutTerminal(node, "out_mesh")
        this.seed = new ParamInt(node, "Seed", 1)
        this.min_dist = new ParamFloat(node, "Min Distance", 0.02, [0.02, 0.5])
        // example: 0.05 + 0.03*sin(vtx_pos.x*6)

        //this.by_density.change_func() // enact the changes it does
    }
        
    run() {
        let in_obj = this.in_obj.get_const()
        assert(in_obj !== null, this, "No mesh input")
        assert(in_obj.get_bbox !== undefined, this, "Input does not define a bounding box")
        let bbox = in_obj.get_bbox()  // TBD cut into shape if shape allows that
        assert(bbox !== null, this, "Object doesn't have content for a bounding box")

        let vtx = [] 
        const r = this.min_dist.v
        assert(r !== null, this, "varying distance not supported by this node")
        const inner2 = r * r
        const A = 4 * r * r - inner2
        const cellSize = r * Math.SQRT1_2
        const gridWidth = Math.ceil(bbox.width() / cellSize), gridHeight = Math.ceil(bbox.height() / cellSize)
        const min_x = bbox.min_x, min_y = bbox.min_y, hw = bbox.width()/2, hh = bbox.height()/2  // for centering the grid
        const grid = new Array(gridWidth * gridHeight)
        const tries_k = 20

        //let timer = new Timer()

        function emitSample(p) {
            queue.push(p)
            vtx.push(p[0], p[1])
            const gx = (p[0] - min_x) / cellSize | 0
            const gy = (p[1] - min_y) / cellSize | 0
            if (gx < 0 || gy < 0 || gx >= gridWidth || gy >= gridHeight)
                return             
            grid[gridWidth * gy + gx] = p;
        }

        function generateAround(p) {
            let phi = prng.next() * 2 * Math.PI
            let r = Math.sqrt(prng.next() * A + inner2); 
            return [p[0] + r * Math.cos(phi), p[1] + r * Math.sin(phi)];  
        }

        function withinExtent(p) {
            const x = p[0], y = p[1];
            return bbox.min_x <= x && x <= bbox.max_x && bbox.min_y <= y && y <= bbox.max_y;
        }
        function near(p) {
            const n = 1
            const gx = (p[0] - min_x ) / cellSize | 0
            const gy = (p[1] - min_y ) / cellSize | 0
            if (gx < 0 || gy < 0 || gx >= gridWidth || gy >= gridHeight)
                return true // prevent it 
            const x0 = Math.max(gx - n, 0)
            const y0 = Math.max(gy - n, 0)
            const x1 = Math.min(gx + n + 1, gridWidth)
            const y1 = Math.min(gy + n + 1, gridHeight);
            for (let y = y0; y < y1; ++y) {
                let o = y * gridWidth;
                for (let x = x0; x < x1; ++x) {
                    let g = grid[o + x];
                    if (g && distance2(g, p) < inner2) 
                        return true;
                }
            }
            return false;
        }
        
        const prng = new RandNumGen(this.seed.v)

        const queue = []
        emitSample([bbox.min_x + bbox.width()*prng.next(), bbox.min_y + bbox.height()*prng.next()]);
        
        while (queue.length > 0) {
            let i = prng.next() * queue.length | 0
            let p = queue[i], j

            
            for (j = 0; j < tries_k; ++j) {
                let q = generateAround(p);
                if (!withinExtent(q))
                    continue
                if (near(q)) 
                    continue
                emitSample(q);
                break;
            }
            if (j === tries_k) { // exhausted all possibilites with this point in the queue
                queue[i] = queue[queue.length-1]
                queue.pop();   
            }
            //if (vtx.length > 10000)
            //    break
        }
        //assert(!too_many_zeros, this, "Expression evaluates to zero too much")

        if (in_obj.is_point_inside) {
            let vtx_in = []
            for(let i = 0; i < vtx.length; i += 2) {
                let x = vtx[i], y = vtx[i + 1]
                if (!in_obj.is_point_inside(x, y))
                    continue               
                vtx_in.push(x, y)
            }
            vtx = vtx_in
        }
      
        const ret = new Mesh()
        ret.set("vtx_pos", new TVtxArr(vtx), 2)
        ret.type = MESH_POINTS
        this.out_mesh.set(ret)
        
        //console.log("Scatter: ", vtx.length, "  ", timer.elapsed(), "msec")
    }
}


class NodeTriangulate extends NodeCls
{
    static name() { return "Triangulate" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_obj")
        this.out_mesh = new OutTerminal(node, "out_mesh")        
    }
    run() {
        let obj = this.in_obj.get_const()
        assert(obj !== null, this, "Missing input mesh")
        assert(obj.arrs !== undefined && obj.arrs.vtx_pos !== undefined, this, "Input doesn't have vertices. type: " + obj.constructor.name())

        if (obj.constructor === Mesh) {
            // do this even if the mesh is already triangle mesh so that we'll get the true triangulation
            let obj = this.in_obj.get_mutable()
            let d = new Delaunator(obj.effective_vtx_pos)
            obj.set('idx', d.triangles)
            obj.set_type(MESH_TRI)
            obj.halfedges = d.halfedges
            obj.hull = d.hull
            this.out_mesh.set(obj)
        }
        else if (obj.constructor === MultiPath) {
            let out_mesh = triangulate_path(obj, this)
            this.out_mesh.set(out_mesh)
        }
    }
}

// build my kind of path from canvas ops
class PathsBuilder {
    constructor() {
        this.vtx_pos = []
        this.paths_ranges = []
        this.from_arr = [] // for each face, from what vertex index it came from 
    }
    moveTo(x,y, from_idx) {
        let l = this.vtx_pos.length / 2
        this.paths_ranges.push(l,l+1,0)
        this.vtx_pos.push(x,y)
        this.from_arr.push(from_idx)
    }
    lineTo(x,y) {
        ++this.paths_ranges[this.paths_ranges.length-2]
        this.vtx_pos.push(x,y)
    }
    closePath() {
        this.paths_ranges[this.paths_ranges.length-1] = 1
    }
    finalize(paths) {
        paths.set('vtx_pos', this.vtx_pos, 2, false)
        paths.paths_ranges = this.paths_ranges
    }
}


class NodeVoronoi extends NodeCls
{
    static name() { return "Voronoi" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_mesh")
        this.out_mesh = new OutTerminal(node, "out_paths")
        this.margin = new ParamVec2(node, "Margin", 0.2, 0.2)
    }
    run() {
        let mesh = this.in_obj.get_const()
        assert(mesh !== null, this, "Missing input mesh")
        assert(mesh.arrs !== undefined && mesh.arrs.vtx_pos !== undefined, this, "Input doesn't have vertices. type: " + mesh.constructor.name())
        assert(mesh.halfedges !== undefined && mesh.hull !== undefined, this, "missing halfedges or hull")
        // voronoi for multiple paths or of non-convex path is not well-defined
        // there is a result but it might have holes (actually degenerate paths with just 2 points). 
        // To make it do the "right thing" the paths
        // itself need to be the hulls (and not the delaunay hull) as is computed in paths triangulate
        // but that would also not look good since the separate voronois would intersect each other
        // it is possible to introduce the concept of multiple hulls into the algorithm but I didn't do it

        let bbox = mesh.get_bbox()
        let mx = this.margin.x, my = this.margin.y

        let delaunay = { triangles:mesh.arrs.idx, points:mesh.effective_vtx_pos, halfedges:mesh.halfedges, hull:mesh.hull }
        let voronoi = new Voronoi(delaunay, [bbox.min_x-mx,bbox.min_y-my, bbox.max_x+mx,bbox.max_y+my]);
        let builder = new PathsBuilder()
        voronoi.renderCells(builder)
        let new_paths = new MultiPath()
        builder.finalize(new_paths)

        // transfer vertex attributes to face attributes
        for(let arr_name in mesh.arrs) {
            if (!arr_name.startsWith("vtx_") || arr_name === "vtx_pos")
                continue
            
            let from_arr = mesh.arrs[arr_name]
            let num_elems = mesh.meta[arr_name].num_elems
            let idx_src = builder.from_arr;

            let new_arr = new from_arr.constructor(idx_src.length * num_elems)
            let ni = 0
            for(let idx of idx_src) {
                for(let i = 0; i < num_elems; ++i) {
                    new_arr[ni++] = from_arr[idx*num_elems+i]  
                }
            }
            new_paths.set("face_" + arr_name.substr(4), new_arr, num_elems, mesh.meta[arr_name].need_normalize)
    
        }


        this.out_mesh.set(new_paths)
    }
}


class NodeGeomDivide extends NodeCls
{
    static name() { return "Divide" }
    constructor(node) {
        super(node)
        this.in_mesh = new InTerminal(node, "in_mesh")
        this.out_mesh = new OutTerminal(node, "out_mesh")
        this.by_dist = new ParamBool(node, "Set distance", false, (v)=>{
            this.divisions.set_enable(!v)
            this.distance.set_enable(v)
            this.distance_uv.set_enable(v)
            this.sep_uv.set_enable(v)
            this.exact.set_enable(v)
        })
        this.divisions = new ParamInt(node, "Divisions", 4, {min:1, max:10})
        this.sep_uv = new ParamBool(node, "Separate U-V", false, (v)=>{
            this.distance.set_visible(!v)
            this.distance_uv.set_visible(v)
        })
        this.distance = new ParamFloat(node, "Distance", 0.1)
        this.distance_uv = new ParamVec2(node, "Distance U-V", 0.1, 0.1)
        this.exact = new ParamBool(node, "Exact", false)

        node.param_alias("Set approximate distance", this.by_dist)
    }

    divide_quad(mesh, out_vtx, out_idx, idx0, idx1, idx2, idx3) {
        // assumes it's a parallelogram
        const vtx = mesh.effective_vtx_pos
        const p0_x = vtx[idx0*2], p0_y = vtx[idx0*2+1]
        const p1_x = vtx[idx1*2], p1_y = vtx[idx1*2+1]
        const p3_x = vtx[idx3*2], p3_y = vtx[idx3*2+1]
        let da_x = p1_x - p0_x, da_y = p1_y - p0_y // vector a from 0 to 1
        let db_x = p3_x - p0_x, db_y = p3_y - p0_y // vector b from 0 to 3

        let div_a, div_b;
        if (!this.by_dist.v)
            div_a = div_b = this.divisions.v;
        else {
            let dist_a, dist_b
            if (this.sep_uv.v) {
                dist_a = this.distance_uv.y, dist_b = this.distance_uv.x
            }
            else {
                dist_a = this.distance.v, dist_b = this.distance.v
            }
            assert(dist_a !== 0 && dist_b !== 0, this, "Division by zero")
            const da_len = Math.sqrt(da_x*da_x + da_y*da_y)
            div_a = Math.round(da_len/dist_a)
            const db_len = Math.sqrt(db_x*db_x + db_y*db_y)
            div_b = Math.round(db_len/dist_b) // how many dividers
            if (this.exact.v) {
                const new_da_len = dist_a*div_a, new_db_len=dist_b*div_b
                da_x *= new_da_len/da_len
                da_y *= new_da_len/da_len
                db_x *= new_db_len/db_len
                db_y *= new_db_len/db_len
            }   
        }
        assert(div_a != 0 && div_b != 0, this, "Division by zero")
        
        da_x /= div_a; da_y /= div_a
        db_x /= div_b; db_y /= div_b

        const vtx_start = out_vtx.length / mesh.meta.vtx_pos.num_elems
        for(let bi = 0; bi <= div_b; ++bi) {
            for(let ai = 0; ai <= div_a; ++ai) {
                const np_x = p0_x + da_x*ai + db_x*bi
                const np_y = p0_y + da_y*ai + db_y*bi
                out_vtx.push(np_x, np_y)
            }
        }

        // quads
        const sz_a = div_a+1
        for(let ai = 0; ai < div_a; ++ai) {
            for(let bi = 0; bi < div_b; ++bi) {
                const idx0 = ai+bi*sz_a
                const idx1 = idx0+1
                const idx2 = idx1+sz_a
                const idx3 = idx0+sz_a
                out_idx.push(vtx_start + idx0, vtx_start + idx1, vtx_start + idx2, vtx_start + idx3)
            }
        }
    }

    divide_line(out_vtx, prev_x, prev_y, x, y, add_last)
    {
        let da_x = x - prev_x, da_y = y - prev_y
        let div_a
        if (!this.by_dist.v)
            div_a = this.divisions.v;
        else {
            const dist = this.distance.v
            div_a = Math.round(Math.sqrt(da_x*da_x + da_y*da_y)/dist)
        }
        da_x /= div_a; da_y /= div_a
        if (add_last)
            div_a += 1
        for(let ai = 0; ai < div_a; ++ai) {
            const np_x = prev_x + da_x*ai
            const np_y = prev_y + da_y*ai
            out_vtx.push(np_x, np_y)
        }
    }

    run() {
        let obj = this.in_mesh.get_const()
        assert(obj !== null, this, "Missing input points")

        if (this.by_dist.v)
            assert(this.distance.v != 0, this, "Division by zero")
        if (obj.constructor === Mesh && obj.type == MESH_QUAD) 
        {
            // quad divides to little quads
            // each quad separately, not unifying vertices from different quads
            const out_vtx = [], out_idx = []
            const idx = obj.arrs.idx
            for(let i = 0; i < idx.length; i += 4) {
                this.divide_quad(obj, out_vtx, out_idx, idx[i], idx[i+1], idx[i+2], idx[i+3])
            }
            const out_mesh = new Mesh()
            out_mesh.set('vtx_pos', new TVtxArr(out_vtx), 2, false)
            out_mesh.set('idx', new TIdxArr(out_idx))
            out_mesh.type = MESH_QUAD
            this.out_mesh.set(out_mesh)
        }
        else if (obj.constructor === MultiPath) {
            const vtx = obj.effective_vtx_pos
            const out_vtx = [], out_ranges = []
            for(let pri = 0; pri < obj.paths_ranges.length; pri += 3) {
                const start_vidx = obj.paths_ranges[pri]*2
                const end_vidx = obj.paths_ranges[pri+1]*2
                const flags = obj.paths_ranges[pri+2]
                const closed = flags & PATH_CLOSED
                let prev_x = vtx[end_vidx-2], prev_y = vtx[end_vidx-2+1]
                const out_start = out_vtx.length
                let first_line = true
                for(let vidx = start_vidx; vidx < end_vidx; vidx += 2) {
                    const x = vtx[vidx], y = vtx[vidx+1]
                    const is_real_line = (!first_line) || (first_line && closed)
                    if (is_real_line) {
                        // in unclosed path, the last line should also include the last point since there's no line coming out of that point to complete it
                        this.divide_line(out_vtx, prev_x, prev_y, x, y, !closed && (vidx == end_vidx - 2))
                    }
                    prev_x = x; prev_y = y
                    first_line = false
                }
                const out_end = out_vtx.length
                out_ranges.push(out_start, out_end, flags)
            }
            const out_paths = new MultiPath()
            out_paths.paths_ranges = out_ranges
            out_paths.set('vtx_pos', new TVtxArr(out_vtx), 2, false)
            this.out_mesh.set(out_paths)
        }
        else {
            assert(false, this, "unexpected geometry")
        }
    }
}

// for debugging
class LinesObj extends PObject
{
    static name() { return "Lines" }
    constructor(lines) {
        super()
        this.lines = lines
    }
    draw_m(m) {
        ctx_img.beginPath();
        for(let l of this.lines) {
            ctx_img.moveTo(l[0][0], l[0][1])
            ctx_img.lineTo(l[1][0], l[1][1])
        }
        ctx_img.strokeStyle = "#000"
        ctx_img.lineWidth = 1 / image_view.viewport_zoom
        ctx_img.stroke()
    }
    draw_template_m(m) {
    }
}


function mesh_lines(idxs, vtx, face_size) {
    let lines = []
    for(let i = 0; i < idxs.length; i += face_size) {
        for(let j = 0; j < face_size; ++j) {
            let idx = idxs[i+j]
            let vidx = idx<<1
            let p_cur = vec2.fromValues(vtx[vidx], vtx[vidx+1])
            p_cur.from_idx = idx
            let idx_next = idxs[i+((j+1) % face_size)]
            let vidx_next = idx_next<<1
            let p_next = vec2.fromValues(vtx[vidx_next], vtx[vidx_next+1])
            p_next.from_idx = idx_next
            lines.push([p_cur, p_next])
        }
    }
    return lines
}

// TBD skip open paths
function path_lines(paths_ranges, vtx) {
    let lines = [], face_sizes = []
    for(let pri = 0; pri < paths_ranges.length; pri += 3) {
        let start_idx = paths_ranges[pri]
        let end_idx = paths_ranges[pri+1]
        let start_vidx = start_idx*2, end_vidx = end_idx*2
        let prev_x = vtx[end_vidx-2], prev_y = vtx[end_vidx-1]
        let prev_from_idx = end_idx-1
        for(let vidx = start_vidx; vidx < end_vidx; vidx += 2) {
            let p_prev = vec2.fromValues(prev_x, prev_y)
            p_prev.from_idx = prev_from_idx
            let x = vtx[vidx], y = vtx[vidx+1]
            let p_cur = vec2.fromValues(x, y)
            p_cur.from_idx = vidx/2
            prev_x = x, prev_y = y, prev_from_idx = p_cur.from_idx
            lines.push([p_prev, p_cur])
        }
        face_sizes.push(end_idx - start_idx)
    }
    return [lines, face_sizes]
}

function inset_lines(lines, width) {
    let from_to = vec2.create(), ort = vec2.create()

    for(let l of lines) {
        vec2.subtract(from_to, l[1], l[0])
        vec2.normalize(from_to, from_to)
        vec2.set(ort, from_to[1], -from_to[0]) // orthogonal
        //vec2.set(ort, from_to[1], -from_to[0]) // orthogonal
        vec2.scaleAndAdd(l[0], l[0], ort, width)
        vec2.scaleAndAdd(l[1], l[1], ort, width)     
    }
    return lines
}

// with paths, detect and skip a line that goes the other way that the rest of the poly since it was too short
// https://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order
function skip_short_knots(intersections) 
{    
    let path_lines = []
    for(let i = 0; i < intersections.length; ++i)
        path_lines.push([intersections[i], intersections[(i+1)%intersections.length]])

    let found, len = path_lines.length
    if (len == 3)
        return
    do {
        found = false
        // go over the path with 3 indices, look for middle that's different in sign from ends
        let a, b, c, np;
        for(a = 0; a < len; ++a) {
            b = (a+1)%len, c = (a+2)%len
            np = get_line_intersection(path_lines[a], path_lines[c], false)
            if (np !== null) {
                found = true;
                break;
            }
        }
        if (found) {
            np.from_idx = intersections[b].from_idx
            intersections.splice(b, 1, np)
            intersections.splice((b+1)%len, 1)
            path_lines.splice(b, 1)
        }
        len = path_lines.length
    } while(found && len > 3) // if we found one knot and removed it, try to find another one
}

function get_line_intersection(l0, l1, allow_overshoot) 
{
    const p0_x = l0[0][0], p0_y = l0[0][1]
    const p1_x = l0[1][0], p1_y = l0[1][1]
    const p2_x = l1[0][0], p2_y = l1[0][1]
    const p3_x = l1[1][0], p3_y = l1[1][1]
    const s1_x = p1_x - p0_x;
    const s1_y = p1_y - p0_y;
    const s2_x = p3_x - p2_x;
    const s2_y = p3_y - p2_y;
    const s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
    const t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
    if (allow_overshoot || (s >= 0 && s <= 1 && t >= 0 && t <= 1))
    {
        // intersect detected
        const i_x = p0_x + (t * s1_x);
        const i_y = p0_y + (t * s1_y);
        return vec2.fromValues(i_x, i_y);
    }
    return null; // No collision
}



function fast_miter_run(mesh, offset, allow_overshoot, nodecls) 
{
    assert(mesh !== null, nodecls, "missing input mesh")
    //assert(mesh.face_size !== undefined, this, "input needs to be a mesh")

    // a line is a list of two points. `lines` has `face_size` lines for each face
    // if face_sizes is not null, then it's different size for every face
    if (mesh.constructor == Mesh) {
        var const_face_size = mesh.face_size()
        var lines = mesh_lines(mesh.arrs.idx, mesh.effective_vtx_pos, const_face_size)
        var face_sizes = null
    }
    else if (mesh.constructor == MultiPath) {
        var const_face_size = null
        var [lines, face_sizes] = path_lines(mesh.paths_ranges, mesh.effective_vtx_pos)
    }
    else {
        assert(false, nodecls, "input needs to be mesh or paths")
    }
    lines = inset_lines(lines, offset) // in-place


    //this.out_mesh.set(new LinesObj(lines))
    //return

    let new_vtx = [], new_idx = [], from_face = [], new_ranges = []
    let from_vidx = [] // for every vertex pushed to new_vtx, what's the index of the vertex in the original object it came from

    let ri = 0
    let cur_face_size = const_face_size
    for (let i = 0, fi = 0; i < lines.length; i += cur_face_size, ++fi) 
    {
        if (face_sizes !== null)
            cur_face_size = face_sizes[fi]

        let got_null = false, intersections = []
        for(let j = 0; j < cur_face_size; ++j) {
            let p = get_line_intersection(lines[i+j], lines[i+((j+1) % cur_face_size)], allow_overshoot)
            if (p === null) {
                got_null = true
                break
            }
            p.from_idx = lines[i+j][1].from_idx
            intersections.push(p)
        }
        if (mesh.constructor == MultiPath) { // knots
            skip_short_knots(intersections)
        }

        if (got_null)
            continue
        let start_idx = ri
        for(let p of intersections) {
            new_vtx.push(p[0], p[1])
            from_vidx.push(p.from_idx)
            new_idx.push(ri)
            ri += 1
        }
        new_ranges.push(start_idx, ri, PATH_CLOSED)
        from_face.push(fi)
    }
    // build output vertices and polys
    let out_obj = null
    if (mesh.constructor == Mesh) {
        out_obj = new Mesh()
        out_obj.set('idx', new TIdxArr(new_idx))
        out_obj.set_type(mesh.type)
    }
    else { // MultiPath
        out_obj = new MultiPath()
        out_obj.paths_ranges = new_ranges;
    }
    out_obj.set('vtx_pos', new TVtxArr(new_vtx), 2)

    // transfer other attributes
    for(let arr_name in mesh.arrs) {
        if (arr_name == "idx" || arr_name == "vtx_pos")
            continue
        
        let from_arr = mesh.arrs[arr_name]
        let num_elems = mesh.meta[arr_name].num_elems
        let idx_src;
        if (arr_name.startsWith("vtx_")) 
            idx_src = from_vidx
        else if (arr_name.startsWith("face_")) 
            idx_src = from_face
        else
            continue

        let new_arr = new from_arr.constructor(idx_src.length * num_elems)
        let ni = 0

        for(let idx of idx_src) {
            for(let i = 0; i < num_elems; ++i) {
                new_arr[ni++] = from_arr[idx*num_elems+i]  
            }
        }
        out_obj.set(arr_name, new_arr, num_elems, mesh.meta[arr_name].need_normalize)
    }
    out_obj.fill_objs = clone_fill_objs(mesh.fill_objs)
    return out_obj
}


class NodeOffsetPath extends NodeCls {
    static name() { return "Offset Path" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_obj")
        this.out_obj = new OutTerminal(node, "out_obj")    
        this.offset = new ParamFloat(node, "Offset", 0.1, [-0.2,0.2])
        const arcTolVis = ()=>{
            this.arcTol.set_visible(this.point_type.sel_idx == 4 || this.open_op.sel_idx == 1)
        }
        this.point_type = new ParamSelect(node, "Point Type", 0, [["Square", ClipperLib.JoinType.jtSquare], 
                                                                  ["Miter", ClipperLib.JoinType.jtMiterAlways],
                                                                  ["Miter Thresh", ClipperLib.JoinType.jtMiter], 
                                                                  ["Fast Miter", -1],
                                                                  ["Round", ClipperLib.JoinType.jtRound]], (sel_idx)=>{
            this.miterLimit.set_visible(sel_idx === 2)
            this.closed_op.set_visible(sel_idx !== 3)
            this.open_op.set_visible(sel_idx !== 3)
            this.allow_overshoot.set_visible(sel_idx === 3)
            arcTolVis()        
        })
        this.closed_op = new ParamSelect(node, "Closed Paths", 0, [["Polygon", ClipperLib.EndType.etClosedPolygon],
                                                                   ["Line", ClipperLib.EndType.etClosedLine]])
        this.open_op = new ParamSelect(node, "Open Paths", 0, [["Square", ClipperLib.EndType.etOpenSquare],
                                                               ["Round", ClipperLib.EndType.etOpenRound],
                                                               ["Butt", ClipperLib.EndType.etOpenButt]], arcTolVis)

        this.miterLimit = new ParamFloat(node, "Miter Thresh", 2.0, [1.0, 4.0]) // sharp edges limit
        this.arcTol = new ParamFloat(node, "Arc Step", 0.002, [0.0001, 0.01]) 
        
        this.allow_overshoot = new ParamBool(node, "Allow over-shoot", false) 
    }


    run() {
        const obj = this.in_obj.get_const()
        assert(obj !== null, this, "missing input mesh")
        if (this.point_type.sel_idx == 3) {
            const new_obj = fast_miter_run(obj, -this.offset.get_value(), this.allow_overshoot.get_value(), this)
            this.out_obj.set(new_obj)
            return
        }

        let arcTol = this.arcTol.get_value()
        if (arcTol <= 0)
            arcTol = 0.1
        ClipperLib.use_xyz = true
        const co = new ClipperLib.ClipperOffset(this.miterLimit.get_value() * CLIPPER_SCALE, arcTol * CLIPPER_SCALE)
        co.ZFillFunction = (bot1, top1, bot2, top2, pt)=>{
            // getting the two lines that intersect, get the Z from the point that is the same on both lines, the common point to both lines
            if (bot1.Z == top1.Z)      pt.Z = bot1.Z
            else if (bot1.Z == bot2.Z) pt.Z = bot1.Z
            else if (bot1.Z == top2.Z) pt.Z = bot1.Z
            else if (top1.Z == bot2.Z) pt.Z = top1.Z
            else if (top1.Z == top2.Z) pt.Z = top1.Z
            else if (bot2.Z == top2.Z) pt.Z = bot2.Z
            else pt.Z = -1
        }
        const paths = obj.ensure_clipper(true)

        for(let p of paths) {
            co.AddPath(p, this.point_type.get_sel_val(), p.closed ? this.closed_op.get_sel_val() : this.open_op.get_sel_val())
        }
        let p_res = new ClipperLib.Paths()
        co.Execute(p_res, this.offset.get_value() * CLIPPER_SCALE);

        p_res = ClipperLib.JS.Lighten(p_res, 0.000001 * CLIPPER_SCALE);
        ClipperLib.use_xyz = false
        let new_obj = new MultiPath()
        
        const xfer_indices = new_obj.from_clipper_paths(p_res)
        // returned for every element in the new vtx_pos, what index it came from from the original vtx_pos (unmultiplied)

        // transfer other attributes
        for(let arr_name in obj.arrs) {
            if (arr_name == "idx" || arr_name == "vtx_pos")
                continue
            
            let src_arr = obj.arrs[arr_name]
            let num_elems = obj.meta[arr_name].num_elems
            // it's meaningful to transfer only vertices since faces may be merged
            if (!arr_name.startsWith("vtx_")) 
                continue

            let new_arr = new src_arr.constructor(xfer_indices.length * num_elems)
            let ni = 0

            for(let idx of xfer_indices) {
                if (idx !== -1)
                    for(let i = 0; i < num_elems; ++i) 
                        new_arr[ni++] = src_arr[idx*num_elems+i]  
                else  // happens when two expansions collide so there's no vertex use as sourse
                    for(let i = 0; i < num_elems; ++i) 
                        new_arr[ni++] = 0 // need some default value, this is as good as any  
            }
            new_obj.set(arr_name, new_arr, num_elems, obj.meta[arr_name].need_normalize)
        }        

        this.out_obj.set(new_obj)

    }
}
"use strict"

var gl = null


function draw_rect(top_left, bottom_right, m, tmat, line_color)
{
    // we don't want to draw this under the canvas transform since that would also transform the line width
    // need 4 points for the rect to make it rotate
    let tl = vec2.clone(top_left), br = vec2.clone(bottom_right)
    let tr = vec2.fromValues(br[0], tl[1]), bl = vec2.fromValues(tl[0], br[1])

    let w_mat = mat3.create()
    mat3.multiply(w_mat, w_mat, m)
    mat3.multiply(w_mat, w_mat, tmat)
    vec2.transformMat3(tl, tl, w_mat)
    vec2.transformMat3(tr, tr, w_mat)
    vec2.transformMat3(bl, bl, w_mat)
    vec2.transformMat3(br, br, w_mat)

    ctx_img.beginPath()
    closed_line(ctx_img, [tl[0],tl[1], tr[0],tr[1], br[0],br[1], bl[0],bl[1]])
    ctx_img.strokeStyle = line_color
    ctx_img.lineWidth = MESH_DISP.line_width
    ctx_img.stroke()
}

class ImageBase extends PObject
{
    static name() { return "Image" }
    constructor(sz_x, sz_y, smooth, spread) {
        super()
        this.t_mat = mat3.create() 
        this.smooth = smooth
        this.spread = spread // "pad", "reflect", "repeat"
        this.sz_x = sz_x // logical size in world coords
        this.sz_y = sz_y

        let hw = sz_x * 0.5
        let hh = sz_y * 0.5
        this.top_left = vec2.fromValues(-hw,-hh)
        this.bottom_right = vec2.fromValues(hw,hh)
    }

    logical_size() { return [this.sz_x, this.sz_y] }
    set_smooth(v) { this.smooth = v }

    set_transform(m) { mat3.copy(this.t_mat, m) }
    get_transform() { return this.t_mat }
    transform(m) { mat3.multiply(this.t_mat, m, this.t_mat) } 

    draw_image(img_impl, m) { // called from derived draw()
        let tl = this.top_left, br = this.bottom_right

        // there's a half pixel mistake here when drawing a image with odd width on a texture of even width but I can't find how to fix it
        let w_mat = mat3.create()
        mat3.multiply(w_mat, w_mat, m)
        mat3.multiply(w_mat, w_mat, this.t_mat)

        ctx_img.save()
        canvas_setTransform(ctx_img, w_mat)
        ctx_img.imageSmoothingEnabled = this.smooth
        ctx_img.drawImage(img_impl, tl[0], tl[1], br[0] - tl[0], br[1] - tl[1])
        ctx_img.restore()   
    }

    get_bbox() { 
        const mn = vec2.fromValues(Number.MAX_VALUE, Number.MAX_VALUE), mx = vec2.fromValues(-Number.MAX_VALUE, -Number.MAX_VALUE)
        const p = vec2.create()
        const mnmx = (ep)=>{            
            vec2.transformMat3(p, ep, this.t_mat)
            vec2.min(mn, mn, p)
            vec2.max(mx, mx, p)
        }
        mnmx(this.top_left)
        mnmx(this.bottom_right)
        mnmx(vec2.fromValues(this.top_left[0], this.bottom_right[1]))
        mnmx(vec2.fromValues(this.bottom_right[0], this.top_left[1]))
        return new BBox(mn[0], mn[1], mx[0], mx[1])
    }

    // return "pad", "repeat" or "reflect"
    get_spread() { 
        return this.spread
    }

    draw_border(m, line_color="#000") {
        draw_rect(this.top_left, this.bottom_right, m, this.t_mat, line_color)
    } 

    draw_template(m) {
        this.draw_border(m, TEMPLATE_LINE_COLOR)
    }

    // image interface
    width() { dassert(false, "width not implemented") }
    height() { dassert(false, "height not implemented") }
    get_pixels() { dassert(false, "get_pixels not implemented") }
    
    
}

// frame buffer is a texture that covers the canvas and only the canvas
class FrameBuffer extends ImageBase
{
    static name() { return "FrameBuffer" }
    constructor(tex_obj, sz_x, sz_y, smooth, type, spread) {
        super(sz_x, sz_y, smooth, spread)
        this.tex_obj = tex_obj
        this.pixels = null
        this.imgBitmap = null
        this.type = type // str
    }

    // TBDno need for destructor, the texture is owned by the NodeShader that created it
    width() { return this.tex_obj.width }
    height() { return this.tex_obj.height }

    get_pixels() {
        if (this.pixels === null) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gl.my_fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.tex_obj, 0);
            //let pixels = new Uint8ClampedArray(this.tex_obj.width * this.tex_obj.height * 4) // problem in firefox
            if (this.type === "rgba") {
                this.pixels = new Uint8Array(this.tex_obj.width * this.tex_obj.height * 4)
                gl.readPixels(0, 0, this.tex_obj.width, this.tex_obj.height, gl.RGBA, gl.UNSIGNED_BYTE, this.pixels);
            }
            else if (this.type === "float") {
                this.pixels = new Float32Array(this.tex_obj.width * this.tex_obj.height)
                gl.readPixels(0, 0, this.tex_obj.width, this.tex_obj.height, gl.RED, gl.FLOAT, this.pixels);
            }
            else 
                dassert(false, "unexpected type: " + this.type)
        }
        return this.pixels
    }

/*    async pre_draw_x(m, disp_values) { // old way to do it with always get_pixels
        if (this.imgBitmap === null) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.tex_obj, 0);
            //console.assert(gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) //slows things down

            // get the pixels from webgl
            let pixels = this.get_pixels(xxx)
            dassert(pixels !== null, "Image is empty")
            let pixelsc = new Uint8ClampedArray(pixels)
            let img_data = new ImageData(pixelsc, this.tex_obj.width, this.tex_obj.height)

            this.imgBitmap = await createImageBitmap(img_data)
        }        
    }*/

    async pre_draw(m, disp_values) {
        if (this.tex_obj.width === 0 || this.tex_obj.height === 0)
            return // happens when an file image was not loaded yet
        // cached for the same of PImage which needs to only generate this once and reuses the output object
        if (this.imgBitmap === null)
            this.imgBitmap = await renderTexToImgBitmap(this.tex_obj)
    }

    draw(m, disp_values) {
        dassert(this.imgBitmap !== null, "Missing imgBitmap")
        this.draw_image(this.imgBitmap, m)
    }
    
    invalidate_img() {
        this.imgBitmap = null
        this.pixels = null
    }
    get_transform_to_pixels() {
        let transform = mat3.create()
        // half in the case of frame buffer since frame buffers are sized 2x2 (actually sz_x*sz_y)
        let hsf = vec2.fromValues(this.width()/2, this.height()/2) // yea.. I don't know why but that works.
        let hs = vec2.fromValues(this.width()/this.sz_x, this.height()/this.sz_y)
        mat3.translate(transform, transform, hsf)
        mat3.scale(transform, transform, hs)
        let inv_t = mat3.create()
        mat3.invert(inv_t, this.t_mat)     
        mat3.mul(transform, transform, inv_t)    
        return transform
    }
    make_gl_texture() {
        dassert(this.tex_obj !== null, "No texture in object")
        this.tex_obj.t_mat = mat3.create()
        mat3.copy(this.tex_obj.t_mat, this.t_mat)
        return this.tex_obj
    }

    describe(parent, dlg)
    {
        if (dlg.recreate_if_needed(this)) {
            dlg.eobj.px_sz = dlg.add_line("Size in Pixels: ").value_elem
            dlg.eobj.log_sz = dlg.add_line("Size in Units: ").value_elem
            dlg.eobj.type = dlg.add_line("Type: ").value_elem
            dlg.eobj.smooth = dlg.add_line("Smoothing: ").value_elem
            dlg.eobj.spread = dlg.add_line("Spread: ").value_elem
            dlg.eobj.tr = dlg.add_line("Transform: ", true).value_elem
            dlg.eobj.tr.classList.add("obj_inf_var_matrix")
            dlg.adjust_labels()
        }
        dlg.eobj.px_sz.innerText = this.width() + " x " + this.height()
        const log_sz = this.logical_size()
        dlg.eobj.log_sz.innerText = log_sz[0] + " x " + log_sz[1]
        dlg.eobj.type.innerText = this.type
        dlg.eobj.smooth.innerText = this.smooth
        dlg.eobj.spread.innerText = this.spread

        dlg.eobj.tr.innerText = format_matrix(this.t_mat)
    }
}

// tells whoever gets it how to create the initial plain texture to draw on
class FrameBufferFactory extends ImageBase
{
    static name() { return "FrameBufferParams" }
    constructor(resolution_x, resolution_y, sz_x, sz_y, smooth, spread, type) {
        super(sz_x, sz_y, smooth, spread)
        this.t_mat = mat3.create() 
        this.resolution_x = resolution_x
        this.resolution_y = resolution_y
        this.type = type  // str (rgba, float)
    }

    set_type(v) {
        this.type = v
    }

    draw(m) {
        this.draw_border(m)
    }
    
    width() { return this.resolution_x }
    height() { return this.resolution_y }

    create_tex() {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        if (this.type === "rgba")
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.resolution_x, this.resolution_y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        else if (this.type == "float")
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, this.resolution_x, this.resolution_y, 0, gl.RED, gl.FLOAT, null);
        else
            dassert(false, "unexpected texture type " + this.type)      
            
        tex.width = this.resolution_x
        tex.height = this.resolution_y
        
        setTexParams(this.smooth, this.spread, this.spread)

        const fb = new FrameBuffer(tex, this.sz_x, this.sz_y, this.smooth, this.type, this.spread)
        fb.transform(this.t_mat)
        gl.bindTexture(gl.TEXTURE_2D, null);
        return fb
    }
}

class NodeCreateFrameBuffer extends NodeCls
{
    static name() { return "Create Pixel-Buffer" }
    constructor(node) {
        super(node)
        this.out_tex = new OutTerminal(node, "out_tex")
        this.resolution = new ParamVec2Int(node, "Resolution", 800, 800)
        this.size = new ParamVec2(node, "Size", 2, 2)                                                                        
        const res_fit = ()=>{
            const minp = Math.min(canvas_image.width, canvas_image.height)
            // if it's scaled, the size in pixels need to adjust for that
            const rx = minp * this.transform.scale[0] * image_view.zoom * this.size.x/2
            const ry = minp * this.transform.scale[1] * image_view.zoom * this.size.y/2
            this.resolution.set(rx, ry)
        }
        this.zoom_fit = new ParamButton(node, "Fit resolution to viewport", res_fit)
        const size_fit = ()=>{
            const sx = (image_view.rect.right - image_view.rect.left) / image_view.viewport_zoom // sample viewport when node is created
            const sy = (image_view.rect.bottom - image_view.rect.top) / image_view.viewport_zoom
            this.size.modify(vec2.fromValues(sx, sy))

            //transform to where the middle of the canvas goes
            let mid = vec2.fromValues(canvas_image.width*0.5, canvas_image.height*0.5)
            vec2.transformMat3(mid, mid, image_view.t_inv_viewport)
            this.transform.set_translate(mid[0], mid[1]);
        }
        this.size_fit = new ParamButton(node, "Fit size to viewport", size_fit)
        this.size_fit.share_line_elem_from(this.zoom_fit)
        this.smoothImage = new ParamBool(node, "Smooth Scaling", true)
        this.tex_edge = new ParamSelect(node, "Texture Edge", 0, ["Pad", "Reflect", "Repeat"])
        this.transform = new ParamTransform(node, "Transform")
        res_fit()
    }
    run() {
        assert(this.transform.is_valid(), this, "invalid transform")
        
        const sz = this.size.get_value()
        const res = this.resolution.get_value()
        const ret = new FrameBufferFactory(res[0], res[1], sz[0], sz[1], this.smoothImage.get_value(), this.tex_edge.get_sel_name(), "rgba");
        ret.transform(this.transform.v)

        this.out_tex.set(ret)
    }

    draw_selection(m) {
        let tex = this.out_tex.get_const()
        if (tex === null)  // happens if we never did run()
            return
        this.transform.draw_dial_at_obj(tex, m)
        this.size.size_dial_draw(this.transform.v, m)
        tex.draw_border(m)
    }    
    image_find_obj(e) {
        return this.transform.dial.find_obj(e) || this.size.size_dial_find_obj(e)
    }
}

function generateTexture(width, height, source, smooth, spread_x, spread_y)
{
    dassert(width > 0 && height > 0, "canvas size can't be 0")
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source);
    tex.width = width
    tex.height = height
    
    // should be pad always for y since the gradient change is in x direction
    setTexParams(smooth, spread_x, spread_y)
    gl.bindTexture(gl.TEXTURE_2D, null);    
    return tex
}

function setTexParams(smooth, spread_x, spread_y) {
    let minfilt = gl.LINEAR
    if (!smooth)
        minfilt = gl.NEAREST
    // set the filtering so we don't need mips
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minfilt);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, minfilt);
    let wrap_x = gl.CLAMP_TO_EDGE // "pad"
    if (spread_x == "reflect")
        wrap_x = gl.MIRRORED_REPEAT
    else if (spread_x == "repeat")
        wrap_x = gl.REPEAT
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap_x);
    let wrap_y = gl.CLAMP_TO_EDGE // "pad"
    if (spread_y == "reflect")
        wrap_y = gl.MIRRORED_REPEAT
    else if (spread_y == "repeat")
        wrap_y = gl.REPEAT    
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap_y);
}

function strip_null_term(text) {
    if (text[text.length-1] == '\0') // happens in chrome
        return text.substr(0,text.length-1)
    return text
}

function analyzeInfoLog(text) {
    text = strip_null_term(text)
    const lines = text.split('\n')
    const messages = {}
    for(let line of lines) {
        const trl = line.trim()
        if (trl.length == 0)
            continue
        if (!line.startsWith('ERROR:')) 
            throw Error("unknown line")
        const prefix_len = 6
        const tl = trl.substr(prefix_len)    
        let numcol = 0, numline = 1, nxcolon = prefix_len
        const colon = tl.indexOf(":")
        if (colon !== -1) {
            nxcolon = tl.indexOf(":",colon+1) 
            if (nxcolon !== -1) {  // "ERROR: Missing main" doesn't have a line
                numcol = parseInt(tl.substr(0,colon))
                numline = parseInt(tl.substr(colon+1, nxcolon))            
            }
        }
        const msg = tl.substr(nxcolon+1).trim()
        //messages.push({line:numline, col:numcol, text:trl})
        if (messages[numline] === undefined)
            messages[numline] = {text: trl}
        else
            messages[numline].text += "\n" + trl
    }
    return messages
}

function createShader(gl, type, source) {
    let shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return [shader, null];
    }

    const errlog = gl.getShaderInfoLog(shader)
    console.log(errlog);
    gl.deleteShader(shader);
    const errlst = analyzeInfoLog(errlog)
    return [null, errlst];
}

const TEXTURES_ACCESS_CODE = `
uniform sampler2D _u_in_tex_0;
uniform sampler2D _u_in_tex_1;
uniform sampler2D _u_in_tex_2;
uniform sampler2D _u_in_tex_3;
uniform mat3 _u_tex_tmat_0;
uniform mat3 _u_tex_tmat_1;
uniform mat3 _u_tex_tmat_2;
uniform mat3 _u_tex_tmat_3;

vec4 in_tex(float x, float y) { 
    return texture(_u_in_tex_0, (_u_tex_tmat_0 * vec3(x, y, 1.0)).xy); 
}
vec4 in_texi(float i, float x, float y) {  // float since expr puts out only floats
    switch(int(i)) {
    case 0: return texture(_u_in_tex_0, (_u_tex_tmat_0 * vec3(x, y, 1.0)).xy);
    case 1: return texture(_u_in_tex_1, (_u_tex_tmat_1 * vec3(x, y, 1.0)).xy);
    case 2: return texture(_u_in_tex_2, (_u_tex_tmat_2 * vec3(x, y, 1.0)).xy);
    case 3: return texture(_u_in_tex_3, (_u_tex_tmat_3 * vec3(x, y, 1.0)).xy);
    }
}
vec4 in_tex(vec2 v) { return in_tex(v.x, v.y); }
vec4 in_texi(float i, vec2 v) { return in_texi(i, v.x, v.y); }
`

const IN_TEX_COUNT = 4
const FLAG_WITH_TEXTURE_ACCESS = 1

const TEX_STATE_EVALUATORS = { "in_tex":  (m,s)=>{ return new GlslTextEvaluator(m,s, "in_tex", [], TYPE_FUNCTION, in_tex_types ) },
                               "in_texi":  (m,s)=>{ return new GlslTextEvaluator(m,s, "in_texi", [], TYPE_FUNCTION, in_texi_types ) }
                             }  // also takes index of texture

function async_timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
const SHADER_WAIT_GRAN = 10;
const SHADER_WAIT_MAX = 10000;

async function waitCompile(gl, program) {
    if (gl.ext_par_shader === null) 
        return
    let timeWaited = 0
    let nextWait = 0 // first wait should be very short
    let waitElem = null
    while(timeWaited < SHADER_WAIT_MAX) {
        const done = gl.getProgramParameter(program, gl.ext_par_shader.COMPLETION_STATUS_KHR)
        if (done)
            break
        if (waitElem === null && timeWaited > 500) {
            waitElem = add_div(main_view, "shader_wait")
            waitElem.innerText = "Compiling shader..."
        }
        await async_timeout(nextWait);
        timeWaited += nextWait
        nextWait = SHADER_WAIT_GRAN
    }
    if (waitElem !== null)
        waitElem.parentElement.removeChild(waitElem)
    if (timeWaited > 1000)
        console.log("waited for shader ", timeWaited, "msec")
}

async function createProgram(gl, vtxSource, fragSource, attr_names, defines, flags=0) {
    let prefixSrc = "#version 300 es\nprecision mediump float;\n"
    for(let name in defines)
        prefixSrc += "#define " + name + " (" + defines[name] + ")\n"
    if ((flags & FLAG_WITH_TEXTURE_ACCESS) != 0)
        prefixSrc += TEXTURES_ACCESS_CODE
    prefixSrc += "#line 1\n"

    const startCompile = performance.now()
    const [vtxShader, vtxerr] = createShader(gl, gl.VERTEX_SHADER, prefixSrc + vtxSource);
    const [fragShader, fragerr] = createShader(gl, gl.FRAGMENT_SHADER, prefixSrc + fragSource);
    if (!vtxShader || !fragShader || !attr_names)
        return [null, vtxerr, fragerr] // TBD integrate error message

    const program = gl.createProgram();
    gl.attachShader(program, vtxShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    gl.deleteShader(vtxShader)  // mark for deletion once the program is deleted
    gl.deleteShader(fragShader) 

    await waitCompile(gl, program)

    let success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!success) {
        const errlog = gl.getProgramInfoLog(program)
        console.log(errlog);  // eslint-disable-line
        gl.deleteProgram(program);
        const err = {1:{text:strip_null_term(errlog)}}
        return [null, err, err]
    }
    program.attrs = {}
    for(let attr_name of attr_names)
        program.attrs[attr_name] = gl.getAttribLocation(program, attr_name);

    const elapsedCompile = performance.now() - startCompile
    if (elapsedCompile > 1000)
        console.log("shader compile took ", elapsedCompile)

    return [program, vtxerr, fragerr];
}

const g_dummy_texture_opt = {sz:50, width:5, dark:180, light:255 }
function make_dummy_texture()
{
    ensure_scratch_canvas()
    const sz = g_dummy_texture_opt.sz
    scratch_canvas.width = sz
    scratch_canvas.height = sz
    checkers_rect(ctx_scratch, sz, sz, g_dummy_texture_opt)

    const t = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, t)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sz, sz, 0, gl.RGBA, gl.UNSIGNED_BYTE, scratch_canvas)
    setTexParams(false, 'repeat', 'repeat')
    gl.bindTexture(gl.TEXTURE_2D, null)
    return t
}



function ensure_webgl() {
    if (gl !== null)    
        return
    gl = canvas_webgl.getContext("webgl2");
    if (!gl) {
        console.error("Failed creating webgl2 context")
        return;
    }

    // for distance field render to float
    gl.ext_col_float = gl.getExtension('EXT_color_buffer_float')
    dassert(gl.ext_col_float !== null, "EXT_color_buffer_float unavailable")
    // for quering the state of long shader compile (bezier curve for distance)
    gl.ext_par_shader = gl.getExtension('KHR_parallel_shader_compile')

    gl.my_fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, gl.my_fb);

    // dummy texture
    gl.dummy_texture = make_dummy_texture(gl)
}


function is_ws(c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}
function is_identifier_rest(c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')
}
function is_digit(c) {
    return (c >= '0' && c <= '9')
}

const SUPPORTED_TYPES = ['float', 'int', 'vec2', 'vec4', 'sampler2D', 'bool', 'mat3']


class NodeShader extends NodeCls
{
    static name() { return "Shader" }
    constructor(node) {
        super(node)
        this.in_mesh = new InTerminal(node, "in_mesh")
        this.in_texs = new InTerminalMulti(node, "in_texs")
        this.in_texs.xoffset = 60 // fix the position of the terminal on the node

        this.in_fb = new InTerminal(node, "in_fb") // don't want to change the name to avoid breakage
        this.out_tex = new OutTerminal(node, "out_texture")

        this.vtx_text = new ParamTextBlock(node, "Vertex Shader", "", (text)=>{
            this.try_update_uniforms(this.vtx_text, text, this.uniforms_vert, this.vert_group)
        })
        this.frag_text = new ParamTextBlock(node, "Fragment Shader", "", (text)=>{
            this.try_update_uniforms(this.frag_text, text, this.uniforms_frag, this.frag_group)
        })
        // used so that the uniforms would get mixed up and rearranged each time they are parsed
        this.vert_group = new ParamGroup(node, "Vertex Shader Uniforms")
        this.frag_group = new ParamGroup(node, "Fragment Shader Uniforms")
        
        this.clear_color = [0,0,0,0] // this can be a param but doesn't need to be yet, needed for Scatter2

        this.sorted_order = []
        mixin_multi_reorder_control(node, this, this.sorted_order, this.in_texs)
        this.override_texs = null // the node we're in can override a specific index of a texture with an internal texture - clip texture in scatter

        this.attr_names = ["vtx_pos"] //null // will be set by caller TODO just figure it out with errors
        this.program = null
        this.uniforms_frag = [] // list of {name:,type:} (also defines). need two groups to know if anything changed in the specific text
        this.uniforms_vert = [] 
        this.uniforms = {} // (unified) map name to Param object
        this.defines = {} // map name to Param object, #defines that the source depends on
        this.last_uniforms_err = null
        this.opt = { override_just_points: false, // override the mesh type and display just the points
                     shuffle_points_seed: null }  // if not null, seed of the shuffling of points when drawing just vertices
        // it's ok for the texture to belong to this node since texture is const only so it won't be modified
        //this.render_to_tex = null 
    }
    destructtor() {
        if (this.program)
            gl.deleteProgram(this.program)
        //if (this.render_to_tex)
        //    gl.deleteTexture(this.render_to_tex)
    }
    uniform_by_name(name) {
        return this.uniforms[name]
    }
    uniform_by_name_in(lst, name) {
        for(let u of lst)
            if (u.name === name)
                return u
        return null
    }

    param_of_uniform(name, exception_not_found=false) {
        let d = this.uniforms[name]
        if (d === undefined || d === null) {
            if (exception_not_found)
                assert(false, this, "Uniform not found " + name)
            return null
        }
        return d.param
    }
    param_of_define(name) {
        let d = this.defines[name]
        if (d === undefined || d === null)
            return null
        return d.param
    }

    parse_glsl_uniform_and_defines(text) 
    {
        // not handling comments or pre-processor
        let uniforms = []
        let ci = 0, len = text.length
        const consume_ws = ()=>{
            while (is_ws(text[ci]) && ci < len)
                ++ci;
        }
        const consume_identifier = ()=>{
            consume_ws()
            if (ci == len)
                return null
            const start = ci
            while (is_identifier_rest(text[ci]) && ci < len)
                ++ci;       
            const value = text.substring(start, ci)
            if (value.length == 0)
                return null
            return value
        }

        while(true) {
            ci = text.indexOf('uniform', ci);
            if (ci === -1)
                break
            ci += 7
            const type = consume_identifier()
            let name = consume_identifier()
            if (type === null || name === null)
                break
            if (name == "t_mat") {
                continue // internal names that should not turn to params
            }

            assert(SUPPORTED_TYPES.includes(type), this, "Unsupported uniform type " + type)
            uniforms.push({type:type, name:name})
        }
        // preprocessor conditions turn to boolean parameters
        const search_prepro = (keyword)=>{
            while(true) {
                ci = text.indexOf(keyword, ci)
                if (ci === -1)
                    break
                ci += keyword.length
                const name = consume_identifier()
                if (name === null)
                    break
                uniforms.push({type:'define', name:name})
            }
        }
        search_prepro('#ifdef')
        search_prepro('#ifndef')
        return uniforms
    }
    

    update_uniforms(text, into, in_group) 
    {
        this.last_uniforms_err = null
        let new_uniforms = this.parse_glsl_uniform_and_defines(TEXTURES_ACCESS_CODE + text)
        let changed = into.length !== new_uniforms.length

        if (!changed) {
            // check if someone changed type. type sameness is made by the compilation
            for(let nu of new_uniforms) {
                const eu = this.uniform_by_name_in(into, nu.name)
                if (eu === null || eu.type !== nu.type) {
                    changed = true // new name not found in old or it changed type in the same source
                    break
                }
            } 
        }
        if (!changed)
            return
        // check type matches between vert and frag
        into.length = 0;
        for(let nu of new_uniforms)
            into.push(nu)
        let new_unified = {}
        const check_redef_and_add = (from_cont)=>{
            for(let u of from_cont) {
                if (new_unified[u.name] === undefined) {
                    // type sameness is checked better in createProgram. better since it runs every run and not just on change (shows the error)
                    new_unified[u.name] = u
                }                    
            }
        }
        check_redef_and_add(this.uniforms_frag)
        check_redef_and_add(this.uniforms_vert)

        // removed uniforms - remove param objects
        // if type changed - remove param so it can be recreated in the new type
        // want to keep the surviving ones around so they won't be reset
        const del_non_existing = (from_cont)=> {
            for(let ename in from_cont) {
                if (new_unified[ename] === undefined || new_unified[ename].type !== from_cont[ename].uniform_type) {
                    this.node.remove_param(from_cont[ename].param)
                    delete from_cont[ename]
                }
            }
        }
        del_non_existing(this.uniforms)
        del_non_existing(this.defines)
        // create new ones that were just added
        for(let new_name in new_unified) {
            if (this.uniforms[new_name] !== undefined || this.defines[new_name] !== undefined)
                continue
            const nu = new_unified[new_name]
            let p = {}
            if (nu.type == 'float')
                p.param = new ParamFloat(this.node, nu.name, 0, [0,1])
            else if (nu.type == 'int' || nu.type == 'sampler2D')
                p.param = new ParamInt(this.node, nu.name, 0)
            else if (nu.type == 'vec2')
                p.param = new ParamVec2(this.node, nu.name, 0, 0, false)
            else if (nu.type == 'vec4')
                p.param = new ParamColor(this.node, nu.name, DEFAULT_VTX_COLOR.rgba)
            else if (nu.type == 'bool' || nu.type == 'define') 
                p.param = new ParamBool(this.node, nu.name, false)
            else if (nu.type == 'mat3')
                p.param = new ParamTransform(this.node, nu.name)
            else
                assert(false, this, "unexpected uniform type")
            if (!nu.name.startsWith('_u_'))
                p.param.set_shader_generated(true)
            if (nu.type == 'define')
                this.defines[new_name] = p
            else                
                this.uniforms[new_name] = p
            p.uniform_type = nu.type
            p.param.set_group(in_group)
        }
        // both groups need to update since we might have removed something from the other group
        this.vert_group.update_elems()
        this.frag_group.update_elems()
        // TBD - save,load

    }

    try_update_uniforms(prm, a, b, c) {
        prm._last_err = null
        try{ 
            this.update_uniforms(a, b, c)
        }
        catch(e) {
            this.last_uniforms_err = e.message
        }
    }

    make_tex_aligned_mesh(tex, sz_x, sz_y) {
        let obj = make_mesh_quadtri(sz_x, sz_y) // can probably be 2,2 but not sure
        obj.transform(tex.t_mat);
        return obj
    }

    is_defines_dirty() {
        for(let dname in this.defines)
            if (this.defines[dname].param.pis_dirty())
                return true
        return false
    }

    async bind_textures(texs, in_fb) 
    {
        assert(texs.length == this.sorted_order.length, this, "unexpected sorted_order size") // sanity

        const empty_indices = []
        for(let ti = 0; ti < IN_TEX_COUNT; ++ti)
        {
            let tex = null // FrameBuffer object
            if (this.override_texs !== null && this.override_texs[ti] !== undefined && this.override_texs[ti] !== null)
                tex = this.override_texs[ti]
            else if (ti < this.sorted_order.length)
                tex = texs[this.sorted_order[ti]]
            else {
                empty_indices.push(ti)
                continue
            }
            
            // if we're creating the texutre, create it in the right unit so that it won't overwrite other stuff
            gl.activeTexture(gl.TEXTURE0 + ti)
            let tex_obj;
            try {           
                if (tex.constructor === WebGLTexture)
                    tex_obj = tex // comes from override (from distance fields)
                else {         
                    tex_obj = tex.make_gl_texture(in_fb)  // in_fb needed for gradient
                    if (isPromise(tex_obj))
                        tex_obj = await tex_obj
                    assert(tex_obj !== null, this, "null tex_obj")
                }
            }
            catch(e) {
                assert(false, this, e.message)
            }

            const texParam = this.param_of_uniform('_u_in_tex_' + ti, true)  // was supposed to be there from uniform parsing
            texParam.modify(ti, false)   // don't dirtify since we're in run() and that would cause a loop
            gl.bindTexture(gl.TEXTURE_2D, tex_obj);
            assert(tex_obj.t_mat !== undefined, this, "texture has no transform") 

            // the texture has an associated transform with it, need to make the glsl code move it accordingly
            const tex_tmat = this.param_of_uniform('_u_tex_tmat_' + ti, true)

            let adj_m = mat3.create()
            mat3.translate(adj_m, adj_m, vec2.fromValues(0.5,0.5))

            //const tr_from = (tex instanceof Gradient) ? in_fb : tex
            let tr_from = null
            if (tex instanceof Gradient || tex instanceof DistanceField) 
                tr_from = in_fb
            else
                tr_from = tex
            assert(tr_from.sz_x !== undefined && tr_from.sz_y !== undefined, this, "Image without dimentions")

            // scale 0-1 range of a texture to -1:1 of the framebuffer (with the translation above)
            mat3.scale(adj_m, adj_m, vec2.fromValues(1 / tr_from.sz_x, 1 / tr_from.sz_y))
        
            let inv_tex_tmat = mat3.create()
            mat3.invert(inv_tex_tmat, tr_from.t_mat)
            mat3.mul(adj_m, adj_m, inv_tex_tmat)

            tex_tmat.modify(adj_m, false)

        }
        // make sure textures uniform that don't have connected inputs to fill it are not set to something unknown
        const ident = mat3.create()
        for(let ti of empty_indices) {
            gl.activeTexture(gl.TEXTURE0 + ti)
            gl.bindTexture(gl.TEXTURE_2D, gl.dummy_texture);
            const texParam = this.param_of_uniform('_u_in_tex_' + ti, true)
            texParam.modify(ti, false)
            const texMat = this.param_of_uniform('_u_tex_tmat_' + ti, true)
            texMat.modify(ident, false)
        }
        gl.activeTexture(gl.TEXTURE0); // restore default state
    }

    unbind_textures(texs) {
        // restore state to default state to avoid texture leak and easier bug finding
        for(let ti = 0; ti < texs.length; ++ti) {
            gl.activeTexture(gl.TEXTURE0 + ti)
            gl.bindTexture(gl.TEXTURE_2D, gl.dummy_texture);
        }
        gl.activeTexture(gl.TEXTURE0);
    }

    async run() 
    {
        ensure_webgl()
        assert(this.last_uniforms_err === null, this, this.last_uniforms_err)
        const fb_factory = this.in_fb.get_const()  // FrameBufferFactory object
        assert(fb_factory !== null, this, "missing input FrameBuffer factory")
        assert(fb_factory.width() !== 0 && fb_factory.height() !== 0, this, "frame buffer has zero size")
        assert(fb_factory.create_tex !== undefined, this, "Expected FrameBuffer factory object")
        const fb = fb_factory.create_tex()
        assert(fb !== null, this, "missing input texture")

        const texs = this.in_texs.get_input_consts()
        assert(texs.length < IN_TEX_COUNT, this, "Too many input textures")
        for(let tex of texs) {
            assert(tex !== null, this, "Connected texture input has null object") // if it's connected, there should be something on it
            assert(tex.make_gl_texture !== undefined, this, "Input should be able to convert to textute")
            if (tex.premake_gl_texture !== undefined)
                await tex.premake_gl_texture(fb_factory) //  stuff that needs to be done well before we get our hands dirty with our own webgl
        }

        let mesh = this.in_mesh.get_const()
        if (mesh === null)
            mesh = this.make_tex_aligned_mesh(fb, fb.sz_x, fb.sz_y)            
        
        // triangles or just vertices
        assert(mesh.type !== undefined, this, "input needs to be a mesh object")
        assert(mesh.type === MESH_TRI || mesh.type === MESH_NOT_SET || this.opt.override_just_points, this, "No triangle faces in input mesh")
//        assert(this.attr_names !== null, this, "Missing attr_names") // TBD parse this from the shaders

        if (this.vtx_text.pis_dirty() || this.frag_text.pis_dirty() || this.is_defines_dirty() || this.program === null) 
        { // program can be null if we reset dirty (due to internal node) without actually doing run
            if (this.program)
                gl.deleteProgram(this.program)
            const defines = {}
            for(let def_name in this.defines) {
                const bv = this.defines[def_name].param.get_value()
                if (bv === true || bv === 1)
                    defines[def_name] = 1 // it's either defined or not defines
            }
            //console.log("~~ createprog")
            const [_prog, vtxerr, fragerr] = await createProgram(gl, this.vtx_text.v, this.frag_text.v, this.attr_names, defines, FLAG_WITH_TEXTURE_ACCESS);
            this.program = _prog
            this.vtx_text.set_errors(vtxerr)
            this.frag_text.set_errors(fragerr)
            assert(this.program, this, "failed to compile shaders")
                
            this.program.uniforms = {}
            for(let uniform_name of Object.keys(this.uniforms).concat(['t_mat'])) {
                this.program.uniforms[uniform_name] = gl.getUniformLocation(this.program, uniform_name);
            }
        }
        else {
            //console.log("~~ skipped create")
        }

        // draw
        gl.bindFramebuffer(gl.FRAMEBUFFER, gl.my_fb);
        canvas_webgl.sresize(fb.width(),  fb.height())

        gl.viewport(0, 0, fb.width(), fb.height());

        gl.useProgram(this.program);

        // do before uniforms are sent, passing the factory since only sizes are needed and DistanceField circles this back to a ShaderNode
        await this.bind_textures(texs, fb_factory) 

        // transform for the geometry
        let transform = mat3.create()
        mat3.invert(transform, fb.t_mat)  // frame-buffer movement, rotation
        const szsc = mat3.create()
        mat3.fromScaling(szsc, vec2.fromValues(2/fb.sz_x, 2/fb.sz_y)) // account for the size of the frame-buffer, normalize it to the [2,2] of the normalized coordinate system
        mat3.mul(transform, szsc, transform)

        // transform to pass to the shader 
        let t_shader = mat3.create()
        mat3.copy(t_shader, fb.t_mat)
        mat3.scale(t_shader, t_shader, vec2.fromValues(fb.sz_x/2, fb.sz_y/2))

        if (this.program.uniforms['t_mat'] !== null)
            gl.uniformMatrix3fv(this.program.uniforms['t_mat'], false, t_shader)
        
        for(let uniform_name in this.uniforms) {
            if (this.program.uniforms[uniform_name] !== null)
                this.uniforms[uniform_name].param.gl_set_value(this.program.uniforms[uniform_name])
        }

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fb.tex_obj, 0);

        gl.clearColor(this.clear_color[0], this.clear_color[1], this.clear_color[2], this.clear_color[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        try {
            mesh.gl_draw(transform, this.program.attrs, this.opt)
        }
        catch(ex) {
            console.warn(ex.message)
            assert(false, this, "Failed webgl draw")
        }

        this.unbind_textures(texs)

        fb.invalidate_img()

        // Don't draw the texture on the canvas. draw on a frame buffer so we'll have a texture we can do stuff with later
        // the texture goes then to the canvas and turns to imgBitmap


        this.out_tex.set(fb)
    }
}

// make is so that resizes that make it smaller, don't actually do anything
// but don't accumilate size indefinitely, get the max of a single frame and set to that
function instrument_canvas_resize(c)
{
    // the maximum size of the last frame. the canvas should not remain larger than this
    c.last_canvas_max = {w:0, h:0}
    c.req_size = {w:0, h:0}
    // avoid carring unnecessarily large canvas for a long time
    c.reset_to_latest_max = function() {
        if (c.last_canvas_max.w > 0 && c.last_canvas_max.h > 0 &&  // don't change to 0
            (c.width > c.last_canvas_max.w || c.height > c.last_canvas_max.h))
        {
            c.width = c.last_canvas_max.w
            c.height = c.last_canvas_max.h
        }

        c.last_canvas_max.w = 0
        c.last_canvas_max.h = 0
    }

    c.sresize = function(w, h) { // s for smart
        if (c.width < w)
            c.width = w
        if (c.height < h)
            c.height = h
        c.req_size.w = w // last requested size
        c.req_size.h = h
        // max of this frame
        if (w > c.last_canvas_max.w)
            c.last_canvas_max.w = w
        if (h > c.last_canvas_max.h)
            c.last_canvas_max.h = h
    }

    c.y_offset = function() {
        return c.height - c.req_size.h
    }

}

const render_teximg = {
    mesh: null, program:null,
    vtx_src:`
in vec4 vtx_pos;
out vec2 v_coord;
void main() {
    v_coord = vec2(vtx_pos.x*0.5+0.5,  1.0-(vtx_pos.y*0.5+0.5));
    gl_Position = vtx_pos;
}
    `,
    frag_src:`
precision mediump float;
in vec2 v_coord;
uniform sampler2D uTex;
out vec4 outColor;
void main() {
    outColor = texture(uTex, v_coord);
}
    `
}
async function renderTexToImgBitmap(tex_obj)
{
    // render to actual canvas
    dassert(tex_obj.width !== undefined && tex_obj.height !== undefined, "Missing dimentions of tex")
    dassert(tex_obj.width > 0 && tex_obj.height > 0, "dimentions is 0")
    canvas_webgl.sresize(tex_obj.width, tex_obj.height)

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    // since canvas may be bigger than viewport, need to set the viewport to the upper left corner, so y is no 0
    gl.viewport(0, 0, tex_obj.width, tex_obj.height); // we just set this to the size from the texture

    if (render_teximg.mesh === null) {
        const [_prog, vtxerr, fragerr] = await createProgram(gl, render_teximg.vtx_src, render_teximg.frag_src, ['vtx_pos'], [], 0)
        render_teximg.program = _prog
        dassert(render_teximg.program !== null, "failed compile teximg")

        render_teximg.mesh = make_mesh_quadtri(1,1)
    }
    gl.useProgram(render_teximg.program);
    // no need to set value to uTex since default 0 is ok

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, tex_obj);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    const transform = mat3.create()
    render_teximg.mesh.gl_draw(transform, render_teximg.program.attrs)

    const imgBitmap = await createImageBitmap(canvas_webgl, 0, canvas_webgl.y_offset(), tex_obj.width, tex_obj.height)
    gl.bindTexture(gl.TEXTURE_2D, null);
    return imgBitmap
}


function copy_members(from, to, with_that, names) {
    for(let name of names)
        if (from[name] !== undefined)
            to[name] = function(){ return from[name].apply(with_that, arguments) }
}

class TerminalProxy extends Terminal
{
    constructor(node, wterm, name_override=null, conn_ev=null) {
        super((name_override !== null)?name_override:wterm.name, node, wterm.is_input, conn_ev)
        this.wrap_term = wterm
        this.width = wterm.width
        this.lines = wterm.lines // not sure if needed...
        this.is_input = wterm.is_input
        this.update_subscriber = wterm.update_subscriber
        this.caching = wterm.caching
        copy_members(wterm, this, wterm, ["set", "get_const", "get_mutable", "clear", "tset_dirty", "is_dirty", 
                                          "get_input_consts", "intr_set", "get_cur_uver", "force_set",
                                          "is_caching", "is_out_term", "subscribe_inf_update", "get_ctrl_block"])
                                          // "set_caching" not supported since it needs to modify the internal node which is not being saved

        copy_members(wterm, this, this, ["draw_path"])
            
        if (wterm.constructor === InTerminalMulti) {
            this.get_attachment = ()=> {
                // goes through the proxy
                return new InAttachMulti(this)
            }
        }
    }
    
    // connect events need to go to the owner of what we're wrapping, not the owner of the proxy (order mixin)
    tdid_connect(line) {
        super.tdid_connect(line)
        this.wrap_term.owner.cls.did_connect(this.wrap_term, line)
    }
    tdoing_disconnect(line) {
        super.tdoing_disconnect(line)
        this.wrap_term.owner.cls.doing_disconnect(this.wrap_term, line)
    }
}


// base class for nodes that have an internal program
class BaseNodeParcel extends NodeCls
{
    constructor(node) {
        super(node)
        this.prog = new Program()
        this.nodes = []
    }
    add_parcel_node(cls) {
        const n = this.prog.add_node(0, 0, null, cls, null)
        this.nodes.push(n)
        if (this.node.subnodes === null)
            this.node.subnodes = []
        this.node.subnodes.push(n)
        return n
    }
    destructtor() {
        for(let n of this.nodes)
            n.cls.destructtor()
    }
    get_error() {
        if (this.error !== null)
            return this.error
        for(let n of this.nodes) {
            const e = n.cls.get_error()
            if (e !== null)
                return e
        }
        return null
    }
    clear_error() {
        this.error = null
        for(let n of this.nodes)
            n.cls.clear_error()
    }
    cclear_dirty() {
        // without this the shader_node texts are never cleaned
        for(let n of this.nodes)
            n.clear_dirty()
    }

    is_internal_dirty() {
        for(let n of this.nodes)
            if (n.has_anything_dirty())
                return true
        return false
    }
}

class BaseNodeShaderParcel extends BaseNodeParcel {
    constructor(node) {
        super(node)
        this.shader_node = this.add_parcel_node(NodeShader)
    }
}


class NodePointGradFill extends BaseNodeShaderParcel
{
    static name() { return "Point Gradient Fill" }
    constructor(node) {
        super(node)
        this.shader_node.cls.attr_names = ["vtx_pos", "vtx_color"]
        this.in_mesh = new TerminalProxy(node, this.shader_node.cls.in_mesh)
        this.in_fb = new TerminalProxy(node, this.shader_node.cls.in_fb)
        this.out_tex = new TerminalProxy(node, this.shader_node.cls.out_tex)

        this.shader_node.cls.vtx_text.set_text(`
in vec4 vtx_pos;
in vec4 vtx_color;

out vec2 v_coord;
out vec4 v_color;

void main() {
    v_coord = vtx_pos.xy;
    v_color = vtx_color;
    gl_Position = vtx_pos;
}
`)
        this.shader_node.cls.frag_text.set_text( `
precision mediump float;

in vec2 v_coord;
in vec4 v_color;
out vec4 outColor;

void main() {
    outColor = v_color;
    //outColor = vec4(v_coord.xy, 1.0, 1.0);
}
`)
    }

    async run() {
        await this.shader_node.cls.run()
    }


}


// just passes the input to the output.
// used for changing a multi-terminal in the internal node to a single-terminal outside
class NodePassThrough extends NodeCls 
{
    static name() { return "Pass Through" }
    constructor(node) {
        super(node)
        this.in = new InTerminal(node, "in") // don't want to change the name to avoid breakage
        this.out = new OutTerminal(node, "out")
        this.line = null
    }
    prepare_connection(prog, to_term) {
        this.prog = prog
        this.to_term = to_term
    }
    run() {
        const obj = this.in.get_const()
        if (obj !== null)
            this.out.set(obj)
    }
    did_connect(term, line) {
        if (term !== this.in)
            return
        // adding the line to the desitnation only when I'm connected since I don't want the destination
        // to think it has input when it doesn't
        this.line = new Line(this.out.get_attachment(), this.to_term.get_attachment())
        this.prog.add_line(this.line, null, false)
    }
    doing_disconnect(term, line) {
        if (term !== this.in)
            return
        this.prog.delete_line(this.line, false)
    }
}

function link_pass_through(prog, to_term) {
    const ptnode = prog.add_node(0, 0, null, NodePassThrough, null)
    ptnode.cls.prepare_connection(prog, to_term)
    return [ptnode, ptnode.cls.in]
}

// snippet for pass through node (not currently used)
// in ctor
        //const [ptnode, ptin] = link_pass_through(this.prog, this.shader_node.cls.in_texs)
        //this.tex_ptnode = ptnode
        //this.in_src = new TerminalProxy(node, ptin, "in_src")
// in run
        // move tex input to shader node       
        //this.tex_ptnode.cls.run()
        //progress_io(this.tex_ptnode)



const SCATTER_VTX_TEXT = `
in vec2 vtx_pos;

uniform mat3 t_mat;
uniform vec2 res;
uniform float rel_res; // in screen units

flat out float v_size;

$UNIFORM_DEFS$

$FUNCS$

float flt_expr(vec2 v_coord) {
    $EXPR$
}

void main() {
    vec3 tmp = t_mat * vec3(vtx_pos.xy, 1.0);
    vec2 v_coord = tmp.xy;
    
    if (in_texi(3.0, v_coord).r == 0.0) {
        v_size = -1.0;
        gl_PointSize = 1.0; // should not be 0
    }
    else {
        float f = flt_expr(v_coord);

        // discretisize the pixel position to whole pixels
        gl_Position = vec4( (floor(vtx_pos.xy * res) + vec2(0.5,0.5)) / res, 0.0, 1.0) ;

        f = f * rel_res ;
        v_size = f;
        gl_PointSize = f;
    }
}   
    
`

const SCATTER_FRAG_TEXT =  `
flat in float v_size;
out vec4 outColor;

void main() {
    if (v_size < 0.0)
        discard;
    // center on vertex
    vec2 pc = (gl_PointCoord - vec2(0.5));

    float dist = length(pc);
    if (dist > 0.5)
        discard;

    if (dist * v_size <= 0.7) // black dot
        outColor = vec4(1.0, 0.0, 0.0, 1.0);
    else {
        outColor = vec4(0.7, 0.7, 0.7, 1.0);
    }
}
`

const SCATTER_CLIP_VTX_TEXT = `
in vec4 vtx_pos;
void main() {
    gl_Position = vtx_pos;
}
`
const SCATTER_CLIP_FRAG_TEXT = `
out vec4 outColor;
void main() {
    outColor = vec4(1.0, 1.0, 1.0, 1.0);
}
`

class NodeScatter2 extends BaseNodeParcel
{
    static name() { return "Scatter Func" }
    constructor(node) 
    {
        super(node)
        this.shader_node = this.add_parcel_node(NodeShader) // main rendering
        this.clip_shader_node = this.add_parcel_node(NodeShader)
        this.triangulate = this.add_parcel_node(NodeTriangulate)
        this.shader_node.cls.attr_names = ["vtx_pos"] //, "vtx_color"]

        let seed_set_enable = ()=>{
            // seed is only relevant if we don't have connection (internal random) of if we have a connection but want to randomize it
            this.seed.set_enable(this.shuffle_in_points.v || !this.in_points.has_connection())
        }

        this.in_points = new TerminalProxy(node, this.shader_node.cls.in_mesh, "in_points", (v)=>{
            this.start_point_count.set_enable(!v) // only relevant for internal geometry
            this.shuffle_in_points.set_enable(v)  // only relevant for external
            seed_set_enable()
        })
        this.in_texs = new TerminalProxy(node, this.shader_node.cls.in_texs, "in_texs")
        this.in_texs.width = 16

        this.in_clip_shape = new InTerminal(node, "clip_shape", (v)=>{
            this.do_clip.set_enable(v)
        })
        this.out_tex = new TerminalProxy(node, this.shader_node.cls.out_tex)
        //this.out_tex = new TerminalProxy(node, this.clip_shader_node.cls.out_tex) // for testing clip

        node.set_state_evaluators({"coord":  (m,s)=>{ return new GlslTextEvaluator(m,s, "v_coord", ['x','y'], TYPE_VEC2) },
                                   ...TEX_STATE_EVALUATORS} ) 

        //this.sz = new ParamVec2(node, "Size", 2, 2);
        this.rel_res = new ParamFloat(node, "Pixels Per Unit", 200)
        this.start_point_count = new ParamInt(node, "Start Count", 10000) // assuming there's no in_points
        this.shuffle_in_points = new ParamBool(node, "Shuffle Input", true, ()=>{
            seed_set_enable()
        })

        this.seed = new ParamInt(node, "Seed", 1)
        this.do_clip = new ParamSelect(node, "Clip Object", 0, ["Clips by bounding-box", "Clips by shape"])
        this.density = new ParamFloat(node, "Density", 0.1, {show_code:true})

        this.shader_node.cls.frag_text.set_text(SCATTER_FRAG_TEXT)
        this.shader_node.cls.opt.override_just_points = true // even if the input mesh has faces, display just the vertices

        //----- clip_shader ------
        this.clip_shader_node.cls.vtx_text.set_text(SCATTER_CLIP_VTX_TEXT)
        this.clip_shader_node.cls.frag_text.set_text(SCATTER_CLIP_FRAG_TEXT)
    }

    make_vtx_text(expr_param, template_text, to_shader_prm)  // TBD refactor with func
    {
        const emit_ctx = new GlslEmitContext()

        const item = expr_param.get_active_item()
        if (item.e !== null) {
            if (item.elast_error !== null) {
                assert(false, this, "Expression error")
            }
            try {
                emit_ctx.inline_str = ExprParser.do_to_glsl(item.e, emit_ctx)
            }
            catch(ex) {
                assert(false, this, ex.message)
            }
        }
        else {
            emit_ctx.inline_str = expr_param.get_value()
            if (Number.isInteger(emit_ctx.inline_str))
                emit_ctx.inline_str += ".0"
        }

        const vtx_text = emit_ctx.do_replace(template_text)
        to_shader_prm.set_text(vtx_text)

        emit_ctx.set_uniform_vars(this.shader_node.cls)
    }

    create_fb(clip_bbox) {
        const sz_x = clip_bbox.width(), sz_y = clip_bbox.height()
        const res_x = Math.round(this.rel_res.v * sz_x)
        const res_y = Math.round(this.rel_res.v * sz_y)
        //console.log("resolution: ", res_x, ", ", res_y)
        const fb = new FrameBufferFactory(res_x, res_y, sz_x, sz_y, false, "pad", "rgba")
        const tr = mat3.create()
        mat3.fromTranslation(tr, clip_bbox.center())
        fb.transform(tr)
        return fb
    }

    random_points_mesh(bbox, seed, len)
    {
        const prng = new RandNumGen(seed)
        const vtx_pos = new TVtxArr(len * 2)
        const bminx = bbox.min_x, bminy = bbox.min_y, bw = bbox.width(), bh = bbox.height()
        for(let i = 0, vi = 0; i < len; ++i) {
            vtx_pos[vi++] = bminx + bw* prng.next() 
            vtx_pos[vi++] = bminy + bh* prng.next()
        }
        const mesh = new Mesh()
        mesh.type = MESH_POINTS
        mesh.set("vtx_pos", vtx_pos, 2, false)
        return mesh
    }

    async render_clip_mask(clip_shape, fb)
    {
        if (this.in_clip_shape.is_dirty()) {
            if (clip_shape.constructor !== Mesh || clip_shape.type != MESH_TRI) {
                this.triangulate.cls.in_obj.force_set(clip_shape)
                this.triangulate.cls.run()
                clip_shape = this.triangulate.cls.out_mesh.get_const()
            }
            this.clip_shader_node.cls.in_mesh.force_set(clip_shape) // instead of messing around with lines
        }
        this.clip_shader_node.cls.in_fb.force_set(fb)
        this.clip_shader_node.cls.clear_color = [0,0,0,1]
        await this.clip_shader_node.cls.run()
        const out_tex = this.clip_shader_node.cls.out_tex.get_const()  
        assert(out_tex !== null, this, "failed clip render")
        return out_tex
    }

    async run() 
    {
        // inputs check
        let clip_bbox = null
        const clip_shape = this.in_clip_shape.get_const()
        const in_points = this.in_points.get_const()
        if (clip_shape !== null) {
            assert(clip_shape.get_bbox !== undefined, this, "clip_shape input needs to be a shape")
            clip_bbox = clip_shape.get_bbox();
        }
        else {
            assert(in_points !== null, this, "missing geometry to define area by")
            assert(in_points.get_bbox !== undefined, this, "in_points input needs to geometry")
            clip_bbox = in_points.get_bbox()
        }


        let points = in_points
        if (points === null) { // shader checks that it is geometry
            points = this.random_points_mesh(clip_bbox, this.seed.v, this.start_point_count.v, clip_shape)
            this.in_points.set(points)
            this.shader_node.cls.opt.shuffle_points_seed = null // don't need to shuffle the randomness we just made
        }
        else {
            this.shader_node.cls.opt.shuffle_points_seed = (this.shuffle_in_points.v) ? this.seed.v : null
        }

        this.make_vtx_text(this.density, SCATTER_VTX_TEXT, this.shader_node.cls.vtx_text) // TBD check dirty

        // make framebuffer factory
        const fb = this.create_fb(clip_bbox)
        this.shader_node.cls.in_fb.force_set(fb) // TBD check if dirty
        
        if (clip_shape !== null && this.do_clip.sel_idx == 1) {
            const clip_tex = await this.render_clip_mask(clip_shape, fb)
            this.shader_node.cls.override_texs = {3:clip_tex}
        }
        else 
            this.shader_node.cls.override_texs = null

        this.shader_node.cls.param_of_uniform('res').modify([fb.resolution_x, fb.resolution_y])
        this.shader_node.cls.param_of_uniform('rel_res').modify(this.rel_res.v)

        await this.shader_node.cls.run()
    }

}



class NodePixelsToVertices extends NodeCls
{
    static name() { return "Pixels to Vertices" }
    constructor(node) {
        super(node)
        this.in_tex = new InTerminal(node, "in_tex")
        this.out_pnt = new OutTerminal(node, "out_pnt")
    }

    extract_points(tex) 
    {
        const vtx_pos = []
        const pixels = tex.get_pixels() // Uint8Array
        const w = tex.width(), h = tex.height()
        const [sz_x, sz_y] = tex.logical_size()
        const f_x = sz_x/w, f_y = sz_y/h, hsz_x = sz_x*0.5, hsz_y = sz_y * 0.5
        const t_mat = tex.t_mat
        let i = 0
        const v1 = vec2.create(), v2 = vec2.create()

        for(let iy = 0; iy < h; ++iy) {
            for(let ix = 0; ix < w; ++ix) {
                const c = pixels[i]
                i += 4
                if (c == 255) {
                    v1[0] = ix*f_x-hsz_x
                    v1[1] = iy*f_y-hsz_y
                    vec2.transformMat3(v2, v1, t_mat)
                    vtx_pos.push(v2[0], v2[1])
                }
            }
        }
        const mesh = new Mesh()
        mesh.set("vtx_pos", new TVtxArr(vtx_pos), 2, false)
        mesh.type = MESH_POINTS
        return mesh       
    }

    run() {
        // extract vertices from image
        const in_tex = this.in_tex.get_const()
        assert(in_tex !== null, this, "Missing image input")
        const mesh = this.extract_points(in_tex)
        this.out_pnt.set(mesh)
    }
}
"use strict"


class PImage extends FrameBuffer
{
    static name() { return "PImage" }
    constructor(js_img, smooth, spread, sz_x, sz_y) {
        let tex = null
        if (js_img !== undefined && js_img !== null) {
            tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            // if the input image is empty (not loaded), init with an empty texture
            const init_img =  (js_img.width > 0 && js_img.height > 0) ? js_img : null
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, js_img.width, js_img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, init_img);
            tex.width = js_img.width
            tex.height = js_img.height
            setTexParams(smooth, spread, spread)
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        super(tex, sz_x, sz_y, smooth, "rgba", spread)
        this.img = js_img
        this.pixels = null
    }

    draw(m) {
        this.draw_image(this.img, m)
    }

    get_pixels() {
        if (this.pixels === null && this.img.width != 0 && this.img.height != 0) {
            canvas_img_shadow.width = this.img.width
            canvas_img_shadow.height = this.img.height
            ctx_img_shadow.drawImage(this.img, 0, 0, this.img.width, this.img.height);
            this.pixels = ctx_img_shadow.getImageData(0, 0, this.img.width, this.img.height).data;
        }
        return this.pixels
    }

}

class NodeLoadImage extends NodeCls
{
    static name() { return "Load Image" }
    constructor(node) {
        super(node)
        this.file_upload = new ParamImageUpload(node, "File Upload")
        this.size = new ParamVec2(node, "size", 2, 2);

        this.size_fit = new ParamButton(node, "Fit size to viewport", ()=>{this.size_fit_func()})
        this.smooth_image = new ParamBool(node, "Smooth Scaling", true)
        this.transform = new ParamTransform(node, "Transform")
        this.out_img = new OutTerminal(node, "out_img")

       // size_fit_func() // fit to the viewport at the time the node is created
        this.tex_edge = new ParamSelect(node, "Texture Edge", 0, ["Pad", "Reflect", "Repeat"])

        this.pimg_cache = null
    }

    // setting the image size is only manual since there's currently no way to differentiate between dirty image param
    // due to page (which shouldn't change the size) load and dirty due to user setting a new file (which should)
    size_fit_func() { // make the image appear in its natural resolution
        const img = this.file_upload.try_get_image()
        if (img === null)
            return
        const nw = img.width/image_view.viewport_zoom
        const nh = img.height/image_view.viewport_zoom
        this.size.modify_e(nw, nh)
    }

    run() {
        ensure_webgl()
        if (this.file_upload.pis_dirty() || this.size.pis_dirty() || this.smooth_image.pis_dirty() || this.tex_edge.pis_dirty() || this.pimg_cache === null) {
            const image = this.file_upload.get_image()
            const sz = this.size.get_value()
            this.pimg_cache = new PImage(image, this.smooth_image.v, this.tex_edge.get_sel_name(), sz[0], sz[1])
        }

        assert(this.transform.is_valid(), this, "invalid transform")
        this.pimg_cache.set_transform(this.transform.v)
        this.out_img.set(this.pimg_cache)
    }

    // duplicated in NodeCreateFrameBuffer
    draw_selection(m) {
        let outimg = this.out_img.get_const()
        if (outimg === null) // happens if we never did run()
            return
        this.transform.draw_dial_at_obj(outimg, m)
        outimg.draw_border(m)

        this.size.size_dial_draw(this.transform.v, m)

    }    
    image_find_obj(e) {
        return this.transform.dial.find_obj(e) || this.size.size_dial_find_obj(e)
    }
}


class ScaleDial extends PointDial
{
    constructor(transform, get_width_height) {
        super( (dx, dy, ctx, e)=>{ // dx,dy are already transformed with the img transform into image coordinates
            const wh = get_width_height()
            if (wh === null)
                return

            //dx = dx*this.transform.scale[0]*image_view.viewport_zoom // fix dx to be really pixels
            //let actual_w_pixels = oimg.width()*this.transform.scale[0]*image_view.viewport_zoom // the actual size of the image currenly in pixels
            //let new_w = actual_w_pixels + dx*2
            //let sx = new_w/image_view.viewport_zoom/oimg.width() // change back to zoom units
            // all of this comes down to the following formula
            let sx = (1 + dx*2/wh[0])*transform.scale[0]
            let sy = (1 + dy*2/wh[1])*transform.scale[1]
            if (e.shiftKey) { // don't do the more fancy follow the minimum one like in primitive resize since that would be much harder here
                sy = sx * ctx.start_yx_ratio
            }
            transform.set_scale(sx, sy)
        }, ()=>{
            return { start_yx_ratio: (transform.scale[1]/transform.scale[0]) }
        })
        this.transform = transform
        this.get_width_height = get_width_height
    }
    draw(m) {
        const wh = this.get_width_height()
        if (wh === null)
            return
        super.draw(wh[0]/2, wh[1]/2, this.transform.v, m)
    }
}

// input mesh for ImgInputSampler that represents a single point for the sampler
// like GradientPixelsAdapter, this is also viewport dependent
class SinglePointMeshDummy
{
    constructor(x, y) {
        this.x = x
        this.y = y
        const h = 1.5/image_view.viewport_zoom
        // goal is to have it 3x3 pixels big in viewport coordinates
        this.bbox = new BBox(this.x - h, this.y - h, this.x + h, this.y + h)
    }
    get_bbox() {
        return this.bbox
    }
}

// extract the color of a single pixel in the given coordinates of the input image or gradient into a variable
class NodeSampleColor extends NodeVarCls
{
    static name() { return "Sample Color" }

    constructor(node) {
        super(node)
        this.in_source = new InTerminal(node, "in_src")

        this.pos = new ParamVec2(node, "Offset", 0, 0)
        this.pos.dial = new PointDial((dx,dy)=>{ this.pos.increment(vec2.fromValues(dx, dy)) })
        this.name = new ParamStr(node, "Name", "samp_color")
    }

    async run() {
        const src_samp = new ImgInputSampler(this.in_source, this)
        const p = this.pos.get_value()
        try {
            await src_samp.prepare(new SinglePointMeshDummy(p[0], p[1]))
        } catch(e) {
            // happens with non sampler gradient. Problem - scale is viewport dependent?
            assert(false, this, e.message)
        }
        src_samp.do_get_pixels()
        const value = src_samp.sample_at_v(p)
        
        this.out_single_var(this.name.get_value(), TYPE_VEC4, value)
    }

    draw_selection(m) {
        if (!this.pos.show_code) // not movable when showing code
            this.pos.dial.draw(this.pos.x, this.pos.y, null, m)
    }
    image_find_obj(e) {
        if (!this.pos.show_code)
            return this.pos.dial.find_obj(e)
        return null
    }
}


class ImgInputSampler
{
    constructor(in_source, in_node) {
        this.in_source = in_source
        this.src = null
        this.width_ = null
        this.height_ = null
        this.in_node = in_node
    }

    async prepare(mesh) {
        this.src = this.in_source.get_const()
        assert(this.src !== null, this.in_node, "missing input source")
        if (this.src.get_pixels_adapter !== undefined)
            this.src = await this.src.get_pixels_adapter(mesh, false) // for Gradient
        assert(this.src.get_pixels !== undefined, this.in_node, "expected object with pixels")
    }

    width() { return this.width_ }
    height() { return this.height_ }

    do_get_pixels() {
        this.pixels = this.src.get_pixels()
        this.transform = this.src.get_transform_to_pixels()
        assert(this.pixels !== null, this.in_node, "Input image is empty")
        this.width_ = this.src.width()
        this.height_ = this.src.height()
    }

    sample_at() {
        // this reimplements SetAttr prop_from_input_framebuffer
        eassert(arguments.length >= 1 && arguments.length <= 2, "Wrong number of arguments in call to at()")
        // if there is just one argument, check if it's a vec2, otherwise assume y=0 for the case of 1D sample gradient
        let v
        if (arguments.length == 1) {
            const a0 = arguments[0]
            if (a0.length !== undefined) {
                eassert(a0.length === 2, "expected numbers or vec2 argument")
                v = a0
            }
            else 
                v = [a0, 0]
        }
        else 
            v = arguments
        return this.sample_at_v(v)
    }

    sample_at_v(v) {
        vec2.transformMat3(v, v, this.transform)
        let rx = Math.round(v[0]), ry = Math.round(v[1])
        const spread = this.src.get_spread()
        const inrx = rx
        rx = handle_spread(spread, rx, this.width_)
        ry = handle_spread(spread, ry, this.height_)
        //if (rx < 0 || ry < 0 || rx >= this.width_ || ry >= this.height_) {
        //    return vec4.fromValues(0,0,0,0)
       // }
        const pidx = (ry * this.width_ + rx) * 4
        const pixels = this.pixels
        return vec4.fromValues(pixels[pidx], pixels[pidx+1], pixels[pidx+2], pixels[pidx+3])
    }

}

function handle_spread(spread, coord, length)
{
    if (coord < 0) {
        if (spread === "pad")
            return 0
        if (spread === "repeat")
            return length+(coord%length) - 1
        if (spread === "reflect") {
            coord = -coord
            return ((coord%(length*2)) < length)?(coord%length):(length-(coord%length))
        }
        dassert(false, "unexpected spread value " + spread)
    }
    else if (coord >= length) {
        if (spread === "pad")
            return length - 1
        if (spread === "repeat")
            return coord%length
        if (spread === "reflect")
            return ((coord%(length*2)) < length)?(coord%length):(length-(coord%length) - 1)
        dassert(false, "unexpected spread value " + spread)
    }
    return coord
}



"use strict"

const PATH_CLOSED = 1
const PATH_CONTINUE_PREV = 2  //means that there shouldn't be a new beingPath for this range, that it continues the previous path (it's a hole)

function get_flag(v, f) {
    return (v & f) == f
}

class PathStringBuilder {
    constructor() { this.lst = [] }
    moveTo(x,y) { this.lst.push('M',x,y) }
    lineTo(x,y) { this.lst.push('L',x,y) }
    bezierCurveTo(a,b,c,d,x,y) { this.lst.push('C',a,b,c,d,x,y) }
    closePath() { this.lst.push('Z') }
    getString() { const l = this.lst; this.lst = []; return l.join(' ') }
}

// https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
class MultiPath extends PObject
{
    static name() { return "MultiPath" }
    constructor() {
        super()
        this.paths_ranges = [] // index (normal index, not multiplied) of start, one-past-end of every path, flags (1 for closed)
        this.paths = null // if created, for every triplet in paths_ranges, a Path2D
        this.arrs = { vtx_pos:null }  // common to all paths
        // bezier control points: for every point i in vtx_pos, ctrl_xx are the two control points of the line coming into i
        //   ctrl_to_prev is the control point coming from i towards the previous point in the path
        //   ctrl_from_prev is the control point coming from (i-1)%len towards point i
        //   for an unclosed path, both control points of the first point in the path are (0,0)
        //   all control points are relative to the point
        this.meta = { vtx_pos:null }
        this.consts = { } // instead of value per vertex or per face, just a single constant value

        this.tcache = { vtx_pos:null, m:null }  // transformed cache (for setattr)
        this.fill_objs = init_fill_objs()
        this.paper_obj = null // paper.js object
        this.clipper_obj = null // clipper.js object

        this.effective_vtx_pos = null
        this.eff_ctrl_to_prev = null
        this.eff_ctrl_from_prev = null

        this.forVec2Arrs = Mesh.prototype.forVec2Arrs // needed when calling Mesh draw_vertices with this
    }
    set(name, arr, num_elems, need_normalize=false) {
        name = normalize_attr_name(name)
        this.arrs[name] = arr
        this.meta[name] = { num_elems: num_elems,
                            need_normalize: need_normalize }
                           
        if (name == "vtx_pos" || name == "ctrl_to_prev" || name == "ctrl_from_prev" || 
            name == "face_color" || // saved with the path
            name == "face_transform" || name == "vtx_transform")
            this.invalidate_pos()
    }
    set_const(name, v) {
        this.consts[name] = v
    }

    oclone() {
        const m = new MultiPath()
        m.paths = null  // will be created as needed
        m.arrs = clone(this.arrs)
        m.meta = clone(this.meta)
        m.consts = clone(this.consts)
        m.paths_ranges = clone(this.paths_ranges)

        m.tcache = { vtx_pos:null, m:null } // will be created as needed
        m.fill_objs = clone(this.fill_objs)
        m.paper_obj = null
        m.clipper_obj = null

        if (this.effective_vtx_pos === this.arrs.vtx_pos)
            m.effective_vtx_pos = m.arrs.vtx_pos
        else
            m.effective_vtx_pos = clone(this.effective_vtx_pos)

        if (this.eff_ctrl_to_prev === this.arrs.ctrl_to_prev)
            m.eff_ctrl_to_prev = m.arrs.ctrl_to_prev
        else
            m.eff_ctrl_to_prev = clone(this.eff_ctrl_to_prev)

        if (this.eff_ctrl_from_prev === this.arrs.ctrl_from_prev)
            m.eff_ctrl_from_prev = m.arrs.ctrl_from_prev
        else
            m.eff_ctrl_from_prev = clone(this.eff_ctrl_from_prev)            

        return m
    }

    invalidate_pos(inv_paths=true) {
        if (inv_paths) // when doing add_vertex we update paths
            this.paths = null
        this.paper_obj = null
        this.clipper_obj = null
        this.make_effective_vtx_pos()
    }
    make_effective_vtx_pos() {
        this.eff_ctrl_to_prev = this.arrs.ctrl_to_prev
        this.eff_ctrl_from_prev = this.arrs.ctrl_from_prev
        return Mesh.prototype.make_effective_vtx_pos.call(this)
    }


    get_disp_params(disp_values) {
        const sv = new DispParamBool(disp_values, "Show Vertices", 'show_vtx', true)
        const sl = new DispParamBool(disp_values, "Show Lines", 'show_lines', true)
        const d = [sv, sl]
        if (this.arrs.line_color !== undefined) {
            const colline = new DispParamBool(disp_values, "In Color", "color_lines", true)
            colline.share_line_elem_from(sl)
            d.push(colline)
        }
        if (this.has_curves()) {
            const scc = new DispParamBool(disp_values, "Show Curve Controls ", 'show_ctrls', true)
            const sccp = new DispParamBool(disp_values, "Points", 'show_ctrls_pnts', true)
            sccp.share_line_elem_from(scc)
            d.push(scc, sccp)
        }
        if (this.arrs.face_color !== undefined || this.consts.face_color !== undefined)
            d.push(new DispParamBool(disp_values, "Show Faces", 'show_faces', true))
        this.forVec2Arrs((name, arr)=>{
            const b = new DispParamBool(disp_values, "Show " + name, 'show_' + name, true)
            const sc = new DispParamFloat(disp_values, "Scale", "scale_" + name, 1.0)
            sc.share_line_elem_from(b)
            d.push(b, sc)
        })            
        return d
    }

    // API
    transform(m) {
        Mesh.transform_arr(m, this.arrs.vtx_pos, this.arrs.vtx_pos)
        let vm = mat3.clone(m)
        vm[6] = 0; vm[7] = 0
        if (this.is_curve()) {
            Mesh.transform_arr(vm, this.arrs.ctrl_to_prev, this.arrs.ctrl_to_prev)
            Mesh.transform_arr(vm, this.arrs.ctrl_from_prev, this.arrs.ctrl_from_prev)
        }
        this.invalidate_pos()
    }

    transform_per_face() 
    { 
        const face_transform = this.arrs.face_transform
        dassert(face_transform.length / 6 === this.face_count(), "unexpect length of face_transform")

        let vtx_pos = this.effective_vtx_pos, ctp = this.eff_ctrl_to_prev, cfp = this.eff_ctrl_from_prev
        const is_curve = this.is_curve()
        if (this.effective_vtx_pos === null || this.effective_vtx_pos === this.arrs.vtx_pos || this.effective_vtx_pos.length != vtx_pos.length) {
            // when vtx needs to be new, all of them need to be new
            this.effective_vtx_pos = new TVtxArr(vtx_pos.length)
            if (is_curve) {
                this.eff_ctrl_to_prev = new TVtxArr(ctp.length)
                this.eff_ctrl_from_prev = new TVtxArr(cfp.length)
            }
        }
        const vtx_new = this.effective_vtx_pos, ctp_new = this.eff_ctrl_to_prev, cfp_new = this.eff_ctrl_from_prev
        
        for(let pri = 0, ti = 0; pri < this.paths_ranges.length; pri += 3, ti += 6) 
        {
            let start_vidx = this.paths_ranges[pri]*2
            let end_vidx = this.paths_ranges[pri+1]*2
            for(let vi = start_vidx; vi < end_vidx; vi += 2) 
            {
                let x = vtx_pos[vi], y = vtx_pos[vi+1]
                vtx_new[vi]   = face_transform[ti]   * x + face_transform[ti+2] * y + face_transform[ti+4];
                vtx_new[vi+1] = face_transform[ti+1] * x + face_transform[ti+3] * y + face_transform[ti+5];

                if (is_curve) {
                    x = ctp[vi]; y = ctp[vi+1]
                    ctp_new[vi]   = face_transform[ti]   * x + face_transform[ti+2] * y;
                    ctp_new[vi+1] = face_transform[ti+1] * x + face_transform[ti+3] * y;   

                    x = cfp[vi]; y = cfp[vi+1]
                    cfp_new[vi]   = face_transform[ti]   * x + face_transform[ti+2] * y;
                    cfp_new[vi+1] = face_transform[ti+1] * x + face_transform[ti+3] * y;   
                }
            }
        }        
    }


    vec_transform_per_vtx(arr_name) 
    {
        const orig_arr = this.arrs[arr_name], vtx_transform = this.arrs.vtx_transform
        dassert(vtx_transform.length / 6 === orig_arr.length / 2, "unexpect length of vtx_transform")

        let cur_eff = this["eff_" + arr_name]
        if (cur_eff === null || cur_eff === orig_arr || cur_eff.length != orig_arr.length)
            cur_eff = new TVtxArr(orig_arr.length)
        this["eff_" + arr_name] = cur_eff

        for(let vi = 0, ti = 0; vi < cur_eff.length; vi += 2, ti += 6) {
            let x = orig_arr[vi], y = orig_arr[vi+1]
            cur_eff[vi]   = vtx_transform[ti] * x + vtx_transform[ti+2] * y;
            cur_eff[vi+1] = vtx_transform[ti+1] * x + vtx_transform[ti+3] * y;                  
        }
    }

    transform_per_vtx() {
        Mesh.prototype.transform_per_vtx.call(this)
        if (this.is_curve()) {
            this.vec_transform_per_vtx('ctrl_to_prev')
            this.vec_transform_per_vtx('ctrl_from_prev')
        }
    }

    computed_prop(name) {
        return Mesh.prototype.computed_prop.call(this, name)
    }

    face_center(face_index) {
        const start_vidx = this.paths_ranges[face_index*3]*2
        const end_vidx = this.paths_ranges[face_index*3+1]*2
        let vtx = this.effective_vtx_pos
        let sx = 0, sy = 0
        for(let vidx = start_vidx; vidx < end_vidx; vidx += 2) {
            sx += vtx[vidx]
            sy += vtx[vidx+1]
        }
        const len = (end_vidx - start_vidx) / 2
        return vec2.fromValues(sx / len, sy / len)
    }

    // API
    is_point_inside(x, y) {
        return Mesh.prototype.is_point_inside.call(this, x, y)
    }
    // API
    get_bbox() {
        if (!this.has_curves()) {
            return Mesh.prototype.get_bbox.call(this)
        }
        else { // add control points as well (see pritive circle rotated)
            let vtx = this.effective_vtx_pos, ctp = this.eff_ctrl_to_prev, cfp = this.eff_ctrl_from_prev
            if (vtx.length == 0)
                return null
            let min_x = Number.MAX_VALUE, max_x = -Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_y = -Number.MAX_VALUE
            this.foreach_line((vidx, prev_x, prev_y, x, y)=>{
                let ct_x = x + ctp[vidx], ct_y = y + ctp[vidx+1] 
                let cf_x = prev_x + cfp[vidx], cf_y = prev_y + cfp[vidx+1]
                min_x = Math.min(min_x, x, ct_x, cf_x)  // doing this is not accurate but it's good enough for now
                max_x = Math.max(max_x, x, ct_x, cf_x)
                min_y = Math.min(min_y, y, ct_y, cf_y)
                max_y = Math.max(max_y, y, ct_y, cf_y)
                prev_x = x, prev_y = y
            })
            return new BBox(min_x, min_y, max_x, max_y)
        }
    }
    draw_border(m) {
        Mesh.prototype.draw_border.call(this, m)
    }

    face_count() {
        return this.paths_ranges.length / 3
    }
    vtx_count() {
        return Mesh.prototype.vtx_count.call(this)
    }

    ensure_tcache(m) {
        return Mesh.prototype.ensure_tcache.call(this, m)
    }

    vidxs_of_face(i) {
        console.assert(i*3 < this.paths_ranges.length, "index out of bounds")
        let start_vidx = this.paths_ranges[i*3]*2
        let end_vidx = this.paths_ranges[i*3 + 1]*2
        let r = []
        for(let vidx = start_vidx; vidx < end_vidx; vidx += 2)
            r.push(vidx)
        return r
    }

    is_curve(vidx) {
        let ctp = this.arrs.ctrl_to_prev, cfp = this.arrs.ctrl_from_prev
        return ctp !== undefined && cfp !== undefined && (ctp[vidx] != 0 || ctp[vidx+1] != 0 || cfp[vidx] != 0 || cfp[vidx+1] != 0)
    }
    has_curves() {
        // can go over the arrays and check if all zeros
        return (this.arrs.ctrl_to_prev !== undefined && this.arrs.ctrl_to_prev !== null)
    }

    call_path_commands(obj, pri) {
        let vtx = this.effective_vtx_pos;
        let ctp = this.eff_ctrl_to_prev, cfp = this.eff_ctrl_from_prev

        let start_vidx = this.paths_ranges[pri]*2
        let end_vidx = this.paths_ranges[pri+1]*2
        let prev_x = vtx[start_vidx], prev_y = vtx[start_vidx+1]
        obj.moveTo(prev_x, prev_y, start_vidx/2) // 'M'
        for(let vidx = start_vidx + 2; vidx < end_vidx; vidx += 2) {
            let vx = vtx[vidx], vy = vtx[vidx+1]
            if (!this.is_curve(vidx))
                obj.lineTo(vx, vy, vidx/2) // 'L', third arg for ClipperPathsBuilder set to coord Z to differentiate between paths
            else 
                obj.bezierCurveTo(prev_x+cfp[vidx], prev_y+cfp[vidx+1], vx+ctp[vidx], vy+ctp[vidx+1], vx, vy, vidx/2) // 'C'
            prev_x = vx; prev_y = vy
        }
        if (get_flag(this.paths_ranges[pri+2], PATH_CLOSED)) {
            const is_curve = this.is_curve(start_vidx)
            if (is_curve) {
                let vx = vtx[start_vidx], vy = vtx[start_vidx+1]
                obj.bezierCurveTo(prev_x+cfp[start_vidx], prev_y+cfp[start_vidx+1], vx+ctp[start_vidx], vy+ctp[start_vidx+1], vx, vy, start_vidx/2) //'C'
            }
            obj.closePath(!is_curve) // 'Z' parameter is true if this is supposed to create a real line, for distance field
        }
        if (obj.donePath !== undefined)
            obj.donePath()
    }

    call_all_paths_commands(obj) {
        for(let pri = 0; pri < this.paths_ranges.length; pri += 3) {
            let start_idx = this.paths_ranges[pri]
            let end_idx = this.paths_ranges[pri+1]
            obj.startPath(end_idx - start_idx)
            this.call_path_commands(obj, pri)
        }
    }


    ensure_paths_created() {
        if (this.paths !== null && this.paths.length*3 === this.paths_ranges.length) 
            return

        // sample face_color here since the number of Path2D can be different from the number of faces in the array (due to holes)
        const fcol = this.arrs.face_color
        const do_fill = fcol !== undefined
        let cidx = 0

        this.paths = []
        let jp = null
        for(let pri = 0; pri < this.paths_ranges.length; pri += 3) {
            const flags = this.paths_ranges[pri+2]
            const continue_prev = get_flag(flags, PATH_CONTINUE_PREV)
            let col = null
            if (do_fill) {
                col = "rgba(" + fcol[cidx] + "," + fcol[cidx+1] + "," + fcol[cidx+2] + "," + (fcol[cidx+3]/255) + ")"
                cidx += 4            
            }
            if (!continue_prev) {
                jp = ctx_img.makePath2D()
                jp.face_color = col  // used in draw_poly() take just the color of the first face, ignore the potential case that the other faces can have a different color
            }
            else
                dassert(jp !== null, "continue-prev must have previous path")
            this.call_path_commands(jp, pri)
            if (!continue_prev)
                this.paths.push(jp)
        }
    }

    
    make_clip_path(face_fill, foi) 
    {
        let jp = ctx_img.makePath2D()
        for(let pri = 0, i = 0; pri < this.paths_ranges.length; pri += 3, ++i) {
            if (face_fill[i] != foi)
                continue
            this.call_path_commands(jp, pri);
        }
        return jp;
    }

   
    draw_poly(do_lines, do_fill, lines_color, do_col_lines) {
        this.ensure_paths_created()

        const base_line_width = 1 / image_view.viewport_zoom

        let line_adp = null
        const do_line_col = this.arrs.line_color !== undefined && do_col_lines
        const do_line_width = this.arrs.line_width !== undefined

        if (do_line_col && do_line_width)
            line_adp = new LineColorAndWidthDrawAdapter(ctx_img, this.arrs.line_color, this.arrs.line_width, base_line_width, this.vtx_count())
        else if (do_line_col)
            line_adp = new LineColorDrawAdapter(ctx_img, this.arrs.line_color, this.vtx_count())
        else if (do_line_width)
            line_adp = new LineWidthDrawAdapter(ctx_img, this.arrs.line_width, base_line_width, this.vtx_count())

        if (lines_color === null) { // not template
            lines_color = (this.consts.line_color !== undefined) ? make_str_color(this.consts.line_color) : "#000"
        }
        const const_line_width = (this.consts.line_width !== undefined) ? this.consts.line_width : MESH_DISP.line_width

        const has_const_face_col = this.consts.face_color !== undefined
        let const_face_col = null
        if (has_const_face_col)
            const_face_col = make_str_color(this.consts.face_color)
        let pri = 0
        for(let p of this.paths) {
            const has_arr_face_col = p.face_color !== null
            if (do_fill && (has_arr_face_col || has_const_face_col)) {
                const face_col = has_arr_face_col ? p.face_color : const_face_col
                ctx_img.fillStyle = face_col
                ctx_img.fill(p)
                ctx_img.lineWidth = base_line_width
                ctx_img.strokeStyle = face_col
                if (ctx_img.need_antialias_gap_fill) // not needed for SVG saver
                    ctx_img.stroke(p) // fill antialiasing gaps
            }
            if (do_lines) {
                ctx_img.lineWidth = const_line_width * base_line_width
                ctx_img.strokeStyle = lines_color
                                    
                if (!line_adp) {
                    ctx_img.stroke(p)
                }
                else {
                    // can't use paths since I need to change the color every line
                    this.call_path_commands(line_adp, pri)
                }
            }
            pri += 3
        }
    }

    foreach_line(line_func) {
        let vtx = this.effective_vtx_pos;
        for(let pri = 0; pri < this.paths_ranges.length; pri += 3) {
            const start_vidx = this.paths_ranges[pri]*2
            const end_vidx = this.paths_ranges[pri+1]*2
            let  prev_x = vtx[end_vidx-2], prev_y = vtx[end_vidx-2+1]
            for(let vidx = start_vidx; vidx < end_vidx; vidx += 2) {
                const vx = vtx[vidx], vy = vtx[vidx+1]
                // first line is the closing line (between last and first point if it's a closed path
                line_func(vidx, prev_x, prev_y, vx, vy)
                prev_x = vx; prev_y = vy
            }
        }
    }

    draw_control_points(draw_points, lines_color="#000") {
        const ctp = this.eff_ctrl_to_prev, cfp = this.eff_ctrl_from_prev
        const radius = MESH_DISP.vtx_radius / image_view.viewport_zoom
        ctx_img.strokeStyle = lines_color
        ctx_img.beginPath()
        this.foreach_line((vidx, prev_x, prev_y, vx, vy)=>{
            if (this.is_curve(vidx))
            {
                const vcfp_x = cfp[vidx], vcfp_y = cfp[vidx+1]
                const vctp_x = ctp[vidx], vctp_y = ctp[vidx+1]
                const abs_cfp_x = prev_x+vcfp_x, abs_cfp_y = prev_y+vcfp_y
                const abs_ctp_x = vx+vctp_x, abs_ctp_y = vy+vctp_y
                ctx_img.moveTo(prev_x, prev_y)
                ctx_img.lineTo(abs_cfp_x, abs_cfp_y)
                ctx_img.moveTo(vx, vy)
                ctx_img.lineTo(abs_ctp_x, abs_ctp_y)
                
                if (draw_points) {
                    if (vcfp_x != 0 || vcfp_y != 0) {
                        ctx_img.moveTo(abs_cfp_x + radius, abs_cfp_y)
                        ctx_img.arc(abs_cfp_x, abs_cfp_y, radius, 0, 2*Math.PI)
                    }
                    if (vctp_x != 0 || vctp_y != 0) {
                        ctx_img.moveTo(abs_ctp_x + radius, abs_ctp_y)
                        ctx_img.arc(abs_ctp_x, abs_ctp_y, radius, 0, 2*Math.PI)
                    }
                }
            }
        })
        ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        ctx_img.stroke()
    }

    // API
    async pre_draw(m, disp_values) {
        if (this.arrs.vtx_pos !== null && !this.arrs.face_color && this.arrs.face_fill)
            await Mesh.prototype.pre_draw_poly_fill_clip.call(this, m)        
    }

    // API
    draw_m(m, disp_values) {
        if (this.arrs.vtx_pos === null)
            return
        if (!this.arrs.face_color && this.arrs.face_fill)
            Mesh.prototype.draw_poly_fill_clip.call(this, m)
            // do the line after the clip so it would be over it 
        if (disp_values.show_lines || disp_values.show_faces)
            this.draw_poly(disp_values.show_lines, disp_values.show_faces, null, disp_values.color_lines)
        if (disp_values.show_vtx) 
            Mesh.prototype.draw_vertices.call(this, "#000", true, disp_values)
        if (disp_values.show_ctrls) 
            this.draw_control_points(disp_values.show_ctrls_pnts)
    }

    draw_selection_m(m, select_vindices) {
        Mesh.prototype.draw_selection_m.call(this, m, select_vindices)
    }

    draw_template_m(m) {
        this.draw_poly(true, false, TEMPLATE_LINE_COLOR, false)
        Mesh.prototype.draw_vertices.call(this, TEMPLATE_LINE_COLOR, false)
    }    

    add_fillobj(proxy) {
        return Mesh.prototype.add_fillobj.call(this, proxy)
    }

    
    ensure_paper() {
        if (this.paper_obj !== null && this.paper_obj.children.length*3 === this.paths_ranges.length)
            return this.paper_obj
        const p = new paper.CompoundPath()
        p.remove()  // avoid having it drawing to nowhere
        p.bezierCurveTo = p.cubicCurveTo
        for(let pri = 0; pri < this.paths_ranges.length; pri += 3) {
            this.call_path_commands(p, pri)
        }
        this.paper_obj = p
        return this.paper_obj
    }

    // should be called only after ctor
    from_paper(paper_obj) {
        let vtx = [], ctp = [], cfp = [], ranges = [], cur_idx = 0, has_curves = false
        for(let child of paper_obj.children) {
            const start_idx = cur_idx
            let prev_curve = child.lastCurve
            for(let curve of child.curves) {
                const p1 = curve.point1
                vtx.push(p1.x, p1.y)
                const ph2 = prev_curve.handle2, ph1 = prev_curve.handle1
                ctp.push(ph2.x, ph2.y)
                cfp.push(ph1.x, ph1.y)
                if (ph1.x !== 0 || ph1.y !== 0 || ph2.x !== 0 || ph2.y !== 0) {
                    has_curves = true
                }
                ++cur_idx
                prev_curve = curve
            }
            ranges.push(start_idx, cur_idx, child.closed ? PATH_CLOSED : 0)
        }
        this.set('vtx_pos', new TVtxArr(vtx), 2)
        if (has_curves) {
            this.set('ctrl_to_prev',   new TVtxArr(ctp), 2)
            this.set('ctrl_from_prev', new TVtxArr(cfp), 2)
        }
        this.paths_ranges = ranges
        this.invalidate_pos()
        this.paper_obj = paper_obj
    }

    has_open() {
        for(let pri = 0; pri < this.paths_ranges.length; pri += 3) {
            if (!get_flag(this.paths_ranges[pri+2], PATH_CLOSED))
                return true
        }
        return false
    }

    ensure_clipper() {     
        if (this.clipper_obj !== null)
            return this.clipper_obj
        const b = new ClipperPathsBuilder()
        for(let pri = 0; pri < this.paths_ranges.length; pri += 3) {
            this.call_path_commands(b, pri)
        }
        this.clipper_obj = b.d
        //ClipperLib.JS.ScaleUpPaths(this.clipper_obj, CLIPPER_INT_SCALE);
        return this.clipper_obj
    }

    from_clipper_paths(clipper_obj) {
        let vtx = [], ranges = [], cur_idx = 0, xfer_indices = []
        if (clipper_obj.constructor === ClipperLib.PolyTree) 
        {
            for(let path of clipper_obj.m_AllPolys) {
                const start_idx = cur_idx
                for(let pnt of path.m_polygon) {
                    vtx.push(pnt.X / CLIPPER_SCALE, pnt.Y / CLIPPER_SCALE)
                    xfer_indices.push(pnt.Z)
                    ++cur_idx
                }
                ranges.push(start_idx, cur_idx, path.IsOpen ? 0 : PATH_CLOSED) 
                path.closed = !path.IsOpen
            }    

        }
        else { // it's an array
            for(let path of clipper_obj) {
                const start_idx = cur_idx
                for(let pnt of path) {
                    vtx.push(pnt.X / CLIPPER_SCALE, pnt.Y / CLIPPER_SCALE)
                    xfer_indices.push(pnt.Z)
                    ++cur_idx
                }
                ranges.push(start_idx, cur_idx, PATH_CLOSED) // Paths are implicitly closed
                path.closed = true // simulate what it would look like if we created it
            }    
        }
        this.set('vtx_pos', new TVtxArr(vtx), 2)
        this.paths_ranges = ranges
        this.invalidate_pos()
        this.clipper_obj = clipper_obj
        return xfer_indices
    }

    add_vertex(p, props)
    {
        dassert(this.effective_vtx_pos === this.arrs.vtx_pos, "Working with effective_vtx_pos not supported")

        Mesh.prototype.add_vertex_props.call(this, p, props)
        // extend the last range
        if (this.paths_ranges.length == 0)
            this.paths_ranges.push(0,0,0)
        this.paths_ranges[this.paths_ranges.length - 2]++
        
        if (this.paths !== null) {
            this.paths[this.paths.length - 1].lineTo(p[0], p[1])
        }

        this.invalidate_pos(false) // don't invalidate paths since we updated it
    }

    get_last_vertex() {
        return Mesh.prototype.get_last_vertex.call(this)
    }

    describe(parent, dlg)
    {
        if (dlg.recreate_if_needed(this)) {
            dlg.eobj.vtxnum = dlg.add_line("Vertex Count: ").value_elem
            dlg.eobj.facenum = dlg.add_line("Face Count: ").value_elem
            dlg.eobj.has_curve = dlg.add_line("Has Curves: ").value_elem
            dlg.eobj.props = dlg.add_line("Properties:", true).value_elem
            dlg.eobj.props.classList.add("obj_inf_prop_list")
            dlg.adjust_labels()

        }
        dlg.eobj.vtxnum.innerText = this.arrs.vtx_pos.length / 2
        dlg.eobj.facenum.innerText = this.face_count()
        dlg.eobj.has_curve.innerText = this.has_curves() ? "true" : "false"
        dlg.eobj.props.innerText = Object.keys(this.arrs).join("\n")
        
    }

}

class DynamicLineDrawAdapter
{
    constructor(ctx, prop_arr, vtx_count, num_elems) {
        this.ctx = ctx
        this.da_num_elems = num_elems
        // 4 float values per vertex that have the color of the line that ends in the vertex
        if (prop_arr !== null)
            dassert(prop_arr.length === vtx_count * num_elems, "Wrong element width, expected " + num_elems + " got " + prop_arr.length / vtx_count)
        this.prop_arr = prop_arr 
        this.vidx = null // where we are in the line_col array
        this.start_idx = null
        this.began = false
        this.first = null
        this.prev = {x:null, y:null}
        this.cur = {x:null, y:null}
        for(let i = 0; i < num_elems; ++i) {
            this.prev[i] = null
            this.cur[i] = null
        }
    }

    next_col(into, x, y) {
        const vidx = this.vidx
        for(let i = 0; i < this.da_num_elems; ++i)
            into[i] = this.prop_arr[vidx + i]
        into.x = x
        into.y = y
        this.vidx += this.da_num_elems
    }

    moveTo(x, y, start_idx) {
        this.vidx = start_idx * this.da_num_elems
        this.start_idx = start_idx
        this.next_col(this.prev, x, y)
        //this.first = {r:this.prev.r, g:this.prev.g, b:this.prev.b, a:this.prev.a, x:this.prev.x, y:this.prev.y}
        this.first = { ...this.prev }
        if (!this.began)
            this.ctx.beginPath()
        this.ctx.moveTo(x,y)
        // wide lines would product discontinuities with this
        this.ctx.lineCap = "round"
        this.ctx.lineJoin = "round" // not required but to keep it consistent when doing small 3 point rects for instance
    }

    v_different(a, b) {
        for(let i = 0; i < this.da_num_elems; ++i)
            if (a[i] !== b[i])
                return true
        return false
    }

    check_changed_value(x, y) {
        // check if the current line needs a different color
        this.next_col(this.cur, x, y)
        const prev = this.prev
        const ret = this.v_different(this.cur, prev)
        if (ret) {
            this.donePath()
            this.ctx.beginPath()
            this.ctx.moveTo(prev.x,prev.y)
        }
        // swap cur to prev
        const tmp = this.prev
        this.prev = this.cur
        this.cur = tmp
        return ret
    }
    check_changed_with_first() {
        const prev = this.prev
        const ret = this.v_different(this.first, prev)
        if (ret) {
            this.donePath()
            this.ctx.beginPath()
            this.ctx.moveTo(prev.x,prev.y)
        }
        this.prev = this.first  // for donePath
    }
    lineTo(x, y) {
        this.check_changed_value(x, y)
        this.ctx.lineTo(x,y)
    }
    bezierCurveTo(px,py, nx,ny, x,y, idx) {
        if (this.start_idx === idx)
            this.check_changed_with_first()
        else
            this.check_changed_value(x, y)
        this.ctx.bezierCurveTo(px,py, nx,ny, x,y)
    }
    closePath(real_line) {
        if (!real_line)
            return
        this.check_changed_with_first()
        // can't do closePath since we might have added multiple sub-paths along the way
        this.ctx.lineTo(this.first.x, this.first.y)
        //this.ctx.closePath()
        
        this.donePath()
    }

    donePath() {
        const prev = this.prev
        this.set_ctx_prop(prev)
        this.ctx.stroke()
    }
}


class LineColorDrawAdapter extends DynamicLineDrawAdapter
{
    constructor(ctx, line_col_arr, vtx_count) {
        super(ctx, line_col_arr, vtx_count, 4)
        // 4 float values per vertex that have the color of the line that ends in the vertex       
    }

    set_ctx_prop(v) {
        this.ctx.strokeStyle = make_str_color(v)
    }
}

class LineWidthDrawAdapter extends DynamicLineDrawAdapter
{
    constructor(ctx, line_width_arr, base_width, vtx_count) {
        super(ctx, line_width_arr, vtx_count, 1)
        this.base_width = base_width
    }

    set_ctx_prop(v) {
        this.ctx.lineWidth = v[0] * this.base_width
    }
}

class LineColorAndWidthDrawAdapter extends DynamicLineDrawAdapter
{
    constructor(ctx, line_col_arr, line_width_arr, base_width, vtx_count) {
        super(ctx, null, vtx_count, 5)
        this.base_width = base_width
        this.col_arr = line_col_arr
        this.width_arr = line_width_arr
    }

    next_col(into, x, y) {
        const idx = this.vidx / 5
        const cidx = idx*4
        for(let i = 0; i < 4; ++i)
            into[i] = this.col_arr[cidx + i]
        into[4] = this.width_arr[idx]
        into.x = x
        into.y = y
        this.vidx += this.da_num_elems
    }

    set_ctx_prop(v) {
        this.ctx.strokeStyle = make_str_color(v)
        this.ctx.lineWidth = v[4] * this.base_width
    }
}



// used in NodeManualGeom
class PathRangesList extends Parameter {
    constructor(node) {
        super(node, "path_ranges")
        this.lst = []  // contains references to PathPoly objects all points of a poly point to the same object
    }
    save() { return {ranges:this.lst} }
    load(v) { this.lst = v.ranges }

    add_default() {
        let p
        if (this.lst.length == 0) {
            this.lst.push(0,1,0)
        }
        else {
            let last_end = this.lst[this.lst.length - 2]
            let last_flags = this.lst[this.lst.length - 1]
            if (get_flag(last_flags, PATH_CLOSED))
                this.lst.push(last_end, last_end+1, 0)
            else
                ++this.lst[this.lst.length - 2]
        }
        this.pset_dirty()
    }
    close_current(clicked_index) {
        let last_flags = this.lst[this.lst.length - 1]
        if (get_flag(last_flags, PATH_CLOSED))
            return false
        // go backwards to see where the current poly starts
        let last_start = this.lst[this.lst.length - 3]
        if (last_start !== clicked_index)
            return false
        this.lst[this.lst.length - 1] |= PATH_CLOSED
        this.pset_dirty()
        return true // managed to close
    }
    remove(indices) { 
        // for simplicity, expand, remove and redo ranges
        let polys_index = [], polys = []
        for(let rpi = 0; rpi < this.lst.length; rpi += 3) {
            let start_vidx = this.lst[rpi], end_vidx = this.lst[rpi+1] // not actually vidxs
            let poly = { flags: this.lst[rpi+2], count: end_vidx-start_vidx}
            polys.push(poly)
            for(let vidx = start_vidx; vidx < end_vidx; ++vidx)
                polys_index.push(poly)
        }
        for(let index of indices) {
            --polys_index[index].count
            console.assert(polys_index[index].count >=0) // sanity
            delete polys_index[index]
        }
        polys = cull_list(polys)
        let new_lst = [], pos = 0
        for(let p of polys) 
            if (p.count > 0) {
                new_lst.push(pos, pos+p.count, p.flags)
                pos += p.count
            }
        this.lst = new_lst
    }

    // given the index of a point, find the index of the previous point in the same path
    get_prev_point_in_path(idx) {
        // it's possible to cache the result and this this in O(1) but not actually needed for now
        for(let rpi = 0; rpi < this.lst.length; rpi += 3) {
            const start_idx = this.lst[rpi], end_idx = this.lst[rpi+1]
            if (idx >= start_idx && idx < end_idx) {
                if (idx > start_idx)
                    return idx-1
                return end_idx-1
            }
        }
        return null // index not found?
    }

    add_elems(parent) {}
}


function triangulate_path(obj, node)         
{ // https://github.com/shooshx/ArNavNav/blob/352a5a3acaabbc0591fb995b36255dc750406d22/src/poly2tri/adapter.cc            
    var swctx = new poly2tri.SweepContext([]);
    let vtx = obj.effective_vtx_pos;
    let added_poly = 0
    let all_pnts = []
    //for(let pcmds of obj.cmds) 
    for(let pri = 0; pri < obj.paths_ranges.length; pri += 3)
    {
        let plst = [] // of current hole
        let start_vidx = obj.paths_ranges[pri]*2
        let end_vidx = obj.paths_ranges[pri+1]*2
        for(let vidx = start_vidx; vidx < end_vidx; vidx += 2) {
            let tpnt = new poly2tri.Point(vtx[vidx], vtx[vidx+1])
            tpnt.my_index = vidx / 2
            tpnt.visited = false
            plst.push(tpnt)
        }
        if (plst.length >= 3) {
            swctx.addHole(plst)
            all_pnts.push.apply(all_pnts, plst)
            ++added_poly;
        }
    }
    let out_mesh = new Mesh()
    let idx = []
    let halfedges = []
    if (added_poly > 0) {
        // need to iterate since triangulate only processes one countour and its holes at a time
        while(true) {
            try {
                swctx.triangulate()
            } catch(e) {
                assert(false, node, "Failed triangulation")
            }
            var triangles = swctx.getTriangles();
            for(let tri of triangles) {
                let tripnt = tri.getPoints()
                console.assert(tripnt.length == 3, "unexpected size of triangle")
                // for the edge case of triangulation emitting points that it created, not from the input (don't know how to reproduce this)
                console.assert(tripnt[0].my_index !== undefined && tripnt[1].my_index !== undefined && tripnt[2].my_index !== undefined, "External helper point?")
                tri.start_at_idx = idx.length
                //idx.push(tripnt[0].my_index, tripnt[1].my_index, tripnt[2].my_index)
                idx.push(tripnt[2].my_index, tripnt[1].my_index, tripnt[0].my_index)
                tripnt[0].visited = true; tripnt[1].visited = true; tripnt[2].visited = true
                halfedges.push(-1,-1,-1) // size of halfedges is the same as idx
            }
            // make halfedges, see what it needs to look like: https://github.com/mapbox/delaunator
            for(let tri of triangles) {
                let tripnt = tri.getPoints()
                for(let pi = 0; pi < 3; ++pi) {
                    let p = tripnt[pi]
                    let nei_tri = tri.getNeighbor(pi)  // beightbor across p
                    if (nei_tri === null || !nei_tri.interior_) {
                        continue
                    }
                    let p_after = tripnt[(pi+1)%3]
                    let p_before = tripnt[(pi-1+3)%3]
                    let index_in_tri = 2-tri.index(p_before)
                    let index_in_nei = 2-nei_tri.index(p_after)
                    halfedges[tri.start_at_idx + index_in_tri] = nei_tri.start_at_idx + index_in_nei
                }
            }

            let leftover = []
            for(let p of all_pnts) {
                if (!p.visited)
                    leftover.push(p)
            }
            if (leftover.length < 3)
                break;

            // hack poly2tri to start over without having to reinitialize the holes
            swctx.points_ = leftover
            swctx.map_ = []
            swctx.triangles_ = []
        }
    }
    for(let attrname in obj.arrs) {
        let attrarr = obj.arrs[attrname]
        if (attrarr === null) // ctrl_to_x would be null if there's no rounded corners
            continue
        console.assert(isTypedArray(attrarr), "not a typed-array " + attrname)
        out_mesh.set(attrname, new attrarr.constructor(attrarr), obj.meta[attrname].num_elems, obj.meta[attrname].need_normalize)
    }
    out_mesh.set("idx", new TIdxArr(idx))
    out_mesh.set_type(MESH_TRI)
    out_mesh.halfedges = halfedges


    let d = new Delaunator(out_mesh.effective_vtx_pos)
    out_mesh.hull = d.hull
    
    return out_mesh
    
}


// Chaikin round corners
// see https://simblob.blogspot.com/2019/10/chaikin-curves.html and https://sighack.com/post/chaikin-curves
class NodeRoundCorners extends NodeCls
{
    static name() { return "Round Corners" }
    constructor(node) {
        super(node)
        this.in_obj = new InTerminal(node, "in_obj")
        this.out_paths = new OutTerminal(node, "out_paths")
        
        this.alg = new ParamSelect(node, "Algorithm", 0, ["Chaikin", "Continuous", "Catmull-Rom", "Geometric", "Simplify"],(sel_idx)=>{
            this.factor.set_visible(sel_idx == 2 || sel_idx == 3 || sel_idx == 4)
        })
        this.factor = new ParamFloat(node, "Factor", 0.5, [0,1])
    }

    run_paper_alg() {
        let obj = this.in_obj.get_const()
        assert(obj !== null, this, "No input")

        const p = obj.ensure_paper()
        obj.paper_obj = null // changed in place        
        switch(this.alg.sel_idx) {
        case 1: p.smooth({type:"continuous"}); break;
        case 2: p.smooth({type:"catmull-rom", factor:this.factor.v }); break;
        case 3: p.smooth({type:"geometric", factor:this.factor.v }); break;
        case 4: assert(p.simplify(this.factor.v), this, "Failed simplify"); break; //
        }
        
        let new_obj = new MultiPath()
        new_obj.from_paper(p)
        this.out_paths.set(new_obj)
    }

    run() {
        let obj = this.in_obj.get_const()
        assert(obj !== null, this, "No input")
        if (this.alg.sel_idx !== 0) {
            this.run_paper_alg()
            return
        }
        // "Chaikin"
        let vtx = obj.effective_vtx_pos
        let new_vtx = [], new_ranges = [], ctp = [], cfp = []

        let round_poly = (poly_len, get_vidx, is_closed)=>{
            let prev_vidx = get_vidx(poly_len-1)
            let prev_x = vtx[prev_vidx], prev_y = vtx[prev_vidx+1]
            let prev_mid_x = 0, prev_mid_y = 0
            let new_start_vidx = new_vtx.length
            for(let i = 0; i < poly_len; ++i) {
                let vidx = get_vidx(i)
                let x = vtx[vidx], y = vtx[vidx+1]
                let mid_x = (x + prev_x)/2, mid_y = (y + prev_y)/2
                new_vtx.push(mid_x, mid_y)
                ctp.push(prev_x - mid_x, prev_y - mid_y)
                cfp.push(prev_x - prev_mid_x, prev_y - prev_mid_y)
                prev_x = x; prev_y = y
                prev_mid_x = mid_x; prev_mid_y = mid_y
            }
            let vidx = get_vidx(0)
            if (is_closed) {
                cfp[new_start_vidx] = prev_x - prev_mid_x; cfp[new_start_vidx+1] = prev_y - prev_mid_y
            }
            else {
                cfp[new_start_vidx] = 0; cfp[new_start_vidx+1] = 0
            }
            new_ranges.push(new_start_vidx/2, new_vtx.length/2, is_closed?PATH_CLOSED:0)
        }

        if (obj.constructor === MultiPath) {
            for(let rpi = 0; rpi < obj.paths_ranges.length; rpi += 3) {
                let start_vidx = obj.paths_ranges[rpi]
                let end_vidx = obj.paths_ranges[rpi+1]
                let is_closed = get_flag(obj.paths_ranges[rpi+2], PATH_CLOSED)
                round_poly(end_vidx-start_vidx, (i)=>{ return (start_vidx+i)*2 }, is_closed)
            }
        }
        else if (obj.constructor === Mesh) {
            let face_size = obj.face_size()
            let idx = obj.arrs.idx
            assert(idx !== null, this, "Mesh is empty")
            for(let pi = 0; pi < idx.length; pi += face_size) {
                round_poly(face_size, (i)=>{ return idx[pi+i]*2 }, true)
            }
        }
        else {
            assert(false, this, "input is not Mesh or Paths")
        }
        let new_obj = new MultiPath()
        new_obj.set('vtx_pos', new TVtxArr(new_vtx), 2, false) // this operation has to flatten the any transform property
        new_obj.set('ctrl_to_prev', new TVtxArr(ctp), 2, false)
        new_obj.set('ctrl_from_prev', new TVtxArr(cfp), 2, false)
        new_obj.paths_ranges = new_ranges
        this.out_paths.set(new_obj)

        // preserve face attributes. vertices changed place so are not preserved
        for(let arr_name in obj.arrs) {
            if (!arr_name.startsWith("face_") || arr_name == "vtx_transform") 
                continue
            let from_arr = obj.arrs[arr_name]
            let new_arr = new from_arr.constructor(from_arr)
            new_obj.set(arr_name, new_arr, obj.meta[arr_name].need_normalize)
        }
        new_obj.fill_objs = clone_fill_objs(obj.fill_objs)
    }
}


class NodeBoolOp extends NodeCls
{
    static name() { return "Boolean Operation" }
    constructor(node) {
        super(node)
        this.in_obj1 = new InTerminalMulti(node, "in_obj_subject")
        this.in_obj1.width = 17
        this.in_obj2 = new InTerminalMulti(node, "in_obj_clip")
        this.in_obj2.width = 17
        this.out_paths = new OutTerminal(node, "out_paths")
        
        this.op = new ParamSelect(node, "Operation", 0, [["Union", ClipperLib.ClipType.ctUnion],
                                                         ["Intersection", ClipperLib.ClipType.ctIntersection],
                                                         ["Subtract", ClipperLib.ClipType.ctDifference],
                                                         ["Xor", ClipperLib.ClipType.ctXor]], (sel_idx)=>{
            this.swap.set_visible(sel_idx === 2)
        })
        this.swap = new ParamBool(node, "Swap", false)
    }

    run() {
        let objs1 = this.in_obj1.get_input_consts()
        let objs2 = this.in_obj2.get_input_consts()

        if (this.swap.v && (this.op.sel_idx == 2)) {
            const t = objs1; objs1 = objs2; objs2 = t
        }
        if (this.op.sel_idx !== 0) {
            assert(objs1.length > 0, this, "Missing input subject")
            assert(objs2.length > 0, this, "Missing input clip")
        }
        else {
            assert(objs1.length + objs2.length > 0, this, "Missing input")
        }

        // see https://sourceforge.net/p/jsclipper/wiki/documentation/
        ClipperLib.use_xyz = false
        const cpr = new ClipperLib.Clipper();
        let p_res = null
        try {
            let has_open = false
            for(let obj of objs1) {
                const p = obj.ensure_clipper()
                for(let pp of p) {
                    has_open |= !pp.closed
                    assert(cpr.AddPath(pp, ClipperLib.PolyType.ptSubject, pp.closed), this, "failed AddPath")
                }
            }
            for(let obj of objs2) {
                const p = obj.ensure_clipper()
                 for(let pp of p) {
                    assert(pp.closed, this, "Clip obj should not be open") // also checked in AddPath
                    assert(cpr.AddPath(pp, ClipperLib.PolyType.ptClip, true), this, "failed AddPath")
                }
            }
            if (has_open)
                p_res = new ClipperLib.PolyTree()
            else
                p_res = new ClipperLib.Paths();
    
            const succeeded = cpr.Execute(this.op.get_sel_val(), p_res, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
            assert(succeeded, this, "Clipper failed")
        }
        catch(e) {
            assert(false, this, e.message)
        }

        let new_obj = new MultiPath()
        new_obj.from_clipper_paths(p_res)
        this.out_paths.set(new_obj)
    }

}
"use strict"

function make_str_color(c) {
    return "rgba(" + c[0] + "," + c[1] + "," + c[2] + "," + (c[3]/255) + ")"
}

function svg_create_elem(elem_type) {
    return document.createElementNS("http://www.w3.org/2000/svg", elem_type);
}
function svg_add_elem(parent, elem_type) {
    const e = svg_create_elem(elem_type)
    parent.appendChild(e)
    return e
}

function rectEquals(a, b) {
    return a.x === b.x && a.y === b.y && a.w === b.w && a.h === b.h
}

function interp_point(pa, pb, t) {
    const x = pa[0] * (1-t) + pb[0] * t
    const y = pa[1] * (1-t) + pb[1] * t
    return [x,y]
}

function interp_color(ca, cb, t) {
    const r = ca[0] * (1-t) + cb[0] * t
    const g = ca[1] * (1-t) + cb[1] * t
    const b = ca[2] * (1-t) + cb[2] * t
    const a = ca[3] * (1-t) + cb[3] * t
    return [r,g,b,a]
}

// number of points in the Node's list that are not stop points from the beginning of the index space
const NODE_POINT_LST_OFFSET = 4

class Gradient extends PObject 
{
    static name() { return "Gradient" }
    constructor(x1,y1, x2,y2, tex_smooth) {
        super()
        this.p1 = vec2.fromValues(x1,y1) // point at v=0
        this.p2 = vec2.fromValues(x2,y2) // point at v=1
        this.tex_smooth = tex_smooth
        this.stops = [] // list of [value,color] where color is [r,g,b,alpha]
        this.grd = null
        this.ctx_create_func = null
        this.t_mat = mat3.create() // transform for circles and fill
        this.spread = 'pad'  // 'reflect', 'repeate'
        this.via_svg = false
        this.svg = null  // image object
        this.svg_of_rect = null // the pmin,pmax points of the rect this svg was generated with
        this.sample_tex = false
        this.offset = 0
    }
    add_stop(value, color) {
        this.stops.push({value:value,color:color})
        this.obj = null
    }
    get_disp_params(disp_values) {
        return [ new DispParamBool(disp_values, "Show Fill", 'show_fill', true),
                ]
    }

    set_spread(spreadName, via_svg) {
        this.spread = spreadName
        this.via_svg = via_svg
    }
    set_offset(v) {
        this.offset = v 
    }

    need_svg() {
        return this.via_svg
    }

    add_stops(grd) {
        for(let s of this.stops) {
            dassert(s.value >= 0 && s.value <= 1, "stop out of range")
            grd.addColorStop(s.value, make_str_color(s.color))
        }
    }

    ensure_grd() { // it doesn't matter which context creates the gradient object, it will be usable in both img and shadow
        if (this.grd === null) {
            let grd = this.ctx_create_func.call()
            this.add_stops(grd)
            this.grd = grd
        }
    }

    make_rect_points(pmin, pmax, is_viewport_coords) {
        let tinv = mat3.create()
        mat3.invert(tinv, this.t_mat)

        // need to make this rect a path and not fillRect since in the transformed space it's not axis aligned
        let rp = [pmin, pmax, vec2.fromValues(pmax[0], pmin[1]), vec2.fromValues(pmin[0], pmax[1])]

        for(let i = 0; i < 4; ++i) {
            if (is_viewport_coords)
                vec2.transformMat3(rp[i], rp[i], image_view.t_inv_viewport)
            if (!this.need_svg()) { // with svg the transform is in the image
                vec2.transformMat3(rp[i], rp[i], tinv)
            }
        }

        let rect = { x: rp[0][0], y: rp[0][1], w: rp[1][0] - rp[0][0], h: rp[1][1] - rp[0][1], pnts:rp }
        if (this.need_svg()) {
            // drawImage can't handle an image with coordinates that are not int, so enlarge the image
            // to the nearest int size and adjust the (x,y) point its drawn in
            const iw = Math.ceil(rect.w), ih = Math.ceil(rect.h)
            rect = {x: rect.x - (iw-rect.w), y: rect.y - (ih-rect.h), w: iw, h: ih }
        }
        return rect
    }

    make_viewport_rect_points() {
        return this.make_rect_points(vec2.fromValues(0,0), vec2.fromValues(canvas_image.width, canvas_image.height), true)
    }

    async pre_draw_rect(rect) {
        // if we're coming from SetAttr, this would generate a new svg so we'll need to really await
        if (this.need_svg()) {
            if (this.need_ensure_svg(rect)) {
                await this.ensure_svg(rect)
            }
        }
    }

    draw_fill_rect(ctx, rect) {        
        this.ensure_grd()
        // if we're coming from draw(), this would not await since the svg was generated in pre_draw with the same rect


        if (this.need_svg()) {
            dassert(this.svg !== null, "Missing svg") // can happen due to previous error
            
            ctx.drawImage(this.svg, rect.x, rect.y)         // PROBLEM width,height is in pixels integer   
        }
        else {
            ctx.save()
            canvas_transform(ctx, this.t_mat) // circle squash
    
            const rp = rect.pnts
            ctx.fillStyle = this.grd
            ctx.beginPath()
            // can't use x+w since if there's a transform, we actuall draw a rotated rect
            ctx.moveTo(rp[0][0], rp[0][1]); ctx.lineTo(rp[2][0], rp[2][1])
            ctx.lineTo(rp[1][0], rp[1][1]); ctx.lineTo(rp[3][0], rp[3][1])
            ctx.fill()
            ctx.restore()
        }

    }

    draw_fill() {
        // rect that fills all the viewport
        const rp = this.make_viewport_rect_points()
        //console.log("DRAW ", canvas_image.width)
        this.draw_fill_rect(ctx_img, rp)
        // we can't do async stuff in draw (since that would cause flicker) so we make sure we didn't make any promise just now
        
    }

    transform(m) { mat3.multiply(this.t_mat, m, this.t_mat) }
    set_transform(m) { mat3.copy(this.t_mat, m) }
    get_transform() { return this.t_mat }

    draw_line_points(pa, pb, line_color="#000") {
        let tpa = vec2.create(), tpb = vec2.create()
        vec2.transformMat3(tpa, pa, this.t_mat)  // needed for correct template
        vec2.transformMat3(tpb, pb, this.t_mat)

        let radius = MESH_DISP.vtx_radius / image_view.viewport_zoom
        let did1 = false, did0 = false
        ctx_img.beginPath();
        ctx_img.moveTo(tpa[0], tpa[1])
        ctx_img.lineTo(tpb[0], tpb[1])
        ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        ctx_img.strokeStyle = line_color
        ctx_img.stroke()
        for(let s of this.stops) {
            let [x,y] = interp_point(tpa, tpb, s.value)
            if (s.value == 1)
                did1 = true
            else if (s.value == 0)
                did0 = true

            ctx_img.beginPath();
            ctx_img.arc(x, y, radius, 0, 2*Math.PI)
            ctx_img.fillStyle = make_str_color(s.color)
            ctx_img.fill()
            ctx_img.stroke()
            // TBD what if it can't be seen?
        }
        if (!did1) {
            ctx_img.beginPath();
            ctx_img.arc(tpb[0], tpb[1], radius, 0, 2*Math.PI)
            ctx_img.stroke()
        }
        if (!did0) {
            ctx_img.beginPath();
            ctx_img.arc(tpa[0], tpa[1], radius, 0, 2*Math.PI)
            ctx_img.stroke()
        }
    }    

    // selected points on the line (highlights)
    draw_sel_points(selected_indices, pa, pb) {
        const radius = MESH_DISP.vtx_sel_radius/image_view.viewport_zoom
        ctx_img.beginPath();
        for(let idx of selected_indices) {
            let p;
            switch(idx) {
            case 0: p = this.p1; break;
            case 1: p = this.p2; break;
            case 2: p = pa; break;
            case 3: p = pb; break;
            default: 
                p = interp_point(pa, pb, this.stops[idx-NODE_POINT_LST_OFFSET].value)
            }
            // no need to transorm with t_mat since this is done only on the gradient node where t_mat is ident
            ctx_img.moveTo(p[0] + radius, p[1])
            ctx_img.arc(p[0], p[1], radius, 0, 2*Math.PI)
        }
        ctx_img.lineWidth = 2/image_view.viewport_zoom
        ctx_img.strokeStyle = MESH_DISP.sel_color
        ctx_img.stroke()        
    }

    // from SetAttr
    async get_pixels_adapter(for_obj, is_fb) {
        let ad = new GradientPixelsAdapter(for_obj, this, is_fb)
        await ad.make_pixels(!is_fb)
        return ad
    }

    async pre_draw(m, disp_values) {
        if (this.need_svg() && disp_values.show_fill) {
            //console.log("PRE-DRAW ", canvas_image.width)
            const rp = this.make_viewport_rect_points()
            if (this.need_ensure_svg(rp)) {
                await this.ensure_svg(rp)
            }
        }
    }

    draw_m(m, disp_values) {
        if (disp_values.show_fill) {
            this.draw_fill()
        }
    }


    make_svg_text(rect) {
        let [elem_name, geom] = this.svg_text_geom()

        //console.log("w=", rect.w, "  h=", rect.h)
        const m = this.t_mat
        let lst = ['<svg viewBox="', rect.x, " ", rect.y, " ", rect.w, " ", rect.h, '" xmlns="http://www.w3.org/2000/svg" width="', rect.w,'" height="', rect.h,'"><', elem_name,
                   ' id="grad" gradientUnits="userSpaceOnUse" spreadMethod="', this.spread ,'" gradientTransform="matrix(', m[0], " ", m[1], " ", m[3], " ", m[4], " ", m[6], " ", m[7] ,')" ']
        lst = lst.concat(geom)
        lst.push(' >')

        let use_stops = this.stops

        if (this.offset != 0)
        {
            if (this.spread == 'repeat') {
                let offset = this.offset % 1.0
                if (offset < 0)
                    offset += 1.0
                use_stops = []
                for(let si in this.stops) {
                    const s = this.stops[si]
                    let v = s.value + offset
                    if (v > 1.0)
                        v -= 1.0
                    if (si == this.stops.length - 1) // last
                        v -= 0.000001 // so first and last don't flickr
                    use_stops.push({color: s.color, value:v, orig_value:s.value})
                }
                use_stops.sort((a, b) => a.value - b.value);

                // add points at 0 and 1, otherwise it does the wrong thing
                let a = use_stops[use_stops.length - 1]
                let b = use_stops[0]
                const back_offset = 1.0 - offset

                const samp = (back_offset - a.orig_value)/(b.orig_value - a.orig_value)
                const mid_col = interp_color(a.color, b.color, samp);
                use_stops.push({value: 1.0, color: mid_col})
                use_stops.unshift({value: 0.0, color: mid_col })
            }
            else if (this.spread == 'reflect') {
                // cover all the space where offset can get to
                // don't attempt to set points in 0,1 since they'll look bad
                use_stops = []
                let offset = this.offset % 2.0
                for(let si in this.stops) {
                    const s = this.stops[si]
                    use_stops.push({color: s.color, value:s.value + offset, orig_value:s.value})  // base
                    use_stops.push({color: s.color, value:s.value - 2 + offset, orig_value:s.value}) // 1 before neg
                    use_stops.push({color: s.color, value:s.value + 2 + offset, orig_value:s.value})

                    use_stops.push({color: s.color, value:-s.value + offset, orig_value:s.value}) // invert to neg
                    use_stops.push({color: s.color, value:-s.value + 2 + offset, orig_value:s.value}) // after base (inverted)
                }
                use_stops.sort((a, b) => a.value - b.value);
            }
        }

        const add_stop = (c, v)=>{        
            lst.push('<stop offset="', v, '" stop-color="rgb(', c[0], ',', c[1], ',', c[2], ')" stop-opacity="', c[3]/255, '" />')
        }
        for(let s of use_stops)
            add_stop(s.color, s.value)    
        
        lst.push('</', elem_name, '><rect x="', rect.x,'" y="', rect.y,'" width="', rect.w, '" height="', rect.h, '" fill="url(\'#grad\')" /></svg>')
        let text = lst.join('')
        return text
    }

    need_ensure_svg(rect) {
        if (this.svg !== null && this.svg_of_rect !== null && rectEquals(rect, this.svg_of_rect) )
            return false // cache is good
        return true
    }

    // this will be needed even if we're not going to draw it, for get_pixels, so make this async
    // rather than pre_draw
    // this function returns either a promise of an svg image or the svg image if it's already created
    async ensure_svg(rect) {

        const text = this.make_svg_text(rect)
        let svg = new Image()
        //let svg = im

        const promise = new Promise((resolve, reject) => {
            svg.onload = ()=>{resolve(svg) };
            svg.onerror = (e)=>{ reject( { message:"SVG error" }) };
        })

        svg.decoding = 'sync' // doesn't always work, just a hint
        svg.src = "data:image/svg+xml;base64," + btoa(text)
        //svg.setAttribute("href", "data:image/svg+xml;base64," + btoa(text))
        if (svg.complete) {
            this.svg = svg
        }
        else {
            this.svg = await promise
        }
        this.svg_of_rect = rect
        //main_view.appendChild(this.svg)
        return this.svg
    }

    async make_img_gl_texture(for_fb) {
        const pa = await this.get_pixels_adapter(for_fb, true) // draws on canvas_img_shadow
        // TBD use canvas directly instead of ImageData
        //const pixels = pa.get_pixels()
        const tex = generateTexture(for_fb.width(), for_fb.height(), canvas_img_shadow, this.tex_smooth, 'pad', 'pad') 
            // pad since we're rendering at the size of the frame-buffer so this is not very important (still can be visible if texture is sampled outside the framebuffer)
        tex.t_mat = mat3.create()
        mat3.copy(tex.t_mat, this.t_mat)        
        return tex
    }

    
}


// adapts the gradient object which doesn't have dimentions to an object that can be used with
// SetAttr which samples pixels.
// take the bbox that we want to sample in and render the gradient only there
class GradientPixelsAdapter {
    constructor(for_obj, grd_obj, is_fb) {
        this.pixels = null
        this.obj = grd_obj

        if (grd_obj.sample_tex) {
            this.bbox = new BBox(SAMPLER_COORDS[0].x, SAMPLER_COORDS[0].y, SAMPLER_COORDS[1].x, SAMPLER_TEX_HEIGHT_SZ) // need to have some width
            this.w_width = this.bbox.width()   
            this.w_height = this.bbox.height()
            this.px_width = grd_obj.tex_res
            this.px_height = SAMPLER_TEX_HEIGHT_PX
            this.dest_tmat = null
            this.draw_scale = [this.px_width / this.w_width, this.px_height / this.w_height]
            return
        }

        dassert(for_obj !== null && for_obj.get_bbox !== undefined, "Expected object with bounding box")

        this.bbox = for_obj.get_bbox() // in abstract coords
        this.w_width = this.bbox.width()   
        this.w_height = this.bbox.height()

        if (!is_fb) { // either size is coming from the texture destination or we're drawing on the viewport so the size is coming from the viewport
            // TBD this is very problematic, if the viewport right now is somewhere else
            // If there is a SetAttr that is very small in the current viewport, this would cause it to have very low sampling resolution
            this.px_width = Math.round(this.w_width * image_view.viewport_zoom)  
            this.px_height = Math.round(this.w_height * image_view.viewport_zoom)
            this.draw_scale = [image_view.viewport_zoom, image_view.viewport_zoom]
            this.dest_tmat = null
            this.obj_sz_x = null
            this.obj_sz_y = null            
        }
        else {
            this.px_width = for_obj.width()
            this.px_height = for_obj.height()
            this.obj_sz_x = for_obj.sz_x
            this.obj_sz_y = for_obj.sz_y
            //this.draw_scale = [this.px_width/this.w_width, this.px_height/this.w_height] // good
            this.draw_scale = [this.px_width/this.obj_sz_x, this.px_height/this.obj_sz_y]
            this.dest_tmat = for_obj.t_mat // transform of the destination (Framebuffer)
        }
       // this.t_mat = grd_obj.t_mat
    }
    width() { return this.px_width }
    height() { return this.px_height }
    get_spread() { return this.obj.spread }

    async make_pixels(doImageData) {
        if (this.pixels !== null) 
            return
        this.obj.ensure_grd()

        canvas_img_shadow.width = this.px_width
        canvas_img_shadow.height = this.px_height

        ctx_img_shadow.save()
        // bring to top-left corner of the mesh to 0,0
        let m = mat3.create()
        mat3.scale(m, m, this.draw_scale)
        canvas_setTransform(ctx_img_shadow, m)
       if (this.dest_tmat === null) {
           ctx_img_shadow.translate(-this.bbox.min_x, -this.bbox.min_y)
        }
        else { // from FrameBuffer
           //ctx_img_shadow.translate(this.bbox.width()*0.5, this.bbox.height()*0.5) // good
            ctx_img_shadow.translate(this.obj_sz_x*0.5, this.obj_sz_y*0.5)

            // if the destination FrameBuffer is also transformed, do the opposite of that
            let dminv = mat3.create()
            mat3.invert(dminv, this.dest_tmat)
            canvas_transform(ctx_img_shadow, dminv)
        }

        const rp = this.obj.make_rect_points(vec2.fromValues(this.bbox.min_x,this.bbox.min_y), vec2.fromValues(this.bbox.max_x, this.bbox.max_y), false)
        await this.obj.pre_draw_rect(rp)
        this.obj.draw_fill_rect(ctx_img_shadow, rp)

        ctx_img_shadow.restore()
        if (doImageData)
            this.pixels = ctx_img_shadow.getImageData(0, 0, this.px_width, this.px_height).data;
        else
            this.pixels = null
    }

    get_pixels() {
        return this.pixels        
    }
    get_transform_to_pixels() {
        let transform = mat3.create()
        // for gradient we need to stretch all the points sampled to the size of the sampled bbox area
        mat3.scale(transform, transform, vec2.fromValues(this.width()-1, this.height()-1 ))
        mat3.scale(transform, transform, vec2.fromValues(1/this.bbox.width(), 1/this.bbox.height() ))
        mat3.translate(transform, transform, vec2.fromValues(-this.bbox.min_x, -this.bbox.min_y))
        return transform
    }
}

const SAMPLER_TEX_HEIGHT_PX = 10
const SAMPLER_TEX_HEIGHT_SZ = 0.2

class LinearGradient extends Gradient {
    static name() { return "Linear Gradient" }
    constructor(x1,y1, x2,y2, tex_res, tex_smooth, sample_tex) {
        if (sample_tex) {
            x1 = SAMPLER_COORDS[0].x; y1 = SAMPLER_COORDS[0].y; 
            x2 = SAMPLER_COORDS[1].x; y2 = SAMPLER_COORDS[1].y;
        }
        super(x1,y1, x2, y2, tex_smooth)
        this.tex_res = tex_res // only relevant for Sample tex

        this.ctx_create_func = function() { return ctx_img.createLinearGradient(x1,y1, x2,y2) }

        this.tex_obj_cache = null
        this.sample_tex = sample_tex  // bool means the texture is going to be a 1d sample range and not an actual image
    }
    destructor() {
        if (this.tex_obj_cache !== null)
            this.del_texture_cache()
    }

    transform(m) { 
        if (this.sample_tex)
            return // it should be appear to be possible to transform a sampler gradient
        super.transform(m)
    }
    set_transform(m) { 
        if (this.sample_tex)
            return
        super.set_transform(m)
    }

    draw_selection_m(m, selected_indices) {
        this.draw_line_points(this.p1, this.p2)
        this.draw_sel_points(selected_indices, this.p1, this.p2)
    }
    draw_template_m(m) {
        this.draw_line_points(this.p1, this.p2, TEMPLATE_LINE_COLOR)
    }
    svg_text_geom() {
        return ["linearGradient", ['x1="', this.p1[0], '" y1="', this.p1[1], '" x2="', this.p2[0], '" y2="', this.p2[1], '"']]
    }

    del_texture_cache() {
        gl.deleteTexture(this.tex_obj_cache)
        this.tex_obj_cache = null
        this.tex_with_params = null        
    }

    make_sample_gl_texture() {
        if (this.tex_obj_cache !== null) {
            return this.tex_obj_cache // caller should do bind
        }
        // draw canvas
        canvas_img_shadow.width = this.tex_res
        canvas_img_shadow.height = SAMPLER_TEX_HEIGHT_PX

        const grd = ctx_img_shadow.createLinearGradient(0,0, this.tex_res,0)
        this.add_stops(grd)

        ctx_img_shadow.fillStyle = grd
        ctx_img_shadow.beginPath()
        // can't use x+w since if there's a transform, we actuall draw a rotated rect
        ctx_img_shadow.moveTo(0,0); ctx_img_shadow.lineTo(this.tex_res, 0)
        ctx_img_shadow.lineTo(this.tex_res, SAMPLER_TEX_HEIGHT_PX); ctx_img_shadow.lineTo(0, SAMPLER_TEX_HEIGHT_PX)
        ctx_img_shadow.fill()
        //const im = ctx_img_shadow.getImageData(0, 0, resolution, SAMPLER_TEX_HEIGHT_PX)
     
        let tex = generateTexture(this.tex_res, SAMPLER_TEX_HEIGHT_PX, canvas_img_shadow, this.tex_smooth, this.spread, 'pad')
        tex.t_mat = mat3.create()  // identity transform

        this.tex_obj_cache = tex
        return tex
    }


    async make_gl_texture(for_obj) {
        if (this.sample_tex)
            return this.make_sample_gl_texture()
        return await this.make_img_gl_texture(for_obj)
    }
}



// get the points on the circle that are used for changing the radius
function get_circle_points(p1, r1, p2, r2) {
    let v12 = vec2.fromValues(p2[0]-p1[0], p2[1]-p1[1])  // this is what canvas does
    if (v12[0] == 0 && v12[1] == 0)
        v12 = vec2.fromValues(1,0)
    vec2.normalize(v12, v12)
    const pa = vec2.fromValues(p1[0], p1[1])
    vec2.scaleAndAdd(pa, pa, v12, -r1)
    const pb = vec2.fromValues(p2[0], p2[1])
    vec2.scaleAndAdd(pb, pb, v12, -r2)
    return [pa,pb]       
}
function get_circle_points_xy(p1, r1, p2, r2) {
    let r = get_circle_points(vec2.fromValues(p1.x,p1.y), r1, vec2.fromValues(p2.x,p2.y), r2)
    return [{x:r[0][0],y:r[0][1]}, {x:r[1][0],y:r[1][1]}]
}

function circle(p, r) {
    ctx_img.moveTo(p[0]+r, p[1])
    ctx_img.arc(p[0], p[1], r, 0, 2*Math.PI)
}

class RadialGradient extends Gradient {
    static name() { return "Radial Gradient" }
    constructor(x1,y1,r1, x2,y2,r2, tex_smooth) {
        super(x1,y1, x2, y2, tex_smooth)
        dassert(r1 > 0 && r2 > 0, "radius radius needs to be positive")

        this.r1 = r1
        this.r2 = r2
        this.ctx_create_func = ()=>{ 
            return ctx_img.createRadialGradient(x1,y1,r1, x2,y2,r2) 
        }
    }
    draw_circles(tp1, tp2, line_color="#000") {
        const p1 = this.p1, p2 = this.p2, r1 = this.r1, r2 = this.r2
        ctx_img.save()
        canvas_transform(ctx_img, this.t_mat)
        {
            ctx_img.beginPath()
            circle(p1, r1) // use p1 since we're transforming the canvas above
            circle(p2, r2)
        }
        ctx_img.restore()
        // point marker
        const radius = MESH_DISP.vtx_radius / image_view.viewport_zoom
        circle(tp1, radius)
        circle(tp2, radius)
        ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        ctx_img.strokeStyle = line_color
        ctx_img.stroke()

        // center circles should be different somehow so mark them with additional white
        ctx_img.beginPath()
        ctx_img.strokeStyle = "#ffffff"
        circle(tp1, radius*0.7) 
        circle(tp2, radius*0.7)
        ctx_img.stroke()
        ctx_img.strokeStyle = "#000"
    }

    draw_controls(line_color="#000") {
        // anything that draws point-marker circles can't use the canvas transform so the points
        // need to be manually transformed with t_mat.
        const tp1 = vec2.create(), tp2 = vec2.create()
        vec2.transformMat3(tp1, this.p1, this.t_mat)
        vec2.transformMat3(tp2, this.p2, this.t_mat)
        this.draw_circles(tp1, tp2, line_color)
        // not using tp1,tp2 for this since r1,r2 can't be transformed
        const [pa,pb] = get_circle_points(this.p1, this.r1, this.p2, this.r2)

        this.draw_line_points(pa, pb, line_color)        
    }

    draw_selection_m(m, selected_indices) {
        this.draw_controls()
        const [pa,pb] = get_circle_points(this.p1, this.r1, this.p2, this.r2)
        this.draw_sel_points(selected_indices, pa, pb)
    }
    draw_template_m(m) {
        this.draw_controls(TEMPLATE_LINE_COLOR)
    }

    svg_text_geom(grad) {
        return ["radialGradient", ['cx="', this.p2[0], '" cy="', this.p2[1], '" r="',  this.r2, '" fx="', this.p1[0], '" fy="', this.p1[1], '" fr="', this.r1, '"']]
    }

    async make_gl_texture(for_obj) {
        return await this.make_img_gl_texture(for_obj)
    }
}

const CONIC_COLORS_RADIUS = 100

class ConicGradient extends Gradient
{
    static name() { return "Conic Gradient" }
    constructor(x1,y1, tex_smooth) {
        super(x1,y1, x1, y1, tex_smooth)
 
        this.ctx_create_func = ()=>{ 
            return ctx_img.createConicGradient(this.offset*2*Math.PI, x1, y1) 
        }
    }

    need_svg() {  // svg doesn't support conic, and we don't need to anyway
        return false
    }

    draw_controls(line_color="#000")
    {
        const tp1 = vec2.create()
        vec2.transformMat3(tp1, this.p1, this.t_mat)
        const vtx_radius = MESH_DISP.vtx_radius / image_view.viewport_zoom
        ctx_img.beginPath()
        circle(tp1, vtx_radius)

        circle(tp1, CONIC_COLORS_RADIUS / image_view.viewport_zoom) // color selection radius

        ctx_img.lineWidth = MESH_DISP.line_width/image_view.viewport_zoom
        ctx_img.strokeStyle = line_color
        ctx_img.stroke()
    }

    draw_stops_points()
    {
        const tp1 = vec2.create()
        vec2.transformMat3(tp1, this.p1, this.t_mat)
        const vtx_radius = MESH_DISP.vtx_radius / image_view.viewport_zoom
        const colors_radius = CONIC_COLORS_RADIUS / image_view.viewport_zoom

        // reverse order so that the first one show above the last one
        for(let si = this.stops.length - 1; si >= 0; --si) {
            const s = this.stops[si]
            // value is 0-1 for the whole circle, convert to radians
            const ang = (s.value + this.offset) * 2*Math.PI
            const x = tp1[0] + Math.cos(ang) * colors_radius
            const y = tp1[1] + Math.sin(ang) * colors_radius

            ctx_img.beginPath();
            ctx_img.arc(x, y, vtx_radius, 0, 2*Math.PI)
            ctx_img.fillStyle = make_str_color(s.color)
            ctx_img.fill()
            ctx_img.stroke()
        }
    }

    draw_sel_points(selected_indices) {
        const radius = MESH_DISP.vtx_sel_radius/image_view.viewport_zoom
        const colors_radius = CONIC_COLORS_RADIUS / image_view.viewport_zoom
        ctx_img.beginPath();
        for(let idx of selected_indices) {
            let p;
            if (idx == 0) 
                p = this.p1
            else if (idx < NODE_POINT_LST_OFFSET)
                continue
            else {
                const s = this.stops[idx-NODE_POINT_LST_OFFSET]
                const ang = (s.value + this.offset) * 2*Math.PI
                p = [ this.p1[0] + Math.cos(ang) * colors_radius,
                      this.p1[1] + Math.sin(ang) * colors_radius ]
            }
            // no need to transorm with t_mat since this is done only on the gradient node where t_mat is ident
            ctx_img.moveTo(p[0] + radius, p[1])
            ctx_img.arc(p[0], p[1], radius, 0, 2*Math.PI)
        }
        ctx_img.lineWidth = 2/image_view.viewport_zoom
        ctx_img.strokeStyle = MESH_DISP.sel_color
        ctx_img.stroke()        
    }
    

    draw_selection_m(m, selected_indices) {
        this.draw_controls()
        this.draw_stops_points()
        this.draw_sel_points(selected_indices)
    }
    draw_template_m(m) {
        this.draw_controls(TEMPLATE_LINE_COLOR)
    }
}

// add_point_select_mixin expects a list of points, gradient has 2 or 3 points
// outside the list, this adapts this data to the expected interface
class GradPointsAdapterParam {
    constructor(p1, p2, range_lst_param, nodecls) {
        this.p1 = p1
        this.p2 = p2
        this.move_prm = [p1,p2,null,null]    
        this.range_lstprm = range_lst_param
        this.nodecls = nodecls
        // simulates a list with move_prm followed by range_lst_prm
    }
    count() {
        return this.move_prm.length + this.range_lstprm.count()
    }

    get_value(vidx) {
        dassert(vidx !== undefined, "unexpected vidx undefined")
        const idx = vidx / 2
        //if (idx == 0 || idx == 1)
        //    return [null,null] // test, select only radius points
        if (idx < this.move_prm.length) {
            if (this.move_prm[idx] === null) // 2,3 of linear are not used
                return [null,null]
            return this.move_prm[idx].get_value()
        }
        const [pa,pb] = this.get_pa_pb()
        const t = this.range_lstprm.get_value(idx - this.move_prm.length)
        const x = pa.x * (1-t) + pb.x * t
        const y = pa.y * (1-t) + pb.y * t
        return [x,y]
    }
    increment(idx, dv) {
        if (idx < this.move_prm.length) {
            this.move_prm[idx].increment(dv)  // move end point
        }
        else {
            const [pa,pb] = this.get_pa_pb()
            // project dv on the line
            const v12 = vec2.fromValues(pb.x - pa.x, pb.y - pa.y)
            const dt = vec2.dot(dv, v12) / vec2.dot(v12, v12);

            const ridx = idx - this.move_prm.length
            const v = Math.min(1, Math.max(0, this.range_lstprm.get_value(ridx) + dt))

            this.increment_color_point(ridx, v)
        } 
    }
    increment_color_point(ridx, v) {
        this.range_lstprm.modify(ridx, v) // moves stop value
        this.nodecls.redo_sort()
    }

    project_to_stops_line(cp) {
        const [pa,pb] = this.get_pa_pb()
        // project clicked point to the line and find the distance to the line the the value on the line for that point
        return project_dist(cp, pa, pb)
    }

    reprint_all_lines() { // mark yellow
        this.range_lstprm.reprint_all_lines()
    }
    translate_idx_to_obj(sel_indices) {
        const inv_sorder_order = []
        for(let i in this.nodecls.sorted_order)
            inv_sorder_order[this.nodecls.sorted_order[i]] = parseInt(i)
        const ret = []
        for(let sidx of sel_indices) {
            if (sidx < this.move_prm.length)
                ret.push(sidx) // special points
            else
                ret.push(inv_sorder_order[sidx - this.move_prm.length] + this.move_prm.length) 
        }
        return ret
    }
}

class Linear_GradPointsAdapterParam extends GradPointsAdapterParam {
    constructor(p1, p2, range_lst_param, nodecls) {
        super(p1, p2, range_lst_param, nodecls)
    }
    get_pa_pb() {
        return [this.p1, this.p2]
    }
}

function went_other_way(pr2, pcenter, pv) {
    const to_pr2 = vec2.fromValues(pr2.x-pcenter.x, pr2.y-pcenter.y)
    const to_pv = vec2.fromValues(pv[0]-pcenter.x, pv[1]-pcenter.y)
    return vec2.dot(to_pr2, to_pv) < 0
}

class Radial_GradPointsAdapterParam extends GradPointsAdapterParam {
    constructor(p1, r1, p2, r2, range_lst_param, nodecls) {
        super(p1, p2, range_lst_param, nodecls)
        this.r1 = r1
        this.r2 = r2
    }
    get_pa_pb() {
        return get_circle_points_xy(this.p1, this.r1.v, this.p2, this.r2.v)
    }
    get_value(vidx) {
        dassert(vidx !== undefined, "unexpected vidx undefined")
        let idx = vidx / 2
        // special handling of the points on the radius
        if (idx == 2) {
            let [pa,pb] = this.get_pa_pb()
            return [pa.x, pa.y]
        }
        if (idx == 3) {
            let [pa,pb] = this.get_pa_pb()
            return [pb.x, pb.y]
        }
        return super.get_value(vidx)
    }
    increment(idx, dv) {
        // special handling of the points on the radius
        if (idx == 2) {
            const [pa,pb] = this.get_pa_pb()
            const pv = vec2.fromValues(pa.x + dv[0], pa.y + dv[1])
            const r = vec2.distance(pv, vec2.fromValues(this.p1.x, this.p1.y))
            this.r1.modify(r)

            const [pa2,pb2] = this.get_pa_pb()
            if (went_other_way(pa2, this.p1, pv))
                this.r1.modify(0)
        }
        else if (idx == 3) {
            const [pa,pb] = this.get_pa_pb()
            const pv = vec2.fromValues(pb.x + dv[0], pb.y + dv[1])
            const r = vec2.distance(pv, vec2.fromValues(this.p2.x, this.p2.y))
            this.r2.modify(r)
            
            const [pa2,pb2] = this.get_pa_pb()
            if (went_other_way(pb2, this.p2, pv))
                this.r2.modify(0)            
        }
        else
            super.increment(idx, dv)
    }
}

class Conic_GradPointsAdapterParam extends GradPointsAdapterParam {
    constructor(p1, range_lst_param, nodecls) {
        super(p1, null, range_lst_param, nodecls)
    }

    get_value(vidx) {
        dassert(vidx !== undefined, "unexpected vidx undefined")
        let idx = vidx / 2
        // special handling of the points on the radius
        if (idx < this.move_prm.length) {
            return super.get_value(vidx)
        }

        let t = this.range_lstprm.get_value(idx - this.move_prm.length)

        const colors_radius = CONIC_COLORS_RADIUS / image_view.viewport_zoom

        const ang = (t + this.nodecls.stops_offset.v) * 2*Math.PI
        const x = this.p1.x + Math.cos(ang) * colors_radius
        const y = this.p1.y + Math.sin(ang) * colors_radius

        return [x,y]
        
    }
    increment(idx, dv) {
        if (idx < this.move_prm.length) {
            super.increment(idx, dv)
            return
        }

        const colors_radius = CONIC_COLORS_RADIUS / image_view.viewport_zoom

        const ridx = idx - this.move_prm.length
        const ot = this.range_lstprm.get_value(ridx) 
        const o_inang = (ot + this.nodecls.stops_offset.v) * 2*Math.PI
        const ov = vec2.fromValues(Math.cos(o_inang) * colors_radius,
                                   Math.sin(o_inang) * colors_radius)
        const nv = vec2.create()
        vec2.add(nv, ov, dv)
        vec2.normalize(nv, nv)
        vec2.normalize(ov, ov)

        const n_ang = Math.atan2(nv[1], nv[0])
        const o_ang = Math.atan2(ov[1], ov[0])
        let d_angle = n_ang - o_ang 

        // like in rotation dial
        if (d_angle > Math.PI) d_angle -= 2*Math.PI
        if (d_angle < -Math.PI) d_angle += 2*Math.PI

        const dt = d_angle/(2*Math.PI)
        // connect start and end
        let nt = ot + dt
        if (nt > 1.0)
            nt -= 1.0
        if (nt < 0.0)
            nt += 1.0

        this.increment_color_point(ridx, nt)
    }

    project_to_stops_line(cp) {
        const vp = vec2.clone(cp)
        vp[0] -= this.p1.x
        vp[1] -= this.p1.y

        let ang = Math.atan2(vp[1], vp[0])
        //if (ang > Math.PI) ang -= 2*Math.PI
        if (ang < 0) ang += 2*Math.PI    
        
        // const ang = (t + this.nodecls.stops_offset.v) * 2*Math.PI
        const t = (ang / (2*Math.PI)) - this.nodecls.stops_offset.v

        const colors_radius = CONIC_COLORS_RADIUS / image_view.viewport_zoom
        const dist = vec2.length(vp) - colors_radius

        return [dist, t]
    }
}


function project_dist(cp, p1, p2) {
    let v12 = vec2.fromValues(p2.x - p1.x, p2.y - p1.y)
    let v1p = vec2.fromValues(cp[0] - p1.x, cp[1] - p1.y)
    let ad = vec2.dot(v1p, v12) / vec2.dot(v12, v12);
    let d = Math.min(1, Math.max(0, ad))
    let pp = vec2.fromValues(p1.x, p1.y) // projected point
    pp[0] += d * v12[0]
    pp[1] += d * v12[1]
    vec2.sub(pp, pp, cp) // vector from projected to cp
    let dist = vec2.len(pp)
    return [dist,d]
}



const GRADIENT_PRESETS = [
    [ {v:0, c:'#f00'}, {v:0.5, c:'#ff0'}, {v:1, c:'#0f0'}],
    [ {v:0, c:'#000'}, {v:0.25, c:'#800000'}, {v:0.5, c:'#ff8000'}, {v:0.75, c:'#ffff80'}, {v:1, c:'#fff'}],  // fire
    [ {v:0, c:'hsl(0,100%,50%)'},{v:60/300, c:'hsl(60,100%,50%)'},{v:120/300, c:'hsl(120,100%,50%)'},
      {v:180/300, c:'hsl(180,100%,50%)'},{v:240/300, c:'hsl(240,100%,50%)'},{v:1, c:'hsl(300,100%,50%)'} ],
    [ {v:0, c:'#6727E0'}, {v:0.35, c:'#D418CC'}, {v:0.63, c:"#FB63B1"}, {v:1, c:"#F8F45F"} ],
    [ {v:0, c:'#000'}, {v:1, c:"#fff"} ],
    [ {v:0, c:'#000'}, {v:1, c:"rgba(0,0,0,0)"} ],
    [ {v:0, c:'#C2EAF4'}, {v:0.174, c:'#8C6DE2'}, {v:0.32, c:'#E21BD8'}, {v:0.57, c:'#D2CA4A'}, {v:0.68, c:'#F3F94D'}, {v:1, c:"#14EDE2"} ],
    [ {v:0, c:'#0EE0F4'}, {v:0.31, c:"#4FE2BB"}, {v:0.59, c:"#A4E57E"}, {v:1, c:"#FEE835"} ],
    [ {v:0, c:'#72B743'}, {v:0.3, c:"#9DD224"}, {v:0.57, c:"#D9F98D"}, {v:0.662, c:"#E2FFA1"}, {v:1, c:"#FED242"} ],
    [ {v:0, c:'#E74079'}, {v:0.33, c:"#FEC0A0"}, {v:0.66, c:"#FFE45B"}, {v:1, c:"#ED9B20"} ],
    [ {v:0, c:'#1CFECF'}, {v:0.39, c:'#536FDE'}, {v:1, c:"#FE73E6"} ],
    [ {v:0, c:'#E8FF85'}, {v:0.212, c:'#CAFAD6'}, {v:0.5, c:'#C6EEF9'}, {v:0.761, c:'#DBCBFA'}, {v:1, c:"#F89ADD"} ],
    [ {v:0, c:'#FF21AB'}, {v:0.313, c:'#EB1F6F'}, {v:0.4, c:'#EA2869'}, {v:0.711, c:'#FF7C73'}, {v:1, c:"#FF9C36"} ],
    [ {v:0, c:"#582A20"}, {v:0.056, c:"#E9D7D1"}, {v:0.308, c:"#B64D49"}, {v:0.417, c:"#82322F"}, {v:0.438, c:"#9C6563"}, 
       {v:0.460, c:"#D2B9B8"}, {v:0.479, c:"#FEFEFE"}, {v:0.742, c:"#95B4CB"}, {v:0.871, c:"#7690B9"}, {v:0.919, c:"#83A7C3"}, {v:1, c:"#D9E8F3"} ], // MS Word 2003 "Horizon"
    [ {v:0, c:"#A703AA"}, {v:0.130, c:"#E91A5F"}, {v:0.278, c:"#EF4716"}, {v:0.480, c:"#FFFD00"}, {v:0.648, c:"#209046"}, {v:0.791, c:"#081BF9"}, {v:1, c:"#A203AD"} ], // MS Word 2003 "Rainbow"
    [ {v:0, c:"#3366FE"}, {v:0.230, c:"#05A298"}, {v:0.363, c:"#74CF4E"}, {v:0.498, c:"#FFFE00"}, {v:0.735, c:"#FF6F30"}, {v:1, c:"#FF3497"} ], // MS Word 2003 "Rainbow II"
    [ {v:0, c:'#00f'}, {v:0.5, c:'#000'}, {v:1, c:'#f00'}],
  //  [ {v:0, c:'#f00'}, {v:1, c:"#fff"} ],
  //  [ {v:0, c:'#0f0'}, {v:1, c:"#fff"} ],
  //  [ {v:0, c:'#00f'}, {v:1, c:"#fff"} ],
  // [ {v:0, c:'#0ff'}, {v:1, c:"#fff"} ],
  //  [ {v:0, c:'#ff0'}, {v:1, c:"#fff"} ],
  //  [ {v:0, c:'#f0f'}, {v:1, c:"#fff"} ],

]

function checkers_rect(ctx, w, h, opt) {
    if (opt === undefined)
        opt = ColorPicker.CHECKERS
    const l = opt.light, d = opt.dark, cw = opt.width
    ctx.fillStyle = "rgb(" + l + "," + l + "," + l + ")"
    ctx.fillRect(0, 0, w, h)
    ctx.fillStyle = "rgb(" + d + "," + d + "," + d + ")"
    for(let x = 0, xi = 0; x < w; x += cw, ++xi) {
        for(let y = 0, yi = 0; y < h; y += cw, ++yi) {
            if (xi % 2 == yi % 2)
                continue
            ctx.fillRect(x, y, cw, cw)
        }
    }
}

const PRESET_RECT_SZ = 45
function make_preset_img(pr, parent) {
    if (pr.img !== undefined) {
        parent.appendChild(pr.img)
        return
    }
    ensure_scratch_canvas()
    scratch_canvas.width = PRESET_RECT_SZ
    scratch_canvas.height = PRESET_RECT_SZ
    checkers_rect(ctx_scratch, PRESET_RECT_SZ, PRESET_RECT_SZ)
    let g = ctx_scratch.createLinearGradient(0,0,PRESET_RECT_SZ,PRESET_RECT_SZ)
    for(let stop of pr) {
        g.addColorStop(stop.v, stop.c)
    }
    ctx_scratch.fillStyle = g
    ctx_scratch.fillRect(0, 0, PRESET_RECT_SZ, PRESET_RECT_SZ)
    let url = scratch_canvas.toDataURL()
    let img = new Image()
    img.src = url
    pr.img = img // cache
    parent.appendChild(pr.img)
}


function vec2col(c) {
    return [clamp(0, Math.round(c[0]), 255), 
            clamp(0, Math.round(c[1]), 255), 
            clamp(0, Math.round(c[2]), 255), 
            (c.length == 4) ? clamp(0, Math.round(c[3]), 255) : 255]
}

function col_equals(a, b) {
    const ACCURACY = 1
    return Math.abs(a[0]-b[0]) < ACCURACY && Math.abs(a[1]-b[1]) < ACCURACY && Math.abs(a[2]-b[2]) < ACCURACY && Math.abs(a[3]-b[3]) < ACCURACY
}

// This mocks a param that has fixed coordinates that can't be changed
class DummyVec2Param {
    constructor(x, y) {
        this.x = x // used in GradPointsAdapterParam::get_value
        this.y = y
    }
    get_value() {
        return [null, null] // indicate that it can't be selected and moved
    }
    increment() {}
}

const SAMPLER_COORDS = [new DummyVec2Param(0,0), new DummyVec2Param(1,0)]
const GRADIENT_ADD_PNT_DIST = 10

class NodeGradient extends NodeCls
{
    static name() { return "Gradient" }
    constructor(node) {
        super(node)
        this.sorted_order = [] // list is not recreated, just overwritten
        this.selected_indices = []
        this.points_adapter = null
        node.set_state_evaluators({"t":  (m,s)=>{ return new ObjSingleEvaluator(m,s) }})

        this.out = new OutTerminal(node, "out_gradient")
        // Sample is for NodeFuncFill to get color from float. It's just a linear gradient without any geometry
        this.type = new ParamSelect(node, "Type", 0, ["Linear", "Radial", "Sample", "Conic"], (sel_idx)=>{
            this.r1.set_visible(sel_idx == 1)
            this.r2.set_visible(sel_idx == 1)
            this.p1.set_visible(sel_idx == 0 || sel_idx == 1 || sel_idx == 3)
            this.p2.set_visible(sel_idx == 0 || sel_idx == 1)
            this.spread.set_visible(sel_idx != 3)
            offset_enable()

            this.tex_resolution.set_visible(sel_idx == 2)
 
            // set points adapter
            if (sel_idx == 0)
                this.points_adapter = new Linear_GradPointsAdapterParam(this.p1, this.p2, this.values, this)
            else if (sel_idx == 2) //Sample
                this.points_adapter = new Linear_GradPointsAdapterParam(SAMPLER_COORDS[0], SAMPLER_COORDS[1], this.values, this)
            else if (sel_idx == 1)
                this.points_adapter = new Radial_GradPointsAdapterParam(this.p1, this.r1, this.p2, this.r2, this.values, this)
            else if (sel_idx == 3)
                this.points_adapter = new Conic_GradPointsAdapterParam(this.p1, this.values, this)
                
            this.selected_indices.includes_shifted = function(v) { return this.includes(v + NODE_POINT_LST_OFFSET) } // used for yellow mark of the selected point
            add_point_select_mixin(this, this.selected_indices, this.points_adapter) // done here after the adapter is created
        })
        this.method = new ParamSelect(node, "Method", 0, ["Stops", "Function"], (sel_idx)=>{
            this.table.set_visible(sel_idx == 0)
            if (sel_idx == 0) 
                this.table.remake_table() // when it was not visible, it wasn't updated
            this.add_stops_btn.set_visible(sel_idx == 0)
            this.func.set_visible(sel_idx == 1)
            this.func_samples.set_visible(sel_idx == 1)
        })
        this.method.share_line_elem_from(this.type)
        this.p1 = new ParamVec2(node, "Point 1", -0.5, 0)
        this.r1 = new ParamFloat(node, "Radius 1", 0.1)
        this.p2 = new ParamVec2(node, "Point 2", 0.5, 0)
        this.r2 = new ParamFloat(node, "Radius 2", 0.7)
 
        this.spread = new ParamSelect(node, "Spread", 0, [["Pad",       ['pad', false]], // [display-name, [spread-name, via_svg]]
                                                          ["Pad (svg)", ['pad', true]],
                                                          ["Reflect",   ['reflect', true]],
                                                          ["Repeat",    ['repeat', true]] ], 
        (sel_idx)=>{
            offset_enable()
        })
        this.func = new ParamColor(node, "f(t)=", ["#cccccc", "rgb(255, 128, 0.0) + rgb(t, t, t)*255"], {show_code:true}) // just a way to generate points example: rgb(255,128,0)+rgb(t,t,t)*255
        this.func_samples = new ParamInt(node, "Sample Num", 10, {min:1, max:30, visible:false})
        const presets_btn = new ParamImageSelectBtn(node, "Presets", GRADIENT_PRESETS, make_preset_img, (pr)=>{this.load_preset(pr)})
        this.add_stops_btn = new ParamBool(node, "Add stops", true, (v)=>{
            this.print_stops()
        }, {allow_expr:false, as_btn:true})
        this.add_stops_btn.share_line_elem_from(presets_btn)
        this.table = new ParamTable(node, "Stops", this.sorted_order)
        this.values = new ParamFloatList(node, "Value", this.table, this.selected_indices, ()=>{this.redo_sort()})
        this.colors = new ParamColorList(node, "Color", this.table)

        // for generating texture
        this.tex_resolution = new ParamInt(node, "Tex Resolution", 128, [8,128]) // only for sampler
        this.tex_smooth = new ParamBool(node, "Tex Smooth", false)
        this.stops_offset = new ParamFloat(node, "Offset(t)", "0")  // offset function or constant offset
        const offset_enable = ()=>{
            this.stops_offset.set_visible( this.spread.sel_idx == 2 || this.spread.sel_idx == 3 || this.type.sel_idx == 3)
        }

        this.load_preset(GRADIENT_PRESETS[0])
        
        // TBD points as expressions
    }
    print_stops() {
        let s = ""
        for(let i = 0; i < this.sorted_order.length; ++i) {
            const ci = this.sorted_order[i]*4
            const c = ColorPicker.make_hex({r:this.colors.lst[ci], g:this.colors.lst[ci+1], b:this.colors.lst[ci+2], alpha:this.colors.lst[ci+3]/255})
            s += "{v:" + this.values.lst[this.sorted_order[i]].toFixed(3) + ', c:"' + c + '"}, '
        }
        console.log(s)
    }
    is_radial() { return this.type.sel_idx == 1 }
    post_load_hook() { this.redo_sort() } // sort loaded values for the table
    // sort the arrays in the order of the value
    redo_sort(force) {
        let tmparr = []
        for(let i = 0; i < this.values.lst.length; ++i)
            tmparr.push([this.values.lst[i],i])
        tmparr.sort(function(a,b) { return a[0]-b[0] })
        let changed = force || (tmparr.length !== this.sorted_order.length)
        if (!changed)
            for(let i = 0; i < tmparr.length; ++i)
                if (tmparr[i][1] !== this.sorted_order[i]) { // anything changed?
                    changed = true
                    break
                }
        if (!changed)
            return
        this.sorted_order.length = 0
        for(let t of tmparr) {
            this.sorted_order.push(t[1])
        }
        this.table.remake_table()
    }



    image_click(ex, ey) {
        if (!this.add_stops_btn.v)
            return
        const cp = image_view.epnt_to_model(ex, ey)
        const [dist, d] = this.points_adapter.project_to_stops_line(cp)

        if (dist > GRADIENT_ADD_PNT_DIST/image_view.viewport_zoom)
            return
        this.values.add(d); 
        this.colors.add([0xcc, 0xcc, 0xcc, 0xff])
        this.redo_sort()
        trigger_frame_draw(true)
    }
    async run() {
        if (this.method.sel_idx == 1) {
            this.load_from_func()
        }
        let obj
        try {
            if (this.is_radial()) 
                obj = new RadialGradient(this.p1.x, this.p1.y, this.r1.v, this.p2.x, this.p2.y, this.r2.v, this.tex_smooth.get_value())
            else if (this.type.sel_idx == 3)
                obj = new ConicGradient(this.p1.x, this.p1.y, this.tex_smooth.get_value())
            else
                obj = new LinearGradient(this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.tex_resolution.get_value(), this.tex_smooth.get_value(), this.type.sel_idx == 2)   
        }
        catch(e) {
            assert(false, this, e.message)
        }
        
        for(let i = 0; i < this.values.lst.length; ++i) {
            const sorted_i = this.sorted_order[i]
            const ci = sorted_i*4
            const v = this.values.lst[sorted_i]
            assert(v >= 0 && v <= 1, this, "stop " + i + " out of range")
            obj.add_stop(v, this.colors.lst.slice(ci, ci+4))
        }
        const [spreadName, via_svg] = this.spread.get_sel_val()
        obj.set_spread(spreadName, via_svg)
        obj.set_offset(this.stops_offset.dyn_eval())

        // making the svg (if needed) is in pre_draw or in adapter's make_pixels()
        this.out.set(obj)
    }

    selected_obj_name() { return (this.selected_indices.length > 0) ? "stops" : null }
    delete_selection() {
        let rm_indices = []
        // indices 0,1 are the end points, cant remove them, the stops are shifted by 2
        for(let idx of this.selected_indices) 
            if (idx >= NODE_POINT_LST_OFFSET)
                rm_indices.push(idx - NODE_POINT_LST_OFFSET)
        this.values.remove(rm_indices)
        this.colors.remove(rm_indices)
        this.redo_sort()
        this.clear_selection()
        trigger_frame_draw(true)
    }

    load_preset(pr) {
        this.values.clear()
        this.colors.clear()
        for(let stop of pr) {
            this.values.add(stop.v)
            let c = ColorPicker.parse_hex(stop.c)            
            this.colors.add([c.r, c.g, c.b, c.alphai])
        }
        this.redo_sort(true) // force sort since we want to force a remake_table 
        this.clear_selection()
        trigger_frame_draw(true)
    }

    load_from_func() {
        const value_need_t = this.func.need_input_evaler("t")
        this.values.clear()
        this.colors.clear()
        let samples = [] // array of [stop-val, color]

        if (value_need_t === null) { // doesn't depend on t
            const c = this.func.dyn_eval()
            samples.push({v:0, c:vec2col(c)})
        }
        else {
            let t_wrap = [0]
            value_need_t.dyn_set_obj(t_wrap)

            // start with sampling in steps of 0.1
            const STEPS = this.func_samples.v
            for(let i = 0; i <= STEPS; ++i) {
                t_wrap[0] = 1/STEPS*i
                const c = this.func.dyn_eval()
                samples.push({v:t_wrap[0], c:vec2col(c)})
            }
            

            // remove points that are not contributing (are a linear iterp of the two adjacent points)
            let did_remove = true
            while(did_remove) {
                did_remove = false
                let a=0, b=1, c=2
                while (c < samples.length) {
                    const va = samples[a].v, vb = samples[b].v, vc = samples[c].v
                    const fb = (vb-va)/(vc-va) // the fraction of b as if a=0 and c=1
                    const intrp = vec4.create()
                    vec4.lerp(intrp, samples[a].c, samples[c].c, fb)
                    if (col_equals(intrp, samples[b].c)) {
                        samples.splice(b, 1)
                        did_remove = true
                    }
                    ++a; ++b; ++c 
                    // skip anyway to the next triplet since we don't want to examine each time points that were adjacent in the 
                    // original sample since if there are many many samples, they would always be close to each other
                    // this is why we need the outer loop
                }
            }
            value_need_t.dyn_set_obj(null) // don't ref local object
        }
        for(let s of samples) {
            this.values.add(s.v)
            this.colors.add(s.c)
        }             
        this.redo_sort(true)

        // TBD don't do all the color table on every click (when doing colors.add)
    }
}
"use strict"


const FUNC_VERT_SRC = `
in vec4 vtx_pos;
out vec2 v_coord;
uniform mat3 t_mat;

void main(void)
{
    vec3 tmp = t_mat * vec3(vtx_pos.xy, 1.0);
    v_coord = tmp.xy;
    gl_Position = vec4(vtx_pos.xy, 1.0, 1.0);
}
`

const EXPR_FRAG_SRC = `

in vec2 v_coord;
out vec4 outColor;


#ifdef _D_IS_GLSL_CODE
#line 1
$GLSL_CODE$
#else // expr code

$UNIFORM_DEFS$

$FUNCS$

#ifndef _D_EXPR_IS_COLOR
float flt_expr() {
    $EXPR$
}
#else
$EXPR_VEC_RET$ vec_expr() {
    $EXPR$
}
vec4 vec_cvt(vec4 v) { return v; }
vec4 vec_cvt(vec3 v) { return vec4(v, 1.0); }
#endif

void main() {
#ifndef _D_EXPR_IS_COLOR
    float v = flt_expr();
 #ifdef _D_TEX0_GRAD
    outColor = texture(_u_in_tex_0, vec2(v,0));
 #else
    outColor = vec4(vec3(1.0, 0.5, 0.0) + vec3(v*2.0-1.0, v*2.0-1.0, v*2.0-1.0), 1.0);
 #endif
#else     
    outColor = vec_cvt(vec_expr());
#endif     
}

#endif // expr code
`

const GLSL_START_V_CODE = `void main() {
    outColor = vec4(1.0, v_coord.x, 0.0, 1.0);    
}
`

// texture can be samples implicitly by have a float expression (and a gradient)
// or explicitly by having a color expression and using in_tex() - takes x,y or vec2 and returns vec4 color

const in_tex_types = {[type_tuple(TYPE_VEC2)]: TYPE_VEC4, [type_tuple(TYPE_NUM, TYPE_NUM)]: TYPE_VEC4}
const in_texi_types = {[type_tuple(TYPE_NUM, TYPE_VEC2)]: TYPE_VEC4, [type_tuple(TYPE_NUM, TYPE_NUM, TYPE_NUM)]: TYPE_VEC4}


class ParamProxy extends Parameter {
    constructor(node, wrap, label=undefined) {
        super(node, (label === undefined) ? wrap.label : label)
        this.wrap = wrap
        if (this.wrap.my_expr_items !== undefined)
            this.my_expr_items = this.wrap.my_expr_items // make resolve_variables work
        if (this.wrap.post_load_hook !== undefined)
            this.post_load_hook = ()=>{ this.wrap.post_load_hook() }
    }
    save() { return this.wrap.save() }
    load(v) { this.wrap.load(v) }
    add_elems(parent) {
        // the proxy group overrides that of the wrapped param
        if (this.group_param !== null && this.group_param.line_elem !== null)
            parent = this.group_param.line_elem        
        this.wrap.add_elems(parent)
    }
    pis_dirty() { return this.wrap.pis_dirty() }
    pclear_dirty() { this.wrap.pclear_dirty() }
    // don't forward set_group() since the proxy can be in a different group
}

// evaluator for the v_coord variable in glsl
class GlslTextEvaluator extends EvaluatorBase {
    constructor(objref, subscripts, glsl_name, allowed_subscripts, obj_type, func_ret_by_args=null) {        
        super()
        this.objref = objref
        if (subscripts.length === 0) { // just name without sub
            this.type = obj_type
            this.name = glsl_name
        }
        else {
            eassert(subscripts.length == 1, "wrong number of subscripts")
            const sub = subscripts[0]
            eassert(allowed_subscripts.indexOf(sub) !== -1, "unknown subscript " + sub)
            this.name = glsl_name + "." + sub
            this.type = TYPE_NUM
        }
        this.func_ret_by_args = func_ret_by_args // map type tuple to function return type
    }
    consumes_subscript() { return true }
    eval() {
        eassert(false, "text evaluator can't be evaled")
    }
    check_type() {
        return this.type
    }
    func_ret_type(args_type_tuple) {
        if (this.func_ret_type_ === null)
            throw new TypeErr("Undefined func_ret_type for " + this.name)
        const t = this.func_ret_by_args[args_type_tuple]
        if (t === undefined)
            throw new TypeErr("No function overload of func " + this.name + "() takes arguments " + type_tuple_str(args_type_tuple))
        return t
    }
    clear_types_cache() {} // no need to clear since it's not dependent on anything that can change
    to_glsl(emit_ctx) {
        return this.name
    }
    additional_score_flags() {
        return EXPR_GLSL_ONLY
    }
}

function glsl_type_name(t) {
    switch(t) {
    case TYPE_NUM: return "float"
    case TYPE_VEC2: return "vec2"
    case TYPE_VEC3: return "vec3"
    case TYPE_VEC4: return "vec4"
    default: throw TypeErr("unexpected type for glsl " + t)
    }
}



class GlslEmitContext {
    constructor() {
        this.add_funcs = null    // function definitions to go before main
        this.uniform_decls = []  // set of strings of the uniform declarations
        this.inline_str = null  // the final expression
        this.uniform_evaluators = {} // map name of uniform to UniformVarRef
        this.glsl_code = ""
        this.vec_expr_type = 'vec4'
        this.locals_defs = {} // map local variable name to type
    }
    add_uniform(type, name, evaluator) { // expression getting uniforms from variables
        if (this.uniform_evaluators[name] !== undefined)
            return  // happens if the same variable appears more than once in the expression
        this.uniform_decls.push("uniform " + glsl_type_name(type) + " " + name + ";")
        this.uniform_evaluators[name] = evaluator
    }

    do_replace(text) {
        let func_body = ""
        for(let name in this.locals_defs) // define all locals ahead of everything else since a local may be first assigned in an if
            func_body += glsl_type_name(this.locals_defs[name]) + " " + name + ";\n"
        

        return text.replace('$FUNCS$', (this.add_funcs === null)?"":this.add_funcs.to_text())
                   .replace('$UNIFORM_DEFS$', this.uniform_decls.join('\n')) // from variables
                   .replace(/\$EXPR\$/g, func_body + this.inline_str)
                   .replace('$EXPR_VEC_RET$', this.vec_expr_type)
                   .replace('$GLSL_CODE$', this.glsl_code)
    }
    
    set_uniform_vars(shader_cls) {
        for(let name in this.uniform_evaluators) {
            let evaluator = this.uniform_evaluators[name]
            const param = shader_cls.param_of_uniform(name)
            console.assert(param !== null, "Missing expected uniform param " + name)
            param.modify(ExprParser.do_eval(evaluator), false)
        }
    }

    set_uniform_vars_to_obj(obj) {
        for(let name in this.uniform_evaluators) {
            let evaluator = this.uniform_evaluators[name]
            obj[name] = ExprParser.do_eval(evaluator);
        }
    }
}

// glsl example: 
// void main () {
//    outColor = in_tex(v_coord);
// }

class NodeFuncFill extends BaseNodeShaderParcel
{
    static name() { return "Function Fill" }
    constructor(node) 
    {
        super(node)
        this.shader_node.cls.attr_names = ["vtx_pos"]

        //this.in_mesh = new TerminalProxy(node, this.shader_node.cls.in_mesh)
        this.in_texs = new TerminalProxy(node, this.shader_node.cls.in_texs)  
        this.in_texs.xoffset = 30

        this.in_fb = new TerminalProxy(node, this.shader_node.cls.in_fb)  
        this.out_tex = new TerminalProxy(node, this.shader_node.cls.out_tex)

        // this is the coordinates of the pixel to be referenced by the code as `coord`
        node.set_state_evaluators({"coord":  (m,s)=>{ return new GlslTextEvaluator(m,s, "v_coord", ['x','y'], TYPE_VEC2) },
                                   ...TEX_STATE_EVALUATORS} ) 

        //this.time = new ParamProxy(node, this.shader_node.cls.uniform_by_name('time').param)
        this.type = new ParamSelect(node, "Type", 0, ["Float to Gradient", "Direct Color", "GLSL Program"], (sel_idx)=>{
            this.float_expr.set_visible(sel_idx === 0)
            this.tex0_is_gradient.set_visible(sel_idx === 0)
            this.color_expr.set_visible(sel_idx === 1)
            this.glsl_text.set_visible(sel_idx === 2)
            if (sel_idx === 0) {
                this.active_param = this.float_expr
                this.active_item = this.float_expr.get_active_item()
                this.remove_param_proxies()
            }
            else if (sel_idx === 1) {
                this.active_param = this.color_expr
                this.active_item = this.color_expr.code_item  // color doesn't have non-code expr yet
                this.remove_param_proxies()
            }
            else {
                this.active_param = null
                this.active_item = null
                this.process_glsl_text(this.glsl_text.v)
            }
           // this.make_frag_text() // changes where we take the expr from
        })
        this.tex0_is_gradient = new ParamBool(node, "Use first texture as gradient", true)
        this.float_expr = new ParamFloat(node, "Float\nExpression", "coord.x", {show_code:true})
        // color_expr is expected to return a vec4 or vec3 with values in range [0,1]
        this.color_expr = new ParamColor(node, "Color\nExpression", ["#cccccc", "rgb(coord.x, coord.y, 1.0)"], {show_code:true})

        // with GLSL input we want go generate the text and get the uniforms before run so that panel parameters can be populated
        this.glsl_text = new ParamTextBlock(node, "GLSL\nCode", GLSL_START_V_CODE, (v)=>{
            this.process_glsl_text(v)
        })
        this.proxies_group = new ParamGroup(node, "Uniforms")

        this.order_table = new ParamProxy(node, this.shader_node.cls.order_table, "Tex Order")
        this._tex_order = new ParamProxy(node, this.shader_node.cls.order, "order") // proxy so that save would reach it


        this.shader_node.cls.vtx_text.set_text(FUNC_VERT_SRC)
        //this.shader_node.cls.frag_text.set_text(NOISE_FRAG_SRC)
        node.param_alias("Expression", this.float_expr)

        // the expression is parsed when it's edited and glsl code is saved to this
        // the final text with $$ replaced depends on the input so it's made only in run
        this.active_param = null // points to either float_expr or color_expr
        this.active_item = null // points tot the ExpressionItem inside the active param
        this.glsl_emit_ctx = null
        this.param_proxies = []
    }

    get_sorted_order() {
        return this.shader_node.cls.sorted_order
    }

    remove_param_proxies(do_update=true) {
        for(let p of this.param_proxies)
            this.node.remove_param(p)
        this.param_proxies = []
        if (do_update)
            this.proxies_group.update_elems()
    }

    process_glsl_text(v) {
        this.glsl_emit_ctx = this.make_frag_text()
        let frag_text = this.glsl_emit_ctx.do_replace(EXPR_FRAG_SRC)
        this.shader_node.cls.frag_text.set_text(frag_text, false)
    
        this.remove_param_proxies(false)
        for(let p of this.shader_node.parameters) {
            if (p.label.startsWith('_u_') || p.label.startsWith('_D_') || (p.is_shader_generated && !p.is_shader_generated()))
                continue; // internal stuff
            const prox = new ParamProxy(this.node, p)
            prox.set_group(this.proxies_group)
            this.param_proxies.push(prox)
        }
        this.proxies_group.update_elems()
    }

    make_frag_text() 
    {
        let emit_ctx = new GlslEmitContext()
        if (this.type.sel_idx === 2) { // glsl
            emit_ctx.glsl_code = this.glsl_text.v
            return emit_ctx;
        }
        if (this.active_param.show_code && this.active_item.e !== null) {
            if (this.active_item.elast_error !== null) {
                assert(false, this, "Expression error " + this.active_item.elast_error.msg)
            }
            try {
                // returns the function text
                emit_ctx.inline_str = ExprParser.do_to_glsl(this.active_item.e, emit_ctx)
                assert(emit_ctx.inline_str !== null, this, 'unexpected expression null')
                // check type if vec3 add alpha
                emit_ctx.vec_expr_type = glsl_type_name(this.active_item.etype)
            }
            catch(ex) {
                assert(false, this, ex.message)
            }
        }
        else {  // it's a constant (not expression)
            if (this.type.sel_idx === 0) {
                emit_ctx.inline_str = "return " + this.active_param.get_value()
                if (Number.isInteger(emit_ctx.inline_str))
                    emit_ctx.inline_str += ".0"
            }
            else {
                // expects the numbers from expr to be [0,1] range
                let c = this.active_param.get_value()
                emit_ctx.inline_str = "return vec4(" + (c.r/255) + "," + (c.g/255) + "," + (c.b/255) + "," + c.alpha + ")"
            }
        }
        return emit_ctx;
    }

    async run() {
        let in_fb = this.in_fb.get_const() // TBD wrong
        assert(in_fb !== null, this, "missing input texture-params")

        const texs = this.in_texs.get_input_consts()

        if (this.type.sel_idx !== 2) { // was already done for GLSL during change
            // need to remake text due to expression change
            if (this.active_param.pis_dirty() || this.type.pis_dirty()) {
                this.glsl_emit_ctx = this.make_frag_text()
            }
            let frag_text = this.glsl_emit_ctx.do_replace(EXPR_FRAG_SRC)
            //console.log("TEXT: ", frag_text)
            this.shader_node.cls.frag_text.set_text(frag_text, false)
        }

        // set_text creates parameters for the uniforms in the text, which are then read in run and transfered to gl
        this.glsl_emit_ctx.set_uniform_vars(this.shader_node.cls)
        this.shader_node.cls.param_of_define("_D_EXPR_IS_COLOR").modify( this.type.sel_idx === 1, false)
        this.shader_node.cls.param_of_define("_D_TEX0_GRAD").modify(texs.length >= 1 && this.tex0_is_gradient.get_value(), false)
        this.shader_node.cls.param_of_define("_D_IS_GLSL_CODE").modify( this.type.sel_idx === 2, false)

        // don't need to actually give anything to the evaluator since it's not doing eval, it's doing to_glsl

        try {
            await this.shader_node.cls.run()
        }
        finally {
            if (this.type.sel_idx === 2) { // transfer glsl errors back to editor
                this.glsl_text.set_errors( this.shader_node.cls.frag_text.get_errors() )
            }
        }

    }

}


class NodeImageProc extends NodeFuncFill
{
    static name() { return "Image Process" }
    constructor(node) 
    {
        super(node)
        this.in_texs.xoffset = node.width / 2
        this.in_fb.tvisible = false
        this.tex0_is_gradient.modify(false)
    }

    async run() {
        const in_texs = this.in_texs.get_input_consts()
        assert(in_texs.length !== 0, this, "no input image")
        let in_tex
        if (this.tex0_is_gradient.get_value() && this.type.sel_idx === 0) {
            assert(in_texs.length >= 2, this, "second input required (since first input is gradient)")
            in_tex = in_texs[this.get_sorted_order()[1]]
            assert(in_tex instanceof ImageBase, this, "second input needs to be an image")
        }
        else {
            in_tex = in_texs[this.get_sorted_order()[0]]
            assert(in_tex instanceof ImageBase, this, "first input needs to be an image")
        }

        const fb = new FrameBufferFactory(in_tex.width(), in_tex.height(), in_tex.sz_x, in_tex.sz_y, in_tex.smooth, in_tex.edge, in_tex.type)
        fb.set_transform(in_tex.t_mat)
        this.in_fb.force_set(fb)

        await super.run()
    }
}

// Perlin noise: https://github.com/stegu/webgl-noise/tree/master/src

const NOISE_FRAG_SRC =  `
precision mediump float;

in vec2 v_coord;
out vec4 outColor;


vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
    return mod289(((x*34.0)+1.0)*x);
}

vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise_2d(vec2 v)
{
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                        -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
    // First corner
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);

    // Other corners
    vec2 i1;
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
    //i1.y = 1.0 - i1.x;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    // x0 = x0 - 0.0 + 0.0 * C.xx ;
    // x1 = x0 - i1 + 1.0 * C.xx ;
    // x2 = x0 - 1.0 + 2.0 * C.xx ;
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

    // Permutations
    i = mod289(i); // Avoid truncation effects in permutation
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
            + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}


float snoise_3d(vec3 v)
{ 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
}

uniform float time;

void main_x() {
    float v = snoise_3d(vec3(v_coord.xy, time));
    //float v = snoise_2d(v_coord);
    outColor = vec4(v, v, v, 1.0);
    //outColor = vec4(abs(v_coord.x), abs(v_coord.y), time, 1.0);

}



void main() {
    vec3 v_coord3 = vec3(v_coord.xy, 0.0);
    // Perturb the texcoords with three components of noise
    vec3 uvw = v_coord3 + 0.1*vec3(snoise_3d(v_coord3 + vec3(0.0, 0.0, time)),
                                   snoise_3d(v_coord3 + vec3(43.0, 17.0, time)),
                                   snoise_3d(v_coord3 + vec3(-17.0, -43.0, time)));
    //uvw = v_coord3;                                   
    // Six components of noise in a fractal sum
    float n = snoise_3d(uvw - vec3(0.0, 0.0, time));
    n += 0.5 * snoise_3d(uvw * 2.0 - vec3(0.0, 0.0, time*1.4)); 
    n += 0.25 * snoise_3d(uvw * 4.0 - vec3(0.0, 0.0, time*2.0)); 
    n += 0.125 * snoise_3d(uvw * 8.0 - vec3(0.0, 0.0, time*2.8)); 
    n += 0.0625 * snoise_3d(uvw * 16.0 - vec3(0.0, 0.0, time*4.0)); 
    n += 0.03125 * snoise_3d(uvw * 32.0 - vec3(0.0, 0.0, time*5.6)); 
    n = n * 0.7;
    // A "hot" colormap - cheesy but effective 
    outColor = vec4(vec3(1.0, 0.5, 0.0) + vec3(n, n, n), 1.0);    

}

`









"use strict"

// cool smoothmin in 3d video https://youtu.be/lctXaT9pxA0?t=370   
// meatballs: http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares/
// 3d graph calculator for seeing distance fields in 3d https://www.math3d.org/
// d3 marching squares (used): https://github.com/d3/d3-contour
// rendering based marching squares (not used) https://github.com/sakri/MarchingSquaresJS
// another img (not used) https://github.com/RaumZeit/MarchingSquares.js
// article about ray marching in 3d: https://adrianb.io/2016/10/01/raymarching.html#:~:text=Raymarching%20is%20a%20fairly%20new,the%20camera's%20field%20of%20vision.
// shaders for 2d primitives: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
// smoothmin: https://www.iquilezles.org/www/articles/smin/smin.htm\
// 3d primitives: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm



const DISTANCE_VTX_TEXT = `
in vec4 vtx_pos;
out vec2 v_coord;
uniform mat3 t_mat;

void main() {
    vec3 tmp = t_mat * vec3(vtx_pos.xy, 1.0);
    v_coord = tmp.xy;
    gl_Position = vtx_pos;
}
`

const DISTANCE_FRAG_TEXT = `
out vec4 outColor;
in vec2 v_coord;
uniform bool u_raw_value;


float get_arg(int i) {
    return texelFetch(_u_in_tex_3, ivec2(i,0), 0).r;
}

$FUNCS$

float value_func(vec2 coord) {
    $EXPR$
}

vec3 lines_color_(float d) {
    d *= 2.0;
    if (d < 0.0)
        return vec3(1.0, 0.45, 0.5) + d;
    else
        return vec3(0.4, 0.5, 1.0) - d;
}

vec3 lines_color(float d) {
    d *= 2.0;
    vec3 col = vec3(0.7, 0.475, 0.75) - sign(d)*vec3(0.3, -0.025, -0.25);
    d = trunc(d*15.0)/15.0;

    col -= abs(d);
    return col;
}

vec3 smooth_lines_color(float d) {
    d *= 2.0;
    vec3 col = vec3(0.7, 0.475, 0.75) - sign(d)*vec3(0.3, -0.025, -0.25);
    float id = trunc(d*15.0)/15.0;
    float id2 = (trunc(d*15.0)+sign(d))/15.0;
    
    vec3 cola = col - abs(id);
    vec3 colb = col - abs(id2);
    col = mix(cola, colb, smoothstep(-0.0,0.05,abs(mod(sign(d)*d,1.0/15.0))) );
    return col;
}

void main() {
    float d = value_func(v_coord);
   // d = d - 1.0;

   if (u_raw_value)
       outColor = vec4(d, d, d, 1.0);
   else 
       outColor = vec4(lines_color(d), 1.0);
}
`
// stand-in for a real param to the ExpressionItem in DistanceField
class DummyParam {
    constructor(owner) {
        this.owner = owner
        this.v = null
        this.visible = true
        this.enable = true
        this.label = "<dummy>"
    }
    pis_enable() { return true }
    pis_visible() { return true }
    pis_active() { return true }
    reg_expr_item() {}
    call_change() {}
    pset_dirty() {}
    
}
// stand-in owner for the Shader NodeCls in DistanceField
class NodeStandin {
    constructor() {
        this.inputs = []
        this.outputs = []
        this.parameters = []
        this.state_access = null
    }
    register_rename_observer() {}
}

function float_strs(nums) {
    const lst = []
    for(let n of nums)
        lst.push(asFloatStr(n))
    return lst
}

const ARGS_TEX_UNIT = 3

// used as from of dummy lines to shader for textures
class DummyNodePlaceholder {
    constructor(id) {
        this.lines = []  // needed by add line
        // needed by sort order mixin so that the shader node will have a proper sorted_order
        this.owner = {id: id, 
                      name: "dummy_node" + id,
                      register_rename_observer: ()=>{}
                    }
    }
    
}

class DistanceField extends PObject 
{
    static name() { return "Field" }
    constructor(dfnode) {
        super()
        this.t_mat = mat3.create()
        this.dfnode = dfnode

        this.p_prog = null // may not need to display at all
        this.p_shader_node = null
        this.p_args_tex = null
        this.p_img = null
        this.last_tex_premade = null
    }

    set_dfnode(dfnode) {
        this.dfnode = dfnode
    }

    transform(m) { 
        if (this.dfnode.tr === null) {
            this.dfnode.tr = mat3.create()
            this.dfnode.inv_tr = mat3.create()
        }
        mat3.multiply(this.dfnode.tr, m, this.dfnode.tr)
        mat3.invert(this.dfnode.inv_tr, this.dfnode.tr)
    }
    set_transform(m) { 
        this.dfnode.tr = null
        this.transform(m)
    }
    get_transform() {
        if (this.dfnode.tr === null)
            return mat3.create()
        return this.dfnode.tr;
    }

    ensure_prog() {
        if (this.p_prog !== null)
            return
        this.p_prog = new Program()
        this.p_shader_node = this.p_prog.add_node(0, 0, "<dist-shader>", NodeShader, null)

        //this.set_state_evaluators({"coord":  (m,s)=>{ return new ObjSingleEvaluator(m,s) } })
        this.p_shader_node.set_state_evaluators({"coord":  (m,s)=>{ return new GlslTextEvaluator(m,s, "v_coord", ['x','y'], TYPE_VEC2) }})
        this.p_shader_node.cls.vtx_text.set_text(DISTANCE_VTX_TEXT)
    }

    make_frag_text(template)  // TBD cache this
    {
        ensure_webgl()
        this.ensure_prog()
        const dfstate = new DFTextState()
        const [var_name, dftext] = this.dfnode.make_text(dfstate)

        let func_body = dftext + "return " + var_name + ";"

        const text = template.replace('$FUNCS$', dfstate.func_set.to_text())
                             .replace('$EXPR$', func_body)

        this.p_shader_node.cls.frag_text.set_text(text)

        // args texture
        if (this.p_args_tex === null)
            this.p_args_tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.p_args_tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, dfstate.args_arr.length, 1, 0, gl.RED, gl.FLOAT, new Float32Array(dfstate.args_arr));
        setTexParams(false, 'pad', 'pad')
        this.p_args_tex.t_mat = mat3.create()
        this.p_args_tex.sz_x = 1; this.p_args_tex.sz_y = 1 // things requred by ShaderNode
        this.p_shader_node.cls.override_texs = {3:this.p_args_tex}
        gl.bindTexture(gl.TEXTURE_2D, null);

        // input textures
        this.p_prog.delete_lines_of(this.p_shader_node.cls.in_texs)
        let idx = 0
        for(let img_prox of dfstate.img_proxies) {
            const ln = new Line(new DummyNodePlaceholder(idx++), this.p_shader_node.cls.in_texs.get_attachment())
            this.p_prog.add_line(ln)
            ln.to_term.force_set(img_prox.prox_get_const_obj())
        }

        return dfstate
    }

    make_viewport_fb() {
        const pmin = vec2.fromValues(0,0), pmax = vec2.fromValues(canvas_image.width, canvas_image.height)
        vec2.transformMat3(pmin, pmin, image_view.t_inv_viewport)
        vec2.transformMat3(pmax, pmax, image_view.t_inv_viewport)
        const pavg = vec2.create()
        vec2.add(pavg, pmin, pmax)
        vec2.scale(pavg, pavg, 0.5)
        const tr = mat3.create()
        mat3.fromTranslation(tr, pavg)

        const fb = new FrameBufferFactory(canvas_image.width, canvas_image.height, pmax[0]-pmin[0], pmax[1]-pmin[1], false, "pad", "rgba")
        fb.transform(tr)
        //const fb = new FrameBufferFactory(canvas_image.width, canvas_image.height, 4, 4, false, "pad", "rgba")
        return fb
    }

    set_shader_variables_uniforms(dfstate) {
        // variables values
        const uniforms = dfstate.uniform_values.get_kv()
        for(let u_name in uniforms) {
            const prm = this.p_shader_node.cls.uniforms[u_name]
            dassert(prm !== undefined, "Uniform not found " + u_name)
            prm.param.modify(uniforms[u_name])
        }
    }

    async pre_draw(m, disp_values) 
    {
        const dfstate = this.make_frag_text(DISTANCE_FRAG_TEXT)
        //const fb = new FrameBufferFactory(800, 800, 2, 2, false, "pad", "rgba") // TBD
        const fb = this.make_viewport_fb()

        this.p_shader_node.cls.in_fb.force_set(fb)
        this.p_shader_node.cls.uniforms["u_raw_value"].param.modify(false)
        this.set_shader_variables_uniforms(dfstate)


        await this.p_shader_node.cls.run()
        this.p_shader_node.clear_dirty() // otherwise it remains dirty since it's not part of normal run loop

        this.p_img = this.p_shader_node.cls.out_tex.get_const()
        await this.p_img.pre_draw(null, null)
    }

    draw(m, disp_values) {
        this.p_img.draw(m, null)
    }

    // called from marching cubes
    async get_pixels_for_fb(fb_fact) {
        const img = await this.do_texture(fb_fact)
        return img.get_pixels()
    }

    async do_texture(fb_fact) {
        // TBD cache
        const dfstate = this.make_frag_text(DISTANCE_FRAG_TEXT)
        this.p_shader_node.cls.in_fb.force_set(fb_fact)
        this.p_shader_node.cls.uniforms["u_raw_value"].param.modify(true)
        this.set_shader_variables_uniforms(dfstate)
        await this.p_shader_node.cls.run()
        this.p_shader_node.clear_dirty() 
        //return null
        const img = this.p_shader_node.cls.out_tex.get_const()
        dassert(img !== null, "distance shader produced not output")
        return img
    }

    async premake_gl_texture(for_fb_factory) {
        const factory_copy = clone(for_fb_factory)
        factory_copy.set_type("float") // don't mess up the factory we're give since it's needed by the webgl node
        factory_copy.set_smooth(false) // float texture can't do linear interpolation without an additional extension
        const img = await this.do_texture(factory_copy)
        
        const tex = img.tex_obj
        tex.t_mat = mat3.create()
        mat3.copy(tex.t_mat, this.t_mat)
        // this is saved just to be returns in make_gl_texture since we can'd do all of the above in make_gl_texture since it's called in the middle of other webgl stuff
        this.last_tex_premade = tex 
    }

    make_gl_texture(for_fb_factory) {
        return this.last_tex_premade
    }

    draw_selection(m, select_vindices) {
    }

    draw_template(m) {
    }

}

function asFloatStr(v) {
    if (Number.isInteger(v)) {
        const sv = v + ".0"
        if (sv.includes('e'))
            return "" + v  // avoid adding .0 that messes the exponent
        return sv
    }
    return "" + v
}



class DFTextState {
    constructor() {
        this.var_count = 1
        this.args_arr = []
        this.tr_arr = []
        this.func_set = new FuncsSet()
        this.uniform_values = new FuncsSet() // not actually funcs, map uniform name to its value
        this.img_proxies = [];
    }
    alloc_var() {
        const v = this.var_count
        ++this.var_count;
        return v
    }
    alloc_tex_slots(img_proxies) {
        dassert(this.img_proxies.length + img_proxies.length <= IN_TEX_COUNT - 1, "Too many textures in distance field") // -1 since tex 3 is for args
        const ret = this.img_proxies.length;
        this.img_proxies.push(...img_proxies)
        return ret
    }
}

function range_getarg(a, b) {
    let s = []
    for(let i = a; i < b; ++i)
        s.push("get_arg(" + i + ")")
    return s.join(', ')
}

// node in the tree that produces glsl code
class DFNodeBase {
}


class DFNode extends DFNodeBase {
    constructor(func_maker=null, tr=null, args=null, children=null, func_set=null) { // need default values for clone
        super()
        this.func_maker = func_maker  //  afunction that takes list of arguments and returns a string with the function call        
        this.tr = tr // actual matrix
        if (this.tr !== null) {
            this.inv_tr = mat3.create()
            mat3.invert(this.inv_tr, this.tr)
        }
        else
            this.inv_tr = null
        this.inline_tr = false // is the transform inline or given to the function as arg
        this.args = args // list of floats
        this.children = children // list of DFNode
        this.func_set = func_set // my own functions (not children's)
        // pass just the index of the first arg instead of the values of all args
        // for functions that take lots of data (mesh)
        this.pass_first_arg_idx = false; 
    }
    make_text(dfstate) {
        // call order to any function is func_name(tr_index_in_args_arr_if_exists, child_vars_if_exist, float_args_if_exist)
        const child_vars = []
        let text = "", prefix = "", postfix = "", added_type = false
        const myvar = "v" + dfstate.alloc_var()

        if (this.children !== null) {
            for(let child of this.children) {
                const [var_name, add_text] = child.make_text(dfstate)
                child_vars.push(var_name)
                text += add_text
            }
        }

        let args_strs = []
        if (this.inv_tr !== null) {
            const mytr_idx = dfstate.args_arr.length
            const tr = this.inv_tr
            dfstate.args_arr.push(tr[0], tr[1], tr[3],tr[4], tr[6],tr[7])

            if (this.inline_tr) {
                let in_coord_var = "in_coord" + dfstate.alloc_var()
                prefix += "float " + myvar + " = 0.0;\n"
                prefix += "vec2 " + in_coord_var + " = coord;\n"
                prefix += "{\n"
                prefix += "  mat3x2 tr = mat3x2(" + range_getarg(mytr_idx, mytr_idx+6) + ");\n"
                prefix += "  vec2 coord = tr * vec3(" + in_coord_var + ", 1.0);\n"
                postfix = "}\n"
                added_type = true
            }
            else {
                args_strs.push(mytr_idx)
            }
        }

        if (this.args !== null) {
            if (this.pass_first_arg_idx)
                args_strs.push(dfstate.args_arr.length);
            for(let i = 0; i < this.args.length; ++i) {
                const my_idx = dfstate.args_arr.length
                if (!this.pass_first_arg_idx)
                    args_strs.push("get_arg(" + my_idx + ")")
                dfstate.args_arr.push(this.args[i])
            }
        }

        if (this.func_set !== null) {
            dfstate.func_set.extend(this.func_set)  
        }

        text += (added_type ? "" : "float ") + myvar + " = " + this.func_maker.make_func(args_strs, child_vars, dfstate) + ";\n"
        
        // returns the name of the variable in which the current result is in
        // and the text to add before to create this variable
        return [myvar, prefix + text + postfix]
    }
}

class FuncMaker
{
    make_func(args_strs, child_vars, dfstate) {
        dassert(false, "unimplemented make_func")
    }
    get_init_val() { // for combiner in copy, start value for repeated composition
        dassert(false, "unimplemented get_init_val")
    }
}


class Call_FuncMaker extends FuncMaker {
    constructor(func_name) { // func_call_text
        super()
        this.func_name = func_name
    }
    make_func(args_strs, child_vars, dfstate) {
        return this.func_name + "(coord, " + args_strs.join(", ") + ")"
    }
}


class BaseDFNodeCls extends NodeCls
{
    constructor(node) {
        super(node)
        this.out_obj = null // cache the out objet so that that the shader inside it compile the program only when needed
    }
    set_out_dfnode(dfnode) {
        assert(dfnode !== null, this, "null dfnode")
        if (this.out_obj === null)
            this.out_obj = new DistanceField(dfnode)
        else
            this.out_obj.set_dfnode(dfnode)
        this.out.set(this.out_obj)        
    }
}

// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
class NodeDFPrimitive extends BaseDFNodeCls 
{
    static name() { return "Field Primitive" }
    constructor(node) {
        super(node)

        //node.set_state_evaluators({"coord":  (m,s)=>{ return new ObjSingleEvaluator(m,s) }})

        this.out = new OutTerminal(node, "out_field")

        this.type = new ParamSelect(node, "Shape", 0, ["Circle", "Inverse-Circle", "Box"], (sel_idx)=>{
            this.radius.set_visible(sel_idx === 0 || sel_idx === 1)
            this.size.set_visible(sel_idx === 2)
        })
        this.radius = new ParamFloat(node, "Radius", 0.25, {enabled:true})
        this.size = new ParamVec2(node, "Size", 0.5, 0.3)

        this.transform = new ParamTransform(node, "Transform")      
    }

    need_size() {
        return this.type.sel_idx === 2
    }

    run() {
        let dfnode = null, glsl_funcs = new FuncsSet()
        
        const add = (name, args, args_vals, func)=>{
            const s = `float $NAME$(vec2 coord, int tr_idx, $ARGS$) {
    mat3x2 tr = mat3x2(get_arg(tr_idx), get_arg(tr_idx+1), get_arg(tr_idx+2), get_arg(tr_idx+3), get_arg(tr_idx+4), get_arg(tr_idx+5));
    vec2 p = tr * vec3(coord, 1.0);
    $F$
}`.replace('$F$', func).replace('$NAME$', name).replace('$ARGS$', 'float ' + args.join(', float ')) 
            glsl_funcs.add(name, s)
            dfnode = new DFNode(new Call_FuncMaker(name), this.transform.get_value(), args_vals, [], glsl_funcs)
        }

        switch (this.type.sel_idx) {
        case 0: 
            add("circle", ["radius"], [this.radius.get_value()], "return sqrt(p.x*p.x + p.y*p.y) - radius;")
            break
        case 1: // used for blobs with added level of 1 - http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares/
            add("inv_circle", ["radius"],  [this.radius.get_value()], "return sqrt((radius*radius) / (p.x*p.x + p.y*p.y));")
            break
        case 2: {
            const sz = this.size.get_value()
            add("box", ["width", "height"], [sz[0], sz[1]], `vec2 d = abs(p)-vec2(width/2.0, height/2.0);
return length(max(d,0.0)) + min(max(d.x,d.y),0.0);`)
            break
        }
        default:
            assert(false, this, "expr not set")
        }
        this.set_out_dfnode(dfnode)
    }

    draw_selection(m) {
        this.transform.draw_dial_at_obj(null, m)
        if (this.need_size())
            this.size.size_dial_draw(this.transform.v, m)
    }    
    image_find_obj(e) {
        let hit = this.transform.dial.find_obj(e) 
        if (hit)
            return hit
        if (this.need_size()) {
            hit = this.size.size_dial_find_obj(e)
            if (hit)
                return hit
        }
        return null
    }
}


const DFCALL_TRI = `
float sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2)
{
    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;
    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;
    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
    float s = sign( e0.x*e2.y - e0.y*e2.x );
    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),
                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),
                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));
    return -sqrt(d.x)*sign(d.y);
}

float triMesh(vec2 coord, int startIdx) {
    int countTri = int(get_arg(startIdx));
    float d = 1e38;
    int idx = startIdx + 1;
    for(int i = 0; i < countTri; ++i) {
        d = min(d, sdTriangle(coord, vec2(get_arg(idx), get_arg(idx+1)), vec2(get_arg(idx+2), get_arg(idx+3)), vec2(get_arg(idx+4), get_arg(idx+5))));
        idx += 6;
    }
    return d;
}`


const DFFUNC_MULTI_PATH = `
float sdPolygon(in vec2 p, int count, int idx)
{
    float d = 1e38;
    float s = 1.0;
    int lastIdx = idx+(count-1)*2;
    vec2 vj = vec2(get_arg(lastIdx), get_arg(lastIdx+1));

    for(int i = 0; i < count; ++i)
    {
        vec2 vi = vec2(get_arg(idx), get_arg(idx+1));
        idx += 2;

        vec2 e = vj - vi;
        vec2 w = p - vi;
        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );
        d = min(d, dot(b,b));
        bvec3 c = bvec3(p.y >= vi.y, p.y < vj.y, e.x*w.y > e.y*w.x);
        if (all(c) || all(not(c))) 
            s*=-1.0;  
        vj = vi;
    }
    return s*sqrt(d);
}

float multiPath(vec2 coord, int startIdx) {
    int countPaths = int(get_arg(startIdx));
    float d = 3.402823466e+38;
    int idx = startIdx + 1;
    for(int i = 0; i < countPaths; ++i) {
        int polyLen = int(get_arg(idx));
        idx += 1;
        d = min(d, sdPolygon(coord, polyLen, idx));
        idx += polyLen*2;
    }
    return d;
}
`

const DFFUNC_MULTI_PATH_CURVE = `
float multiPathWithCurves(vec2 p, int startIdx) 
{
    int countPaths = int(get_arg(startIdx));
    float d =  1e38;
    int idx = startIdx + 1;
    for(int i = 0; i < countPaths; ++i) {
        int polyLen = int(get_arg(idx));
        idx += 1;
        // ------ inner function, inlined here since it needs to update idx

        float inner_d = 1e38;

        float s = 1.0, md;
        vec2 vj = vec2(get_arg(idx), get_arg(idx+1));
        idx += 2;
        vec2 vi;
        int inters = 0;
        //polyLen = 2;

        for(int i = 0; i < polyLen; ++i)
        {
            int isCurve = int(get_arg(idx));
            idx += 1;
            if (isCurve == 0) {
                vi = vec2(get_arg(idx), get_arg(idx+1));
                idx += 2;
    
                vec2 e = vj - vi;
                vec2 w = p - vi;
                vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );
                md = dot(b,b);

                // intersect with a ray from p parallel to x axis
                float t = w.y/e.y;
                float u = t*e.x - w.x;
                if (t >= 0.0 && t <= 1.0 && u < 0.0)
                    ++inters;
            }
            else {
                vec2 prev_c = vec2(get_arg(idx), get_arg(idx+1));
                vec2 cur_c = vec2(get_arg(idx+2), get_arg(idx+3));
                vi = vec2(get_arg(idx+4), get_arg(idx+5));
                idx += 6;

                md = cubic_bezier_dis(p, vj, prev_c, cur_c, vi);
                inters += cubic_bezier_sign(p, vj, prev_c, cur_c, vi);                     
            }
    
            inner_d = min(inner_d, md);
            vj = vi;
        }
        float sb = ((inters % 2) == 0)?1.0:-1.0;

        float ret_d = sb*sqrt(inner_d);

        // ------ 
        d = min(d, ret_d); // between polygons
        
    }
    return d;
}
`

class ArgsCurveAdder {
    constructor(into_args) {
        this.args = into_args
        this.cur_moveTo = null
    }
    startPath(len) {
        this.args.push(len)
    }
    moveTo(x, y) {
        this.cur_moveTo = [x,y]
        this.args.push(x, y)
    }
    lineTo(x, y) {
        this.args.push(0, x, y)
    }
    bezierCurveTo(prev_cx, prev_cy, cur_cx, cur_cy, x, y) {
        this.args.push(1, prev_cx, prev_cy, cur_cx, cur_cy, x, y)
    }
    closePath(real_line) {
        dassert(this.cur_moveTo !== null, "nothing to close")
        if (real_line)
            this.args.push(0, this.cur_moveTo[0], this.cur_moveTo[1])
        this.cur_moveTo = null
    }
}

class NodeDFFromGeom extends BaseDFNodeCls 
{
    static name() { return "Field From Geometry" }
    constructor(node) {
        super(node)
        this.in_geom = new InTerminal(node, "in_geom")
        this.out = new OutTerminal(node, "out_field")
    }

    args_for_tri_mesh(mesh) {
        const args = [], vtx = mesh.effective_vtx_pos
        args.push(mesh.face_count()) 
        for(let idx of mesh.arrs.idx) {
            args.push(vtx[idx*2], vtx[idx*2+1])
        }
        return args
    }

    args_for_quad_mesh(mesh) {
        const args = [], vtx = mesh.effective_vtx_pos
        args.push(mesh.face_count()) 
        let i = 0;
        for(let idx of mesh.arrs.idx) {
            if ((i++ % 4) == 0)
                args.push(4)
            args.push(vtx[idx*2], vtx[idx*2+1])
        }
        return args        
    }

    args_for_multipath(obj) {
        const args = [], vtx = obj.effective_vtx_pos
        args.push(obj.face_count()) 
        for(let pri = 0; pri < obj.paths_ranges.length; pri += 3) {
            let start_vidx = obj.paths_ranges[pri]*2
            let end_vidx = obj.paths_ranges[pri+1]*2
            args.push((end_vidx - start_vidx)/2)
            for(let vidx = start_vidx; vidx < end_vidx; vidx += 2) {
                args.push(vtx[vidx], vtx[vidx+1])
            }
        }
        return args
    }

    args_for_multi_curves(obj) {
        const args = []
        args.push(obj.face_count()) 
        obj.call_all_paths_commands(new ArgsCurveAdder(args))
        return args
    }

    run() {
        const in_obj = this.in_geom.get_const()
        assert(in_obj !== null, this, "no input")
        const glsl_funcs = new FuncsSet()
        let dfnode = null, args_vals = null

        if (in_obj.constructor === Mesh) {
            if (in_obj.type === MESH_TRI) {
                args_vals = this.args_for_tri_mesh(in_obj)
                glsl_funcs.add("triMesh", DFCALL_TRI)
                dfnode = new DFNode(new Call_FuncMaker("triMesh"), null, args_vals, null, glsl_funcs)
                dfnode.pass_first_arg_idx = true
            }
            else if (in_obj.type === MESH_QUAD) {
                args_vals = this.args_for_quad_mesh(in_obj)
            }
        }
        else if (in_obj.constructor == MultiPath) {
            if (!in_obj.has_curves())
                args_vals = this.args_for_multipath(in_obj)
            else 
            {
                glsl_funcs.add("sdCubicBezier", DFFUNC_BEZIER)
                glsl_funcs.add("multiPathWithCurves", DFFUNC_MULTI_PATH_CURVE)
                args_vals = this.args_for_multi_curves(in_obj)
                dfnode = new DFNode(new Call_FuncMaker("multiPathWithCurves"), null, args_vals, null, glsl_funcs)
                dfnode.pass_first_arg_idx = true
            }
        }
        else 
            assert(false, this, "unsupposedted input object")
        if (dfnode === null) {
            glsl_funcs.add("multiPath", DFFUNC_MULTI_PATH)
            dfnode = new DFNode(new Call_FuncMaker("multiPath"), null, args_vals, null, glsl_funcs)
            dfnode.pass_first_arg_idx = true            
        }
        dfnode.inline_tr = true
        this.set_out_dfnode(dfnode)
    }
}

function commaize(arr) {
    let r = ""
    for(let c of arr)
        r += c + ", "
    return r
}
function commaize_pre(arr) {
    let r = ""
    for(let c of arr)
        r += ", " + c
    return r
}

// take a binary function like min(a,b) and make a chain to handle any number of arguments
class BinaryToMulti_FuncMaker extends FuncMaker {
    constructor(func_name, init_val) {
        super()
        this.func_name = func_name
        this.init_val = init_val
    }// binary_func_to_multi

    make_func(args_strs, child_vars, dfstate) {
        const len = child_vars.length
        if (len === 1)
            return child_vars[0]
        let ret = ""
        for(let i = 0; i < len - 2; ++i) 
            ret += this.func_name + "(" + commaize(args_strs) + child_vars[i] + ", "
        ret += this.func_name + "(" + commaize(args_strs) + child_vars[len-2] + ", " + child_vars[len-1]
        ret += ')'.repeat(len-1)
        return ret
    }
    get_init_val() {
        return this.init_val
    }
}

class MultiSum_FuncMaker extends FuncMaker {
    make_func(args_strs, child_vars, dfstate) {
        return "(" + child_vars.join(" + ") + ")"
    }
    get_init_val() {
        return 0
    }
}

// https://www.iquilezles.org/www/articles/smin/smin.htm
// TBD code dup
const poly_smin = `float poly_smin(float k, float d1, float d2) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}
`
const exp_smin = `float exp_smin(float k, float a, float b) {
    k = 1.0/k;
    float res = exp2( -k*a ) + exp2( -k*b );
    return -log2( res )/k;
}
`
//doesn't actually work
const pow_smin = `float pow_smin(float k, float a, float b) {
    a = pow( a, k ); b = pow( b, k );
    return pow( (a*b)/(a+b), 1.0/k );
}
`

function make_combiner(op_sel_idx, radius)
{
    let func_maker = null, func_set = new FuncsSet(), args=[]

    switch (op_sel_idx) {
    case 0: func_maker = new BinaryToMulti_FuncMaker("min", 1e38); break;
    case 1: func_maker = new BinaryToMulti_FuncMaker("max", 0); break;
    case 2: func_maker = new MultiSum_FuncMaker(); break;
    case 3: 
        func_maker = new BinaryToMulti_FuncMaker('poly_smin', 1e38); 
        func_set.add('poly_smin', poly_smin)
        args.push(radius)
        break;
    case 4: 
        func_maker = new BinaryToMulti_FuncMaker('exp_smin', 1e38); 
        func_set.add('exp_smin', exp_smin)
        args.push(radius)
        break;
  /*  case 5: 
        func_maker = new BinaryToMulti_FuncMaker('pow_smin', 1e38); 
        func_set.add('pow_smin', pow_smin)
        args.push(radius)
        break;                */
    default: assert(false, this, "unexpected operator")
    }
    return [func_maker, func_set, args]
}

class Expr_FuncMaker extends FuncMaker
{
    constructor(sitem, funcs, uniform_decls, uniform_values, imgs = null) {
        super()
        this.sitem = sitem  // ItemStandin
        this.funcs = funcs
        this.uniform_decls = uniform_decls
        this.uniform_values = uniform_values
        if (imgs !== null) {
            this.imgs = [] // references const objects
            for(let img of imgs)
                this.imgs.push(new ObjConstProxy(img, null))
            // this doesn't detect if the same image was added a few times just with different transform
            // Doing that would allow adding the same texture again and again more than 3 times
        }
        else
            this.imgs = null
    }
    make_func(args_strs, child_vars, dfstate) {
        // do glsl emit again now that the children names are known
        const value_need_in_field = this.sitem.need_input_evaler("in_fields")
        if (value_need_in_field) 
            value_need_in_field.dyn_set_obj(child_vars)
        if (this.imgs !== null) {
            const value_need_in_tex = this.sitem.need_input_evaler("in_texi")
            if (value_need_in_tex) {
                const offset = dfstate.alloc_tex_slots(this.imgs)
                value_need_in_tex.dyn_set_obj(offset)
            }
        }  
            
        const emit_ctx = new GlslEmitContext()
        emit_ctx.inline_str = this.sitem.eto_glsl(emit_ctx) 
        dassert(emit_ctx.inline_str !== null, 'unexpected expression null')

        dfstate.func_set.extend(this.funcs)

        const func_name = "expr_func_" + dfstate.alloc_var()
        let childs_args_declr = ""
        for(let c of child_vars)
            childs_args_declr += ', float ' + c

        let func = "float " + func_name + "(vec2 coord" + childs_args_declr + ") {\n"
        func += emit_ctx.inline_str + "\n"
        func += "}\n"
        for(let uniform_str of this.uniform_decls)
            dfstate.func_set.add("#uniform|" + uniform_str, uniform_str) // need key so that the same uniform won't be declared twice
        dfstate.func_set.add(func_name, func)
        for(let u_name in this.uniform_values)
            dfstate.uniform_values.add(u_name, this.uniform_values[u_name])

        return func_name + "(coord" + commaize_pre(child_vars) + ")"
    }
}

// reference object that must have subscripts that are ints
// the glsl result is a variable name that is of type float
class GlslArrayEvaluator extends EvaluatorBase {
    constructor(objref,subscripts) {
        super()
        eassert(subscripts.length == 1, "wrong number of subscripts")
        this.sub = subscripts[0]
        this.objref = objref
    }
    consumes_subscript() { return true }
    eval() { 
        eassert(false, "text evaluator can't be evaled", this.line_num)  
    }
    check_type() {
        return TYPE_NUM
    }
    clear_types_cache() {}
    to_glsl(emit_ctx) {
        eassert(this.objref.obj !== null, "object not set", this.line_num)
        let child = this.objref.obj[this.sub]
        eassert(child !== undefined, "subscript not found " + this.sub, this.line_num)        
        return child
    }
}

// this object is a one-time use standin for the long-term item that is inside the node param
// it holds the expression and what's needed to fill the evaluator needs of the expression
class ItemStandin
{
    constructor(item) {
        this.e = item.e
        this.parse_opt = item.parse_opt
        this.need_inputs = item.need_inputs // this, like e is also recreated each pase so we can just take reference it and not copy
    }

    need_input_evaler(input_name) {
        if (this.need_inputs === undefined || this.need_inputs === null)
            return null
        let ev = this.need_inputs[input_name]
        if (ev === undefined)
            return null
        return ev
    }

    eto_glsl(emit_ctx) {
        return ExprParser.do_to_glsl(this.e, emit_ctx, this.parse_opt)                  
    }

    oclone() {
        // called from clone() when copying the object, no need to really copy since this is an immutable object
        // (except type cache in the expr but that's probably ok since it's not going to change due to changing variables or evaluators)
        return this
    }
}


class NodeDFCombine extends BaseDFNodeCls
{
    static name() { return "Field Combine" }
    constructor(node) {
        super(node)
        this.in_df_objs = new InTerminalMulti(node, "in_fields")
        this.out = new OutTerminal(node, "out_field")

        node.set_state_evaluators({"coord":  (m,s)=>{ return new GlslTextEvaluator(m,s, "coord", ['x','y'], TYPE_VEC2) },
                                   "in_fields": (m,s)=>{ return new GlslArrayEvaluator(m,s) }
                                    })//...TEX_STATE_EVALUATORS} ) 
        // in_fields is an array accessed with in_fields.0 - static index
        // since making it a function is not so simple, need to select one of N variables

        this.op = new ParamSelect(node, "Operator", 0, ["Min (union)", "Max (intersect)", "Sum", "Smooth-min (poly)", "Smooth-min (exp)", "Function"], (sel_idx)=>{
            this.radius.set_visible(sel_idx === 3 || sel_idx === 4)
            this.dist_func.set_visible(sel_idx === 5)
        })
        this.radius = new ParamFloat(node, "Radius", 0.25, {enabled:true})
        this.dist_func = new ParamFloat(node, "Distance\nFunction", "length(coord) - 1", {show_code:true})

        this.sorted_order = []
        mixin_multi_reorder_control(node, this, this.sorted_order, this.in_df_objs)
    }

    make_dist_func(children) {
        const ditem = this.dist_func.get_active_item()
        const item = new ItemStandin(ditem) 

        const value_need_in_field = item.need_input_evaler("in_fields")
        if (value_need_in_field) {
            // for the first emit pass that's done here, give it dummy variable names for the child indices that exist so that the check in to_glsl pass
            const dummy_names = []
            for(let i = 0; i < children.length; ++i)
                dummy_names[i] = "###dummy_name_" + i
            value_need_in_field.dyn_set_obj(dummy_names)
        }
        
        // do first emit here so that we can commit the variable values to the value the are during this run
        // and for error checking. In this emit child var names are still unknown, The final text will get emitted in make_text.
        const emit_ctx = new GlslEmitContext()
        try {
            emit_ctx.inline_str = ditem.eto_glsl(emit_ctx) 
        }
        catch(e) {
            assert(false, this, e.message)
        }
        assert(emit_ctx.inline_str !== null, this, 'unexpected expression null')
        // inline_str not used since this is going to run again in the object with the real variables
        // runs here so an error is visible in the node

        const uniform_values = {}
        emit_ctx.set_uniform_vars_to_obj(uniform_values) // commit the variables to their current value to set in the output object
        return new DFNode(new Expr_FuncMaker(item, emit_ctx.add_funcs, emit_ctx.uniform_decls, uniform_values, []), null, null, children, null)
    }


    run() {
        const objs = this.in_df_objs.get_input_consts()
        if (this.op.sel_idx !== 5) // function doesn't need to have inputs
            assert(objs.length > 0, this, "No inputs")
        const children = []
        for(let i = 0; i < objs.length; ++i) {
            const obj = objs[this.sorted_order[i]]
            assert(obj.constructor === DistanceField, this, "Input object is not a Distance Field")
            children.push(obj.dfnode)
        }
       
        let dfnode
        if (this.op.sel_idx !== 5) {
            const [func_maker, func_set, args] = make_combiner(this.op.sel_idx, this.radius.get_value())
            dfnode = new DFNode(func_maker, null, args, children, func_set)
        }
        else {
            dfnode = this.make_dist_func(children)
        }
        dfnode.inline_tr = true // in case we pass it through transform node
        this.set_out_dfnode(dfnode)
    }
}

class DFNodeForLoop extends DFNodeBase {
    constructor(child, tr_lst, combiner_maker, combiner_args, combiner_funcs) {
        super()
        this.child = child
        this.tr = null
        this.inv_tr = null

        this.tr_lst = tr_lst
        this.combiner_maker = combiner_maker
        this.combiner_args = combiner_args
        this.combiner_funcs = combiner_funcs
    }
    make_text(dfstate) {
        const myvar = "v" + dfstate.alloc_var()

        const [child_var_name, child_text] = this.child.make_text(dfstate)

        let args_strs = []

        for(let i = 0; i < this.combiner_args.length; ++i) {
            const my_idx = dfstate.args_arr.length
            args_strs.push("get_arg(" + my_idx + ")")
        }
        dfstate.args_arr.push(...this.combiner_args)

        dfstate.func_set.extend(this.combiner_funcs)

        const inv_tr = mat3.create()
        let trs_start = dfstate.args_arr.length
        dfstate.args_arr.push(this.tr_lst.length)
        for(let tr of this.tr_lst) {
            mat3.invert(inv_tr, tr)
            if (this.inv_tr !== null) // has a self transform as well?
                mat3.multiply(inv_tr, inv_tr, this.inv_tr)
            dfstate.args_arr.push(inv_tr[0], inv_tr[1], inv_tr[3],inv_tr[4], inv_tr[6],inv_tr[7])
        }

        const in_coord_var = "in_coord" + dfstate.alloc_var()
        const count_var = "in_count" + dfstate.alloc_var()
        let text = "float " + myvar + " = " + asFloatStr(this.combiner_maker.get_init_val()) + ";\n"  // TBD from combiner
        text += "vec2 " + in_coord_var + " = coord;\n"
        text += "int " + count_var + " = int(get_arg(" + trs_start + "));"
        trs_start++;
        text += "for(int i = 0; i < " + count_var + "; ++i) {\n"
        text += "  int tr_idx = i*6 + " + trs_start + ";\n"
        text += "  mat3x2 tr = mat3x2(get_arg(tr_idx), get_arg(tr_idx+1), get_arg(tr_idx+2), get_arg(tr_idx+3), get_arg(tr_idx+4), get_arg(tr_idx+5));\n"
        text += "  coord = tr * vec3(" + in_coord_var + ", 1.0);\n"
        text += child_text
        text += "  " + myvar + " = " + this.combiner_maker.make_func(args_strs, [myvar, child_var_name]) + ";\n"
        text += "}\n"

        return [myvar, text]
    }
}

// this is not the same node as NodeGeomCopy since we need the combine params
class NodeDFCopy extends CopyNodeMixin(BaseDFNodeCls)
{
    static name() { return "Field Copy" }
    constructor(node) {
        super(node)
        this.in_df_obj = new InTerminal(node, "in_field")
        this.out = new OutTerminal(node, "out_field")

        this.op = new ParamSelect(node, "Operator", 0, ["Min (union)", "Max (intersect)", "Sum", "Smooth-min"], (sel_idx)=>{
            this.radius.set_visible(sel_idx === 3)
        })
        this.radius = new ParamFloat(node, "Radius", 0.25, {enabled:true})        

        this.add_terminal_and_params(node)
    }
    run() {
        const in_obj = this.in_df_obj.get_const()
        assert(in_obj !== null, this, "No input object to copy")
        assert(in_obj.constructor === DistanceField, this, "input is not DistanceField")

        const [tg_vtx_count, tr_need_target] = this.get_meta_target()
        const index_wrap = this.get_index_wrap()

        
        const [func_maker, func_set, args] = make_combiner(this.op.sel_idx, this.radius.get_value())

        const in_dfnode = in_obj.dfnode
        const tr_lst = []
        for(let i = 0; i < tg_vtx_count; ++i) 
        {
            index_wrap[0] = i
            if (tr_need_target !== null)
                tr_need_target.dyn_set_prop_index(i)
            const m = this.transform.dyn_eval()
            tr_lst.push(m)
        }

        const dfnode = new DFNodeForLoop(in_dfnode, tr_lst, func_maker, args, func_set)
        this.set_out_dfnode(dfnode)
    }
}

// a call to in_texi that can change its index according to the texture index allocation in the Object it is in
class DFImgGlslTextEvaluator extends GlslTextEvaluator {
    to_glsl_mutate_args(emit_ctx, args) {
        // all textures that came from the same NodeDFImage will have the same offset
        const tex_offset = this.objref.obj
        dassert(tex_offset !== null, "texi offset not set")
        dassert(Number.isInteger(tex_offset), "texi offset expected to be int")

        args[0] += " + " + tex_offset + ".0"
        return this.name
    }
}


// this is a separate not from NodeDFCombine just so that there won't be confusion with the input terminals
class NodeDFImage extends BaseDFNodeCls
{
    static name() { return "Field Image" }
    constructor(node) {
        super(node)
        this.in_texs = new InTerminalMulti(node, "in_texs")
        this.out = new OutTerminal(node, "out_field")

        node.set_state_evaluators({"coord":  (m,s)=>{ return new GlslTextEvaluator(m,s, "coord", ['x','y'], TYPE_VEC2) },
                                   "in_texi":  (m,s)=>{ return new DFImgGlslTextEvaluator(m,s, "in_texi", [], TYPE_FUNCTION, in_texi_types )}} ) 

        this.dist_func = new ParamFloat(node, "Distance\nFunction", "in_texi(0,coord).r", {show_code:true})

        this.sorted_order = []
        mixin_multi_reorder_control(node, this, this.sorted_order, this.in_texs)
    }

    run() {
        const imgs = this.in_texs.get_input_consts()

        const ditem = this.dist_func.get_active_item()
        const item = new ItemStandin(ditem) 

        const value_need_in_tex = item.need_input_evaler("in_texi")
        if (value_need_in_tex) 
            value_need_in_tex.dyn_set_obj(0) // placeholder for in_texi offset, just so that the test glsl generation won't complain

        // same idea as NodeDFCombine
        const emit_ctx = new GlslEmitContext()
        try {
            emit_ctx.inline_str = ditem.eto_glsl(emit_ctx) 
        }
        catch(e) {
            assert(false, this, e.message)
        }
        assert(emit_ctx.inline_str !== null, this, 'unexpected expression null')

        // order imges 
        const sorted_imgs = []
        for(let i of this.sorted_order)
            sorted_imgs.push(imgs[i])

        const uniform_values = {}
        emit_ctx.set_uniform_vars_to_obj(uniform_values) // commit the variables to their current value to set in the output object
        const dfnode = new DFNode(new Expr_FuncMaker(item, null, emit_ctx.uniform_decls, uniform_values, sorted_imgs), null, null, null, null)
        dfnode.inline_tr = true
        this.set_out_dfnode(dfnode)
    }
}




// See https://en.wikipedia.org/wiki/Test_functions_for_optimization
function goldsteinPrice(x, y) {
    return (1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y))
        * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y));
  }

class NodeMarchingSquares extends NodeCls
{
    static name() { return "Marching Squares" }
    constructor(node) {
        super(node)
        this.in_df_obj = new InTerminal(node, "in_field")
        this.out = new OutTerminal(node, "out_paths")

        node.set_state_evaluators({"index":  (m,s)=>{ return new ObjSingleEvaluator(m,s) }})

        this.alg = new ParamSelect(node, "Algorithm", 0, ["Square Marching", "Po-Trace"])
        this.thresh = new ParamFloat(node, "First Iso", 0, {enabled:true, min:-1, max:1})
        this.count = new ParamInt(node, "Iso Count", 1, {enabled:true, min:1, max:20}, (v)=>{
            this.step.set_enable(v > 1)
        })
        this.step = new ParamFloat(node, "Iso Step", 0.2, {enabled:true, min:-0.4, max:0.4})
        this.res = new ParamVec2Int(node, "Resolution", 256, 256)
        this.size = new ParamVec2(node, "Size", 2, 2)
        this.flip_sign = new ParamBool(node, "Flip sign", true)
        this.transform = new ParamTransform(node, "Transform")
    }

    async values_from_df(df, width, height, sx, sy, tr, sign) {
        const fb_fact = new FrameBufferFactory(width, height, sx, sy, false, "pad", "float")
        fb_fact.transform(tr)
        const values = await df.get_pixels_for_fb(fb_fact)

        if (sign < 0) {
            const len = values.length
            for(let i = 0; i < len; ++i)
                values[i] = -values[i]
        }
      
        return values
    }

    values_test_func(width, height, sx, sy, tr, sign)
    {
        const top_left = vec2.fromValues(-sx/2, -sy/2), bot_left = vec2.fromValues(-sx/2, sy/2), top_right = vec2.fromValues(sx/2, -sy/2)
        vec2.transformMat3(top_left, top_left, tr)
        vec2.transformMat3(bot_left, bot_left, tr)
        vec2.transformMat3(top_right, top_right, tr)
        const da = vec2.create(), db = vec2.create() // the square has two orthogonal vectors a,b
        vec2.subtract(da, top_right, top_left)
        vec2.subtract(db, bot_left, top_left)
        da[0] /= width-1; da[1] /= width-1
        db[0] /= height-1; db[1] /= height-1

        const values = new Float32Array(width * height);
        let k = 0
        for (let ib = 0; ib < height; ++ib) {
            for (let ia = 0; ia < width; ++ia) {
                const x = da[0] * ia + db[0] * ib + top_left[0]
                const y = da[1] * ia + db[1] * ib + top_left[1]
                //values[k] = goldsteinPrice(x, y);
                values[k] = sign * (Math.sqrt(x*x + y*y) - 1)
                k++
            }
        }
        return values
    }

    run_square_march(values, threshs, width, height) {
        const thresh_vals = []
        for(let e of threshs)
            thresh_vals.push(e.thresh)

        //const contours = d3.contours().size([width, height]).thresholds([this.thresh.v])(values);
        const gen = d3.contours()
        gen.size([width, height])
        gen.smooth(true) // without this it's just steps
        const cont = gen.thresholds(thresh_vals)(values)
        // returns a list of multipaths
        return cont
    }

    make_face_idxf(face_idx, th_length) {
        if (th_length == 1)
            return new Array(face_idx.length).fill(0)
        // fraction between 0-1 of the index            
        const face_idxf = [] // fraction between 0-1 of the index
        for(let idx of face_idx)
            face_idxf.push(idx / (th_length-1))  
        return face_idxf      
    }

    square_march(values, threshs, width, height, sx, sy, tr) 
    {
        const conts = this.run_square_march(values, threshs, width, height)

        const v = vec2.create()
        function tr_p(out, p) {
            out[0] = (p[0]-0.5) / (width-1) * sx - (sx/2)
            out[1] = (p[1]-0.5) / (height-1) * sy - (sy/2)
            vec2.transformMat3(out, out, tr)
        }

        const vtx = [], ranges = [], face_idx = []
        let cont_idx = 0
        for(let cont of conts) {
            for(let paths of cont.coordinates) {
                let extra_flag = 0
                for(let path of paths) { // can have 1 or two paths if there's an outside when the value is negative inside
                    const start_at = vtx.length/2
                    for(let point of path) {
                        tr_p(v, point)
                        vtx.push(v[0], v[1])
                    }
                    ranges.push(start_at, vtx.length/2, PATH_CLOSED | extra_flag)
                    face_idx.push(threshs[cont_idx].index)
                    extra_flag = PATH_CONTINUE_PREV // more than 1 path here means there's holes
                }
            }
            ++cont_idx
        }
        const face_idxf = this.make_face_idxf(face_idx, threshs.length)

        const obj = new MultiPath()
        obj.set('vtx_pos', new TVtxArr(vtx), 2)
        obj.paths_ranges = ranges
        obj.set('face_index', new Uint32Array(face_idx), 1)
        obj.set('face_indexf', new Float32Array(face_idxf), 1)
        return obj
    }

    potrace_res_to_obj(paths, width, height, sx, sy, tr, count_threshs) 
    {
        function tr_p(out, p) {
            out[0] = (p.x-0.5) / (width-1) * sx - (sx/2)
            out[1] = (p.y-0.5) / (height-1) * sy - (sy/2)
            vec2.transformMat3(out, out, tr)
        }

        const vtx = [], ranges = [], ctp = [], cfp = [], face_idx = []
        const t = vec2.create(), tc = vec2.create()  // scratchpads for transformed points
        for(let path of paths) {
            const c = path.curve
            const startIdx = vtx.length / 2
            tr_p(t, c.c[(c.n - 1) * 3 + 2])
            let prev_x = t[0], prev_y = t[1]
            for(let i = 0; i < c.n; ++i) {
                if (c.tag[i] === "CURVE") {
                    tr_p(t, c.c[i*3 + 2])
                    vtx.push(t[0], t[1])
                    tr_p(tc, c.c[i*3 + 1])
                    ctp.push(tc[0] - t[0], tc[1] - t[1])
                    tr_p(tc, c.c[i*3 + 0])
                    cfp.push(tc[0] - prev_x, tc[1] - prev_y)
                    prev_x = t[0]; prev_y = t[1]
                }
                else if (c.tag[i] == "CORNER") {
                    tr_p(t,  c.c[i*3 + 1])
                    tr_p(tc, c.c[i*3 + 2])
                    vtx.push(t[0],t[1],  tc[0],tc[1])
                    ctp.push(0, 0, 0, 0)
                    cfp.push(0, 0, 0, 0)
                    prev_x = tc[0]; prev_y = tc[1]
                }
                else
                    assert(false, this, "unexpected tag")
            }
            ranges.push(startIdx, vtx.length /2, PATH_CLOSED | path.flag)
            face_idx.push(path.cont_index)
        }

        const face_idxf = this.make_face_idxf(face_idx, count_threshs)

        const obj = new MultiPath()
        obj.set('vtx_pos', new TVtxArr(vtx), 2)
        obj.set('ctrl_to_prev',   new TVtxArr(ctp), 2)
        obj.set('ctrl_from_prev', new TVtxArr(cfp), 2)
        obj.set('face_index', new Uint32Array(face_idx), 1)
        obj.set('face_indexf', new Float32Array(face_idxf), 1)
        obj.paths_ranges = ranges
        return obj        
    }

    potrace(values, threshs, width, height, sx, sy, tr) {
        const arr = new Uint8Array(width * height)
        const len = width * height
        const thresh_len = threshs.length
        for(let i = 0; i < len; ++i) {
            const in_v = values[i]
            let out_v = threshs.length // in case of not finding anything below
            for(let j = 0; j < thresh_len; ++j) {
                const t = threshs[j].thresh
                if (in_v < t) {
                    out_v = j
                    break
                }
            }
            // TBD possible optimization for linear thresholds
            arr[i] = out_v
        }
     /*   const thresh = threshs[0]
        for(let i = 0; i < len; ++i)
            arr[i] = (values[i] < thresh) ? 0 : 1
*/
        let all_paths = []
        for(let i in threshs) {
            Potrace.setBm(arr, width, height, parseInt(i)+1)
            const paths = Potrace.process()
            let flag = 0
            for(let p of paths) {
                p.cont_index = threshs[parseInt(i)].index
                p.flag = flag
                all_paths.push(p)
                flag = PATH_CONTINUE_PREV
            }
            Potrace.clear()
        }
        //const svg = Potrace.getSVG(0.1, 'curve')
        //console.log(svg)
        //console.log(paths)

        return this.potrace_res_to_obj(all_paths, width, height, sx, sy, tr, threshs.length)
    }



    make_thresholds(sign) {
        const value_need_index = this.step.need_input_evaler("index")
        let index_wrap = [0]
        if (value_need_index !== null)
            value_need_index.dyn_set_obj(index_wrap)
        let ret = []
        let step = this.step.v
        for(let i = 0; i < this.count.v; ++i) {
            if (value_need_index !== null) {
                index_wrap[0] = i
                step = this.step.dyn_eval()
            }
            ret.push({thresh:(this.thresh.v + i * step)*sign, index:i})
        }
        ret = ret.sort((a, b)=>{ return a.thresh - b.thresh});
        return ret
    }

    async run() {
        const df = this.in_df_obj.get_const()
        assert(df !== null && df.constructor === DistanceField, this, "Missing input distance field")

        const width = this.res.x, height = this.res.y
        const sx = this.size.x, sy = this.size.y
        const tr = this.transform.v
        const sign = this.flip_sign.v ? -1 : 1

        let values
        if (true)
            values = await this.values_from_df(df, width, height, sx, sy, tr, sign)
        else
            values = this.values_test_func(width, height, sx, sy, tr, sign)

        let obj, threshs = this.make_thresholds(sign)
        if (this.alg.sel_idx === 0)
            obj = this.square_march(values, threshs, width, height, sx, sy, tr)
        else if (this.alg.sel_idx === 1)
            obj = this.potrace(values, threshs, width, height, sx, sy, tr)
     

        this.out.set(obj)
    }

    draw_selection(m) {
        this.transform.draw_dial_at_obj(null, m)
        this.size.size_dial_draw(this.transform.v, m)
        
        const sx = this.size.x, sy = this.size.y
        const top_left = vec2.fromValues(-sx/2, -sy/2), bottom_right = vec2.fromValues(sx/2, sy/2)
        draw_rect(top_left, bottom_right, m, this.transform.v, "#000")
    }    
    image_find_obj(e) {
        return this.transform.dial.find_obj(e) || this.size.size_dial_find_obj(e)
    }
}


"use strict"


//pick one of the inputs and set it to the output depending on an expression
class NodePickOne extends NodeCls
{
    static name() { return "Pick One" }
    constructor(node) {
        super(node)
        this.sorted_order = []

        this.in_m = new InTerminalMulti(node, "in_multi")
        this.out = new OutTerminal(node, "out")

        this.pick_expr = new ParamInt(node, "Pick Index", "(frame_num == 0) ? 0 : 1", {show_code:true})
        mixin_multi_reorder_control(node, this, this.sorted_order, this.in_m)
        this.last_line_picked = null
    }
    is_picking_lines() { return true }

    // called before run, selects which inputs to run
    pick_lines(of_terminal) {

        assert(of_terminal === this.in_m, this, "Unexpected terminal in pick_lines")
        assert(this.in_m.lines.length > 0, this, "No inputs")

        this.pick_expr.resolve_variables(this.vars_in.my_vsb, true, false) // this is needed since pick_lines runs before resolving variables
        this.pick_expr.resolve_variables(this.vars_in.my_vsb, false, true) // this is needed since pick_lines runs before resolving variables
        const pick = this.pick_expr.get_value()
        assert(pick >= -1 && pick < this.in_m.lines.length, this, "Index out of range " + pick)
        if (pick === -1) {
            assert(this.out.get_const() !== null, this, "pick result is -1 but no previous output exists")
            this.last_line_picked = null
            return []
        }
        const idx = this.sorted_order[pick]
        const line = this.in_m.lines[idx]
        this.last_line_picked = line
        return [line]
    }

    should_clear_out_before_run() {
        return this.last_line_picked !== null
    }

    run() {
        if (this.last_line_picked === null)
            return  // keep the previous result
        const line = this.last_line_picked
        this.last_line_picked = null 
        collect_line(line) // manual collect, just the input we want
        const obj = line.to_term.get_const()
        // don't check if obj is empty here. If it's empty due to an error, forward it into the anim loop so that the error will reach there
        this.out.set(obj)
    }
}

// pass the input to output only if an expression changes
// this is needed for making a difference between a frame change and pan/zoom/space press
class NodeChangeFilter extends NodeCls 
{
    static name() { return "Change Filter" }
    constructor(node) {
        super(node)

        this.in = new InTerminal(node, "in")
        this.out = new OutTerminal(node, "out")

        // make this node pass-through
        // this can be unchecked if we want any parameter change to cause an animation frame (but not panning which doesn't do run in any case)
        this.enabled = new ParamBool(node, "Filter Enabled", true, (v)=>{
            this.change_expr.enabled = v;
        })
        // the value of this expr is not used, only the fact that the value changes
        this.change_expr = new ParamInt(node, "Change Expr", "frame_num", {show_code:true})
    }

    should_clear_out_before_run() { return false } // don't clear my cache

    is_dirty_override(parent_dirty) { // ignored parent_dirty
        // I know better than my terminals when I want to run
        if (!this.enabled.get_value())
            return null  // do the default behaviour
        if (this.out.get_const() !== null && !this.change_expr.pis_dirty())
            return false
        return true
    }

    run() {
        if (this.enabled.get_value() && this.out.get_const() !== null && !this.change_expr.pis_dirty())
            return
        const obj = this.in.get_const()
        assert(obj !== null, this, "No input")
        this.out.set(obj)
    }

}

// represents the shadow-nodes canvas sqare that snaps the follow node
class FollowTarget {
    constructor(node) {
        this.node = node
        this.wuid = node.of_program.alloc_ephemeral_obj_id(this)
    }
    draw_nshadow() {
        ctx_nd_shadow.beginPath();
        const x = this.node.x + NODE_WIDTH*0.5
        const y = this.node.y + NODE_HEIGHT
        //ctx_nd_shadow.arc(x, y , 35, 0, 2*Math.PI)
        ctx_nd_shadow.fillStyle = color_from_uid(this.wuid)
        ctx_nd_shadow.fillRect(x-40, y, 80, 35)
//        ctx_nd_shadow.fill()   
    }
}

function add_follow_target(inst)
{
    inst.node.follow_target = new FollowTarget(node)
    inst.node_move_hook = (ev, is_cascading)=>{
        if (!this.node.can_follow || is_cascading) // if it's a move due to the followee moving, don't need to do anything
            return
        this.node.unfollow() // start moving due to a user drag, disconnect it immediately
        const center_e = { cvs_x: (this.node.x + nodes_view.pan_x + NODE_WIDTH*0.5)*nodes_view.zoom,
                        cvs_y: (this.node.y + nodes_view.pan_y + NODE_HEIGHT*0.5)*nodes_view.zoom }
        const obj = nodes_find_obj_shadow(center_e)
        if (obj === null || obj.constructor !== FollowTarget || obj === this.node.follow_target || obj.node.followed_by_node !== null) {
            this.node.snap_suggest = null
            return
        }
        this.node.snap_suggest = {x:obj.node.x, y:obj.node.y + obj.node.height, obj:obj.node }
        console.log("FOUND " + obj.node.name)
    }
    inst.node_mouse_up_hook = (ev)=>{
        if (this.node.snap_suggest !== null) {
            const of_node = this.node.snap_suggest.obj
            this.node.unfollow()
            this.node.follow(of_node)
            this.node.mousemove( { dx: of_node.x - this.node.x, dy: of_node.y + of_node.height + 1 - this.node.y }, true)
            this.node.snap_suggest = null
            
            draw_nodes()
        }
        else {
            this.node.unfollow()
        }
    }
}


const LINE_COLOR_ANIM_FLOW = "#ACFFEC"
const TERM_COLOR_ANIM_FLOW = "#ACFFEC"

class NodeAnimCls extends NodeCls 
{
    constructor(node) {
        super(node)
        node.can_display = false
        //node.can_follow = true
        node.can_run_on_select = false // doesn't run when selected
    }  

    // called when flow just enters this node
    entered() {}
    exiting() {}
    get_anim_traits() { dassert(false, "unimplemented") }
    // for event
    want_flow_hijack() { dassert(false, "unimplemented") }

    run() { // do nothing
    }
}

class AnimInTerminal extends InTerminal
{
    constructor(node, name) {
        super(node, name)
        this.kind = KIND_FLOW_ANIM
        this.color = TERM_COLOR_ANIM_FLOW
    }
    is_dirty() {
        return false // doesn't transport object so it's never dirty
    }
}

class AnimOutTerminal extends OutTerminal
{
    constructor(node, name) {
        super(node, name)
        this.kind = KIND_FLOW_ANIM
        this.color = TERM_COLOR_ANIM_FLOW
    }
    // there can be only one output line, delete any existing
    pre_add_line_hook() {
        const lines_copy = [...this.lines]
        for(let line of lines_copy)
            program.delete_line(line, false) 
    }
}

const FRAME_RATE_NORMAL = -1 // normal rate from requestAnimationFrame
const FRAME_RATE_MAX = -2

// returned from get_anim_traits()
class AnimTraits
{
    constructor() {
        this.next = false //should skip to next flow node and call again on it
        this.frame_rate = FRAME_RATE_NORMAL
        this.render = true
        this.blocking_frames = 1
        this.jump_here = false // relevant only for EventFlow, when it triggers
    }
}


// controls program.anim_flow.start_node
/*
class AnimStartFlow extends NodeAnimCls
{
    static name() {
        return "Start Flow"
    }
    constructor(node) {
        super(node)
        node.can_enable = true
        this.start = new AnimOutTerminal(node, "start")
        this.traits = new AnimTraits()
        this.traits.next = true // start does nothing but go to the first
    }

    toggle_enable_flag(do_draw, to_value) {
        this.node.of_program.anim_flow.set_anim_node(this.node)
    }

    get_anim_traits() {
        return this.traits
    }
}*/

class AnimEventFlow extends NodeAnimCls
{
    static name() {
        return "Flow Event"
    }
    constructor(node) {
        super(node)
        node.can_enable = true
        this.start = new AnimOutTerminal(node, "start")
        this.type = new ParamSelect(node, "On Event", 2, ["Manual Condition", "Any Input Variable", "Frame-num At"], (sel_idx)=>{
            this.on_manual.set_visible(sel_idx == 0)
            this.on_framenum.set_visible(sel_idx == 2)
        })
        this.on_manual = new ParamBool(node, "Trigger", false, null, {pulse_btn:true}) // trigger wheneven this is pressed or changes to a true value
        this.on_framenum = new ParamInt(node, "Frame-Num", 0, { allowed_code:false, allowed:false }) // just a single number, this is an optimization, for anything more, use a condition
    
        this.traits = new AnimTraits()
        this.traits.next = true
        this.current_trigger_value = null
    }

    toggle_enable_flag(do_draw, to_value) {
        this.node.of_program.anim_flow.toggle_event_node(this.node)
    }

    get_anim_traits() {
        return this.traits
    }
    clear_flow_hijack() {
        this.current_trigger_value = false // want to see if it was just set this run (if run() was called at all, due to dirtiness)
    }
    want_flow_hijack() {
        return this.current_trigger_value
    }


    run() {
        // need to cache it in run, before the dirty flag is cleared and the pulse ends
        switch(this.type.sel_idx) {
        case 0: this.current_trigger_value = this.on_manual.get_value(); break;
        case 1: this.current_trigger_value = this.vars_in.is_dirty(); break;
        case 2: this.current_trigger_value = (g_anim.frame_num_box.vbget() == this.on_framenum.get_value()); break;
        }
    }
}


class AnimSpan extends NodeAnimCls
{
    static name() {
        return "Flow Span"
    }
    constructor(node) {
        super(node)
        this.prev = new AnimInTerminal(node, "previous")
        this.next = new AnimOutTerminal(node, "next")

        this.frame_rate = new ParamSelect(node, "Frame Rate", 0, [["Normal", FRAME_RATE_NORMAL], ["Maximum", FRAME_RATE_MAX]], (sel_idx)=>{
            this.blocking_frames.set_visible(sel_idx === 1)
        })
        // number of frames to run at the same time without returning
        this.blocking_frames = new ParamInt(node, "Block Frames", 1)
        this.render = new ParamBool(node, "Render", true)
        this.stop_at = new ParamSelect(node, "Stop", 0, ["Never", "Frame Count", "Condition"], (sel_idx)=>{
            this.stop_at_count.set_visible(sel_idx === 1)
        })
        this.stop_at_count = new ParamInt(node, "After Count", 0) 

        this.traits = new AnimTraits()
        this.first_frame = null // for frame_count
    }

    entered() {
        this.first_frame = null
    }

    get_anim_traits() {
        if (this.stop_at.sel_idx === 1) {
            const now_frame_num = g_anim.frame_num_box.v
            if (this.first_frame === null) {
                this.first_frame = now_frame_num
                //console.log("  first-get ", this.node.name, " at frame ", this.first_frame)
            }
            else {
                const check_count = this.stop_at_count.get_value()
                if (now_frame_num - this.first_frame >= check_count) {
                    this.traits.next = true
                    return this.traits
                }
            }
        }
        this.traits.frame_rate = this.frame_rate.get_sel_val()
        if (this.traits.frame_rate === FRAME_RATE_MAX) {
            const blf = this.blocking_frames.get_value()
            assert(blf >= 1, this, "Block Frames can't be less than 1")
            this.traits.blocking_frames = blf
        }
        this.traits.render = this.render.get_value()
        this.traits.next = false
        this.traits.blocking_frames = 1 // reset to default
        return this.traits
    }
}


// this node exposes the variables as output even when it is not currently flowing
// both in global and local mode
class FlowVariable extends NodeVariable
{
    static name() {
        return "Flow Set Variable"
    }
    constructor(node) {
        super(node)
        node.can_display = false
        node.can_run_on_select = false // doesn't run when selected

        this.prev = new AnimInTerminal(node, "previous")
        this.next = new AnimOutTerminal(node, "next")

        this.can_enable = false
        this.global_checkbox_override = (v)=>{
            if (this.node.enable_active === v)
                return
            this.node.of_program.set_glob_var_node(this.node, true, v)
        }

        this.next_traits = new AnimTraits()
        this.next_traits.next = true

        this.cur_traits = null
        this.flowing = false
    }  

    // called when flow just enters this node
    get_anim_traits() { 
        return this.next_traits
    }

    // need to implement things from NodeAnimCls
    entered() {
        this.flowing = true
        this.node.set_self_dirty()
    }

    exiting() {
        this.flowing = false
        this.node.set_self_dirty()
    }

    run() 
    {        
        this.set_only_if_missing = false
        if (!this.flowing) {
            //const is_global = this.global.get_value()
            //if (is_global)
                this.set_only_if_missing = true // make run() do nothing by update with the latest param (but don't output variables)
            //else {
            //    this.del_cur_refs() // in case it was global before
            //    this.var_out.set(new VariablesObj())
            //    return
            //}
        }
        super.run();
    }

}
"use strict"

// body - position and velocity, apply force


// Basic Body def node
// - static/dynamic
//    kynetic - moving but doesn't respond to force
// - shape - box, circle, from input polygon, from input fixtures
// - position, angle
// - density (disabled for static)
//    - warning if all fixtures have 0 density
// - friction, Restitution

// Rigid body ? - attache several fixtures

// World node

// screen control node
// pointer can grab bodies and move them - set position/apply force?



class B2FixtureDec {
    constructor(cnode_id) {
        this.def = null
        this.obj = null
        this.cnode_id = cnode_id 
    }
}

class B2BodyDec {
    constructor(cnode_id) {
        this.name = null // for debugging
        this.def = null
        this.fixtures = []
        this.obj = null
        this.cnode_id = cnode_id // creating node unique-id
        this.index = null // temporary for building the world
        this.t_mat = null // not actually used

        this.on_init_params = [] // functions that are called just after the initialization of the world (for things that are not in the defs, kinematic velocity)
    }
    getPos() {
        if (this.obj !== null)
            return this.obj.GetPosition()
        return this.def.position
        
    }
    getAngle() {
        if (this.obj !== null)
            return this.obj.GetAngle()
        return this.def.angle
    }
}

class B2JointDec {
    constructor(cnode_id) {
        this.def = null
        this.body_refA = null // B2Body objects
        this.body_refB = null
        this.init_call = null // function to call for initializing the joint with the two real bodies
        this.obj = null
        this.cnode_id = cnode_id  // creating node unique-id
    } 
}

// for nodes that use a b2.World for display


class B2Def extends PObject
{
    constructor() {
        super()
        this.bodies = []  // list of B2BodyDec
        this.joints = []  // list of B2JointDec

        this.cnode_to_obj = []

        // kind of a hack to take advantage of the fact the world can draw itself
        this.p_draw_world_cache = null // not copied on clone

    }
    
    add_body() {
        for(let b of arguments) {
            this.cnode_to_obj[b.cnode_id] = b
            this.bodies.push(b)
        }
    }
    add_joint() {
        for(let j of arguments) {
            this.cnode_to_obj[j.cnode_id] = j
            this.joints.push(j)
        }
    }

    ensure_world_cache() {
        if (this.p_draw_world_cache !== null)
            return
        this.p_draw_world_cache = createWorld(this, [0,0], false) // create world just for calling DebugDraw    
    }

    draw_m(m, disp_values) {
        this.ensure_world_cache()
        this.p_draw_world_cache.draw_mw(disp_values)
    }
    draw_template_m(m) {
        this.ensure_world_cache()
        this.p_draw_world_cache.draw_template_m(m)
    }

    can_draw_shadow() { 
        return true 
    }
    draw_shadow_m(m) {
        this.ensure_world_cache()
        this.p_draw_world_cache.draw_shadow_m()
    }
}

class B2World extends PObject
{
    static name() { return "Physics World" }
    constructor() {
        super()

        //this.bodied_decs = []
        //this.joints_decs = []

        this.obj = null
        this.bodies = []

        // map cnode_id of the creator node to the object it created in the context of this world
        // this is done like this so that the same def can go to different worlds
        // used by online params
        this.cnode_to_obj = [] 

        this.p_draw_debug = null
        this.p_draw_shadow = null
        this.p_draw_template = null
    }

    clone() {
        assert(false, this, "World object can't be cloned")
        // due to the b2 objects and multiple refs to the same objects
    }



    do_draw(flags, drawer) {      
        drawer.SetFlags(flags)
        drawer.ctx.lineWidth = 1.0/image_view.viewport_zoom
        this.obj.SetDebugDraw(drawer);
        this.obj.DebugDraw()        
    }

    draw_mw(disp_values) { // used by B2Defs to draw without setting the current world
        if (this.p_draw_debug === null) 
            this.p_draw_debug = new CanvasDebugDraw(ctx_img);

        let flags = 0
        flags |= b2.DrawFlags.e_shapeBit
        flags |= b2.DrawFlags.e_jointBit
        //flags |= b2.DrawFlags.e_controllerBit
        //flags |= b2.DrawFlags.e_pairBit // lines connecting bodies
        this.do_draw(flags, this.p_draw_debug)
    }
    draw_m(m, disp_values) {
        add_current_world(this) // for online updates from nodes
        this.draw_mw(disp_values, this)
    }

    draw_template_m(m) {
        if (this.p_draw_template === null) {
            this.p_draw_template = new CanvasDebugDraw(ctx_img);
            this.p_draw_template.set_color_template(true)
        }
        this.do_draw(b2.DrawFlags.e_shapeBit | b2.DrawFlags.e_jointBit, this.p_draw_template)
    }

    can_draw_shadow() { 
        return true 
    }

    draw_shadow_m(m) {
        // used for selecting object with click in image view
        if (this.p_draw_shadow === null) {
            this.p_draw_shadow = new CanvasDebugDraw(ctx_img_shadow);
            this.p_draw_shadow.set_color_from_shape(true)
        }
        this.do_draw(b2.DrawFlags.e_shapeBit, this.p_draw_shadow)
    }      

}

function b2VecFromArr(v) { return new b2.Vec2(v[0], v[1]) }
 

// for change of parameters by user during sim
// also called from on_init for parameters the must be set only on world creation
// also called from eresolve when variables change
function make_phy_caller(obj_func_name, node_id, change_func, adapter=null) {
    return function(v) {
        for(let w of g_current_worlds) {
            const obj = w.cnode_to_obj[node_id]
            if (obj === undefined)
                continue
            if (typeof obj_func_name !== 'string') {
                obj_func_name(w, v, obj)  // it's actually a function override (for Density)
                continue
            }
            dassert(obj.obj[obj_func_name] !== undefined, "object missing function " + obj_func_name)
            if (adapter !== null)
                v = adapter(v)            
            obj.obj[obj_func_name](v)
        }
        if (change_func)
            change_func(v)
    }
}

class PhyParamFloat extends ParamFloat {
    constructor(node, label, start_v, conf, obj_func_name, id_suffix="") {
        super(node, label, start_v, conf, make_phy_caller(obj_func_name, node.id + id_suffix, null))
    }
}
class PhyParamFloatPositive extends PhyParamFloat {
    constructor(node, label, start_v, conf, obj_func_name, id_suffix="") {
        if (conf === null)
            conf = {}
        conf.validate = (v)=>{ if (v !== null) assert(v >= 0, node.cls, "Can't be negative")} 
        super(node, label, start_v, conf, obj_func_name, id_suffix)
    }
}

class PhyParamBool extends ParamBool {
    constructor(node, label, start_v, obj_func_name, change_func=null, id_suffix="") {
        super(node, label, start_v, make_phy_caller(obj_func_name, node.id + id_suffix, change_func))
    }
}
class PhyParamVec2 extends ParamVec2 {
    constructor(node, label, start_x, start_y, obj_func_name, change_func=null, id_suffix="") {
        super(node, label, start_x, start_y, null, make_phy_caller(obj_func_name, node.id + id_suffix, change_func, b2VecFromArr))
    }
}
class PhyParamTransform extends ParamTransform {
    constructor(node, label, start_v, id_suffix="") {
        super(node, label, start_v, {b2_style:true}, make_phy_caller((w, m)=>{
            const obj = w.cnode_to_obj[node.id]
            obj.obj.SetTransformXY(this.translate[0], this.translate[1], glm.toRadian(this.rotate))
        }, node.id + id_suffix, null))
    }
}

function b2MakeBox(w, h, pivot) {
    const s = new b2.PolygonShape()
    s.SetAsBox(Math.abs(w) * 0.5, Math.abs(h) * 0.5, pivot, 0)
    return s
}

class NodeB2Body extends NodeCls
{
    static name() { return "Physics Body" }
    constructor(node) {
        super(node)
        //this.in_obj = new InTerminal(node, "in_obj")
        this.out = new OutTerminal(node, "b2_defs")
        
        this.type = new ParamSelect(node, "Type", 0, [["Static", b2.staticBody], ["Kinematic", b2.kinematicBody], ["Dynamic",b2.dynamicBody]],(sel_idx)=>{
            this.kin_lin_velocity.set_visible(sel_idx == 1);
            this.kin_ang_velocity.set_visible(sel_idx == 1);
            this._sep2.set_visible(sel_idx == 1);
        })
        this.shape = new ParamSelect(node, "Shape", 0, ["Box", "Circle"],(sel_idx)=>{
            this.size.set_visible(sel_idx === 0)
            this.radius.set_visible(sel_idx === 1)
        })
        this.size = new PhyParamVec2(node, "Size(m)", 0.5, 0.5, (w, v, bobj)=>{
            const s = b2MakeBox(v[0], v[1], this.get_shape_pivot())
            const fobj = w.cnode_to_obj[node.id + "_f"]
            if (fobj !== undefined)
                fobj.obj.m_shape = s
            bobj.obj.SetAwake(true)
        })
        this.radius = new PhyParamFloatPositive(node, "Radius(m)", 0.5, {min:0, max:1}, (w, v, bobj)=>{
            const fobj = w.cnode_to_obj[node.id + "_f"]
            if (fobj !== undefined)
                fobj.obj.m_shape.m_radius = v
            // TBD mass???
            bobj.obj.SetAwake(true)
        })
       
        this._sep1 = new ParamSeparator(node, "_sep1")

        this.kin_lin_velocity = new PhyParamVec2(node, "Linear V(m/s)", 0, 0, "SetLinearVelocity")
        this.kin_ang_velocity = new PhyParamFloat(node, "Angular V(r/s)", 0, {min:-90, max:90}, "SetAngularVelocity")
        this._sep2 = new ParamSeparator(node, "_sep2")

        this.density = new PhyParamFloat(node, "Density(kg)", 1, {min:0, max:10}, (w, v, bobj)=>{
            const fobj = w.cnode_to_obj[node.id + "_f"]
            if (fobj !== undefined)
                fobj.obj.SetDensity(v)
            bobj.obj.ResetMassData() // to the body
        })
        this.restit = new PhyParamFloat(node, "Restitution", 0.1, {min:0, max:1}, "SetRestitution", "_f") // doesn't change existing contacts
        this.friction = new PhyParamFloat(node, "Friction", 0.1, {min:0, max:1}, "SetFriction", "_f")

        this.transform = new PhyParamTransform(node, "Transform", {})

        this.radius_dial = new PointDial((dx,dy)=>{
            this.radius.increment(dx)
        })
    }

    get_shape_pivot() {
        return new b2.Vec2(-this.transform.rotate_pivot[0], -this.transform.rotate_pivot[1])
    }
    
    run() {
        const b = new B2BodyDec(this.node.id)
        b.name = this.node.name
        b.def = new b2.BodyDef()
        b.def.type = this.type.get_sel_val()
        b.def.position.Set(this.transform.translate[0], this.transform.translate[1])
        b.def.angle = glm.toRadian(this.transform.rotate)
        b.t_mat = mat3.copy(mat3.create(), this.transform.v) // don't want this to be tied to the Param, best thing is to copy it

        let s = null
        const pivot = this.get_shape_pivot()
        if (this.shape.sel_idx === 0) {  // box
            s = b2MakeBox(this.size.x, this.size.y, pivot)
        }
        else if (this.shape.sel_idx === 1) { // circle 
            s = new b2.CircleShape(this.radius.v)
            s.Set(pivot)
        }
        else
            assert(false, node, "not supported")

        const f = new B2FixtureDec(this.node.id + "_f")
        f.def = new b2.FixtureDef()
        f.def.shape = s
        f.def.density = this.density.v
        f.def.restitution = this.restit.v
        f.def.friction = this.friction.v
        f.def.userData = { node_id: this.node.id } // for shadow find
        b.fixtures.push(f)
        if (this.type.sel_idx === 1) { // kinematic
            b.on_init_params.push(this.kin_lin_velocity, this.kin_ang_velocity)
        }
        
        const ret = new B2Def()
        ret.add_body(b)
        this.out.set(ret)
    }

    dials_hidden() {
        return has_current_world() && this.type.sel_idx != 0
    }

    draw_selection(m) {
        if (this.dials_hidden()) {
            // moving objects should not show the move dial in the wrong place
            return
        }
        this.transform.draw_dial_at_obj(null, m)
        if (this.size.pis_visible())
            this.size.size_dial_draw(this.transform.v, m)
        if (this.radius.pis_visible())
            this.radius_dial.draw(this.radius.v, 0, this.transform.v, m)

    }

    image_find_obj(e) {
        if (this.dials_hidden()) 
            return null
        if (this.radius.pis_visible()) { // radius before transform since they may overlap
            const hit = this.radius_dial.find_obj(e)
            if (hit)
                return hit
        }
        let hit = this.transform.dial.find_obj(e)
        if (hit)
            return hit
        if (this.size.pis_visible()) {
            hit = this.size.size_dial_find_obj(e)
            if (hit)
                return hit
        }
        return null
    }

    img_hit_find_obj() {
        return new MouseJointProxy(this.node)
    }
}

class MouseJointProxy
{
    constructor(node) {
        this.node = node
        this.joint = null
        this.target = new b2.Vec2()
        this.with_world = null
    }
    mousemovable() {
        const [obj,w] = this.get_dynamic_obj()
        return obj !== null
    }
    mousemove(e) {
        if (this.joint === null)
            return
        const mpnt = image_view.epnt_to_model(e.ex, e.ey)
        this.target.x = mpnt[0]
        this.target.y = mpnt[1]
    
        //console.log("~~", this.target.x, this.target.y)
        this.joint.SetTarget(this.target)
    } 
    mouseup() {
        if (this.joint === null)
            return
        this.with_world.obj.DestroyJoint(this.joint)
        this.joint = null
        this.with_world = null
    }

    get_dynamic_obj() {
        if (!has_current_world())
            return [null,null]
        const w = first_current_world()
        dassert(w !== undefined, "no current world") // sanity
        const obj = w.cnode_to_obj[this.node.id]
        if (obj === undefined || obj.constructor !== B2BodyDec || obj.def.type !== b2.dynamicBody)
            return [null,null]
        return [obj,w]
    }
    
    mousedown(e) {
        this.node.select()
        const [obj,w] = this.get_dynamic_obj()
        if (obj === null)
            return
        const def = new b2.MouseJointDef()
        def.bodyB = obj.obj
        def.bodyA = obj.obj
        const mpnt = image_view.epnt_to_model(e.ex, e.ey)
        this.target.x = mpnt[0]
        this.target.y = mpnt[1]
        def.target = this.target
        def.maxForce = 100 *  obj.obj.GetMass()
        const frequencyHz = 5.0;
        const dampingRatio = 0.7;
        b2.LinearStiffness(def, frequencyHz, dampingRatio, def.bodyA, def.bodyB);
        this.joint = w.obj.CreateJoint(def)
        this.with_world = w
    }
}

function isSingleBody(def) {
    return def.bodies.length === 1 && def.joints.length === 0
}

function getWorldPoint_fromBodyDef(def, localPoint) {
    const xf = new b2.Transform();
    xf.p.Copy(b2Maybe(bd.position, b2Vec2.ZERO));
    xf.q.SetAngle(b2Maybe(bd.angle, 0));

    b2Transform.MulXV(this.m_xf, localPoint, out);
}

const FREQUENCY_HZ_FOR_DAMPING = 1.0

class NodeB2Joint extends NodeCls
{
    static name() { return "Physics Joint" }
    constructor(node) {
        super(node)

        this.inA = new InTerminal(node, "in_bodyA")
        this.inB = new InTerminal(node, "in_bodyB")
        this.out = new OutTerminal(node, "b2_defs")

        const anchors_vis = ()=>{
            const rel = this.rel_anchor.get_value()
            this.anchor.set_visible(this.type.sel_idx === 0 && !rel)
            const v = (this.type.sel_idx === 1) || (this.type.sel_idx === 0 && rel)
            this.anchorA.set_visible(v)
            this.anchorB.set_visible(v)
        }

        this.type = new ParamSelect(node, "Type", 0, ["Revolute", "Distance", ],(sel_idx)=>{
            this.enableMotor.set_visible(sel_idx === 0)
            this.motorSpeed.set_visible(sel_idx === 0)
            this.maxTorque.set_visible(sel_idx === 0)
            this.rel_anchor.set_visible(sel_idx === 0)

            anchors_vis()
            this.collideConnected.set_visible(sel_idx === 1)
            this.damping.set_visible(sel_idx === 1)
            this.min_len.set_visible(sel_idx === 1)
            this.max_len.set_visible(sel_idx === 1)
        })

        // ------- Revolute ---------
        this.rel_anchor = new ParamBool(node, "Body-Relative Anchors", false, (v)=>{
            anchors_vis()
        }) 
        // these can't change during sim
        this.anchor = new ParamVec2(node, "Anchor", 0, 0, null, (x,y)=>{
        })  
        // relative to body center
        this.anchorA = new PhyParamVec2(node, "Anchor A", 0, 0, (w, v, obj)=>{
            obj.obj.m_localAnchorA = b2VecFromArr(v)
            this.online_awake_objects(w)
        }) 
        this.anchorB = new PhyParamVec2(node, "Anchor B", 0, 0, (w, v, obj)=>{
            obj.obj.m_localAnchorB = b2VecFromArr(v)
            this.online_awake_objects(w)
        })

        this.enableMotor = new PhyParamBool(node, "Motor", false, "EnableMotor", (v)=>{
            this.motorSpeed.set_enable(v)
            this.maxTorque.set_enable(v)
        })
        this.motorSpeed = new PhyParamFloat(node, "Motor Speed(r/s)", 0.5, {min:-6, max:6}, "SetMotorSpeed")
        this.maxTorque = new PhyParamFloat(node, "Max Torque(N/m)", 10, {min:0, max:10}, "SetMaxMotorTorque")
        this.anchor.dial = new PointDial((dx,dy)=>{ this.anchor.increment(vec2.fromValues(dx, dy)) })

        // ------- Distance ---------
        // if two objects are connected by more than one joint this bool needs to be the same on all or only the last one initialized will take
        this.collideConnected = new PhyParamBool(node, "Collide Connected", false, (w, v, obj)=>{
            obj.obj.m_collideConnected = v
        })
        this.damping = new PhyParamFloat(node, "Damping", 0.2, {min:0, max:1}, (w, v, obj)=>{
            if (this.last_A_def === null || this.last_B_def === null)
                return
            const objA = w.cnode_to_obj[this.last_A_def.cnode_id]
            const objB = w.cnode_to_obj[this.last_B_def.cnode_id]
            if (objA === undefined || objB === undefined)
                return
            const dummyDef = {}
            b2.LinearStiffness(dummyDef, FREQUENCY_HZ_FOR_DAMPING, v, objA.obj, objB.obj)
            obj.obj.SetStiffness(dummyDef.stiffness)
            obj.obj.SetDamping(dummyDef.damping)
        })
        // TBD validator
        this.min_len = new PhyParamFloatPositive(node, "Min Length", 0.1, {min:0, max:2}, (w, v, obj)=>{
            obj.obj.SetMinLength(obj.obj.GetLength() - v)
        })
        this.max_len = new PhyParamFloatPositive(node, "Max Length", 0.1, {min:0, max:2}, (w, v, obj)=>{
            obj.obj.SetMaxLength(obj.obj.GetLength() + v)
        })

        this.anchorA.dial = new PointDial((dx,dy)=>{ this.anchorA.increment(vec2.fromValues(dx, dy)) }, null)
        this.anchorA.member_body_def = "last_A_def" // for lookup in draw_selection

        this.anchorB.dial = new PointDial((dx,dy)=>{ this.anchorB.increment(vec2.fromValues(dx, dy)) }, null)
        this.anchorB.member_body_def = "last_B_def"

        this.dialed_params = [this.anchor, this.anchorA, this.anchorB]

        // the positions of the bodies in the last run, for placing the anchors that are relative
        this.last_A_def = null  // b2.Vec2
        this.last_B_def = null
    }

    online_awake_objects(w) {
        if (this.last_A_def !== null) {
            const objA = w.cnode_to_obj[this.last_A_def.cnode_id]
            if (objA !== undefined)
                objA.obj.SetAwake(true)
        }
        if (this.last_B_def !== null) {
            const objB = w.cnode_to_obj[this.last_B_def.cnode_id]
            if (objB !== undefined)
                objB.obj.SetAwake(true)
        }
    }

    get_ab_anchors(bodyA, bodyB) {
        const ancA_obj = b2VecFromArr(this.anchorA.get_value())
        bodyA.GetWorldPoint(ancA_obj, ancA_obj)
        const ancB_obj = b2VecFromArr(this.anchorB.get_value())
        bodyB.GetWorldPoint(ancB_obj, ancB_obj)
        return [ancA_obj, ancB_obj]
    }

    run() {
        const defsA = this.inA.get_const()
        const defsB = this.inB.get_const()
        assert(defsA !== null && defsB !== null, this, "Missing input")
        assert(defsA.constructor === B2Def || !isSingleBody(defsA), this, "bodyA is not a physics body")
        assert(defsB.constructor === B2Def || !isSingleBody(defsB), this, "bodyB is not a physics body")

        const j = new B2JointDec(this.node.id)
        j.body_refA = defsA.bodies[0]
        j.body_refB = defsB.bodies[0]
        this.last_A_def = j.body_refA
        this.last_B_def = j.body_refB

        if (this.type.sel_idx === 0) {
            j.def = new b2.RevoluteJointDef()
            j.init_call = (bodyA, bodyB)=>{
                j.def.Initialize(bodyA, bodyB, b2VecFromArr(this.anchor.get_value()))
                if (this.rel_anchor.get_value()) {
                    // init it on the single point and the move it since there's no INitialize with rel anchors
                    j.def.localAnchorA = b2VecFromArr(this.anchorA.get_value())
                    j.def.localAnchorB = b2VecFromArr(this.anchorB.get_value())
                }
            }
            j.def.motorSpeed = this.motorSpeed.get_value()
            j.def.enableMotor = this.enableMotor.get_value()
            j.def.maxMotorTorque = this.maxTorque.get_value()
        }
        else if (this.type.sel_idx === 1) {
            j.def = new b2.DistanceJointDef()
            j.def.collideConnected = this.collideConnected.get_value()
            j.init_call = (bodyA, bodyB)=>{
                const [ancA_obj, ancB_obj] = this.get_ab_anchors(bodyA, bodyB)
                j.def.Initialize(bodyA, bodyB, ancA_obj, ancB_obj)
                b2.LinearStiffness(j.def, FREQUENCY_HZ_FOR_DAMPING, this.damping.get_value(), bodyA, bodyB)
                j.def.minLength -= this.min_len.get_value()
                j.def.maxLength += this.max_len.get_value()
            }
        }
        else
            assert(false, this, "Unexpected type")

        const ret = new B2Def()
        ret.add_body(j.body_refA, j.body_refB)
        ret.add_joint(j)
        this.out.set(ret)
    }

    dials_hidden() {
        return has_current_world()
    }

    draw_selection(m) {
        if (this.dials_hidden())
            return
        for(let p of this.dialed_params)
            if (p.pis_visible()) {
                let t_mat = null
                if (p.member_body_def !== undefined) {
                    const last_def = this[p.member_body_def]
                    if (last_def !== null) {
                        t_mat = mat3.create()
                        // don't use the param t_mat since that include the pivot move which we don't want since this is just the position of the body
                        mat3.translate(t_mat, t_mat, [last_def.def.position.x, last_def.def.position.y])
                        mat3.rotate(t_mat, t_mat, last_def.def.angle)
                    }
                }
                p.dial.draw(p.x, p.y, t_mat, m)
            }
    }
    image_find_obj(e) {
        if (this.dials_hidden())
            return null
        for(let p of this.dialed_params) {
            if (p.pis_visible()) {
                const hit = p.dial.find_obj(e)
                if (hit)
                    return hit
            }
        }
        return null
    }
}

function createWorld(def, gravity, for_sim) 
{
    const w = new B2World()
    w.obj = new b2.World(new b2.Vec2(gravity[0], gravity[1]))
    if (for_sim)  // don't want to register if we're just creating it for drawing since that would make the dials disapper
        add_current_world(w) // for call_change on on_init to work
    let index_gen = 0

    for(let body of def.bodies)
        body.index = null

    for(let body of def.bodies) {
        if (body.index !== null) // can happen if the same body was added more than once through multiple paths
            continue // don't allow it to participate more than once since that complicates stuff
        body.index  = index_gen++ // this is the index of the new B2Body in w.bodies, for reference by joints
        const mb = new B2BodyDec(body.cnode_id) // don't want to change the input one
        w.bodies.push(mb)
        w.cnode_to_obj[body.cnode_id] = mb
        mb.def = body.def
        mb.obj = w.obj.CreateBody(mb.def)
        for(let fixt of body.fixtures) {
            const mf = new B2FixtureDec()
            mb.fixtures.push(mf)
            mf.def = fixt.def
            mf.obj = mb.obj.CreateFixture(mf.def)      
            w.cnode_to_obj[fixt.cnode_id] = mf              
        }

        for(let pp of body.on_init_params)
            pp.call_change() // set config that needs the bodies 
    }

    for(let joint of def.joints) {
        dassert(joint.body_refA.index !== null && joint.body_refB.index !== null, "bodies not in world?") // sanity
        const mj = new B2JointDec(joint.cnode_id)
        w.cnode_to_obj[joint.cnode_id] = mj
        mj.def = joint.def
        mj.body_refA = w.bodies[joint.body_refA.index]
        mj.body_refB = w.bodies[joint.body_refB.index]
        joint.init_call(mj.body_refA.obj, mj.body_refB.obj)
        mj.obj = w.obj.CreateJoint(mj.def)
        // bodies of this world stay referenced by this joint in the input world but that doesn't really matter since if it gets to
        // another world it will get reinited here
    }

    return w
}

// merge several bodies definition to one scene
class NodeB2Merge extends NodeCls
{
    static name() { return "Physics Merge" }
    constructor(node) {
        super(node)

        this.in_defs = new InTerminalMulti(node, "b2_in_defs")
        this.out = new OutTerminal(node, "b2_defs")
    }

    run() {
        const in_defs = this.in_defs.get_input_consts()

        const udef = new B2Def();
        const body_ids = new Set()
        for(let def of in_defs) {
            assert(def !== null, this, "empty input")
            for(let b of def.bodies)  { // the same body can arrive multiple times from different joints
                if (body_ids.has(b.cnode_id))
                    continue
                udef.add_body(b)
                body_ids.add(b.cnode_id)
            }
            udef.add_joint(...def.joints)
        }
        this.out.set(udef)
    }
}

// for online updates
// this gets set and reset every draw with the currently drawn worlds, also on createWorld
var g_current_worlds = new Set()  
function phy_reset_current_worlds() {
    g_current_worlds.length = 0
}
function add_current_world(w) {
    g_current_worlds.add(w)
}
function has_current_world() {
    g_current_worlds.length > 0
}
function first_current_world() {
    g_current_worlds.values().next().value
}


class NodeB2Sim extends NodeCls
{
    static name() { return "Physics Simulator" }
    constructor(node) {
        super(node)

        // returns the same world object it got
        this.in = new InTerminal(node, "b2_in") // defs or world from prev frame
        this.out = new OutTerminal(node, "b2_world")

        this.gravity = new ParamVec2(node, "Gravity", 0, 9.8)

    }

    run() {
        const inobj = this.in.get_const()
        assert(inobj !== null, this, "no input")
        let w = inobj
        if (inobj.constructor === B2Def) // first frame
            w = createWorld(inobj, this.gravity.get_value(), true)
        else
            assert(inobj.constructor === B2World, this, "input not a defs or world")

        const timeStep = 1.0 / 60.0
        const velocityIterations = 6
        const positionIterations = 2
        w.obj.Step(timeStep, velocityIterations, positionIterations)
        
        this.out.set(w)
    }
}


// extract the transform relative to a given body in a given world and set it to a given object
class NodeExtractTransform extends NodeVarCls
{
    static name() { return "Extract Transform" }
    constructor(node) {
        super(node)
        this.in_world = new InTerminal(node, "in_world")
        this.in_body = new InTerminal(node, "in_body")

        // relative to the center of in_body
        this.offset = new ParamVec2(node, "Offset", 0, 0)
        this.offset.dial = new PointDial((dx,dy)=>{ this.offset.increment(vec2.fromValues(dx, dy)) })
        this.name = new ParamStr(node, "Name", "trans")

        this.last_tmat = null
    }
    run() {
        const in_body = this.in_body.get_const()
        assert(in_body !== null, this, "missing in_body")
        assert(in_body.constructor === B2Def && in_body.bodies.length === 1, this, "in_body should be a single body definition")
        const in_world = this.in_world.get_const()
        assert(in_world !== null, this, "missing in_world")
        assert(in_world.constructor === B2World || in_world.constructor === B2Def, this, "in_world needs to be a B2World, it is " + in_world.constructor.name)

        const body_def = in_body.bodies[0]
        /*const def_m = mat3.create()
        mat3.translate(def_m, def_m, vec2.fromValues(body_def.def.position.x, body_def.def.position.y))
        mat3.rotate(def_m, def_m, body_def.def.angle)
        mat3.invert(def_m, def_m)
        
        vec2.transformMat3(offset, offset, def_m) // turns it to relative to definition*/
        const offset = this.offset.get_value()

        const body = in_world.cnode_to_obj[body_def.cnode_id]
        assert(body !== undefined, this, "Can't find body " + body_def.cnode_id)
        
        const pos = body.getPos()
        const angle = body.getAngle()
        const m = mat3.create()
        mat3.translate(m, m, vec2.fromValues(pos.x , pos.y ))
        mat3.rotate(m, m, angle)
        this.last_tmat = mat3.create()
        mat3.copy(this.last_tmat, m)
        mat3.translate(m, m, offset) // not sure why this is the right order

        this.out_single_var(this.name.get_value(), TYPE_MAT3, m)
    }

    draw_selection(m) {
        this.offset.dial.draw(this.offset.x, this.offset.y, this.last_tmat, m)
    }
    image_find_obj(e) {
        return this.offset.dial.find_obj(e)
    }
}


class NodePen extends NodeCls
{
    static name() { return "Pen" }
    constructor(node) {
        super(node)

        node.set_state_evaluators({"index":  (m,s)=>{ return new ObjSingleEvaluator(m,s) }})

        this.in_obj = new InTerminal(node, "in_obj")
        this.out_obj = new OutTerminal(node, "out_obj")

        this.prop_store = new ParamObjStore(node, "<obj-store>", {gen_id:1, ids_lst:[]}, ()=>{
             this.prop_prms.length = 0
            const lst_copy = [...this.prop_store.v.ids_lst]
            this.prop_store.v.ids_lst.length = 0 // going to repopulate it
            for(let id of lst_copy)
                this.add_property(node, id)
            this.props_group.update_elems()
        })

        this.steps = new ParamInt(node, "Steps", 1)
        this.enable = new ParamBool(node, "Enable", true, null, { expr_visible: true })
        this.pos = new ParamVec2(node, "Position", 0, 0, { show_code: true })
        this.min_dist = new ParamFloat(node, "Min Distance", 0.05)

        this.first_sep = new ParamSeparator(node, "first_sep", "param_sep_line")

        this.props_group = new ParamGroup(node, "vars_params")
        this.prop_prms = [] // list of objects that contain the paramters of each prop

        this.add_prm_btn = new ParamButton(node, "[+]", ()=>{
            this.add_property(node, null)
            this.props_group.update_elems()
        }, ["param_btn", "param_var_add_btn"])

        this.prev_pos = null
    }

    // similar to add_variable in NodeVariable
    add_property(node, id) 
    {
        if (id === null)
            id = this.prop_store.v.gen_id++
        const prefix = "p" + id + "_"
        const p = { id:id }
        this.prop_store.v.ids_lst.push(id)
        this.prop_prms.push(p)
        
        p.p_group = new ParamGroup(node, prefix + "group")
        p.p_group.set_group(this.props_group)

        p.type = new ParamSelect(node, ["Type", prefix], 0, ["Float", "Float2", "Color"], (sel_idx)=>{
            p.expr_float.set_visible(sel_idx === 0)
            p.expr_vec2.set_visible(sel_idx === 1)
            p.expr_color.set_visible(sel_idx === 2)            
        })

        p.bind_to = new ParamSelect(node, ["Bind To", prefix], 0, [["Vertex", "vtx_"], ["Lines", "line_"]])
        p.bind_to.share_line_elem_from(p.type)

        p.remove_btn = new ParamButton(node, ["[-]", prefix], ()=>{
            arr_remove_is(this.prop_prms, p)
            arr_remove_eq(this.prop_store.v.ids_lst, p.id)
            for(let pp of p.params)
                node.remove_param(pp)
            this.props_group.update_elems()
            this.props_group.pset_dirty(true) // node doesn't get updated without this
        }, ["param_btn", "param_var_rm_btn"]) 
        p.remove_btn.share_line_elem_from(p.type)

        p.name = new ParamStr(node, ["Name", prefix], "width")
        // TBD check name starts with vtx_, check duplicate name

        p.expr_float = new ParamFloat(node, ["Float", prefix], 1.0, {show_code:true})
        p.expr_vec2 = new ParamVec2(node, ["Float2", prefix], 0, 0, {show_code:true})
        p.expr_color = new ParamColor(node, ["Color", prefix], "#cccccc", {show_code:true})
        p.sep = new ParamSeparator(node, prefix + "sep", "param_sep_line")

        p.params = [p.p_group, p.type, p.bind_to, p.name, p.expr_float, p.expr_vec2, p.expr_color, p.sep, p.remove_btn]

        for(let pp of p.params) {
            if (pp === p.p_group)
                continue // don't want to set the group to the group of this var
            pp.set_group(p.p_group)
            pp.call_change()            
        }
        return p
    }

    add_vtx(in_obj, pos) {

    }

    run() {
        const in_obj = this.in_obj.get_mutable()
        assert(in_obj !== null, this, "Missing input")
        assert(in_obj.add_vertex !== undefined, this, "Expected a geometry object")
        if (!this.enable.get_value()) {
            // useful for skipping some frames at the beginning
            this.out_obj.set(in_obj) // just pass through
            return
        }

        const steps = this.steps.get_value()

        const index_wrap = [0]

        const pos_need_index = this.pos.need_input_evaler("index")
        if (pos_need_index !== null)            
            pos_need_index.dyn_set_obj(index_wrap)

        // populate active params
        const active_params = {} // map name to Param
        for(let p of this.prop_prms) {
            let ap = null
            switch (p.type.sel_idx) {
            case 0: ap = p.expr_float; break;
            case 1: ap = p.expr_vec2; break;
            case 2: ap = p.expr_color; break;
            default: assert(false, this, "unexpected type")
            }
            const name = p.bind_to.get_sel_val() + p.name.get_value();
            active_params[name] = ap
            const prop_need_index = ap.need_input_evaler("index")
            if (prop_need_index !== null)
                prop_need_index.dyn_set_obj(index_wrap)
        }

        const prop_vals = {}
        this.prev_pos = in_obj.get_last_vertex()

        try {
            // add vertices with properties
            for(let i = 0; i < steps; ++i) {
                index_wrap[0] = i
                const pos = this.pos.dyn_eval()

                if (this.prev_pos !== null) { // TBD param to disable this
                    const min_dist = this.min_dist.get_value()
                    const d = vec2.distance(this.prev_pos, pos)
                    if (d < min_dist)
                        continue
                }
                this.prev_pos = pos

                for(let pname in active_params) {
                    prop_vals[pname] = active_params[pname].dyn_eval()
                }

                try {
                    in_obj.add_vertex(pos, prop_vals);
                } catch(e) {
                    assert(false, this, e.message)
                }
            }
        }
        catch(e) { // dyn_eval may fail
            assert(false, this, e.message)
        }

        this.out_obj.set(in_obj)
    }
}


// from https://github.com/flyover/box2d.ts/blob/master/testbed/draw.ts
class CanvasDebugDraw extends b2.Draw 
{
    constructor(ctx) {
      super(ctx);
      this.ctx = ctx
      this.col_from_shape = false
      this.last_shape_color = null
      this.col_template = false
    }

    set_color_from_shape(v) {
        this.col_from_shape = v
    }
    set_color_template(v) {
        this.col_template = v
    }

    NextShape(ud) {
        this.last_shape_color = color_from_uid(ud.node_id)
    }
  
    PushTransform(xf) {
      const ctx = this.ctx
      if (ctx) {
        ctx.save();
        ctx.translate(xf.p.x, xf.p.y);
        ctx.rotate(xf.q.GetAngle());
      }
    }
  
    PopTransform(xf) {
      const ctx = this.ctx
      if (ctx) {
        ctx.restore();
      }
    }

    resolve_color(color, alpha) {
        if (this.col_from_shape) {
            if (this.last_shape_color === null)
                return "rgba(0,0,0,0)"
            return this.last_shape_color
        }
        if (alpha === null)
            alpha = color.a
        if (this.col_template)
            return "rgba(" + TEMPLATE_LINE_COLOR_V[0] + "," + TEMPLATE_LINE_COLOR_V[1] + "," + TEMPLATE_LINE_COLOR_V[2] + "," + alpha + ")"
        return color.MakeStyleString(alpha)
    }
  
    DrawPolygon(vertices, vertexCount, color) {
      const ctx = this.ctx
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(vertices[0].x, vertices[0].y);
        for (let i = 1; i < vertexCount; i++) {
          ctx.lineTo(vertices[i].x, vertices[i].y);
        }
        ctx.closePath();
        ctx.strokeStyle = this.resolve_color(color, 1);
        ctx.stroke();
      }
    }
  
    DrawSolidPolygon(vertices, vertexCount, color) {
      const ctx = this.ctx
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(vertices[0].x, vertices[0].y);
        for (let i = 1; i < vertexCount; i++) {
          ctx.lineTo(vertices[i].x, vertices[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = this.resolve_color(color, 0.5);
        ctx.fill();
        ctx.strokeStyle = this.resolve_color(color, 1);
        ctx.stroke();
      }
    }
  
    DrawCircle(center, radius, color) {
      const ctx = this.ctx
      if (ctx) {
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, 0, b2.pi * 2, true);
        ctx.strokeStyle = this.resolve_color(color, 1);
        ctx.stroke();
      }
    }
  
    DrawSolidCircle(center, radius, axis, color) {
      const ctx = this.ctx
      if (radius < 0)
        return
      if (ctx) {
        const cx = center.x;
        const cy = center.y;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, b2.pi * 2, true);
        ctx.moveTo(cx, cy);
        ctx.lineTo((cx + axis.x * radius), (cy + axis.y * radius));
        ctx.fillStyle = this.resolve_color(color, 0.5);
        ctx.fill();
        ctx.strokeStyle = this.resolve_color(color, 1);
        ctx.stroke();
      }
    }
  
    // #if B2_ENABLE_PARTICLE
    DrawParticles(centers, radius, colors, count) {
      const ctx = this.ctx
      if (ctx) {
        if (colors !== null) {
          for (let i = 0; i < count; ++i) {
            const center = centers[i];
            const color = colors[i];
            ctx.fillStyle = color.MakeStyleString();
            // ctx.fillRect(center.x - radius, center.y - radius, 2 * radius, 2 * radius);
            ctx.beginPath(); ctx.arc(center.x, center.y, radius, 0, b2.pi * 2, true); ctx.fill();
          }
        } else {
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          // ctx.beginPath();
          for (let i = 0; i < count; ++i) {
            const center = centers[i];
            // ctx.rect(center.x - radius, center.y - radius, 2 * radius, 2 * radius);
            ctx.beginPath(); ctx.arc(center.x, center.y, radius, 0, b2.pi * 2, true); ctx.fill();
          }
          // ctx.fill();
        }
      }
    }
    // #endif
  
    DrawSegment(p1, p2, color) {
      const ctx = this.ctx
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = this.resolve_color(color, 1);
        ctx.stroke();
      }
    }
  
    DrawTransform(xf) {
      const ctx = this.ctx
      if (ctx) {
        this.PushTransform(xf);
  
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(1, 0);
        ctx.strokeStyle = b2.Color.RED.MakeStyleString(1);
        ctx.stroke();
  
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 1);
        ctx.strokeStyle = b2.Color.GREEN.MakeStyleString(1);
        ctx.stroke();
  
        this.PopTransform(xf);
      }
    }
  
    DrawPoint(p, size, color) {
      const ctx = this.ctx
      if (ctx) {
        ctx.fillStyle = this.resolve_color(color, null);
        size /= image_view.viewport_zoom;
        //size /= g_camera.m_extent;
        const hsize = size / 2;
        ctx.fillRect(p.x - hsize, p.y - hsize, size, size);
      }
    }
  
    DrawAABB(aabb, color) {
      const ctx = this.ctx
      if (ctx) {
        ctx.strokeStyle = this.resolve_color(color, null);
        const x = aabb.lowerBound.x;
        const y = aabb.lowerBound.y;
        const w = aabb.upperBound.x - aabb.lowerBound.x;
        const h = aabb.upperBound.y - aabb.lowerBound.y;
        ctx.strokeRect(x, y, w, h);
      }
    }
  }


"use strict"


class NodeHTTPSend extends NodeCls
{
    static name() { return "HTTP Send" }
    constructor(node) {
        super(node)

        this.in = new InTerminal(node, "input")
        this.out = new OutTerminal(node, "output")

        this.attr_name = new ParamStr(node, "Attribute", "face_color")
        this.uri = new ParamStr(node, "URI", "/post_data")
    }

    run() {
        const obj = this.in.get_const()
        assert(obj.arrs !== undefined, this, "Object with no arrays")
        const arr = obj.arrs[this.attr_name.v]
        assert(arr !== undefined, this, "Object does not have attribute " + this.attr_name.v)

        const req = new XMLHttpRequest();
        req.open("POST", this.uri.v, true);
        req.onload = (event) => {
            //console.log("sent")
        }
        
        try {
            req.send(arr)
        }
        catch(e) {
            log.error("failed send " + this.uri.v)
        }

        this.out.set(obj)
    }
}
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3, mat2 = glMatrix.mat2, glm = glMatrix.glMatrix, vec4 = glMatrix.vec4, vec3 = glMatrix.vec3
glm.setMatrixArrayType(Float64Array)

var ctx_nodes, ctx_img
var ctx_nd_shadow // the canvas_nd_shadow is auxilary for the canvas_nodes for identifying objects
var ctx_img_shadow // canvas_img_shadow auxilary for canvas_image

const PRELOAD_IMAGES = [ "img/check_checked.png", "img/check_int.png", "img/check_none.png",
                         "img/red_ex.png", "img/gray_ex.png",   
                        ]
var preloaded = []

function preload_images() {
    for(var name of PRELOAD_IMAGES) {
        let img = new Image()
        img.src = name
        preloaded.push(img)
    }
}

function show_overflow() { // for debugging
    body.style.overflow = "initial"
    main_view.style.overflow = "initial"
    canvas_img_shadow.style.display = "initial"
}

var scratch_canvas = null // canvas for temporary jobs
var ctx_scratch = null
function ensure_scratch_canvas() {
    if (scratch_canvas !== null)
        return
    scratch_canvas = addTextChild(main_view, "<canvas id='scratch_canvas'></canvas>")
    ctx_scratch = scratch_canvas.getContext('2d')
}

// this causes flicker when displaying an object that has pre_draw() since the canvas resize causes it to clear and then it's only 
// drawn in the next micro-task
function _resize_img_panel(w, h, x, y) {
    if (w !== null) {
        image_panel.style.width = w + "px"
        canvas_image.width = w
    }
    if (h !== null) {
        canvas_image.height = h // Assumes image canvas takes the whole height
    }

    image_view.resize_redraw()
}
function _resize_edit_panel(w, h, x, y) {
    if (w !== null) {
        edit_panel.style.width = w + "px"
        canvas_nodes.width = w
        canvas_nd_shadow.width = w
    }
    edit_panel.style.top = x + "px"
    edit_panel.style.left = y + "px"

    draw_nodes()    
}
function _resize_edit_param(w, h) {
    if (h !== null)
        edit_params.style.height = h + 'px';
}
function _resize_nodes_panel(w, h) {
    if (h !== null) {
        edit_nodes.style.height = h + "px"
        canvas_nodes.height = h
        canvas_nd_shadow.height = h
    }
    draw_nodes()              
}

var main_view = null
var hover_box = null
var image_panel = null
var canvas_image = null, canvas_webgl = null, canvas_img_shadow = null
var image_splitter = null
var edit_panel = null
var edit_params = null
var div_params_list = null // recreated when readding params
var div_display_params_cont = null // for disp_params
var edit_splitter = null
var edit_nodes = null
var canvas_nodes = null, canvas_nd_shadow = null

function create_global_elems() {
    main_view = add_div_id(body, null, "main_view")
      image_panel = add_div_id(main_view, null, "image_panel")
        canvas_image = add_elem_id(image_panel, "canvas", null, "canvas_image")
        canvas_webgl = add_elem_id(image_panel, "canvas", null, "canvas_webgl")
        canvas_img_shadow = add_elem_id(image_panel, "canvas", null, "canvas_img_shadow")
      image_splitter = add_div_id(main_view, "splitter", "image_splitter")
      edit_panel = add_div_id(main_view, null, "edit_panel")
        edit_params = add_div_id(edit_panel, null, "edit_params")
          div_params_list = add_div_id(edit_params, null, "div_params_list")
          div_display_params_cont = add_div(edit_params, "div_display_params_cont")
        edit_splitter = add_div_id(edit_panel, "splitter", "edit_splitter")
        edit_nodes = add_div(edit_panel)
          canvas_nodes = add_elem_id(edit_nodes, 'canvas', null, "canvas_nodes")
    canvas_nd_shadow = add_elem_id(body, 'canvas', null, "canvas_nd_shadow")
    hover_box = add_div(main_view, "hover_box")
}

function page_onload()
{
    create_global_elems()
    set_loading(true)
    preload_images()
    nodes_view = new NodesView(canvas_nodes)
    image_view = new ImageView()
    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_nd_shadow = canvas_nd_shadow.getContext('2d', {alpha: false})
    ctx_img = canvas_image.getContext('2d')
    ctx_img_shadow = canvas_img_shadow.getContext('2d')
    paper.project = new paper.Project(null)

    ctx_img.makePath2D = function() { return new Path2D } // allow mocking for SVG save
    ctx_img.need_antialias_gap_fill = true

    clear_program()  // for the case of completely empty state
    
    try {
        load_state()
    }
    catch(e) {
        console.error("failed load " + e)
    }
    
    instrument_canvas_resize(canvas_webgl)
    setup_vert_splitter(main_view, image_splitter, _resize_img_panel, _resize_edit_panel)
    setup_horz_splitter(edit_panel, edit_splitter, _resize_edit_param, _resize_nodes_panel)
    create_top_menu(main_view)
    create_anim_bar()
    
    panel_mouse_control(nodes_view, canvas_nodes, "_nodes")
    panel_mouse_control(image_view, canvas_image, "_image")
    panel_mouse_wheel(image_view, canvas_image)
    panel_mouse_wheel(nodes_view, canvas_nodes)
    setup_key_bindings()

    image_view.resize_redraw()
    
    //add_node(-50, -50, null, NodeGeomPrimitive)
    //add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    calc_img_viewport()

    // manually draw since we're not wrapped in a handler that will call it
    //call_frame_draw(true, true)
    anim_frame()
    clear_draw_req()

    set_loading(false)
}



class Program {
    constructor() {
        this.nodes = [] // nodes in an array for iteration
        this.obj_map = {}  // node-id (obj-id) to node 
        this.lines = []
        this.display_node = null
        // map node cls name to the next index a node of this class is going to get
        this.names_indices = {}
        this.next_obj_id = 1
        this.next_eph_obj_id = 1
        this.glob_var_nodes = [] // runs before the display node
        this.tdisp_nodes = [] // template display
        this.input_nodes = []
        this.nodes_decor = [] // non-functional decorations in the nodes view

        this.anim_flow = new AnimFlow()
    }

    // for objects who's id is serialized (node, line)
    // counter is also saved with the program
    alloc_graphic_obj_id() {
        return this.next_obj_id++ 
    }
    // for objects who's id is not serialized (terminals)
    // counter not saved, different namespace but all go into the same obj_map
    alloc_ephemeral_obj_id(t) {
        const id = "e" + this.next_eph_obj_id++
        this.obj_map[id] = t
        return id
    }

    add_node(x, y, name, cls, id) 
    {
        if (name === null) {
            if (this.names_indices[cls.name()] === undefined)
                this.names_indices[cls.name()] = 1
            else
                this.names_indices[cls.name()]++
            name = cls.name().toLowerCase().replace(/[\s-]/g,'_') + "_" + this.names_indices[cls.name()]
        }
        if (id === null || id === undefined) {
            id = this.alloc_graphic_obj_id()
        }
        else {
            console.assert(this.obj_map[id] === undefined, "node-id already exists")
        }
        let node = new Node(x, y, name, cls, id, this)
        this.obj_map[node.id] = node
        this.nodes.push(node)

        for(let t of node.terminals) {
            t.tuid = this.alloc_ephemeral_obj_id(t) // not saving these ids anywhere because they're only for display of hover, not referenced by something else
        }
        if (this.nodes.length === 1 && node.nkind === KIND_OBJ) // first node, display it (also happens in internal programs)
            this.set_display_node(node)

        return node
    }

    
    delete_node(node, redraw)
    {
        if (node.is_selected_inf !== null)
            node.unselect()
        if (this.display_node == node) 
            program.set_display_node(null)
        if (node.disp_template)
            program.set_template_node(node, false)
        if (node.receives_input)
            program.set_input_node(node, false)
        if (node.enable_active) {
            node.cls.toggle_enable_flag(false, false)
        }
        if (obj_inf_dlg !== null)
            obj_inf_dlg.node_deleted(node)
        if (node.destructor)
            node.destructor()
        arr_remove_is(this.nodes, node)
        delete this.obj_map[node.id];
        for(let t of node.terminals) {
            while(t.lines.length > 0)
                this.delete_line(t.lines[0], false)
            delete this.obj_map[t.tuid];
        }
        
        if (redraw) {
            draw_nodes()
            trigger_frame_draw(true)
        }
    }

    add_line(line, uid, redraw) {
        this.lines.push(line)
        if (uid === null || uid === undefined)
            uid = this.alloc_graphic_obj_id()
        line.uid = uid
        this.obj_map[uid] = line
        line.from_term.lines.push(line)
        line.to_term.lines.push(line)
        try {
            line.to_term.get_attachee().tdid_connect(line)  // telling the node into what terminal line was connected
        } catch(e) {}    
        line.to_term.tset_dirty(true) // need function so that it will work for multi in as well
        if (redraw)
            trigger_frame_draw(true)
    }


    delete_line(line, redraw) {
        try { // might do console.assert to check stuff, don't want it to mess with us
            line.to_term.get_attachee().tdoing_disconnect(line)
        } catch(e) {}
        arr_remove_is(line.from_term.lines, line)
        arr_remove_is(line.to_term.lines, line)
        line.to_term.clear()
        line.to_term.tset_dirty(true)
        arr_remove_is(this.lines, line)
        delete this.obj_map[line.uid]

        try { // might do console.assert to check stuff, don't want it to mess with us
            line.to_term.get_attachee().tdid_disconnect(line)
        } catch(e) {}

        if (redraw) {
            draw_nodes()
            trigger_frame_draw(true)
        }
    }

    delete_lines_of(term) {
        while(term.lines.length > 0)
            this.delete_line(term.lines[0], false)
    }


    set_display_node(node, do_draw=true) {
        if (node == this.display_node)
            return
        this.display_node = node
        if (do_draw)
            trigger_frame_draw(true)  // need to do run since the const output might have gotten changed
    }
    
    set_template_node(node, do_draw=true) {
        node.disp_template = !node.disp_template 
        if (node.disp_template)
            this.tdisp_nodes.push(node)
        else {
            arr_remove_is(program.tdisp_nodes, node)
        }
        if (do_draw)
            trigger_frame_draw(true)
    }

    set_glob_var_node(node, do_draw, to_value) {
        node.set_enable_active_dirty(to_value)
        if (node.enable_active) {
            this.glob_var_nodes.push(node)
        }
        else {
            arr_remove_is(program.glob_var_nodes, node)
        }
        if (do_draw)
            trigger_frame_draw(true)
    }

   
    set_input_node(node, do_draw=true) {
        node.receives_input = !node.receives_input
        if (node.receives_input)
            this.input_nodes.push(node)
        else {
            arr_remove_is(program.input_nodes, node)
        }
        if (do_draw)
            draw_nodes()
    }
    
    nodes_add_decor(obj, uid=null) {
        if (uid === null || uid === undefined)
            uid = this.alloc_graphic_obj_id()
        obj.uid = uid
        this.nodes_decor.push(obj)
        this.obj_map[obj.uid] = obj
    }
    delete_decor(obj) {
        arr_remove_is(this.nodes_decor, obj)
        delete this.obj_map[obj.uid];
        draw_nodes()
    }
}

var program = null


function clear_program() {
    nodes_unselect_all(false, false) // don't want to delete the image of the prog just cleared, it's nice that it stays
    program = new Program()
}


function assert(cond, node_cls, msg) {
    console.assert(node_cls.__proto__ instanceof NodeCls, "Assert with the node.cls")
    console.assert(node_cls !== undefined && msg !== undefined)
    if (!cond)
        throw { message: msg, node_cls:node_cls }
}

// thrown in draw (and anywhere alse that's not directly in a node or expression)
function dassert(cond, msg) {
    if (!cond) {
        throw new Error(msg)
    }
}

function is_obj_p(p) {
    return p.kind === KIND_OBJ || p.kind === KIND_VARS
}
function is_obj_n(p) {
    return p.nkind === KIND_OBJ || p.nkind === KIND_VARS
}

function calc_img_viewport() {
    let t_viewport = mat3.create()
    image_view.t_viewport = t_viewport
    let f
    if (canvas_image.width > canvas_image.height) {
        f = canvas_image.height*0.5  // half since I want the viewport to be size 2x2
        image_view.margin_x = (canvas_image.width - canvas_image.height) / (canvas_image.height )
        image_view.margin_y = 0
    }
    else {
        f = canvas_image.width*0.5
        image_view.margin_y = (canvas_image.height - canvas_image.width) / (canvas_image.width )
        image_view.margin_x = 0
    }
    image_view.viewport_zoom = f*image_view.zoom // used for measuring radius of hit test in pixels
    mat3.scale(t_viewport, t_viewport, vec2.fromValues(image_view.viewport_zoom, image_view.viewport_zoom))
    mat3.translate(t_viewport, t_viewport, vec2.fromValues(1 + image_view.margin_x + image_view.pan_x / f, 1 + image_view.margin_y + image_view.pan_y / f))
    t_viewport[6] = Math.round(t_viewport[6]) // need to make sure the translation is whole int so that image display would not be interpolated
    t_viewport[7] = Math.round(t_viewport[7])

    image_view.t_inv_viewport = mat3.create()
    mat3.invert(image_view.t_inv_viewport, t_viewport)

    dirty_viewport_dependents()
}

function dirty_viewport_dependents() {
    for(let n of program.nodes) {
        n.cls.dirty_viewport()
    }
}


function collect_line(line) {
    const obj = line.from_term.get_ctrl_block()
    assert(obj !== null, line.from_term.owner.cls, "No output from node " + line.from_term.owner.name)
    line.to_term.intr_set(obj, line.from_term.get_cur_uver())
}

function collect_inputs(n)
{
    for(let in_t of n.inputs) {
        if (!is_obj_p(in_t))
            continue
        in_t.collect_terminal()
    }
}

function isPromise(x) {
    return Boolean(x && typeof x.then === 'function')
}

function lines_list_subtract(total, picked) {
    const ret = []
    for(let t of total) {
        let found = false
        for(let p of picked) {
            if (t === p) {
                found = true
                break
            }
        }
        if (!found)
            ret.push(t)
    }
    return ret
}

// returns true if the argument node was dirty of out of its parents is was dirty
// picked = false if this is an un-picked branch (which still needs to resolve variables)
async function run_nodes_tree(n, picked) 
{
    //console.assert(n._node_dirty !== null)
    if (n._last_visited_fv == frame_ver)
        return
    n._last_visited_fv = frame_ver

    const node_picking_lines = n.cls.is_picking_lines()
    let parent_dirty = false

    // all inputs, including var
    for(let inp_t of n.inputs) {  
        if (!is_obj_p(inp_t))
            continue // flow nodes are not supposed to be run recursively (relevant when resolving vars for a flow node)
        // all lines going into an input
        let run_lines = inp_t.lines, not_picked_lines = null
        if (node_picking_lines && inp_t.kind === KIND_OBJ) {// var terminal doesn't participate in picking (always runs)
            run_lines = n.cls.pick_lines(inp_t)
            not_picked_lines = lines_list_subtract(inp_t.lines, run_lines)
        }
        
        for(let line of run_lines) {
            parent_dirty |= await run_nodes_tree(line.from_term.owner, picked)
        }
        if (not_picked_lines !== null) {
            // on unpicked branches, we still want to resolve variables so that online params would work (with variables)
            for(let line of not_picked_lines) {
                await run_nodes_tree(line.from_term.owner, false)
            }
        }
    }

    // resolve globals like frame_num that can affect dirtiness
    n.cls.nresolve_variables(true) 

    if (!picked)
        return false // non-picked branch should not set dirtiness

    const this_dirty = n.has_anything_dirty(parent_dirty) || (is_obj_n(n) && !n.has_cached_output())

    // if we're on a not-picked branch, don't run, the output is not going to be used
    if (this_dirty) {

        // clear outputs of what's just going to run to make sure it updated its output
        // otherwise it can have something there from a previous iteration (which will stay there in case of an error)
        // shouldn't be before running the inputs since that causes error in animation loops
        if (n.cls.should_clear_out_before_run()) // disabled for NodeChangeFilter so that it won't create new versions when there's no change
            for(let out_t of n.outputs) {
                out_t.clear()
            }


        if (!node_picking_lines) // a node that's picking lines, also does its own collect
            collect_inputs(n)
        else
            n.cls.vars_in.collect_terminal() // need to do this here never-the-less so that resolve would work, this is ok since pick-one node isn't interested in picking the variable terminal
        n.cls.nresolve_variables(false)
    
        if (!n.check_params_errors())
            throw { message: "Parameter error", node_cls:n.cls }  // abort if there are any errors

        const r = n.cls.run()
        if (isPromise(r))
            await r

        n.clear_dirty() // it finished running so it didn't throw and exception
    }

    return this_dirty
}

function clear_inputs_errors(prog) {
    let had_errors = false
    for(let n of prog.nodes) {
        // but we need to clear them all so there won't be leftovers from last run
     //   for(let t of n.inputs)  disabled, see progress_io
     //       t.clear() 
        // also clear errors
        had_errors |= (n.cls.get_error() !== null)
        n.cls.clear_error()
    }
    if (had_errors)
        draw_nodes() // show error in node view
}

function do_clear_all(prog) {
    for(let n of prog.nodes) {
        // set the indicator that the node needs to run
        n._node_dirty = true
        n.reeval_all_exprs() // if there are parsing error, trigger them
        // but we need to clear them all so there won't be leftovers from last run
        for(let t of n.outputs)
            t.clear() 
    }
}



// happens when calling run(), clears every iteration
function set_error(node_cls, msg) {
    if (node_cls.get_error() === null)
        node_cls.nset_error({message:msg})
    draw_nodes()
}

var draw_request = {draw:false, do_run:false, clear_all:false}
function trigger_frame_draw(do_run, clear_all=false)  {
    draw_request.draw = true
    draw_request.do_run |= do_run
    draw_request.clear_all |= clear_all
}
function clear_draw_req() {
    draw_request.draw = false
    draw_request.do_run = false
    draw_request.clear_all = false
}

function eventWrapper(func, event_name, do_save=true) {
    return function() {
        //console.log("-event ", event_name)
        // clear any event that happened in async microtasks triggered by the previous draw and before this was called again
        // we want to just get the events that happen during func()
        clear_draw_req() 
        let r
        try {
            r = func.apply(null, arguments)
        }
        catch(e) {
            if (e.node_cls === undefined) {
                throw e
            }
            clear_draw_req() // don't want the next iteration here to draw
            set_error(e.node_cls, e.message)
            console.error(e)
            return
        }
        
        // if animation is running calling this would interfere with the animation frame-count and animation state, so don't
        if (draw_request.draw && !g_anim.run) {
            if (do_save)  // automatic events like onload shouldn't save since they are not user interaction
                save_state()

            const do_run = draw_request.do_run, clear_all = draw_request.clear_all
            //console.log("-event-draw ", event_name, " do-run=", do_run, "  clear=", clear_all)
            clear_draw_req()
            
            call_frame_draw(do_run, clear_all)
            clear_draw_req() // in case any run triggered a frame again (happens with shaders that are generated in run()
        }
        return r;    
    }
}

const FLAG_DONT_SAVE = 1

function myAddEventListener(obj, event_name, func, flags=0) {
    const w = eventWrapper(func, event_name + "-" + obj, flags != FLAG_DONT_SAVE)
    obj.addEventListener(event_name, w)
    return w
}

function stop_propogation_on(event_name, ...elems) {
    for(let e of elems) {
        e.addEventListener(event_name, function(e) {
            e.stopPropagation()            
        })
    }
}


var in_draw = false


async function call_frame_draw(do_run, clear_all, done_callback=null) {  // callback for save PNG
    if (in_draw) {
        return null // avoid starting a call if the previous async call didn't finish yet (indicated several triggers from the same stack)
    }
    in_draw = true

    try {
        const ret = await do_frame_draw(do_run, clear_all)
        if (done_callback)
            done_callback(true)
        return ret
    }
    catch (err) {
        if (done_callback)
            done_callback(false)
        console.error(err)
        return null
    }
    finally {
        in_draw = false 
        //clear_draw_req()
    }
    
}

function handle_node_exception(e) {
    if (e.node_cls === undefined) {
        throw e // wasn't thrown from assert
    }
    set_error(e.node_cls, e.message)
    console.error(e)    
}

function get_display_object() { // for shadow select
    if (program.display_node === null)
        return null
    return program.display_node.outputs[0].get_const() 
}

var frame_ver = 1 // always ascending id of the frame, for modern dirty analysis


function get_nodes_to_run()
{
    const run_root_nodes = new Set()
    let disp_obj = null

    for(let gn of program.glob_var_nodes) // these need to be first so that global would be there for eval. Set is order preserving
        run_root_nodes.add(gn)
    if (program.display_node === null) { 
        show_display_params(null, null) // remove what's shown
    }
    else {
        run_root_nodes.add(program.display_node)
        disp_obj = program.display_node.outputs[0].get_const() // if there's no output object
    }

    for(let tn of program.tdisp_nodes) 
        run_root_nodes.add(tn)
    if (selected_nodes.length > 0)
        for(let sn of selected_nodes)
            if (sn.can_run_on_select)
                run_root_nodes.add(sn)
    return [run_root_nodes, disp_obj]
}

function clear_img_canvas() {
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)
}

// called whenever the display needs to be updated to reflect a change
async function do_frame_draw(do_run, clear_all) 
{
    fps_counter_update()
    canvas_webgl.reset_to_latest_max()

    // needs to be first so that variable nodes in the flow would have a chance to run first
    const anim_traits = await program.anim_flow.pget_anim_traits()

    let [run_root_nodes, disp_obj] = get_nodes_to_run()
        
    if (run_root_nodes.size > 0 && (do_run || disp_obj === null)) { // last-term: do_run will be false on select but if we don't have anything to display, we still need to run, do this only for the main display object and not for select or template
        if (clear_all) {
            try {
                do_clear_all(program)
            }
            catch(e) { // can happen if some peval failed
                console.error("Error in do_clear_all: " + e)
                return null
            }
        }
        clear_inputs_errors(program)
 
        let disp_node_error = false
        for(let node of run_root_nodes) {
            try {
                await run_nodes_tree(node, true)
            }
            catch(e) {
                handle_node_exception(e)
                if (node === program.display_node)
                    disp_node_error = true
            }
        }
        if (disp_node_error) // don't want to continue displaying something that came out of a node that had an error up in its chain
            disp_obj = null
        else if (program.display_node !== null)
            disp_obj = program.display_node.outputs[0].get_const() // in case it was null
    }


    if (!anim_traits.render) {
        ++frame_ver
        return anim_traits
    }

    // do this before obj draw so that if there are missing display params, they'll get a default value
    show_display_params(disp_obj, program.display_node) 

    if (program.display_node !== null && disp_obj === null) {
        set_error(program.display_node.cls, "No output generated")
    }

    // do async stuff before the actual draw so that draw can be synchronous
    if (disp_obj !== null) { // can get here if there are only template displays do need to do this check
        try {
            await disp_obj.pre_draw(image_view.t_viewport, program.display_node.display_values)
        } catch(ex) {
            if (program.display_node !== null)
                set_error(program.display_node.cls, ex.message)
        }
    }

    // all syncronouse from here on (don't want to clear the canvas and then leave for a promise, that would cause fliker)
    clear_img_canvas()
    phy_reset_current_worlds() // draw of the world re-adds only the active ones

    if (disp_obj !== null) {
        try {
            disp_obj.draw(image_view.t_viewport, program.display_node.display_values)
        } catch(e) {
            if (program.display_node !== null)
                set_error(program.display_node.cls, e.message)                    
        }
    }
    if (selected_nodes.length > 0) {
        for(let sn of selected_nodes) {
            try {
                sn.cls.draw_selection(image_view.t_viewport)
            } catch(e) {
                set_error(sn.cls, e.message)
            }
        }
    }
    // template displays
    for(let tn of program.tdisp_nodes) {
        const tdist_obj = tn.outputs[0].get_const()
        if (tdist_obj === null) {
            set_error(tn.cls, "No output generated")
            continue
        }
        try {
            tdist_obj.draw_template(image_view.t_viewport)
        } catch(e) {
            set_error(tn.cls, e.message)
        }                
    }    

    ++frame_ver
    return anim_traits
}

function get_output_term_of_kind(node, kind) {
    for(let tn of node.outputs)
        if (tn.kind == kind) 
            return tn
    return null
}

// traces where the animation flow is in the program
class AnimFlow
{
    constructor() {
      //  this.start_node = null
        this.current_node = null
        this.event_nodes = []

        this.default_anim_traits = new AnimTraits()
    }

   /* set_anim_node(node)
    {
        if (node !== null)
            node.enable_active = !node.enable_active 
        if (this.start_node === node)
            this.start_node = null
        else
            this.start_node = node
        this.reset_anim_flow()
    }*/

    toggle_event_node(node) 
    {
        node.enable_active = !node.enable_active 
        if (node.enable_active) {
            this.event_nodes.push(node)
        }
        else {
            arr_remove_is(this.event_nodes, node)
        }
    }


   /* reset_anim_flow()
    {
        this.current_node = this.start_node
    }*/

    async check_events() {
        for(let evn of this.event_nodes) {
            evn.cls.clear_flow_hijack()
            await run_nodes_tree(evn, true)
            const want = evn.cls.want_flow_hijack()
            if (want) {
                this.current_node = evn
                return true
            }
        }
        return false
    }

    async pget_anim_traits()
    {
        await this.check_events() // event can change current_node
        // if there's no events, we should, there can't be any active flow, so we should also be at the default traits
        if (this.current_node === null || this.event_nodes.length == 0) {
            return this.default_anim_traits
        }
        let t = null
        // loop until we find a node that doesn't forward to next
        do { 
            // anything connected to the vars_in? if so, need to run it
            if (this.current_node === null)
                t = this.default_anim_traits
            else {
                await run_nodes_tree(this.current_node, true)
                // by-design, this does not made to trigger more events since events are triggered just once in a frame
                // otherwise it would cause loops and it's not possible to know what got dirtied since frame_ver is not incremented.
                // frame_ver can't be incremented here since that would mess with variable dirty check
               // console.log("calling ", this.current_node.name)
                t = this.current_node.cls.get_anim_traits()
            }

            if (t.next) {
                const next_node = get_output_term_of_kind(this.current_node, KIND_FLOW_ANIM)
                if (next_node.lines.length === 0) // nothing to transfer to, go to default
                    this.current_node = null
                else {
                    const nx = next_node.lines[0].to_term.owner
                    if (nx !== this.current_node) {
                        this.current_node.cls.exiting()
                        this.current_node = nx
                        this.current_node.cls.entered()
                    }
                }
                //console.log("Flowed to ", this.current_node.name)
            }
            // TBD detect loop?
        } while(t.next)

        return t
    }
}

class Animation {
    constructor() {
        //this.frame_time = 0;
        this.run = false;  // running right now?
        this.pre_draw_handlers = []
        this.globals_vars_box = new VariablesObj()
        this.frame_num_box = new VarBox()
        this.frame_num_box.vbset(-1, TYPE_NUM)
        this.globals_vars_box.add("frame_num", this.frame_num_box)
        this.start_time = null
        this.frame_time = 0
        this.fixed_refs = [ this.globals_vars_box.make_ref("frame_num") ] // prevent these from releasing by taking a reference to them
    }
    rewind() {
        this.frame_num_box.vbset(-1, TYPE_NUM)
        const did_run = this.run
        this.run = false
       // program.anim_flow.reset_anim_flow()
        if (!did_run)
            window.requestAnimationFrame(anim_frame)
    }
    start() {
        this.run = true
        this.start_time = performance.now()
        window.requestAnimationFrame(anim_frame)
    }
    pause() {
        this.run = false
    }
    one_next() {
        this.run = false
        window.requestAnimationFrame(anim_frame)
    }

    set_frame_num(num) { //from UI
        if (this.run)
            return
        this.frame_num_box.vbset(num, TYPE_NUM)    
        window.requestAnimationFrame(anim_frame)
    }

    reg_pre_draw(func) {
        this.pre_draw_handlers.push(func)
    }
    notify_pre_draw() {
        for(let handler of this.pre_draw_handlers)  // update UI
            handler(g_anim.frame_num_box.v, this.frame_time, this.run)        
    }
}

var g_anim = new Animation()

async function anim_frame()
{
    let anim_traits = null
    let frames_at_once = 1, iter = 0

    while(iter < frames_at_once)
    {
        g_anim.frame_num_box.vbset(g_anim.frame_num_box.v + 1, TYPE_NUM)
        g_anim.notify_pre_draw() // show the number that we just set

        //g_anim.frame_time = performance.now() - g_anim.start_time
        anim_traits = await call_frame_draw(true, false, null)
        // ret can be null if we're already in a draw somewhere else
        if (anim_traits === null)
            anim_traits = g_anim.default_anim_traits

        ++iter
        if (anim_traits.frame_rate === FRAME_RATE_MAX && g_anim.run)
            frames_at_once = anim_traits.blocking_frames
        else 
            break
    }

    if (!g_anim.run) 
        return

    if (anim_traits.frame_rate === FRAME_RATE_NORMAL)
        window.requestAnimationFrame(anim_frame)
    else if (anim_traits.frame_rate === FRAME_RATE_MAX)
        //window.setTimeout(anim_frame, 0)
        setZeroTimeout()
    else
        dassert(false, "unexpected frame_rate")
}


const messageName = 424242;
function setZeroTimeout() {
    window.postMessage(messageName, "*");
}
function handleMessage(event) {
    if (event.source == window && event.data == messageName) {
        event.stopPropagation();
        anim_frame()
    }
}
window.addEventListener("message", handleMessage, true);



const nodes_classes = [
    { group_name: "Geometry", nodes: [
        NodeGeomPrimitive, 
        NodeManualGeom,
        NodeGeomDivide,
        NodeSetAttr, 
        NodeConstAttr,
        NodeGeomMerge,
        NodeGeomSplit,
        NodeGeomCopy,
        NodeRandomPoints,
        NodeScatter2,
        NodeTriangulate,
        NodeVoronoi,
        NodeRoundCorners,
        NodeBoolOp,
        NodeOffsetPath,
        NodePen,
    ]},
    { group_name: "Image", nodes: [
        NodeLoadImage,
        NodeCreateFrameBuffer,
        NodeShader,
        NodePointGradFill,
        NodeFuncFill,
        NodeImageProc,
        NodeGradient,
        NodePixelsToVertices,
        NodeSampleColor
    ]},
    { group_name: "Distance Field", nodes: [
        NodeDFPrimitive,
        NodeDFFromGeom,
        NodeDFCombine,
        NodeDFCopy,
        NodeDFImage,
        NodeMarchingSquares
    ]},
    { group_name: "Flow", nodes: [
        NodePickOne,
        NodeChangeFilter,
      //  AnimStartFlow,
        AnimEventFlow,
        AnimSpan,
        FlowVariable
    ]},
    { group_name: "Physics", nodes: [
        NodeB2Body,
        NodeB2Joint,
        NodeB2Merge,
        NodeB2Sim,
        NodeExtractTransform,
    ]},
    { group_name: "Variables", nodes: [
        NodeVariable,
        NodeVarStep
    ]},
    { group_name: "Groups", nodes: [
        NodeGroupObjects,
        NodeGroupSelect
    ]},
    { group_name: "I/O", nodes: [
        NodeHTTPSend
    ]},
    NodeTransform,
]
var nodes_classes_by_name = {}
for(let c of nodes_classes) {
    if (c.group_name === undefined)
        nodes_classes_by_name[c.name()] = c
    else
        for(let nc of c.nodes)
            nodes_classes_by_name[nc.name()] = nc
}
// old names from saves
nodes_classes_by_name["Manual_Points"] = NodeManualGeom
nodes_classes_by_name["Shrink Faces"] = NodeOffsetPath
nodes_classes_by_name["Geom_Primitive"] = NodeGeomPrimitive
nodes_classes_by_name["Scatter"] = NodeRandomPoints
nodes_classes_by_name["Scatter2"] = NodeScatter2
nodes_classes_by_name["Distance Field Primitive"] = NodeDFPrimitive
nodes_classes_by_name["Distance Field Combine"] = NodeDFCombine
nodes_classes_by_name["Event Flow"] = AnimEventFlow

var nodes_decor = [
    NV_TextNote
]
var nodes_decor_by_name = {}
for(let d of nodes_decor)
    nodes_decor_by_name[d.name()] = d
<!DOCTYPE html><html>
<head>
<script src="gl-matrix.js"></script>
<script src="ColorPicker.js"></script>
<script src="base_node.js"></script>
<script src="gui.js"></script>
<script src="parameters.js"></script>
<script src="mesh.js"></script>
<script src="serialization.js"></script>
<script src="delaunator401.js"></script>
<script src="nodes_mesh.js"></script>
<script>
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3, glm = glMatrix.glMatrix
glm.setMatrixArrayType(Float64Array)

var ctx_nodes, ctx_img

const PRELOAD_IMAGES = [ "check_checked.png", "check_int.png", "check_none.png" ]
var preloaded = []

function preload_images() {
    for(var name of PRELOAD_IMAGES) {
        let img = new Image()
        img.src = name
        preloaded.push(img)
    }
}

function page_onload()
{
    preload_images()
    nodes_view = new NodesView(canvas_nodes)
    image_view = new ImageView(canvas_image)

    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_img = canvas_image.getContext('2d')
    
    canvas_nodes.do_draw = function() {
        draw_nodes()
    }
    canvas_image.do_draw = function() {
        image_view.resize_redraw()
    }
    
    clear_program()
    try {
        load_state()
    }
    catch(e) {
        console.error("failed load " + e)
    }
    
    setup_vert_splitter(main_view, image_panel, canvas_image, image_splitter, edit_panel, canvas_nodes)
    setup_horz_splitter(edit_panel, edit_params, edit_splitter, edit_nodes, canvas_nodes)
    
    panel_mouse_control(nodes_view, canvas_nodes)
    panel_mouse_control(image_view, canvas_image)
    panel_mouse_wheel(image_view, canvas_image)
    setup_key_bindings()

    image_view.resize_redraw()
    
    //add_node(-50, -50, null, NodeGeomPrimitive)
    //add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    calc_img_viewport()
}


var program = null


function clear_program() {
    program = {
        nodes: [], // nodes in an array for iteration
        nodes_map: {},  // node-id to node 
        lines: [],
        display_node: null,
        // map node cls name to the next index a node of this class is going to get
        names_indices: {},
        next_node_id: 1
    }
}


function assert(cond, node, msg) {
    if (!cond)
        throw { msg: msg, node:node }
}

function calc_img_viewport() {
    let t_viewport = mat3.create()
    image_view.t_viewport = t_viewport

    if (canvas_image.width > canvas_image.height) {
        var f = canvas_image.height
        image_view.margin_x = (canvas_image.width - canvas_image.height) / (canvas_image.height * 2)
        image_view.margin_y = 0
    }
    else {
        var f = canvas_image.width
        image_view.margin_y = (canvas_image.height - canvas_image.width) / (canvas_image.width * 2)
        image_view.margin_x = 0
    }
    mat3.scale(t_viewport, t_viewport, vec2.fromValues(f*image_view.zoom, f*image_view.zoom))
    mat3.translate(t_viewport, t_viewport, vec2.fromValues(0.5 + image_view.margin_x + image_view.pan_x / f, 0.5 + image_view.margin_y + image_view.pan_y / f))        

}



function run_nodes_tree(n) {
    if (n.outputs[0].get_const() !== null)
        return
    // all inputs    
    for(let inp_t of n.inputs) {  
        // all lines going into an input
        for(let line of inp_t.lines) {
            run_nodes_tree(line.from_term.node)
            // out-terminals pass data to in-terminals automatically
        }
    }
    n.cls.run()
    // distribute outputs to all connected inputs so that all references of an object will be known
    for(let out_t of n.outputs) {  
        for(let line of out_t.lines) {
            line.to_term.set(line.from_term.get_const())
        }
    }
    // clear all inputs so that they won't take up references
    for(let inp_t of n.inputs) {
        for(let line of inp_t.lines) {
            line.to_term.clear()
        }
    }

}

function clear_outputs(prog) {
    for(let n of prog.nodes) {
        n.outputs[0].clear() // first output is used as an indicator that the node has ran
    }
}

// called whenever the display needs to be updated to reflect a change
function trigger_frame_draw(do_run) 
{
    save_state()
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)

    if (program.display_node == null)
        return

    let disp_obj = program.display_node.outputs[0].get_const()
    if (do_run || disp_obj === null) {
        clear_outputs(program)
        run_nodes_tree(program.display_node)
        disp_obj = program.display_node.outputs[0].get_const()
    }

    //program.display_node.cls.run()
    assert(disp_obj !== null, program.display_node, "No output generated")

    disp_obj.draw(image_view.t_viewport)
}





var nodes_classes = [
    //NodeTestDummy, 
    NodeGeomPrimitive, 
    NodePointColor, 
    //NodeGeomMerge, 
    NodeGroupObjects,
    NodeTransform,
    NodeRandomPoints,
    NodeTriangulate,
]
var nodes_classes_by_name = {}
for(let c of nodes_classes)
    nodes_classes_by_name[c.name()] = c


</script>
<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload=page_onload()><div id="main_view"><div id="image_panel"><canvas id="canvas_image" width="100" height="100"></canvas></div><div id="image_splitter" class="splitter"></div><div id="edit_panel"><div id="edit_params"><div id="div_params_list"></div></div><div id="edit_splitter" class="splitter"></div><div id="edit_nodes"><canvas id="canvas_nodes" width="100" height="100"></div></div></div></body>
</html>
<!DOCTYPE html><html>
<head>
<script src="gl-matrix.js"></script>
<script src="ColorPicker.js"></script>
<script src="base_node.js"></script>
<script src="gui.js"></script>
<script src="parameters.js"></script>
<script src="mesh.js"></script>
<script src="serialization.js"></script>
<script src="delaunator401.js"></script>
<script src="nodes_mesh.js"></script>
<script src="nodes_webgl.js"></script>
<script>
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3, glm = glMatrix.glMatrix
glm.setMatrixArrayType(Float64Array)

var ctx_nodes, ctx_img

const PRELOAD_IMAGES = [ "check_checked.png", "check_int.png", "check_none.png" ]
var preloaded = []

function preload_images() {
    for(var name of PRELOAD_IMAGES) {
        let img = new Image()
        img.src = name
        preloaded.push(img)
    }
}

function page_onload()
{
    preload_images()
    nodes_view = new NodesView(canvas_nodes)
    image_view = new ImageView(canvas_image)

    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_img = canvas_image.getContext('2d')
    
    canvas_nodes.do_draw = function() {
        draw_nodes()
    }
    canvas_image.do_draw = function() {
        image_view.resize_redraw()
    }
    
    clear_program()
    try {
        load_state()
    }
    catch(e) {
        console.error("failed load " + e)
    }
    
    setup_vert_splitter(main_view, image_panel, canvas_image, image_splitter, edit_panel, canvas_nodes)
    setup_horz_splitter(edit_panel, edit_params, edit_splitter, edit_nodes, canvas_nodes)
    
    panel_mouse_control(nodes_view, canvas_nodes)
    panel_mouse_control(image_view, canvas_image)
    panel_mouse_wheel(image_view, canvas_image)
    setup_key_bindings()

    image_view.resize_redraw()
    
    //add_node(-50, -50, null, NodeGeomPrimitive)
    //add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    calc_img_viewport()
}


var program = null


function clear_program() {
    program = {
        nodes: [], // nodes in an array for iteration
        nodes_map: {},  // node-id to node 
        lines: [],
        display_node: null,
        // map node cls name to the next index a node of this class is going to get
        names_indices: {},
        next_node_id: 1
    }
}


function assert(cond, node_cls, msg) {
    console.assert(node_cls.__proto__ instanceof NodeCls, "Assert with the node.cls")
    console.assert(node_cls !== undefined && msg !== undefined)
    if (!cond)
        throw { msg: msg, node_cls:node_cls }
}

function calc_img_viewport() {
    let t_viewport = mat3.create()
    image_view.t_viewport = t_viewport

    if (canvas_image.width > canvas_image.height) {
        var f = canvas_image.height
        image_view.margin_x = (canvas_image.width - canvas_image.height) / (canvas_image.height * 2)
        image_view.margin_y = 0
    }
    else {
        var f = canvas_image.width
        image_view.margin_y = (canvas_image.height - canvas_image.width) / (canvas_image.width * 2)
        image_view.margin_x = 0
    }
    image_view.viewport_zoom = f*image_view.zoom // used for measuring radius of hit test in pixels
    mat3.scale(t_viewport, t_viewport, vec2.fromValues(image_view.viewport_zoom, image_view.viewport_zoom))
    mat3.translate(t_viewport, t_viewport, vec2.fromValues(0.5 + image_view.margin_x + image_view.pan_x / f, 0.5 + image_view.margin_y + image_view.pan_y / f))        

    image_view.t_inv_viewport = mat3.create()
    mat3.invert(image_view.t_inv_viewport, t_viewport)
}



function run_nodes_tree(n) {
    if (n.outputs[0].get_const() !== null)
        return
    // all inputs    
    for(let inp_t of n.inputs) {  
        // all lines going into an input
        for(let line of inp_t.lines) {
            run_nodes_tree(line.from_term.node)
            // out-terminals pass data to in-terminals automatically
        }
    }
    n.cls.run()
    // distribute outputs to all connected inputs so that all references of an object will be known
    for(let out_t of n.outputs) {  
        for(let line of out_t.lines) {
            line.to_term.set(line.from_term.get_const())
        }
    }
    // clear all inputs so that they won't take up references
    for(let inp_t of n.inputs) {
        for(let line of inp_t.lines) {
            line.to_term.clear()
        }
    }

}

function clear_outputs(prog) {
    let had_errors = false
    for(let n of prog.nodes) {
        // first output is used as an indicator that the node has ran
        // but we need to clear them all so there won't be leftovers from last run
        for(let t of n.terminals)
            t.clear() 
        had_errors |= (n.cls.error !== null)
        n.cls.error = null
    }
    if (had_errors)
        draw_nodes()
}

// happens when calling run(), clears every iteration
function set_error(node_cls, msg) {
    if (node_cls.error === null)
        node_cls.error = {msg:msg}
    draw_nodes()
}


// called whenever the display needs to be updated to reflect a change
function trigger_frame_draw(do_run) 
{
    save_state()
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)

    if (program.display_node == null)
        return

    let got_error = false
    let disp_obj = program.display_node.outputs[0].get_const()
    if (do_run || disp_obj === null) {
        clear_outputs(program)
        try {
            run_nodes_tree(program.display_node)
        }
        catch(e) {
            if (e.node_cls === undefined)
                throw e
            set_error(e.node_cls, e.msg)
            console.error(e)
            got_error = true
        }
        disp_obj = program.display_node.outputs[0].get_const()
    }

    if (disp_obj === null) {
        console.error("no out")
        set_error(program.display_node.cls, "No output generated")
        return
    }

    disp_obj.draw(image_view.t_viewport)

    if (selected_node !== null)
        selected_node.cls.draw_selection(image_view.t_viewport)    
}





var nodes_classes = [
    //NodeTestDummy, 
    NodeGeomPrimitive, 
    NodeManualPoints,
    NodePointColor, 
    //NodeGeomMerge, 
    NodeGroupObjects,
    NodeTransform,
    NodeRandomPoints,
    NodeTriangulate,
    NodeShader,
]
var nodes_classes_by_name = {}
for(let c of nodes_classes)
    nodes_classes_by_name[c.name()] = c


</script>
<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload=page_onload()><div id="main_view"><div id="image_panel"><canvas id="canvas_image" width="100" height="100"></canvas><canvas id="canvas_webgl" width="100" height="100"></canvas></div><div id="image_splitter" class="splitter"></div><div id="edit_panel"><div id="edit_params"><div id="div_params_list"></div></div><div id="edit_splitter" class="splitter"></div><div id="edit_nodes"><canvas id="canvas_nodes" width="100" height="100"></div></div></div></body>
</html>
<!DOCTYPE html><html>
<head>
<script src="gl-matrix.js"></script>
<script src="ColorPicker.js"></script>
<script src="gui.js"></script>
<script src="base_node.js"></script>
<script src="parameters.js"></script>
<script src="mesh.js"></script>
<script src="serialization.js"></script>
<script>
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3, glm = glMatrix.glMatrix
glm.setMatrixArrayType(Float64Array)

var ctx_nodes, ctx_img


function page_onload()
{
    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_img = canvas_image.getContext('2d')
    
    canvas_nodes.do_draw = function() {
        draw_nodes()
    }
    canvas_image.do_draw = function() {
        calc_img_viewport()
        trigger_frame_draw()
    }
    
    clear_program()
    try {
        load_state()
    }
    catch(e) {
        console.error("failed load " + e)
    }
    
    setup_vert_splitter(main_view, image_panel, canvas_image, image_splitter, edit_panel, canvas_nodes)
    setup_horz_splitter(edit_panel, edit_params, edit_splitter, edit_nodes, canvas_nodes)
    
    nodes_panel_mouse_control()
    
    //add_node(-50, -50, null, NodeGeomPrimitive)
    //add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    calc_img_viewport()
}


var program = null

var img_view = {
    t_viewport: null
}

function clear_program() {
    program = {
        nodes: [], // nodes in an array for iteration
        nodes_map: {},  // node-id to node 
        lines: [],
        display_node: null,
        // map node cls name to the next index a node of this class is going to get
        names_indices: {},
        next_node_id: 1
    }
}


function assert(cond, node, msg) {
    if (!cond)
        throw { msg: msg, node:node }
}

function calc_img_viewport() {
    img_view.t_viewport = mat3.create()
    if (canvas_image.width > canvas_image.height) {
        var f = canvas_image.height
        var remainx = (canvas_image.width - canvas_image.height) / (canvas_image.height * 2), remainy = 0
    }
    else {
        var f = canvas_image.width
        var remainy = (canvas_image.height - canvas_image.width) / (canvas_image.width * 2), remainx = 0
    }
    mat3.scale(img_view.t_viewport, img_view.t_viewport, vec2.fromValues(f, f))
    mat3.translate(img_view.t_viewport, img_view.t_viewport, vec2.fromValues(0.5 + remainx, 0.5 + remainy))        

}

class NodeCls {
    constructor() {

    }
}

class NodeTestDummy extends NodeCls {
    static name() { return "Test_Dummy" }
    constructor(node) {
        super()
        this.in_1 = new InTerminal(node, "in_1")
        this.in_2 = new InTerminal(node, "in_2")
        this.out = new OutTerminal(node, "out")
    }
}


class NodeGeomPrimitive extends NodeCls
{
    static name() { return "Geom_Primitive" }
    constructor(node) {
        super()
        this.out = new OutTerminal(node, "out_mesh")
        this.size = new ParamVec2(node, "size", 0.5, 0.5)
    }
    run() {
        let m = new Mesh()
        // center at 0,0
        let hx = this.size.x * 0.5, hy = this.size.y * 0.5
        m.set_vtx([-hx, -hy, hx, -hy, hx, hy, -hx, hy])
        m.set_idx([0, 1, 2, 3])
        m.set_type(MESH_QUAD)
        this.out.set(m)
    }
}

class NodePointColor extends NodeCls
{
    static name() { return "Point_Color" }
    constructor(node) {
        super()
        this.in_mesh = new InTerminal(node, "in_mesh")
        this.out_mesh = new OutTerminal(node, "out_mesh")
        this.color = new ParamColor(node, "color", "#cccccc")
    }
    run() {
        let mesh = this.in_mesh.get_mutable()
        assert(mesh, this, "missing in_mesh")
        let prop = new Uint8Array(mesh.arrs.vtx.length * 1.5) // / 2 for (x,y) * 3 for (r,g,b)
        for(let i = 0; i < prop.length; i += 3) {
            prop[i] = this.color.v.r
            prop[i+1] = this.color.v.g
            prop[i+2] = this.color.v.b
        }
        mesh.set_vtx_color(prop)
        this.out_mesh.set(mesh)
    }
}

class NodeMeshMerge extends NodeCls
{
    static name() { return "Mesh_Merge" }
    constructor(node) {
        super()
        this.in_m = new InTerminalMulti(node, "in_multi_mesh")
        this.out = new OutTerminal(node, "out_mesh")
    }
    run() {
        if (this.in_m.lines.length == 0) {
            this.out.set(new Mesh())
            return
        }
        if (this.in_m.lines.length == 1) {
            this.out.set(this.in_m.lines[0].to_term.v)
            return
        }

        // first calculate the size of the eventual arrays and check type agreement
        let szs = this.in_m.lines[0].to_term.v.get_sizes()
        for(let i = 1; i < this.in_m.lines.length; ++i) {
            let line = this.in_m.lines[i]
            let lm = line.to_term.v.get_size()
            assert(lm.type === szs.type, this, "Input " + i + " has different type from input 0")
            for(let k in m.arrs) {
                if (szs[k] === undefined)
                    szs.arrs[k] = lm.arrs[k]
                else {
                    assert(szs.arrs[k].type === lm.arrs[k].type, "Input " + i + " has wrong data-type of element " + k + " from that of input 0")
                    szs.arrs[k].sz += lm.arrs[k].sz
                }
            }
        }
        // create the arrays
        let r = new Mesh()
        for(let k in szs)
            r.arrs[k] = new szs.arrs[k].type(szs.arrs[k].sz)
        // copy the data TBD

    }
}

// TBD: a slightly better way to do this is to own PHandle and have a custom clone
//      that clones only objects with more than 1 refcount
class PObjGroup extends PObject{
    constructor() {
        super()
        this.v = []
    }
    transform(m) {
        for(let obj of this.v) {
            obj.transform(m)
        }
    }
    draw(m) {
        for(let obj of this.v) {
            obj.draw(m)
        }
    }
}

class NodeGroupObjects extends NodeCls {
    static name() { return "Group_Objects" }
    constructor(node) {
        super()
        this.in_m = new InTerminalMulti(node, "in_multi_mesh")
        this.out = new OutTerminal(node, "out_mesh")
    }
    run() {
        let r = new PObjGroup()
        for(let line of this.in_m.lines) {
            r.v.push(line.to_term.get_const())
        }
        this.out.set(r)
    }
}

// maybe wrap with a proxy?
class NodeTransform extends NodeCls
{
    static name() { return "Transform" }
    constructor(node) {
        super()
        this.in = new InTerminal(node, "input")
        this.out = new OutTerminal(node, "output")
        this.transform = new ParamTransform(node, "transform")
    }
    run() {
        // TBD mutate only if not identity
        let obj = this.in.get_mutable()
        assert(obj, this, "missing input")
        obj.transform(this.transform.v)
        this.out.set(obj)
    }

}

function run_nodes_tree(n) {
    if (n.outputs[0].get_const() !== null)
        return
    // all inputs    
    for(let inp_t of n.inputs) {  
        // all lines going into an input
        for(let line of inp_t.lines) {
            run_nodes_tree(line.from_term.node)
            // out-terminals pass data to in-terminals automatically
        }
    }
    n.cls.run()
    // distribute outputs to all connected inputs so that all references of an object will be known
    for(let out_t of n.outputs) {  
        for(let line of out_t.lines) {
            line.to_term.set(line.from_term.get_const())
        }
    }
    // clear all inputs so that they won't take up references
    for(let inp_t of n.inputs) {
        for(let line of inp_t.lines) {
            line.to_term.clear()
        }
    }

}

function clear_outputs(prog) {
    for(let n of prog.nodes) {
        n.outputs[0].clear() // first output is used as an indicator that the node has ran
    }
}

// called whenever the display needs to be updated to reflect a change
function trigger_frame_draw() 
{
    save_state()
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)

    if (program.display_node == null)
        return

    clear_outputs(program)
    run_nodes_tree(program.display_node)

    //program.display_node.cls.run()
    let disp_obj = program.display_node.outputs[0].get_const()
    assert(disp_obj !== null, program.display_node, "No output generated")

    disp_obj.draw(img_view.t_viewport)

}




var nodes_classes = [
    //NodeTestDummy, 
    NodeGeomPrimitive, 
    NodePointColor, 
    //NodeGeomMerge, 
    NodeGroupObjects,
    NodeTransform
]
var nodes_classes_by_name = {}
for(let c of nodes_classes)
    nodes_classes_by_name[c.name()] = c


</script>
<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload=page_onload()><div id="main_view"><div id="image_panel"><canvas id="canvas_image" width="100" height="100"></canvas></div><div id="image_splitter" class="splitter"></div><div id="edit_panel"><div id="edit_params"><div id="div_params_list"></div></div><div id="edit_splitter" class="splitter"></div><div id="edit_nodes"><canvas id="canvas_nodes" width="100" height="100"></div></div></div></body>
</html>
<!DOCTYPE html><html>
<head>
<script src="gl-matrix.js"></script>
<script src="ColorPicker.js"></script>
<script src="gui.js"></script>
<script src="base_node.js"></script>
<script src="parameters.js"></script>
<script src="mesh.js"></script>

<script>
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3

var ctx_nodes, ctx_img


function page_onload()
{
    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_img = canvas_image.getContext('2d')
    
    canvas_nodes.do_draw = function() {
        draw_nodes()
    }
    canvas_image.do_draw = function() {
    }
    
    
    setup_vert_splitter(main_view, image_panel, canvas_image, image_splitter, edit_panel, canvas_nodes)
    setup_horz_splitter(edit_panel, edit_params, edit_splitter, edit_nodes, canvas_nodes)
    
    nodes_panel_mouse_control()
    

    add_node(-50, -50, null, NodeGeomPrimitive)
    add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    init_img_view()
}


var program = {
    nodes: [],
    lines: [],
    display_node: null
}

var img_view = {
    t_viewport: null
}

function assert(cond, node, msg) {
    if (!cond)
        throw { msg: msg, node:node }
}

function init_img_view() {
    img_view.t_viewport = mat3.create()
    let f = Math.min(canvas_image.width, canvas_image.height)
    mat3.scale(img_view.t_viewport, img_view.t_viewport, vec2.fromValues(f, f))
    mat3.translate(img_view.t_viewport, img_view.t_viewport, vec2.fromValues(0.5, 0.5))
}

class NodeCls {
    constructor() {

    }
}

class NodeTestDummy extends NodeCls {
    static name() { return "Test_Dummy" }
    constructor(node) {
        super()
        this.in_1 = new InTerminal(node, "in_1")
        this.in_2 = new InTerminal(node, "in_2")
        this.out = new OutTerminal(node, "out")
    }
}


class NodeGeomPrimitive extends NodeCls
{
    static name() { return "Geom_Primitive" }
    constructor(node) {
        super()
        this.out = new OutTerminal(node, "out_mesh")
        this.size = new ParamVec2(node, "size", 0.5, 0.5)
    }
    run() {
        let m = new Mesh()
        // center at 0,0
        let hx = this.size.x * 0.5, hy = this.size.y * 0.5
        m.set_vtx([-hx, -hy, hx, -hy, hx, hy, -hx, hy])
        m.set_idx([0, 1, 2, 3])
        m.set_type(MESH_QUAD)
        this.out.set(m)
    }
}

class NodePointColor extends NodeCls
{
    static name() { return "Point_Color" }
    constructor(node) {
        super()
        this.in_mesh = new InTerminal(node, "in_mesh")
        this.out_mesh = new OutTerminal(node, "out_mesh")
        this.color = new ParamColor(node, "color", "#cccccc")
    }
    run() {
        assert(this.in_mesh !== null, this, "missing in_mesh")
        let mesh = this.in_mesh.get_mutable()
        let prop = new Uint8Array(mesh.vtx.length * 3)
        for(let i = 0; i < prop.length; i += 3) {
            prop[i] = this.color.v.r
            prop[i+1] = this.color.v.g
            prop[i+2] = this.color.v.b
        }
        mesh.set_vtx_color(prop)
        this.out_mesh.set(mesh)
    }
}

class NodeGeomMerge extends NodeCls
{
    static name() { return "Geom_Merge" }
    constructor(node) {
        super()
        this.in_m = new InTerminalMulti(node, "in_multi_mesh")
        this.out = new OutTerminal(node, "out_mesh")
    }
}

class NodeTransform extends NodeCls
{
    static name() { return "Transform" }
    constructor(node) {
        super()
        this.in = new InTerminal(node, "input")
        this.out = new OutTerminal(node, "output")
        this.transform = new ParamTransform(node, "transform")
    }
    run() {
        let obj = this.in.get_mutable()
        obj.transform(this.transform.v)
        this.out.set(obj)
    }

}

function run_nodes_tree(n) {
    for(let inp_t of n.inputs) {
        assert(inp_t.lines.length <= 1, n, "too many lines into input " + inp_t.name)
        if (inp_t.lines.length > 0) {
            let line = inp_t.lines[0]
            run_nodes_tree(line.from_term.node)
            line.to_term.v = line.from_term.v
        }
    }
    n.cls.run()
}

// called whenever the display needs to be updated to reflect a change
function trigger_frame_draw() 
{
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)

    if (program.display_node == null)
        return

    run_nodes_tree(program.display_node)

    //program.display_node.cls.run()
    let disp_obj = program.display_node.outputs[0].v
    disp_obj.transform(img_view.t_viewport)
    disp_obj.draw()
}



var nodes_classes = [
    NodeTestDummy, NodeGeomPrimitive, NodePointColor, NodeGeomMerge
]


</script>
<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload=page_onload()><div id="main_view"><div id="image_panel"><canvas id="canvas_image" width="100" height="100"></canvas></div><div id="image_splitter" class="splitter"></div><div id="edit_panel"><div id="edit_params"><div id="div_params_list"></div></div><div id="edit_splitter" class="splitter"></div><div id="edit_nodes"><canvas id="canvas_nodes" width="100" height="100"></div></div></div></body>
</html>
<!DOCTYPE html><html>
<head>
<meta charset="utf-8"/>
<script src="gl-matrix.js"></script>
<script src="line_curve_calc.js"></script>
<script src="ColorPicker.js"></script>
<script src="base_node.js"></script>
<script src="gui.js"></script>
<script src="parameters.js"></script>
<script src="mesh.js"></script>
<script src="serialization.js"></script>
<script src="delaunator401.js"></script>
<script src="expr_parser.js"></script>
<script src="nodes_mesh.js"></script>
<script src="nodes_webgl.js"></script>
<script src="nodes_image.js"></script>
<script src="nodes_paths.js"></script>
<script>
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3, glm = glMatrix.glMatrix
glm.setMatrixArrayType(Float64Array)

var ctx_nodes, ctx_img
var ctx_nd_shadow // the canvas_nd_shadow is auxilary for the canvas_nodes for identifying objects
var ctx_img_shadow // canvas_img_shadow auxilary for canvas_image

const PRELOAD_IMAGES = [ "img/check_checked.png", "img/check_int.png", "img/check_none.png",
                         "img/red_ex.png", "img/gray_ex.png",   
                        ]
var preloaded = []

function preload_images() {
    for(var name of PRELOAD_IMAGES) {
        let img = new Image()
        img.src = name
        preloaded.push(img)
    }
}

function _resize_img_panel(w, h) {
    if (w !== null) {
        image_panel.style.width = w + "px"
        canvas_image.width = w
    }
    if (h !== null)
        canvas_image.height = h // Assumes image canvas takes the whole height
    image_view.resize_redraw()
}
function _resize_edit_panel(w, h) {
    if (w !== null) {
        edit_panel.style.width = w + "px"
        canvas_nodes.width = w
        canvas_nd_shadow.width = w
    }
    draw_nodes()    
}
function _resize_edit_param(w, h) {
    if (h !== null)
        edit_params.style.height = h + 'px';
}
function _resize_nodes_panel(w, h) {
    if (h !== null) {
        edit_nodes.style.height = h + "px"
        canvas_nodes.height = h
        canvas_nd_shadow.height = h
    }
    draw_nodes()              
}

function page_onload()
{
    preload_images()
    nodes_view = new NodesView(canvas_nodes)
    image_view = new ImageView(canvas_image)

    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_nd_shadow = canvas_nd_shadow.getContext('2d', {alpha: false})
    ctx_img = canvas_image.getContext('2d')
    ctx_img_shadow = canvas_img_shadow.getContext('2d')
    
    clear_program()
    try {
        load_state()
    }
    catch(e) {
        console.error("failed load " + e)
    }
    
    setup_vert_splitter(main_view, image_splitter, _resize_img_panel, _resize_edit_panel)
    setup_horz_splitter(edit_panel, edit_splitter, _resize_edit_param, _resize_nodes_panel)
    create_top_menu(main_view)
    
    panel_mouse_control(nodes_view, canvas_nodes)
    panel_mouse_control(image_view, canvas_image)
    panel_mouse_wheel(image_view, canvas_image)
    setup_key_bindings()

    image_view.resize_redraw()
    
    //add_node(-50, -50, null, NodeGeomPrimitive)
    //add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    calc_img_viewport()
}

class Program {
    constructor() {
        this.nodes = [] // nodes in an array for iteration
        this.obj_map = {}  // node-id to node 
        this.lines = []
        this.display_node = null
        // map node cls name to the next index a node of this class is going to get
        this.names_indices = {}
        this.next_obj_id = 1
    }

    add_node(x, y, name, cls, id) 
    {
        if (name === null) {
            if (this.names_indices[cls.name()] === undefined)
                this.names_indices[cls.name()] = 1
            else
                this.names_indices[cls.name()]++
            name = cls.name().toLowerCase().replace(/[\s-]/g,'_') + "_" + this.names_indices[cls.name()]
        }
        if (id === null || id === undefined) {
            id = this.next_obj_id++ 
        }
        else {
            console.assert(this.obj_map[id] === undefined, "node-id already exists")
        }
        var node = new Node(x, y, name, cls, id)
        this.obj_map[node.id] = node
        this.nodes.push(node)
        return node
    }

    add_line(line, uid) {
        this.lines.push(line)
        if (uid === null || uid === undefined)
            uid = this.next_obj_id++ 
        line.uid = uid
        this.obj_map[uid] = line
        line.from_term.lines.push(line)
        line.to_term.lines.push(line)
        line.to_term.tset_dirty(true) // need function so that it will work for multi in as well
        trigger_frame_draw(true)
    }
}

var program = null


function clear_program() {
    program = new Program()
}


function assert(cond, node_cls, msg) {
    console.assert(node_cls.__proto__ instanceof NodeCls, "Assert with the node.cls")
    console.assert(node_cls !== undefined && msg !== undefined)
    if (!cond)
        throw { message: msg, node_cls:node_cls }
}

// thrown in draw
function dassert(cond, msg) {
    if (!cond)
        throw new Error(msg)
}

// throw in expressions
function eassert(cond, msg) {
    if (!cond)
        throw new ExprErr(msg)
}



function calc_img_viewport() {
    let t_viewport = mat3.create()
    image_view.t_viewport = t_viewport

    if (canvas_image.width > canvas_image.height) {
        var f = canvas_image.height*0.5  // half since I want the viewport to be size 2x2
        image_view.margin_x = (canvas_image.width - canvas_image.height) / (canvas_image.height )
        image_view.margin_y = 0
    }
    else {
        var f = canvas_image.width*0.5
        image_view.margin_y = (canvas_image.height - canvas_image.width) / (canvas_image.width )
        image_view.margin_x = 0
    }
    image_view.viewport_zoom = f*image_view.zoom // used for measuring radius of hit test in pixels
    mat3.scale(t_viewport, t_viewport, vec2.fromValues(image_view.viewport_zoom, image_view.viewport_zoom))
    mat3.translate(t_viewport, t_viewport, vec2.fromValues(1 + image_view.margin_x + image_view.pan_x / f, 1 + image_view.margin_y + image_view.pan_y / f))
    t_viewport[6] = Math.round(t_viewport[6]) // need to make sure the translation is whole int so that image display would not be interpolated
    t_viewport[7] = Math.round(t_viewport[7])

    image_view.t_inv_viewport = mat3.create()
    mat3.invert(image_view.t_inv_viewport, t_viewport)

    dirty_viewport_dependents()
}

function dirty_viewport_dependents() {
    for(let n of program.nodes) {
        n.cls.dirty_viewport()
    }
}


function run_nodes_tree(n) {
    console.assert(n._node_dirty !== null)
    if (n._visited)
        return
    n._visited = true
    if (n._node_dirty) {
        // all inputs    
        for(let inp_t of n.inputs) {  
            // all lines going into an input
            for(let line of inp_t.lines) {
                run_nodes_tree(line.from_term.node)
            }
        }
        // clear outputs of what's just going to run to make sure it updated its output
        for(let out_t of n.outputs) {
            out_t.clear()
        }
        n.cls.run()
        n.clear_dirty() // it finished running so it didn't throw and exception
    }
    // distribute outputs to all connected inputs so that all references of an object will be known
    //   still need to do that even if not dirty since inputs are cleared
    for(let out_t of n.outputs) {  
        for(let line of out_t.lines) {
            let obj = line.from_term.get_const()
            assert(obj !== null, n.cls, "No output")
            line.to_term.set(obj)
        }
    }
    // clear all inputs of the node that just ran just to be safe (they don't take up references)
    for(let inp_t of n.inputs) {
        for(let line of inp_t.lines) {
            line.to_term.clear()
        }
    }
}

function clear_inputs_errors(prog) {
    let had_errors = false
    for(let n of prog.nodes) {
        // but we need to clear them all so there won't be leftovers from last run
        for(let t of n.inputs)
            t.clear() 
        // also clear errors
        had_errors |= (n.cls.get_error() !== null)
        n.cls.clear_error()
    }
    if (had_errors)
        draw_nodes()
}

function clear_outputs(prog) {
    for(let n of prog.nodes) {
        // set the indicator that the node needs to run
        n._node_dirty = true
        // but we need to clear them all so there won't be leftovers from last run
        for(let t of n.outputs)
            t.clear() 
    }
}

// first mark all flags as null so we know who we already visited
function clear_nodes_status(prog) {
    for(let n of prog.nodes) {
        n._node_dirty = null // for caching of output values
        n._visited = false   // for visiting a node (and distributing it's output, cached or not to the connections)
    } 
}

// go up the tree to find from what point things start to be dirty and need to be re-run
// when a node is found to be dirty (by its parameters), everything under it is also dirty
function mark_dirty_tree(n) {
    if (n._node_dirty !== null) // already been here
        return n._node_dirty
    // all inputs
    for(let inp_t of n.inputs) {  
        // all lines going into an input
        for(let line of inp_t.lines) {
            // if any of the higher nodes is dirty, we're dirty as well
            if (mark_dirty_tree(line.from_term.node)) {
                n._node_dirty = true
                // can't return just yet since it needs to go over all inputs to mark all as dirty or not
            }
        }
    }
    if (n._node_dirty) // found above
        return true
    let this_dirty = n.has_anything_dirty() || n.outputs[0].get_const() === null
    n._node_dirty = this_dirty
    return this_dirty
}

// happens when calling run(), clears every iteration
function set_error(node_cls, msg) {
    if (node_cls.error === null)
        node_cls.error = {message:msg}
    draw_nodes()
}

// just redraw the same output
const RUN_DRAW_SAME = 0
// the viewport change, re-run anything that is viewport dependent
//const RUN_VIEW_CHANGED = 1
// something in the nodes changed, run with output cacheing
const RUN_NODE_CHANGED = 2
// re-run everything
const RUN_ALL = 3

var in_draw = false

// called whenever the display needs to be updated to reflect a change
function trigger_frame_draw(do_run, clear_all=false) 
{
    if (in_draw)
        return // avoid starting a call if the previous async call didn't finish yet (indicated several triggers from the same stack)
    in_draw = true
    save_state()
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)
    //ctx_img.fillStyle = 'rgba(0,0,0,0)'
    //ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)

    if (program.display_node == null) {
        show_display_params(null, null)
        in_draw = false
        return
    }

    let disp_obj = program.display_node.outputs[0].get_const()
    if (do_run || disp_obj === null) {
        if (clear_all)
            clear_outputs(program)
        clear_inputs_errors(program)
        clear_nodes_status(program)
        mark_dirty_tree(program.display_node)
        try {
            run_nodes_tree(program.display_node)
        }
        catch(e) {
            if (e.node_cls === undefined) {
                in_draw = false
                throw e
            }
            set_error(e.node_cls, e.message)
            console.error(e)
        }
        disp_obj = program.display_node.outputs[0].get_const()
    }

    // do this before obj draw so that if there are missing display params, they'll get a default value
    show_display_params(disp_obj, program.display_node) 

    if (disp_obj === null) {
        console.error("no out")
        set_error(program.display_node.cls, "No output generated")
        in_draw = false
        return
    }

    let p
    try {
        p = disp_obj.draw(image_view.t_viewport, program.display_node.display_values)
    } catch(e) {
        set_error(program.display_node.cls, e.message)
    }
    let finalize_draw = ()=>{
        if (selected_node !== null) {
            try {
                selected_node.cls.draw_selection(image_view.t_viewport)
            } catch(e) {
                set_error(selected_node.cls, e.message)
            }
        }
        in_draw = false
    }
    if (p !== undefined)
        p.then(finalize_draw)
    else
        finalize_draw()

}



var nodes_classes = [
    //NodeTestDummy, 
    NodeGeomPrimitive, 
    GeomDivide,
    NodeManualGeom,
    NodeSetAttr, 
    //NodeGeomMerge, 
    NodeGroupObjects,
    NodeTransform,
    NodeRandomPoints,
    NodeTriangulate,
    NodeShader,
    PointGradFill,
    NodeLoadImage,
    CreateTexture,
]
var nodes_classes_by_name = {}
for(let c of nodes_classes)
    nodes_classes_by_name[c.name()] = c
// old names from saves
nodes_classes_by_name["Manual_Points"] = NodeManualGeom


</script>
<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload=page_onload()><div id="main_view"><div id="image_panel"><canvas id="canvas_image" width="100" height="100"></canvas><canvas id="canvas_webgl" width="100" height="100"></canvas><canvas id="canvas_img_shadow" width="100" height="100"></canvas></div><div id="image_splitter" class="splitter"></div><div id="edit_panel"><div id="edit_params"><div id="div_params_list"></div><div id="div_display_params"></div></div><div id="edit_splitter" class="splitter"></div><div id="edit_nodes"><canvas id="canvas_nodes" width="100" height="100"></canvas></div></div></div><canvas id="canvas_nd_shadow" width="100" height="100"></canvas></body>
</html>
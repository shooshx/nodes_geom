<!DOCTYPE html><html>
<head>
<meta charset="utf-8"/>
<script src="gl-matrix.js"></script>
<script src="ColorPicker.js"></script>
<script src="base_node.js"></script>
<script src="gui.js"></script>
<script src="parameters.js"></script>
<script src="mesh.js"></script>
<script src="serialization.js"></script>
<script src="delaunator401.js"></script>
<script src="nodes_mesh.js"></script>
<script src="nodes_webgl.js"></script>
<script>
"use strict"

var vec2 = glMatrix.vec2, mat3 = glMatrix.mat3, glm = glMatrix.glMatrix
glm.setMatrixArrayType(Float64Array)

var ctx_nodes, ctx_img

const PRELOAD_IMAGES = [ "img/check_checked.png", "img/check_int.png", "img/check_none.png",
                         "img/red_ex.png", "img/gray_ex.png",   
                        ]
var preloaded = []

function preload_images() {
    for(var name of PRELOAD_IMAGES) {
        let img = new Image()
        img.src = name
        preloaded.push(img)
    }
}

function page_onload()
{
    preload_images()
    nodes_view = new NodesView(canvas_nodes)
    image_view = new ImageView(canvas_image)

    ctx_nodes = canvas_nodes.getContext('2d')
    ctx_img = canvas_image.getContext('2d')
    
    canvas_nodes.do_draw = function() {
        draw_nodes()
    }
    canvas_image.do_draw = function() {
        image_view.resize_redraw()
    }
    
    clear_program()
    try {
        load_state()
    }
    catch(e) {
        console.error("failed load " + e)
    }
    
    setup_vert_splitter(main_view, image_panel, canvas_image, image_splitter, edit_panel, canvas_nodes)
    setup_horz_splitter(edit_panel, edit_params, edit_splitter, edit_nodes, canvas_nodes)
    create_top_menu(main_view)
    
    panel_mouse_control(nodes_view, canvas_nodes)
    panel_mouse_control(image_view, canvas_image)
    panel_mouse_wheel(image_view, canvas_image)
    setup_key_bindings()

    image_view.resize_redraw()
    
    //add_node(-50, -50, null, NodeGeomPrimitive)
    //add_node(50, 50, null, NodePointColor)
    
    draw_nodes()
    calc_img_viewport()
}

class Program {
    constructor() {
        this.nodes = [] // nodes in an array for iteration
        this.nodes_map = {}  // node-id to node 
        this.lines = []
        this.display_node = null
        // map node cls name to the next index a node of this class is going to get
        this.names_indices = {}
        this.next_node_id = 1
    }

    add_node(x, y, name, cls, id) 
    {
        if (name === null) {
            if (this.names_indices[cls.name()] === undefined)
                this.names_indices[cls.name()] = 1
            else
                this.names_indices[cls.name()]++
            name = cls.name().toLowerCase().replace(' ','_') + "_" + this.names_indices[cls.name()]
        }
        if (id === null || id === undefined) {
            id = this.next_node_id++ 
        }
        else {
            console.assert(this.nodes_map[id] === undefined, "node-id already exists")
        }
        var node = new Node(x, y, name, cls, id)
        this.nodes_map[node.id] = node
        this.nodes.push(node)
        return node
    }
}

var program = null


function clear_program() {
    program = new Program()
}


function assert(cond, node_cls, msg) {
    console.assert(node_cls.__proto__ instanceof NodeCls, "Assert with the node.cls")
    console.assert(node_cls !== undefined && msg !== undefined)
    if (!cond)
        throw { msg: msg, node_cls:node_cls }
}

function calc_img_viewport() {
    let t_viewport = mat3.create()
    image_view.t_viewport = t_viewport

    if (canvas_image.width > canvas_image.height) {
        var f = canvas_image.height*0.5  // half since I want the viewport to be size 2x2
        image_view.margin_x = (canvas_image.width - canvas_image.height) / (canvas_image.height )
        image_view.margin_y = 0
    }
    else {
        var f = canvas_image.width*0.5
        image_view.margin_y = (canvas_image.height - canvas_image.width) / (canvas_image.width )
        image_view.margin_x = 0
    }
    image_view.viewport_zoom = f*image_view.zoom // used for measuring radius of hit test in pixels
    mat3.scale(t_viewport, t_viewport, vec2.fromValues(image_view.viewport_zoom, image_view.viewport_zoom))
    mat3.translate(t_viewport, t_viewport, vec2.fromValues(1 + image_view.margin_x + image_view.pan_x / f, 1 + image_view.margin_y + image_view.pan_y / f))        

    image_view.t_inv_viewport = mat3.create()
    mat3.invert(image_view.t_inv_viewport, t_viewport)

    // webgl space transform (without to pixels scale)
    let t_viewspace = mat3.create()
    image_view.t_viewspace = t_viewspace

    let ratio = canvas_image.width / canvas_image.height
    let zx, zy
    if (ratio > 1) {
        zx = image_view.zoom / ratio; zy = image_view.zoom
    }
    else {
        zx = image_view.zoom; zy = image_view.zoom * ratio
    }
    mat3.scale(t_viewspace, t_viewspace, vec2.fromValues(zx , zy))
    // some magic I figured out using https://mycurvefit.com/ fitting with y=a+b/x and checking the offsets as a function of the zoom
    // don't know why this works.
    let fix_factor = 1 - (1/image_view.zoom)
    let margin_x_fix = image_view.margin_x - (image_view.margin_x/image_view.zoom)
    let margin_y_fix = image_view.margin_y - (image_view.margin_y/image_view.zoom)
    mat3.translate(t_viewspace, t_viewspace, vec2.fromValues( margin_x_fix + image_view.pan_x / f + fix_factor, 
                                                              margin_y_fix + image_view.pan_y / f + fix_factor)) 
    //console.log(image_view.zoom, image_view.pan_x / f + fix_factor)
    //console.log(image_view.margin_x)

    dirty_viewport_dependents()
}

function dirty_viewport_dependents() {
    for(let n of program.nodes) {
        n.cls.dirty_viewport()
    }
}


function run_nodes_tree(n) {
    console.assert(n._node_dirty !== null)
    if (n._visited)
        return
    n._visited = true
    if (n._node_dirty) {
        // all inputs    
        for(let inp_t of n.inputs) {  
            // all lines going into an input
            for(let line of inp_t.lines) {
                run_nodes_tree(line.from_term.node)
            }
        }
        n.cls.run()
        n.clear_dirty() // it finished running so it didn't throw and exception
    }
    // distribute outputs to all connected inputs so that all references of an object will be known
    //   still need to do that even if not dirty since inputs are cleared
    for(let out_t of n.outputs) {  
        for(let line of out_t.lines) { // TBD - only active lines!
            line.to_term.set(line.from_term.get_const())
        }
    }
    // clear all inputs of the node that just ran so that they won't take up references
    for(let inp_t of n.inputs) {
        for(let line of inp_t.lines) {
            line.to_term.clear()
        }
    }
}

function clear_inputs_errors(prog) {
    let had_errors = false
    for(let n of prog.nodes) {
        // but we need to clear them all so there won't be leftovers from last run
        for(let t of n.inputs)
            t.clear() 
        // also clear errors
        had_errors |= (n.cls.get_error() !== null)
        n.cls.clear_error()
    }
    if (had_errors)
        draw_nodes()
}

function clear_outputs(prog) {
    for(let n of prog.nodes) {
        // set the indicator that the node needs to run
        n._node_dirty = true
        // but we need to clear them all so there won't be leftovers from last run
        for(let t of n.outputs)
            t.clear() 
    }
}

// first mark all flags as null so we know who we already visited
function clear_nodes_status(prog) {
    for(let n of prog.nodes) {
        n._node_dirty = null // for caching of output values
        n._visited = false   // for visiting a node (and distributing it's output, cached or not to the connections)
    } 
}

// go up the tree to find from what point things start to be dirty and need to be re-run
// when a node is found to be dirty (by its parameters), everything under it is also dirty
function mark_dirty_tree(n) {
    if (n._node_dirty !== null) // already been here
        return n._node_dirty
    // all inputs
    for(let inp_t of n.inputs) {  
        // all lines going into an input
        for(let line of inp_t.lines) {
            // if any of the higher nodes is dirty, we're dirty as well
            if (mark_dirty_tree(line.from_term.node)) {
                n._node_dirty = true
                // can't return just yet since it needs to go over all inputs to mark all as dirty or not
            }
        }
    }
    if (n._node_dirty) // found above
        return true
    let this_dirty = n.has_anything_dirty() || n.outputs[0].get_const() === null
    n._node_dirty = this_dirty
    return this_dirty
}

// happens when calling run(), clears every iteration
function set_error(node_cls, msg) {
    if (node_cls.error === null)
        node_cls.error = {msg:msg}
    draw_nodes()
}

// just redraw the same output
const RUN_DRAW_SAME = 0
// the viewport change, re-run anything that is viewport dependent
//const RUN_VIEW_CHANGED = 1
// something in the nodes changed, run with output cacheing
const RUN_NODE_CHANGED = 2
// re-run everything
const RUN_ALL = 3


// called whenever the display needs to be updated to reflect a change
function trigger_frame_draw(do_run, clear_all) 
{
    save_state()
    ctx_img.fillStyle = '#fff'
    ctx_img.fillRect(0, 0, canvas_image.width, canvas_image.height)

    if (program.display_node == null)
        return

    let got_error = false
    let disp_obj = program.display_node.outputs[0].get_const()
    if (do_run || disp_obj === null) {
        if (clear_all)
            clear_outputs(program)
        clear_inputs_errors(program)
        clear_nodes_status(program)
        mark_dirty_tree(program.display_node)
        try {
            run_nodes_tree(program.display_node)
        }
        catch(e) {
            if (e.node_cls === undefined)
                throw e
            set_error(e.node_cls, e.msg)
            console.error(e)
            got_error = true
        }
        disp_obj = program.display_node.outputs[0].get_const()
    }

    if (disp_obj === null) {
        console.error("no out")
        set_error(program.display_node.cls, "No output generated")
        return
    }

    disp_obj.draw(image_view.t_viewport)

    if (selected_node !== null)
        selected_node.cls.draw_selection(image_view.t_viewport)    
}





var nodes_classes = [
    //NodeTestDummy, 
    NodeGeomPrimitive, 
    NodeManualPoints,
    NodePointColor, 
    //NodeGeomMerge, 
    NodeGroupObjects,
    NodeTransform,
    NodeRandomPoints,
    NodeTriangulate,
    NodeShader,
    PointGradFill,
    NodeSampleAttribute,
]
var nodes_classes_by_name = {}
for(let c of nodes_classes)
    nodes_classes_by_name[c.name()] = c


</script>
<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body onload=page_onload()><div id="main_view"><div id="image_panel"><canvas id="canvas_image" width="100" height="100"></canvas><canvas id="canvas_webgl" width="100" height="100"></canvas></div><div id="image_splitter" class="splitter"></div><div id="edit_panel"><div id="edit_params"><div id="div_params_list"></div></div><div id="edit_splitter" class="splitter"></div><div id="edit_nodes"><canvas id="canvas_nodes" width="100" height="100"></div></div></div></body>
</html>